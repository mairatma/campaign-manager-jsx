(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Main = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _unescape = require('./unescape');

var _unescape2 = _interopRequireDefault(_unescape);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var parser_;

var HTML2IncDom = function () {
	function HTML2IncDom() {
		_classCallCheck(this, HTML2IncDom);
	}

	/**
  * Should convert the given html string to a function with calls to
  * incremental dom methods.
  * @param {string} html
  * @return {!function()} Function with incremental dom calls for building
  *     the given html string.
  */

	HTML2IncDom.buildFn = function buildFn(html) {
		return function () {
			return HTML2IncDom.run(html);
		};
	};

	/**
  * Gets the html parser being currently used.
  * @return {!function()}
  */


	HTML2IncDom.getParser = function getParser() {
		return parser_ || window.HTMLParser;
	};

	/**
  * Should convert the given html string to calls to incremental dom methods.
  * @param {string} html
  */


	HTML2IncDom.run = function run(html) {
		HTML2IncDom.getParser()(html, {
			start: function start(tag, attrs, unary) {
				var fn = unary ? IncrementalDOM.elementVoid : IncrementalDOM.elementOpen;
				var args = [tag, null, []];
				for (var i = 0; i < attrs.length; i++) {
					args.push(attrs[i].name, attrs[i].value);
				}
				fn.apply(null, args);
			},

			end: function end(tag) {
				IncrementalDOM.elementClose(tag);
			},

			chars: function chars(text) {
				IncrementalDOM.text(text, _unescape2.default);
			}
		});
	};

	/**
  * Changes the function that will be used to parse html strings. By default
  * this will use the `HTMLParser` function from
  * https://github.com/blowsie/Pure-JavaScript-HTML5-Parser. This will accept
  * any function that follows that same api, basically accepting the html
  * string and an object with `start`, `end` and `chars` functions to be called
  * during the parsing.
  * @param {!function(string, !Object} newParser
  */


	HTML2IncDom.setParser = function setParser(newParser) {
		parser_ = newParser;
	};

	return HTML2IncDom;
}();

exports.default = HTML2IncDom;

},{"./unescape":3}],2:[function(require,module,exports){
"use strict";

/* jshint ignore:start */

/*
 * HTML5 Parser By Sam Blowes
 *
 * Designed for HTML5 documents
 *
 * Original code by John Resig (ejohn.org)
 * http://ejohn.org/blog/pure-javascript-html-parser/
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 *
 * ----------------------------------------------------------------------------
 * License
 * ----------------------------------------------------------------------------
 *
 * This code is triple licensed using Apache Software License 2.0,
 * Mozilla Public License or GNU Public License
 *
 * ////////////////////////////////////////////////////////////////////////////
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * ////////////////////////////////////////////////////////////////////////////
 *
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is Simple HTML Parser.
 *
 * The Initial Developer of the Original Code is Erik Arvidsson.
 * Portions created by Erik Arvidssson are Copyright (C) 2004. All Rights
 * Reserved.
 *
 * ////////////////////////////////////////////////////////////////////////////
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 * @license
 */

/*
 *
 * ----------------------------------------------------------------------------
 * Usage
 * ----------------------------------------------------------------------------
 *
 * // Use like so:
 * HTMLParser(htmlString, {
 *     start: function(tag, attrs, unary) {},
 *     end: function(tag) {},
 *     chars: function(text) {},
 *     comment: function(text) {}
 * });
 *
 * // or to get an XML string:
 * HTMLtoXML(htmlString);
 *
 * // or to get an XML DOM Document
 * HTMLtoDOM(htmlString);
 *
 * // or to inject into an existing document/DOM node
 * HTMLtoDOM(htmlString, document);
 * HTMLtoDOM(htmlString, document.body);
 *
 */

(function () {
	// Regular Expressions for parsing tags and attributes
	var startTag = /^<([-A-Za-z0-9_]+)((?:\s+[a-zA-Z_:][-a-zA-Z0-9_:.]*(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/,
	    endTag = /^<\/([-A-Za-z0-9_]+)[^>]*>/,
	    attr = /([a-zA-Z_:][-a-zA-Z0-9_:.]*)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^>\s]+)))?/g;

	// Empty Elements - HTML 5
	var empty = makeMap("area,base,basefont,br,col,frame,hr,img,input,link,meta,param,embed,command,keygen,source,track,wbr");

	// Block Elements - HTML 5
	var block = makeMap("a,address,article,applet,aside,audio,blockquote,button,canvas,center,dd,del,dir,div,dl,dt,fieldset,figcaption,figure,footer,form,frameset,h1,h2,h3,h4,h5,h6,header,hgroup,hr,iframe,ins,isindex,li,map,menu,noframes,noscript,object,ol,output,p,pre,section,script,table,tbody,td,tfoot,th,thead,tr,ul,video");

	// Inline Elements - HTML 5
	var inline = makeMap("abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,textarea,tt,u,var");

	// Elements that you can, intentionally, leave open
	// (and which close themselves)
	var closeSelf = makeMap("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr");

	// Attributes that have their values filled in disabled="disabled"
	var fillAttrs = makeMap("checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected");

	// Special Elements (can contain anything)
	var special = makeMap("script,style");

	var HTMLParser = window.HTMLParser = function (html, handler) {
		var index,
		    chars,
		    match,
		    stack = [],
		    last = html;
		stack.last = function () {
			return this[this.length - 1];
		};

		while (html) {
			chars = true;

			// Make sure we're not in a script or style element
			if (!stack.last() || !special[stack.last()]) {

				// Comment
				if (html.indexOf("<!--") == 0) {
					index = html.indexOf("-->");

					if (index >= 0) {
						if (handler.comment) handler.comment(html.substring(4, index));
						html = html.substring(index + 3);
						chars = false;
					}

					// end tag
				} else if (html.indexOf("</") == 0) {
						match = html.match(endTag);

						if (match) {
							html = html.substring(match[0].length);
							match[0].replace(endTag, parseEndTag);
							chars = false;
						}

						// start tag
					} else if (html.indexOf("<") == 0) {
							match = html.match(startTag);

							if (match) {
								html = html.substring(match[0].length);
								match[0].replace(startTag, parseStartTag);
								chars = false;
							}
						}

				if (chars) {
					index = html.indexOf("<");

					var text = index < 0 ? html : html.substring(0, index);
					html = index < 0 ? "" : html.substring(index);

					if (handler.chars) handler.chars(text);
				}
			} else {
				html = html.replace(new RegExp("([\\s\\S]*?)<\/" + stack.last() + "[^>]*>"), function (all, text) {
					text = text.replace(/<!--([\s\S]*?)-->|<!\[CDATA\[([\s\S]*?)]]>/g, "$1$2");
					if (handler.chars) handler.chars(text);

					return "";
				});

				parseEndTag("", stack.last());
			}

			if (html == last) throw "Parse Error: " + html;
			last = html;
		}

		// Clean up any remaining tags
		parseEndTag();

		function parseStartTag(tag, tagName, rest, unary) {
			tagName = tagName.toLowerCase();

			if (block[tagName]) {
				while (stack.last() && inline[stack.last()]) {
					parseEndTag("", stack.last());
				}
			}

			if (closeSelf[tagName] && stack.last() == tagName) {
				parseEndTag("", tagName);
			}

			unary = empty[tagName] || !!unary;

			if (!unary) stack.push(tagName);

			if (handler.start) {
				var attrs = [];

				rest.replace(attr, function (match, name) {
					var value = arguments[2] ? arguments[2] : arguments[3] ? arguments[3] : arguments[4] ? arguments[4] : fillAttrs[name] ? name : "";

					attrs.push({
						name: name,
						value: value,
						escaped: value.replace(/(^|[^\\])"/g, '$1\\\"') //"
					});
				});

				if (handler.start) handler.start(tagName, attrs, unary);
			}
		}

		function parseEndTag(tag, tagName) {
			// If no tag name is provided, clean shop
			if (!tagName) var pos = 0;

			// Find the closest opened tag of the same type
			else for (var pos = stack.length - 1; pos >= 0; pos--) {
					if (stack[pos] == tagName) break;
				}if (pos >= 0) {
				// Close all the open elements, up the stack
				for (var i = stack.length - 1; i >= pos; i--) {
					if (handler.end) handler.end(stack[i]);
				} // Remove the open elements from the stack
				stack.length = pos;
			}
		}
	};

	function makeMap(str) {
		var obj = {},
		    items = str.split(",");
		for (var i = 0; i < items.length; i++) {
			obj[items[i]] = true;
		}return obj;
	}
}).call(undefined);

/* jshint ignore:end */

},{}],3:[function(require,module,exports){
'use strict';

// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * Unescapes an HTML string using a DOM to resolve non-XML, non-numeric
 * entities. This function is XSS-safe and whitespace-preserving.
 * @private
 * @param {string} str The string to unescape.
 * @return {string} The unescaped {@code str} string.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
function unescape(str) {
  /** @type {!Object<string, string>} */
  var seen = { '&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"' };
  var div = document.createElement('div');

  // Match as many valid entity characters as possible. If the actual entity
  // happens to be shorter, it will still work as innerHTML will return the
  // trailing characters unchanged. Since the entity characters do not include
  // open angle bracket, there is no chance of XSS from the innerHTML use.
  // Since no whitespace is passed to innerHTML, whitespace is preserved.
  return str.replace(HTML_ENTITY_PATTERN_, function (s, entity) {
    // Check for cached entity.
    var value = seen[s];
    if (value) {
      return value;
    }
    // Check for numeric entity.
    if (entity.charAt(0) === '#') {
      // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex numbers.
      var n = Number('0' + entity.substr(1));
      if (!isNaN(n)) {
        value = String.fromCharCode(n);
      }
    }
    // Fall back to innerHTML otherwise.
    if (!value) {
      // Append a non-entity character to avoid a bug in Webkit that parses
      // an invalid entity at the end of innerHTML text as the empty string.
      div.innerHTML = s + ' ';
      // Then remove the trailing character from the result.
      value = div.firstChild.nodeValue.slice(0, -1);
    }
    // Cache and return.
    seen[s] = value;
    return value;
  });
}

exports.default = unescape;

/**
 * Regular expression that matches an HTML entity.
 * @type {!RegExp}
 */

var HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;

},{}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

require('./HTMLParser');

var _HTML2IncDom = require('./HTML2IncDom');

var _HTML2IncDom2 = _interopRequireDefault(_HTML2IncDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _HTML2IncDom2.default;

},{"./HTML2IncDom":1,"./HTMLParser":2}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../metal/src/metal');

var _Uri = require('../../metal-uri/src/Uri');

var _Uri2 = _interopRequireDefault(_Uri);

var _Promise = require('../../metal-promise/src/promise/Promise');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Ajax = function () {
	function Ajax() {
		_classCallCheck(this, Ajax);
	}

	/**
  * XmlHttpRequest's getAllResponseHeaders() method returns a string of
  * response headers according to the format described on the spec:
  * {@link http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders-method}.
  * This method parses that string into a user-friendly name/value pair
  * object.
  * @param {string} allHeaders All headers as string.
  * @return {!Array.<Object<string, string>>}
  */

	Ajax.parseResponseHeaders = function parseResponseHeaders(allHeaders) {
		var headers = [];
		if (!allHeaders) {
			return headers;
		}
		var pairs = allHeaders.split('\r\n');
		for (var i = 0; i < pairs.length; i++) {
			var index = pairs[i].indexOf(': ');
			if (index > 0) {
				var name = pairs[i].substring(0, index);
				var value = pairs[i].substring(index + 2);
				headers.push({
					name: name,
					value: value
				});
			}
		}
		return headers;
	};

	/**
  * Requests the url using XMLHttpRequest.
  * @param {!string} url
  * @param {!string} method
  * @param {?string} body
  * @param {MultiMap=} opt_headers
  * @param {MultiMap=} opt_params
  * @param {number=} opt_timeout
  * @param {boolean=} opt_sync
  * @return {Promise} Deferred ajax request.
  * @protected
  */


	Ajax.request = function request(url, method, body, opt_headers, opt_params, opt_timeout, opt_sync) {
		var request = new XMLHttpRequest();

		var promise = new _Promise.CancellablePromise(function (resolve, reject) {
			request.onload = function () {
				if (request.aborted) {
					request.onerror();
					return;
				}
				resolve(request);
			};
			request.onerror = function () {
				var error = new Error('Request error');
				error.request = request;
				reject(error);
			};
		}).thenCatch(function (reason) {
			request.abort();
			throw reason;
		}).thenAlways(function () {
			clearTimeout(timeout);
		});

		if (opt_params) {
			url = new _Uri2.default(url).addParametersFromMultiMap(opt_params).toString();
		}

		request.open(method, url, !opt_sync);

		if (opt_headers) {
			opt_headers.names().forEach(function (name) {
				request.setRequestHeader(name, opt_headers.getAll(name).join(', '));
			});
		}

		request.send(_metal.core.isDef(body) ? body : null);

		if (_metal.core.isDefAndNotNull(opt_timeout)) {
			var timeout = setTimeout(function () {
				promise.cancel('Request timeout');
			}, opt_timeout);
		}

		return promise;
	};

	return Ajax;
}();

exports.default = Ajax;

},{"../../metal-promise/src/promise/Promise":31,"../../metal-uri/src/Uri":38,"../../metal/src/metal":46}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../metal/src/metal');

var _dom = require('../../metal-dom/src/all/dom');

var _ComponentRegistry = require('./ComponentRegistry');

var _ComponentRegistry2 = _interopRequireDefault(_ComponentRegistry);

var _ComponentRenderer = require('./ComponentRenderer');

var _ComponentRenderer2 = _interopRequireDefault(_ComponentRenderer);

var _events = require('../../metal-events/src/events');

var _State2 = require('../../metal-state/src/State');

var _State3 = _interopRequireDefault(_State2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Component collects common behaviors to be followed by UI components, such
 * as Lifecycle, CSS classes management, events encapsulation and support for
 * different types of rendering.
 * Rendering logic can be done by either:
 *     - Listening to the `render` event inside the `created` lifecycle function
 *       and adding the rendering logic to the listener.
 *     - Using an existing implementation of `ComponentRenderer` like `Soy`,
 *       and following its patterns.
 *     - Building your own implementation of a `ComponentRenderer`.
 * Specifying the renderer that will be used can be done by setting the RENDERER
 * static variable to the renderer's constructor function.
 *
 * Example:
 *
 * <code>
 * class CustomComponent extends Component {
 *   constructor(config) {
 *     super(config);
 *   }
 *
 *   created() {
 *   }
 *
 *   attached() {
 *   }
 *
 *   detached() {
 *   }
 * }
 *
 * CustomComponent.RENDERER = MyRenderer;
 *
 * CustomComponent.STATE = {
 *   title: { value: 'Title' },
 *   fontSize: { value: '10px' }
 * };
 * </code>
 *
 * @extends {State}
 */

var Component = function (_State) {
	_inherits(Component, _State);

	/**
  * Constructor function for `Component`.
  * @param {Object=} opt_config An object with the initial values for this
  *     component's state.
  * @param {boolean|string|Element=} opt_parentElement The element where the
  *     component should be rendered. Can be given as a selector or an element.
  *     If `false` is passed, the component won't be rendered automatically
  *     after created.
  * @constructor
  */

	function Component(opt_config, opt_parentElement) {
		_classCallCheck(this, Component);

		/**
   * All listeners that were attached until the `DomEventEmitterProxy` instance
   * was created.
   * @type {!Object<string, bool>}
   * @protected
   */

		var _this = _possibleConstructorReturn(this, _State.call(this, opt_config));

		_this.attachedListeners_ = {};

		/**
   * Gets all nested components.
   * @type {!Array<!Component>}
   */
		_this.components = {};

		/**
   * Instance of `DomEventEmitterProxy` which proxies events from the component's
   * element to the component itself.
   * @type {DomEventEmitterProxy}
   * @protected
   */
		_this.elementEventProxy_ = null;

		/**
   * The `EventHandler` instance for events attached from the `events` state key.
   * @type {!EventHandler}
   * @protected
   */
		_this.eventsStateKeyHandler_ = new _events.EventHandler();

		/**
   * Whether the element is in document.
   * @type {boolean}
   */
		_this.inDocument = false;

		/**
   * The initial config option passed to this constructor.
   * @type {!Object}
   * @protected
   */
		_this.initialConfig_ = opt_config || {};

		/**
   * Whether the element was rendered.
   * @type {boolean}
   */
		_this.wasRendered = false;

		/**
   * The component's element will be appended to the element this variable is
   * set to, unless the user specifies another parent when calling `render` or
   * `attach`.
   * @type {!Element}
   */
		_this.DEFAULT_ELEMENT_PARENT = document.body;

		_metal.core.mergeSuperClassesProperty(_this.constructor, 'ELEMENT_CLASSES', _this.mergeElementClasses_);

		_this.renderer_ = _this.createRenderer();

		_this.on('stateChanged', _this.handleStateChanged_);
		_this.newListenerHandle_ = _this.on('newListener', _this.handleNewListener_);
		_this.on('eventsChanged', _this.onEventsChanged_);
		_this.addListenersFromObj_(_this.events);

		_this.created();
		if (opt_parentElement !== false) {
			_this.render_(opt_parentElement);
		}
		_this.on('elementChanged', _this.onElementChanged_);
		return _this;
	}

	/**
  * Adds the necessary classes to the component's element.
  * @protected
  */


	Component.prototype.addElementClasses_ = function addElementClasses_() {
		var classesToAdd = this.constructor.ELEMENT_CLASSES_MERGED;
		if (this.elementClasses) {
			classesToAdd = classesToAdd + ' ' + this.elementClasses;
		}
		_dom.dom.addClasses(this.element, classesToAdd);
	};

	/**
  * Adds the listeners specified in the given object.
  * @param {Object} events
  * @protected
  */


	Component.prototype.addListenersFromObj_ = function addListenersFromObj_(events) {
		var eventNames = Object.keys(events || {});
		for (var i = 0; i < eventNames.length; i++) {
			var info = this.extractListenerInfo_(events[eventNames[i]]);
			if (info.fn) {
				var handler;
				if (info.selector) {
					handler = this.delegate(eventNames[i], info.selector, info.fn);
				} else {
					handler = this.on(eventNames[i], info.fn);
				}
				this.eventsStateKeyHandler_.add(handler);
			}
		}
	};

	/**
  * Invokes the attached Lifecycle. When attached, the component element is
  * appended to the DOM and any other action to be performed must be
  * implemented in this method, such as, binding DOM events. A component can
  * be re-attached multiple times.
  * @param {(string|Element)=} opt_parentElement Optional parent element
  *     to render the component.
  * @param {(string|Element)=} opt_siblingElement Optional sibling element
  *     to render the component before it. Relevant when the component needs
  *     to be rendered before an existing element in the DOM.
  * @protected
  * @chainable
  */


	Component.prototype.attach = function attach(opt_parentElement, opt_siblingElement) {
		if (!this.element) {
			throw new Error(Component.Error.ELEMENT_NOT_CREATED);
		}
		if (!this.inDocument) {
			this.renderElement_(opt_parentElement, opt_siblingElement);
			this.inDocument = true;
			this.emit('attached');
			this.attached();
		}
		return this;
	};

	/**
  * Lifecycle. When attached, the component element is appended to the DOM
  * and any other action to be performed must be implemented in this method,
  * such as, binding DOM events. A component can be re-attached multiple
  * times, therefore the undo behavior for any action performed in this phase
  * must be implemented on the detach phase.
  */


	Component.prototype.attached = function attached() {};

	/**
  * Adds a sub component, creating it if it doesn't yet exist.
  * @param {string} key
  * @param {string|!Function} componentNameOrCtor
  * @param {Object=} opt_data
  * @return {!Component}
  */


	Component.prototype.addSubComponent = function addSubComponent(key, componentNameOrCtor, opt_data) {
		if (!this.components[key]) {
			var ConstructorFn = componentNameOrCtor;
			if (_metal.core.isString(ConstructorFn)) {
				ConstructorFn = _ComponentRegistry2.default.getConstructor(componentNameOrCtor);
			}
			this.components[key] = new ConstructorFn(opt_data, false);
		}
		return this.components[key];
	};

	/**
  * Lifecycle. This is called when the component has just been created, before
  * it's rendered.
  */


	Component.prototype.created = function created() {};

	/**
  * Creates the renderer for this component. Sub classes can override this to
  * return a custom renderer as needed.
  * @return {!ComponentRenderer}
  */


	Component.prototype.createRenderer = function createRenderer() {
		_metal.core.mergeSuperClassesProperty(this.constructor, 'RENDERER', _metal.array.firstDefinedValue);
		return new this.constructor.RENDERER_MERGED(this);
	};

	/**
  * Listens to a delegate event on the component's element.
  * @param {string} eventName The name of the event to listen to.
  * @param {string} selector The selector that matches the child elements that
  *   the event should be triggered for.
  * @param {!function(!Object)} callback Function to be called when the event is
  *   triggered. It will receive the normalized event object.
  * @return {!EventHandle} Can be used to remove the listener.
  */


	Component.prototype.delegate = function delegate(eventName, selector, callback) {
		return this.on('delegate:' + eventName + ':' + selector, callback);
	};

	/**
  * Invokes the detached Lifecycle. When detached, the component element is
  * removed from the DOM and any other action to be performed must be
  * implemented in this method, such as, unbinding DOM events. A component
  * can be detached multiple times.
  * @chainable
  */


	Component.prototype.detach = function detach() {
		if (this.inDocument) {
			if (this.element.parentNode) {
				this.element.parentNode.removeChild(this.element);
			}
			this.inDocument = false;
			this.detached();
		}
		this.emit('detached');
		return this;
	};

	/**
  * Lifecycle. When detached, the component element is removed from the DOM
  * and any other action to be performed must be implemented in this method,
  * such as, unbinding DOM events. A component can be detached multiple
  * times, therefore the undo behavior for any action performed in this phase
  * must be implemented on the attach phase.
  */


	Component.prototype.detached = function detached() {};

	/**
  * @inheritDoc
  */


	Component.prototype.disposeInternal = function disposeInternal() {
		this.detach();

		if (this.elementEventProxy_) {
			this.elementEventProxy_.dispose();
			this.elementEventProxy_ = null;
		}

		this.disposeSubComponents(Object.keys(this.components));
		this.components = null;

		this.renderer_.dispose();
		this.renderer_ = null;

		_State.prototype.disposeInternal.call(this);
	};

	/**
  * Calls `dispose` on all subcomponents.
  * @param {!Array<string>} keys
  */


	Component.prototype.disposeSubComponents = function disposeSubComponents(keys) {
		for (var i = 0; i < keys.length; i++) {
			var component = this.components[keys[i]];
			if (!component.isDisposed()) {
				component.dispose();
				delete this.components[keys[i]];
			}
		}
	};

	/**
  * Extracts listener info from the given value.
  * @param {function()|string|{selector:string,fn:function()|string}} value
  * @return {!{selector:string,fn:function()}}
  * @protected
  */


	Component.prototype.extractListenerInfo_ = function extractListenerInfo_(value) {
		var info = {
			fn: value
		};
		if (_metal.core.isObject(value) && !_metal.core.isFunction(value)) {
			info.selector = value.selector;
			info.fn = value.fn;
		}
		if (_metal.core.isString(info.fn)) {
			info.fn = this.getListenerFn(info.fn);
		}
		return info;
	};

	/**
  * Gets the configuration object that was passed to this component's constructor.
  * @return {!Object}
  */


	Component.prototype.getInitialConfig = function getInitialConfig() {
		return this.initialConfig_;
	};

	/**
  * Gets the listener function from its name. If the name is prefixed with a
  * component id, the function will be called on that specified component. Otherwise
  * it will be called on this component instead.
  * @param {string} fnName
  * @return {function()}
  */


	Component.prototype.getListenerFn = function getListenerFn(fnName) {
		if (_metal.core.isFunction(this[fnName])) {
			return this[fnName].bind(this);
		} else {
			console.error('No function named "' + fnName + '" was found in the ' + 'component "' + _metal.core.getFunctionName(this.constructor) + '". Make ' + 'sure that you specify valid function names when adding inline listeners.');
		}
	};

	/**
  * Calls the synchronization function for the state key.
  * @param {string} key
  * @param {Object.<string, Object>=} opt_change Object containing newVal and
  *     prevVal keys.
  * @protected
  */


	Component.prototype.fireStateKeyChange_ = function fireStateKeyChange_(key, opt_change) {
		var fn = this['sync' + key.charAt(0).toUpperCase() + key.slice(1)];
		if (_metal.core.isFunction(fn)) {
			if (!opt_change) {
				opt_change = {
					newVal: this[key],
					prevVal: undefined
				};
			}
			fn.call(this, opt_change.newVal, opt_change.prevVal);
		}
	};

	/**
  * Gets the `ComponentRenderer` instance being used.
  * @return {!ComponentRenderer}
  */


	Component.prototype.getRenderer = function getRenderer() {
		return this.renderer_;
	};

	/**
  * Handles state batch changes. Calls any existing `sync` functions that
  * match the changed state keys.
  * @param {Event} event
  * @protected
  */


	Component.prototype.handleStateChanged_ = function handleStateChanged_(event) {
		this.syncStateFromChanges_(event.changes);
		this.emit('stateSynced', event);
	};

	/**
  * Handles the `newListener` event. Just flags that this event type has been
  * attached, so we can start proxying it when `DomEventEmitterProxy` is created.
  * @param {string} event
  * @protected
  */


	Component.prototype.handleNewListener_ = function handleNewListener_(event) {
		this.attachedListeners_[event] = true;
	};

	/**
  * Merges an array of values for the ELEMENT_CLASSES property into a single object.
  * @param {!Array.<string>} values The values to be merged.
  * @return {!string} The merged value.
  * @protected
  */


	Component.prototype.mergeElementClasses_ = function mergeElementClasses_(values) {
		var marked = {};
		return values.filter(function (val) {
			if (!val || marked[val]) {
				return false;
			} else {
				marked[val] = true;
				return true;
			}
		}).join(' ');
	};

	/**
  * Fired when the `element` state value is changed.
  * @param {!Object} event
  * @protected
  */


	Component.prototype.onElementChanged_ = function onElementChanged_(event) {
		if (event.prevVal === event.newVal) {
			// The `elementChanged` event will be fired whenever the element is set,
			// even if its value hasn't actually changed, since that's how State
			// handles objects. We need to check manually here.
			return;
		}

		this.setUpProxy_();
		this.elementEventProxy_.setOriginEmitter(event.newVal);
		this.addElementClasses_();
		this.syncVisible(this.visible);
	};

	/**
  * Fired when the `events` state value is changed.
  * @param {!Object} event
  * @protected
  */


	Component.prototype.onEventsChanged_ = function onEventsChanged_(event) {
		this.eventsStateKeyHandler_.removeAllListeners();
		this.addListenersFromObj_(event.newVal);
	};

	/**
  * Lifecycle. Renders the component into the DOM.
  *
  * Render Lifecycle:
  *   render event - The "render" event is emitted. Renderers act on this step.
  *   state synchronization - All synchronization methods are called.
  *   attach - Attach Lifecycle is called.
  *
  * @param {(string|Element|boolean)=} opt_parentElement Optional parent element
  *     to render the component. If set to `false`, the element won't be
  *     attached to any element after rendering. In this case, `attach` should
  *     be called manually later to actually attach it to the dom.
  * @param {boolean=} opt_skipRender Optional flag indicating that the actual
  *     rendering should be skipped. Only the other render lifecycle logic will
  *     be run, like syncing state and attaching the element. Should only
  *     be set if the component has already been rendered, like sub components.
  * @protected
  */


	Component.prototype.render_ = function render_(opt_parentElement, opt_skipRender) {
		if (!opt_skipRender) {
			this.emit('render');
		}
		this.setUpProxy_();
		this.syncState_();
		this.attach(opt_parentElement);
		this.wasRendered = true;
	};

	/**
  * Renders this component as a subcomponent, meaning that no actual rendering is
  * needed since it was already rendered by the parent component. This just handles
  * other logics from the rendering lifecycle, like calling sync methods for the
  * state.
  */


	Component.prototype.renderAsSubComponent = function renderAsSubComponent() {
		this.render_(null, true);
	};

	/**
  * Renders the component element into the DOM.
  * @param {(string|Element)=} opt_parentElement Optional parent element
  *     to render the component.
  * @param {(string|Element)=} opt_siblingElement Optional sibling element
  *     to render the component before it. Relevant when the component needs
  *     to be rendered before an existing element in the DOM, e.g.
  *     `component.attach(null, existingElement)`.
  * @protected
  */


	Component.prototype.renderElement_ = function renderElement_(opt_parentElement, opt_siblingElement) {
		var element = this.element;
		if (opt_siblingElement || !element.parentNode) {
			var parent = _dom.dom.toElement(opt_parentElement) || this.DEFAULT_ELEMENT_PARENT;
			parent.insertBefore(element, _dom.dom.toElement(opt_siblingElement));
		}
	};

	/**
  * Setter logic for element state key.
  * @param {string|Element} newVal
  * @param {Element} currentVal
  * @return {Element}
  * @protected
  */


	Component.prototype.setterElementFn_ = function setterElementFn_(newVal, currentVal) {
		return _dom.dom.toElement(newVal) || currentVal;
	};

	/**
  * Creates the `DomEventEmitterProxy` instance and has it start proxying any
  * listeners that have already been listened to.
  * @protected
  */


	Component.prototype.setUpProxy_ = function setUpProxy_() {
		if (this.elementEventProxy_) {
			return;
		}

		var proxy = new _dom.DomEventEmitterProxy(this.element, this);
		this.elementEventProxy_ = proxy;

		_metal.object.map(this.attachedListeners_, proxy.proxyEvent.bind(proxy));
		this.attachedListeners_ = null;

		this.newListenerHandle_.removeListener();
		this.newListenerHandle_ = null;
	};

	/**
  * Fires state synchronization functions.
  * @protected
  */


	Component.prototype.syncState_ = function syncState_() {
		var keys = this.getStateKeys();
		for (var i = 0; i < keys.length; i++) {
			this.fireStateKeyChange_(keys[i]);
		}
	};

	/**
  * Fires synchronization changes for state keys.
  * @param {Object.<string, Object>} changes Object containing the state key
  *     name as key and an object with newVal and prevVal as value.
  * @protected
  */


	Component.prototype.syncStateFromChanges_ = function syncStateFromChanges_(changes) {
		for (var key in changes) {
			this.fireStateKeyChange_(key, changes[key]);
		}
	};

	/**
  * State synchronization logic for the `elementClasses` state key.
  * @param {string} newVal
  * @param {string} prevVal
  */


	Component.prototype.syncElementClasses = function syncElementClasses(newVal, prevVal) {
		if (this.element && prevVal) {
			_dom.dom.removeClasses(this.element, prevVal);
		}
		this.addElementClasses_();
	};

	/**
  * State synchronization logic for `visible` state key.
  * Updates the element's display value according to its visibility.
  * @param {boolean} newVal
  */


	Component.prototype.syncVisible = function syncVisible(newVal) {
		if (this.element) {
			this.element.style.display = newVal ? '' : 'none';
		}
	};

	/**
  * Validator logic for elementClasses state key.
  * @param {string} val
  * @return {boolean} True if val is a valid element classes.
  * @protected
  */


	Component.prototype.validatorElementClassesFn_ = function validatorElementClassesFn_(val) {
		return _metal.core.isString(val);
	};

	/**
  * Validator logic for element state key.
  * @param {string|Element} val
  * @return {boolean} True if val is a valid element.
  * @protected
  */


	Component.prototype.validatorElementFn_ = function validatorElementFn_(val) {
		return _metal.core.isElement(val) || _metal.core.isString(val);
	};

	/**
  * Validator logic for the `events` state key.
  * @param {Object} val
  * @return {boolean}
  * @protected
  */


	Component.prototype.validatorEventsFn_ = function validatorEventsFn_(val) {
		return !_metal.core.isDefAndNotNull(val) || _metal.core.isObject(val);
	};

	return Component;
}(_State3.default);

/**
 * Component state definition.
 * @type {Object}
 * @static
 */


Component.STATE = {
	/**
  * Component element bounding box.
  * @type {Element}
  * @writeOnce
  */
	element: {
		setter: 'setterElementFn_',
		validator: 'validatorElementFn_'
	},

	/**
  * CSS classes to be applied to the element.
  * @type {Array.<string>}
  */
	elementClasses: {
		validator: 'validatorElementClassesFn_'
	},

	/**
  * Listeners that should be attached to this component. Should be provided as an object,
  * where the keys are event names and the values are the listener functions (or function
  * names).
  * @type {Object<string, (function()|string|{selector: string, fn: function()|string})>}
  */
	events: {
		validator: 'validatorEventsFn_',
		value: null
	},

	/**
  * Indicates if the component is visible or not.
  * @type {boolean}
  */
	visible: {
		validator: _metal.core.isBoolean,
		value: true
	}
};

/**
 * CSS classes to be applied to the element.
 * @type {string}
 * @protected
 * @static
 */
Component.ELEMENT_CLASSES = '';

/**
 * The `ComponentRenderer` that should be used. Components need to set this
 * to a subclass of `ComponentRenderer` that has the rendering logic, like
 * `SoyRenderer`.
 * @type {!ComponentRenderer}
 * @static
 */
Component.RENDERER = _ComponentRenderer2.default;

/**
 * Errors thrown by the component.
 * @enum {string}
 */
Component.Error = {
	/**
  * Error when the component is attached but its element hasn't been created yet.
  */
	ELEMENT_NOT_CREATED: 'Can\'t attach component element. It hasn\'t been created yet.'
};

/**
 * A list with state key names that will automatically be rejected as invalid.
 * @type {!Array<string>}
 */
Component.INVALID_KEYS = ['components'];

exports.default = Component;

},{"../../metal-dom/src/all/dom":13,"../../metal-events/src/events":23,"../../metal-state/src/State":37,"../../metal/src/metal":46,"./ComponentRegistry":7,"./ComponentRenderer":8}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../metal/src/metal');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The component registry is used to register components, so they can
 * be accessible by name.
 * @type {Object}
 */

var ComponentRegistry = function () {
	function ComponentRegistry() {
		_classCallCheck(this, ComponentRegistry);
	}

	/**
  * Gets the constructor function for the given component name, or
  * undefined if it hasn't been registered yet.
  * @param {string} name The component's name.
  * @return {?function}
  * @static
  */

	ComponentRegistry.getConstructor = function getConstructor(name) {
		var constructorFn = ComponentRegistry.components_[name];
		if (!constructorFn) {
			console.error('There\'s no constructor registered for the component ' + 'named ' + name + '. Components need to be registered via ' + 'ComponentRegistry.register.');
		}
		return constructorFn;
	};

	/**
  * Registers a component, so it can be found by its name.
  * @param {!Function} constructorFn The component's constructor function.
  * @param {string=} opt_name Name of the registered component. If none is given
  *   the name defined by the NAME static variable will be used instead. If that
  *   isn't set as well, the name of the constructor function will be used.
  * @static
  */


	ComponentRegistry.register = function register(constructorFn, opt_name) {
		var name = opt_name;
		if (!name) {
			if (constructorFn.hasOwnProperty('NAME')) {
				name = constructorFn.NAME;
			} else {
				name = _metal.core.getFunctionName(constructorFn);
			}
		}
		constructorFn.NAME = name;
		ComponentRegistry.components_[name] = constructorFn;
	};

	return ComponentRegistry;
}();

/**
 * Holds all registered components, indexed by their names.
 * @type {!Object<string, function()>}
 * @protected
 * @static
 */


ComponentRegistry.components_ = {};

exports.default = ComponentRegistry;

},{"../../metal/src/metal":46}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _events = require('../../metal-events/src/events');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Base class that component renderers should extend from. It defines the
 * required methods all renderers should have.
 */

var ComponentRenderer = function (_EventEmitter) {
	_inherits(ComponentRenderer, _EventEmitter);

	/**
  * Constructor function for `ComponentRenderer`.
  * @param {!Component} component The component that this renderer is
  *     responsible for.
  */

	function ComponentRenderer(component) {
		_classCallCheck(this, ComponentRenderer);

		var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

		_this.component_ = component;
		_this.componentRendererEvents_ = new _events.EventHandler();
		_this.componentRendererEvents_.add(_this.component_.on('stateChanged', _this.handleComponentRendererStateChanged_.bind(_this)), _this.component_.once('render', _this.render.bind(_this)));
		return _this;
	}

	/**
  * @inheritDoc
  */


	ComponentRenderer.prototype.disposeInternal = function disposeInternal() {
		this.componentRendererEvents_.removeAllListeners();
		this.componentRendererEvents_ = null;
	};

	/**
  * Handles an `stateChanged` event from this renderer's component. Calls the
  * `update` function if the component has already been rendered for the first
  * time.
  * @param {Object.<string, Object>} changes Object containing the names
  *     of all changed state keys, each mapped to an object with its new
  *     (newVal) and previous (prevVal) values.
  */


	ComponentRenderer.prototype.handleComponentRendererStateChanged_ = function handleComponentRendererStateChanged_(changes) {
		if (this.component_.wasRendered) {
			this.update(changes);
		}
	};

	/**
  * Renders the component's whole content (including its main element).
  */


	ComponentRenderer.prototype.render = function render() {
		if (!this.component_.element) {
			this.component_.element = document.createElement('div');
		}
	};

	/**
  * Updates the component's element html. This is automatically called by
  * the component when the value of at least one of its state keys has changed.
  * @param {Object.<string, Object>} changes Object containing the names
  *     of all changed state keys, each mapped to an object with its new
  *     (newVal) and previous (prevVal) values.
  */


	ComponentRenderer.prototype.update = function update() {};

	return ComponentRenderer;
}(_events.EventEmitter);

exports.default = ComponentRenderer;

},{"../../metal-events/src/events":23}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../metal/src/metal');

var _events = require('../../metal-events/src/events');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Collects inline events from a passed element, detaching previously
 * attached events that are not being used anymore.
 * @param {Component} component
 * @constructor
 * @extends {Disposable}
 */

var EventsCollector = function (_Disposable) {
	_inherits(EventsCollector, _Disposable);

	function EventsCollector(component) {
		_classCallCheck(this, EventsCollector);

		var _this = _possibleConstructorReturn(this, _Disposable.call(this));

		if (!component) {
			throw new Error('The component instance is mandatory');
		}

		/**
   * Holds the component intance.
   * @type {!Component}
   * @protected
   */
		_this.component_ = component;

		/**
   * Holds the attached delegate event handles, indexed by the css selector.
   * @type {!Object<string, EventHandler>}
   * @protected
   */
		_this.eventHandles_ = {};

		/**
   * Holds flags indicating which selectors have listeners.
   * @type {!Object<string, boolean>}
   * @protected
   */
		_this.hasListener_ = {};
		return _this;
	}

	/**
  * Attaches the listener described by the given params, unless it has already
  * been attached.
  * @param {string} eventType
  * @param {string} fnNamesString
  */


	EventsCollector.prototype.attachListener = function attachListener(eventType, fnNamesString) {
		var selector = '[data-on' + eventType + '="' + fnNamesString + '"]';

		this.hasListener_[selector] = true;

		if (!this.eventHandles_[selector]) {
			this.eventHandles_[selector] = new _events.EventHandler();
			var fnNames = fnNamesString.split(',');
			for (var i = 0; i < fnNames.length; i++) {
				var fn = this.component_.getListenerFn(fnNames[i]);
				if (fn) {
					this.eventHandles_[selector].add(this.component_.delegate(eventType, selector, this.onEvent_.bind(this, fn)));
				}
			}
		}
	};

	/**
  * Removes all previously attached event listeners to the component.
  */


	EventsCollector.prototype.detachAllListeners = function detachAllListeners() {
		for (var selector in this.eventHandles_) {
			if (this.eventHandles_[selector]) {
				this.eventHandles_[selector].removeAllListeners();
			}
		}
		this.eventHandles_ = {};
		this.listenerCounts_ = {};
	};

	/**
  * Detaches all existing listeners that are not being used anymore.
  * @protected
  */


	EventsCollector.prototype.detachUnusedListeners = function detachUnusedListeners() {
		for (var selector in this.eventHandles_) {
			if (this.eventHandles_[selector] && !this.hasListener_[selector]) {
				this.eventHandles_[selector].removeAllListeners();
				this.eventHandles_[selector] = null;
			}
		}
	};

	/**
  * @inheritDoc
  */


	EventsCollector.prototype.disposeInternal = function disposeInternal() {
		this.detachAllListeners();
		this.component_ = null;
	};

	/**
  * Fires when an event that was registered by this collector is triggered. Makes
  * sure that the event was meant for this component and calls the appropriate
  * listener function for it.
  * @param {!function(!Object)} fn
  * @param {!Object} event
  * @return {*} The return value of the call to the listener function, or undefined
  *   if no function was called.
  * @protected
  */


	EventsCollector.prototype.onEvent_ = function onEvent_(fn, event) {
		// This check prevents parent components from handling their child inline listeners.
		var eventComp = event.handledByComponent;
		if (!eventComp || eventComp === this.component_ || event.delegateTarget.contains(eventComp.element)) {
			event.handledByComponent = this.component_;
			return fn(event);
		}
	};

	/**
  * Prepares the collector to start collecting listeners. Should be called
  * before all calls to `attachListener`.
  */


	EventsCollector.prototype.startCollecting = function startCollecting() {
		this.hasListener_ = {};
	};

	return EventsCollector;
}(_metal.Disposable);

exports.default = EventsCollector;

},{"../../metal-events/src/events":23,"../../metal/src/metal":46}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.EventsCollector = exports.ComponentRenderer = exports.ComponentRegistry = exports.Component = undefined;

var _Component = require('../Component');

var _Component2 = _interopRequireDefault(_Component);

var _ComponentRegistry = require('../ComponentRegistry');

var _ComponentRegistry2 = _interopRequireDefault(_ComponentRegistry);

var _ComponentRenderer = require('../ComponentRenderer');

var _ComponentRenderer2 = _interopRequireDefault(_ComponentRenderer);

var _EventsCollector = require('../EventsCollector');

var _EventsCollector2 = _interopRequireDefault(_EventsCollector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Component2.default;
exports.Component = _Component2.default;
exports.ComponentRegistry = _ComponentRegistry2.default;
exports.ComponentRenderer = _ComponentRenderer2.default;
exports.EventsCollector = _EventsCollector2.default;

},{"../Component":6,"../ComponentRegistry":7,"../ComponentRenderer":8,"../EventsCollector":9}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _dom = require('./dom');

var _dom2 = _interopRequireDefault(_dom);

var _events = require('../../metal-events/src/events');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * DomEventEmitterProxy utility. It extends `EventEmitterProxy` to also accept
 * dom elements as origin emitters.
 * @extends {EventEmitterProxy}
 */

var DomEventEmitterProxy = function (_EventEmitterProxy) {
	_inherits(DomEventEmitterProxy, _EventEmitterProxy);

	function DomEventEmitterProxy() {
		_classCallCheck(this, DomEventEmitterProxy);

		return _possibleConstructorReturn(this, _EventEmitterProxy.apply(this, arguments));
	}

	/**
  * Adds the given listener for the given event.
  * @param {string} event.
  * @param {!function()} listener
  * @return {!EventHandle} The listened event's handle.
  * @protected
  * @override
  */

	DomEventEmitterProxy.prototype.addListener_ = function addListener_(event, listener) {
		if (this.originEmitter_.addEventListener) {
			if (event.startsWith('delegate:')) {
				var index = event.indexOf(':', 9);
				var eventName = event.substring(9, index);
				var selector = event.substring(index + 1);
				return _dom2.default.delegate(this.originEmitter_, eventName, selector, listener);
			} else {
				return _dom2.default.on(this.originEmitter_, event, listener);
			}
		} else {
			return _EventEmitterProxy.prototype.addListener_.call(this, event, listener);
		}
	};

	/**
  * Checks if the given event is supported by the origin element.
  * @param {string} event
  * @protected
  */


	DomEventEmitterProxy.prototype.isSupportedDomEvent_ = function isSupportedDomEvent_(event) {
		return event.startsWith('delegate:') && event.indexOf(':', 9) !== -1 || _dom2.default.supportsEvent(this.originEmitter_, event);
	};

	/**
  * Checks if the given event should be proxied.
  * @param {string} event
  * @return {boolean}
  * @protected
  * @override
  */


	DomEventEmitterProxy.prototype.shouldProxyEvent_ = function shouldProxyEvent_(event) {
		return _EventEmitterProxy.prototype.shouldProxyEvent_.call(this, event) && (!this.originEmitter_.addEventListener || this.isSupportedDomEvent_(event));
	};

	return DomEventEmitterProxy;
}(_events.EventEmitterProxy);

exports.default = DomEventEmitterProxy;

},{"../../metal-events/src/events":23,"./dom":14}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _events = require('../../metal-events/src/events');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * This is a special EventHandle, that is responsible for dom events, instead
 * of EventEmitter events.
 * @extends {EventHandle}
 */

var DomEventHandle = function (_EventHandle) {
	_inherits(DomEventHandle, _EventHandle);

	/**
  * The constructor for `DomEventHandle`.
  * @param {!EventEmitter} emitter Emitter the event was subscribed to.
  * @param {string} event The name of the event that was subscribed to.
  * @param {!Function} listener The listener subscribed to the event.
  * @param {boolean} opt_capture Flag indicating if listener should be triggered
  *   during capture phase, instead of during the bubbling phase. Defaults to false.
  * @constructor
  */

	function DomEventHandle(emitter, event, listener, opt_capture) {
		_classCallCheck(this, DomEventHandle);

		var _this = _possibleConstructorReturn(this, _EventHandle.call(this, emitter, event, listener));

		_this.capture_ = opt_capture;
		return _this;
	}

	/**
  * @inheritDoc
  */


	DomEventHandle.prototype.removeListener = function removeListener() {
		this.emitter_.removeEventListener(this.event_, this.listener_, this.capture_);
	};

	return DomEventHandle;
}(_events.EventHandle);

exports.default = DomEventHandle;

},{"../../metal-events/src/events":23}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.globalEvalStyles = exports.globalEval = exports.features = exports.DomEventHandle = exports.DomEventEmitterProxy = exports.dom = undefined;

var _dom = require('../dom');

var _dom2 = _interopRequireDefault(_dom);

var _DomEventEmitterProxy = require('../DomEventEmitterProxy');

var _DomEventEmitterProxy2 = _interopRequireDefault(_DomEventEmitterProxy);

var _DomEventHandle = require('../DomEventHandle');

var _DomEventHandle2 = _interopRequireDefault(_DomEventHandle);

var _features = require('../features');

var _features2 = _interopRequireDefault(_features);

var _globalEval = require('../globalEval');

var _globalEval2 = _interopRequireDefault(_globalEval);

var _globalEvalStyles = require('../globalEvalStyles');

var _globalEvalStyles2 = _interopRequireDefault(_globalEvalStyles);

require('../events');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _dom2.default;
exports.dom = _dom2.default;
exports.DomEventEmitterProxy = _DomEventEmitterProxy2.default;
exports.DomEventHandle = _DomEventHandle2.default;
exports.features = _features2.default;
exports.globalEval = _globalEval2.default;
exports.globalEvalStyles = _globalEvalStyles2.default;

},{"../DomEventEmitterProxy":11,"../DomEventHandle":12,"../dom":14,"../events":15,"../features":16,"../globalEval":17,"../globalEvalStyles":18}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../metal/src/metal');

var _DomEventHandle = require('./DomEventHandle');

var _DomEventHandle2 = _interopRequireDefault(_DomEventHandle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var dom = function () {
	function dom() {
		_classCallCheck(this, dom);
	}

	/**
  * Adds the requested CSS classes to an element.
  * @param {!Element} element The element to add CSS classes to.
  * @param {string} classes CSS classes to add.
  */

	dom.addClasses = function addClasses(element, classes) {
		if (!_metal.core.isObject(element) || !_metal.core.isString(classes)) {
			return;
		}

		if ('classList' in element) {
			dom.addClassesWithNative_(element, classes);
		} else {
			dom.addClassesWithoutNative_(element, classes);
		}
	};

	/**
  * Adds the requested CSS classes to an element using classList.
  * @param {!Element} element The element to add CSS classes to.
  * @param {string} classes CSS classes to add.
  * @protected
  */


	dom.addClassesWithNative_ = function addClassesWithNative_(element, classes) {
		classes.split(' ').forEach(function (className) {
			if (className) {
				element.classList.add(className);
			}
		});
	};

	/**
  * Adds the requested CSS classes to an element without using classList.
  * @param {!Element} element The element to add CSS classes to.
  * @param {string} classes CSS classes to add.
  * @protected
  */


	dom.addClassesWithoutNative_ = function addClassesWithoutNative_(element, classes) {
		var elementClassName = ' ' + element.className + ' ';
		var classesToAppend = '';

		classes = classes.split(' ');

		for (var i = 0; i < classes.length; i++) {
			var className = classes[i];

			if (elementClassName.indexOf(' ' + className + ' ') === -1) {
				classesToAppend += ' ' + className;
			}
		}

		if (classesToAppend) {
			element.className = element.className + classesToAppend;
		}
	};

	/**
  * Gets the closest element up the tree from the given element (including
  * itself) that matches the specified selector, or null if none match.
  * @param {Element} element
  * @param {string} selector
  * @return {Element}
  */


	dom.closest = function closest(element, selector) {
		while (element && !dom.match(element, selector)) {
			element = element.parentNode;
		}
		return element;
	};

	/**
  * Appends a child node with text or other nodes to a parent node. If
  * child is a HTML string it will be automatically converted to a document
  * fragment before appending it to the parent.
  * @param {!Element} parent The node to append nodes to.
  * @param {!(Element|NodeList|string)} child The thing to append to the parent.
  * @return {!Element} The appended child.
  */


	dom.append = function append(parent, child) {
		if (_metal.core.isString(child)) {
			child = dom.buildFragment(child);
		}
		if (child instanceof NodeList) {
			var childArr = Array.prototype.slice.call(child);
			for (var i = 0; i < childArr.length; i++) {
				parent.appendChild(childArr[i]);
			}
		} else {
			parent.appendChild(child);
		}
		return child;
	};

	/**
  * Helper for converting a HTML string into a document fragment.
  * @param {string} htmlString The HTML string to convert.
  * @return {!Element} The resulting document fragment.
  */


	dom.buildFragment = function buildFragment(htmlString) {
		var tempDiv = document.createElement('div');
		tempDiv.innerHTML = '<br>' + htmlString;
		tempDiv.removeChild(tempDiv.firstChild);

		var fragment = document.createDocumentFragment();
		while (tempDiv.firstChild) {
			fragment.appendChild(tempDiv.firstChild);
		}
		return fragment;
	};

	/**
  * Checks if the first element contains the second one.
  * @param {!Element} element1
  * @param {!Element} element2
  * @return {boolean}
  */


	dom.contains = function contains(element1, element2) {
		if (_metal.core.isDocument(element1)) {
			// document.contains is not defined on IE9, so call it on documentElement instead.
			return element1.documentElement.contains(element2);
		} else {
			return element1.contains(element2);
		}
	};

	/**
  * Listens to the specified event on the given DOM element, but only calls the
  * callback with the event when it triggered by elements that match the given
  * selector.
  * @param {!Element} element The container DOM element to listen to the event on.
  * @param {string} eventName The name of the event to listen to.
  * @param {string} selector The selector that matches the child elements that
  *   the event should be triggered for.
  * @param {!function(!Object)} callback Function to be called when the event is
  *   triggered. It will receive the normalized event object.
  * @return {!DomEventHandle} Can be used to remove the listener.
  */


	dom.delegate = function delegate(element, eventName, selector, callback) {
		var customConfig = dom.customEvents[eventName];
		if (customConfig && customConfig.delegate) {
			eventName = customConfig.originalEvent;
			callback = customConfig.handler.bind(customConfig, callback);
		}
		return dom.on(element, eventName, dom.handleDelegateEvent_.bind(null, selector, callback));
	};

	/**
  * Inserts node in document as last element.
  * @param {Element} node Element to remove children from.
  */


	dom.enterDocument = function enterDocument(node) {
		dom.append(document.body, node);
	};

	/**
  * Removes node from document.
  * @param {Element} node Element to remove children from.
  */


	dom.exitDocument = function exitDocument(node) {
		if (node.parentNode) {
			node.parentNode.removeChild(node);
		}
	};

	/**
  * This is called when an event is triggered by a delegate listener (see
  * `dom.delegate` for more details).
  * @param {string} selector The selector or element that matches the child
  *   elements that the event should be triggered for.
  * @param {!function(!Object)} callback Function to be called when the event
  *   is triggered. It will receive the normalized event object.
  * @param {!Event} event The event payload.
  * @return {boolean} False if at least one of the triggered callbacks returns
  *   false, or true otherwise.
  */


	dom.handleDelegateEvent_ = function handleDelegateEvent_(selector, callback, event) {
		dom.normalizeDelegateEvent_(event);

		var currentElement = event.target;
		var returnValue = true;

		while (currentElement && !event.stopped) {
			if (_metal.core.isString(selector) && dom.match(currentElement, selector)) {
				event.delegateTarget = currentElement;
				returnValue &= callback(event);
			}
			if (currentElement === event.currentTarget) {
				break;
			}
			currentElement = currentElement.parentNode;
		}
		event.delegateTarget = null;

		return returnValue;
	};

	/**
  * Checks if the given element has the requested css class.
  * @param {!Element} element
  * @param {string} className
  * @return {boolean}
  */


	dom.hasClass = function hasClass(element, className) {
		if ('classList' in element) {
			return dom.hasClassWithNative_(element, className);
		} else {
			return dom.hasClassWithoutNative_(element, className);
		}
	};

	/**
  * Checks if the given element has the requested css class using classList.
  * @param {!Element} element
  * @param {string} className
  * @return {boolean}
  * @protected
  */


	dom.hasClassWithNative_ = function hasClassWithNative_(element, className) {
		return element.classList.contains(className);
	};

	/**
  * Checks if the given element has the requested css class without using classList.
  * @param {!Element} element
  * @param {string} className
  * @return {boolean}
  * @protected
  */


	dom.hasClassWithoutNative_ = function hasClassWithoutNative_(element, className) {
		return (' ' + element.className + ' ').indexOf(' ' + className + ' ') >= 0;
	};

	/**
  * Checks if the given element is empty or not.
  * @param {!Element} element
  * @return {boolean}
  */


	dom.isEmpty = function isEmpty(element) {
		return element.childNodes.length === 0;
	};

	/**
  * Check if an element matches a given selector.
  * @param {Element} element
  * @param {string} selector
  * @return {boolean}
  */


	dom.match = function match(element, selector) {
		if (!element || element.nodeType !== 1) {
			return false;
		}

		var p = Element.prototype;
		var m = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector;
		if (m) {
			return m.call(element, selector);
		}

		return dom.matchFallback_(element, selector);
	};

	/**
  * Check if an element matches a given selector, using an internal implementation
  * instead of calling existing javascript functions.
  * @param {Element} element
  * @param {string} selector
  * @return {boolean}
  * @protected
  */


	dom.matchFallback_ = function matchFallback_(element, selector) {
		var nodes = document.querySelectorAll(selector, element.parentNode);
		for (var i = 0; i < nodes.length; ++i) {
			if (nodes[i] === element) {
				return true;
			}
		}
		return false;
	};

	/**
  * Returns the next sibling of the given element that matches the specified
  * selector, or null if there is none.
  * @param {!Element} element
  * @param {?string} selector
  */


	dom.next = function next(element, selector) {
		do {
			element = element.nextSibling;
			if (element && dom.match(element, selector)) {
				return element;
			}
		} while (element);
		return null;
	};

	/**
  * Normalizes the event payload for delegate listeners.
  * @param {!Event} event
  */


	dom.normalizeDelegateEvent_ = function normalizeDelegateEvent_(event) {
		event.stopPropagation = dom.stopPropagation_;
		event.stopImmediatePropagation = dom.stopImmediatePropagation_;
	};

	/**
  * Listens to the specified event on the given DOM element. This function normalizes
  * DOM event payloads and functions so they'll work the same way on all supported
  * browsers.
  * @param {!Element|string} element The DOM element to listen to the event on, or
  *   a selector that should be delegated on the entire document.
  * @param {string} eventName The name of the event to listen to.
  * @param {!function(!Object)} callback Function to be called when the event is
  *   triggered. It will receive the normalized event object.
  * @param {boolean} opt_capture Flag indicating if listener should be triggered
  *   during capture phase, instead of during the bubbling phase. Defaults to false.
  * @return {!DomEventHandle} Can be used to remove the listener.
  */


	dom.on = function on(element, eventName, callback, opt_capture) {
		if (_metal.core.isString(element)) {
			return dom.delegate(document, eventName, element, callback);
		}
		var customConfig = dom.customEvents[eventName];
		if (customConfig && customConfig.event) {
			eventName = customConfig.originalEvent;
			callback = customConfig.handler.bind(customConfig, callback);
		}
		element.addEventListener(eventName, callback, opt_capture);
		return new _DomEventHandle2.default(element, eventName, callback, opt_capture);
	};

	/**
  * Listens to the specified event on the given DOM element once. This
  * function normalizes DOM event payloads and functions so they'll work the
  * same way on all supported browsers.
  * @param {!Element} element The DOM element to listen to the event on.
  * @param {string} eventName The name of the event to listen to.
  * @param {!function(!Object)} callback Function to be called when the event
  *   is triggered. It will receive the normalized event object.
  * @return {!DomEventHandle} Can be used to remove the listener.
  */


	dom.once = function once(element, eventName, callback) {
		var domEventHandle = this.on(element, eventName, function () {
			domEventHandle.removeListener();
			return callback.apply(this, arguments);
		});
		return domEventHandle;
	};

	/**
  * Gets the first parent from the given element that matches the specified
  * selector, or null if none match.
  * @param {!Element} element
  * @param {string} selector
  * @return {Element}
  */


	dom.parent = function parent(element, selector) {
		return dom.closest(element.parentNode, selector);
	};

	/**
  * Registers a custom event.
  * @param {string} eventName The name of the custom event.
  * @param {!Object} customConfig An object with information about how the event
  *   should be handled.
  */


	dom.registerCustomEvent = function registerCustomEvent(eventName, customConfig) {
		dom.customEvents[eventName] = customConfig;
	};

	/**
  * Removes all the child nodes on a DOM node.
  * @param {Element} node Element to remove children from.
  */


	dom.removeChildren = function removeChildren(node) {
		var child;
		while (child = node.firstChild) {
			node.removeChild(child);
		}
	};

	/**
  * Removes the requested CSS classes from an element.
  * @param {!Element} element The element to remove CSS classes from.
  * @param {string} classes CSS classes to remove.
  */


	dom.removeClasses = function removeClasses(element, classes) {
		if (!_metal.core.isObject(element) || !_metal.core.isString(classes)) {
			return;
		}

		if ('classList' in element) {
			dom.removeClassesWithNative_(element, classes);
		} else {
			dom.removeClassesWithoutNative_(element, classes);
		}
	};

	/**
  * Removes the requested CSS classes from an element using classList.
  * @param {!Element} element The element to remove CSS classes from.
  * @param {string} classes CSS classes to remove.
  * @protected
  */


	dom.removeClassesWithNative_ = function removeClassesWithNative_(element, classes) {
		classes.split(' ').forEach(function (className) {
			if (className) {
				element.classList.remove(className);
			}
		});
	};

	/**
  * Removes the requested CSS classes from an element without using classList.
  * @param {!Element} element The element to remove CSS classes from.
  * @param {string} classes CSS classes to remove.
  * @protected
  */


	dom.removeClassesWithoutNative_ = function removeClassesWithoutNative_(element, classes) {
		var elementClassName = ' ' + element.className + ' ';

		classes = classes.split(' ');

		for (var i = 0; i < classes.length; i++) {
			elementClassName = elementClassName.replace(' ' + classes[i] + ' ', ' ');
		}

		element.className = elementClassName.trim();
	};

	/**
  * Replaces the first element with the second.
  * @param {Element} element1
  * @param {Element} element2
  */


	dom.replace = function replace(element1, element2) {
		if (element1 && element2 && element1 !== element2 && element1.parentNode) {
			element1.parentNode.insertBefore(element2, element1);
			element1.parentNode.removeChild(element1);
		}
	};

	/**
  * The function that replaces `stopImmediatePropagation_` for events.
  * @protected
  */


	dom.stopImmediatePropagation_ = function stopImmediatePropagation_() {
		this.stopped = true;
		Event.prototype.stopImmediatePropagation.call(this);
	};

	/**
  * The function that replaces `stopPropagation` for events.
  * @protected
  */


	dom.stopPropagation_ = function stopPropagation_() {
		this.stopped = true;
		Event.prototype.stopPropagation.call(this);
	};

	/**
  * Checks if the given element supports the given event type.
  * @param {!Element|string} element The DOM element or element tag name to check.
  * @param {string} eventName The name of the event to check.
  * @return {boolean}
  */


	dom.supportsEvent = function supportsEvent(element, eventName) {
		if (dom.customEvents[eventName]) {
			return true;
		}

		if (_metal.core.isString(element)) {
			if (!elementsByTag[element]) {
				elementsByTag[element] = document.createElement(element);
			}
			element = elementsByTag[element];
		}
		return 'on' + eventName in element;
	};

	/**
  * Converts the given argument to a DOM element. Strings are assumed to
  * be selectors, and so a matched element will be returned. If the arg
  * is already a DOM element it will be the return value.
  * @param {string|Element|Document} selectorOrElement
  * @return {Element} The converted element, or null if none was found.
  */


	dom.toElement = function toElement(selectorOrElement) {
		if (_metal.core.isElement(selectorOrElement) || _metal.core.isDocument(selectorOrElement)) {
			return selectorOrElement;
		} else if (_metal.core.isString(selectorOrElement)) {
			if (selectorOrElement[0] === '#' && selectorOrElement.indexOf(' ') === -1) {
				return document.getElementById(selectorOrElement.substr(1));
			} else {
				return document.querySelector(selectorOrElement);
			}
		} else {
			return null;
		}
	};

	/**
  * Adds or removes one or more classes from an element. If any of the classes
  * is present, it will be removed from the element, or added otherwise.
  * @param {!Element} element The element which classes will be toggled.
  * @param {string} classes The classes which have to added or removed from the element.
  */


	dom.toggleClasses = function toggleClasses(element, classes) {
		if (!_metal.core.isObject(element) || !_metal.core.isString(classes)) {
			return;
		}

		if ('classList' in element) {
			dom.toggleClassesWithNative_(element, classes);
		} else {
			dom.toggleClassesWithoutNative_(element, classes);
		}
	};

	/**
  * Adds or removes one or more classes from an element using classList.
  * If any of the classes is present, it will be removed from the element,
  * or added otherwise.
  * @param {!Element} element The element which classes will be toggled.
  * @param {string} classes The classes which have to added or removed from the element.
  */


	dom.toggleClassesWithNative_ = function toggleClassesWithNative_(element, classes) {
		classes.split(' ').forEach(function (className) {
			element.classList.toggle(className);
		});
	};

	/**
  * Adds or removes one or more classes from an element without using classList.
  * If any of the classes is present, it will be removed from the element,
  * or added otherwise.
  * @param {!Element} element The element which classes will be toggled.
  * @param {string} classes The classes which have to added or removed from the element.
  */


	dom.toggleClassesWithoutNative_ = function toggleClassesWithoutNative_(element, classes) {
		var elementClassName = ' ' + element.className + ' ';

		classes = classes.split(' ');

		for (var i = 0; i < classes.length; i++) {
			var className = ' ' + classes[i] + ' ';
			var classIndex = elementClassName.indexOf(className);

			if (classIndex === -1) {
				elementClassName = elementClassName + classes[i] + ' ';
			} else {
				elementClassName = elementClassName.substring(0, classIndex) + ' ' + elementClassName.substring(classIndex + className.length);
			}
		}

		element.className = elementClassName.trim();
	};

	/**
  * Triggers the specified event on the given element.
  * NOTE: This should mostly be used for testing, not on real code.
  * @param {!Element} element The node that should trigger the event.
  * @param {string} eventName The name of the event to be triggred.
  * @param {Object=} opt_eventObj An object with data that should be on the
  *   triggered event's payload.
  */


	dom.triggerEvent = function triggerEvent(element, eventName, opt_eventObj) {
		var eventObj = document.createEvent('HTMLEvents');
		eventObj.initEvent(eventName, true, true);
		_metal.object.mixin(eventObj, opt_eventObj);
		element.dispatchEvent(eventObj);
	};

	return dom;
}();

var elementsByTag = {};
dom.customEvents = {};

exports.default = dom;

},{"../../metal/src/metal":46,"./DomEventHandle":12}],15:[function(require,module,exports){
'use strict';

var _dom = require('./dom');

var _dom2 = _interopRequireDefault(_dom);

var _features = require('./features');

var _features2 = _interopRequireDefault(_features);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mouseEventMap = {
	mouseenter: 'mouseover',
	mouseleave: 'mouseout',
	pointerenter: 'pointerover',
	pointerleave: 'pointerout'
};
Object.keys(mouseEventMap).forEach(function (eventName) {
	_dom2.default.registerCustomEvent(eventName, {
		delegate: true,
		handler: function handler(callback, event) {
			var related = event.relatedTarget;
			var target = event.delegateTarget;
			if (!related || related !== target && !target.contains(related)) {
				event.customType = eventName;
				return callback(event);
			}
		},
		originalEvent: mouseEventMap[eventName]
	});
});

var animationEventMap = {
	animation: 'animationend',
	transition: 'transitionend'
};
Object.keys(animationEventMap).forEach(function (eventType) {
	var eventName = animationEventMap[eventType];
	_dom2.default.registerCustomEvent(eventName, {
		event: true,
		delegate: true,
		handler: function handler(callback, event) {
			event.customType = eventName;
			return callback(event);
		},
		originalEvent: _features2.default.checkAnimationEventName()[eventType]
	});
});

},{"./dom":14,"./features":16}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _dom = require('./dom');

var _dom2 = _interopRequireDefault(_dom);

var _metal = require('../../metal/src/metal');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Class with static methods responsible for doing browser feature checks.
 */

var features = function () {
	function features() {
		_classCallCheck(this, features);
	}

	/**
  * Some browsers still supports prefixed animation events. This method can
  * be used to retrieve the current browser event name for both, animation
  * and transition.
  * @return {object}
  */

	features.checkAnimationEventName = function checkAnimationEventName() {
		if (features.animationEventName_ === undefined) {
			features.animationEventName_ = {
				animation: features.checkAnimationEventName_('animation'),
				transition: features.checkAnimationEventName_('transition')
			};
		}
		return features.animationEventName_;
	};

	/**
  * @protected
  * @param {string} type Type to test: animation, transition.
  * @return {string} Browser event name.
  */


	features.checkAnimationEventName_ = function checkAnimationEventName_(type) {
		var prefixes = ['Webkit', 'MS', 'O', ''];
		var typeTitleCase = _metal.string.replaceInterval(type, 0, 1, type.substring(0, 1).toUpperCase());
		var suffixes = [typeTitleCase + 'End', typeTitleCase + 'End', typeTitleCase + 'End', type + 'end'];
		for (var i = 0; i < prefixes.length; i++) {
			if (features.animationElement_.style[prefixes[i] + typeTitleCase] !== undefined) {
				return prefixes[i].toLowerCase() + suffixes[i];
			}
		}
		return type + 'end';
	};

	/**
  * Some browsers (like IE9) change the order of element attributes, when html
  * is rendered. This method can be used to check if this behavior happens on
  * the current browser.
  * @return {boolean}
  */


	features.checkAttrOrderChange = function checkAttrOrderChange() {
		if (features.attrOrderChange_ === undefined) {
			var originalContent = '<div data-component="" data-ref=""></div>';
			var element = document.createElement('div');
			_dom2.default.append(element, originalContent);
			features.attrOrderChange_ = originalContent !== element.innerHTML;
		}
		return features.attrOrderChange_;
	};

	return features;
}();

features.animationElement_ = document.createElement('div');
features.animationEventName_ = undefined;
features.attrOrderChange_ = undefined;

exports.default = features;

},{"../../metal/src/metal":46,"./dom":14}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../metal/src/metal');

var _dom = require('./dom');

var _dom2 = _interopRequireDefault(_dom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Utility functions for running javascript code in the global scope.
 */

var globalEval = function () {
	function globalEval() {
		_classCallCheck(this, globalEval);
	}

	/**
  * Evaluates the given string in the global scope.
  * @param {string} text
  * @param {function()=} opt_appendFn Optional function to append the node
  *   into document.
  * @return {Element} script
  */

	globalEval.run = function run(text, opt_appendFn) {
		var script = document.createElement('script');
		script.text = text;
		if (opt_appendFn) {
			opt_appendFn(script);
		} else {
			document.head.appendChild(script);
		}
		_dom2.default.exitDocument(script);
		return script;
	};

	/**
  * Evaluates the given javascript file in the global scope.
  * @param {string} src The file's path.
  * @param {function()=} opt_callback Optional function to be called
  *   when the script has been run.
  * @param {function()=} opt_appendFn Optional function to append the node
  *   into document.
  * @return {Element} script
  */


	globalEval.runFile = function runFile(src, opt_callback, opt_appendFn) {
		var script = document.createElement('script');
		script.src = src;

		var callback = function callback() {
			_dom2.default.exitDocument(script);
			opt_callback && opt_callback();
		};
		_dom2.default.on(script, 'load', callback);
		_dom2.default.on(script, 'error', callback);

		if (opt_appendFn) {
			opt_appendFn(script);
		} else {
			document.head.appendChild(script);
		}

		return script;
	};

	/**
  * Evaluates the code referenced by the given script element.
  * @param {!Element} script
  * @param {function()=} opt_callback Optional function to be called
  *   when the script has been run.
  * @param {function()=} opt_appendFn Optional function to append the node
  *   into document.
  * @return {Element} script
  */


	globalEval.runScript = function runScript(script, opt_callback, opt_appendFn) {
		var callback = function callback() {
			opt_callback && opt_callback();
		};
		if (script.type && script.type !== 'text/javascript') {
			_metal.async.nextTick(callback);
			return;
		}
		_dom2.default.exitDocument(script);
		if (script.src) {
			return globalEval.runFile(script.src, opt_callback, opt_appendFn);
		} else {
			_metal.async.nextTick(callback);
			return globalEval.run(script.text, opt_appendFn);
		}
	};

	/**
  * Evaluates any script tags present in the given element.
  * @params {!Element} element
  * @param {function()=} opt_callback Optional function to be called
  *   when the script has been run.
  * @param {function()=} opt_appendFn Optional function to append the node
  *   into document.
  */


	globalEval.runScriptsInElement = function runScriptsInElement(element, opt_callback, opt_appendFn) {
		var scripts = element.querySelectorAll('script');
		if (scripts.length) {
			globalEval.runScriptsInOrder(scripts, 0, opt_callback, opt_appendFn);
		} else if (opt_callback) {
			_metal.async.nextTick(opt_callback);
		}
	};

	/**
  * Runs the given scripts elements in the order that they appear.
  * @param {!NodeList} scripts
  * @param {number} index
  * @param {function()=} opt_callback Optional function to be called
  *   when the script has been run.
  * @param {function()=} opt_appendFn Optional function to append the node
  *   into document.
  */


	globalEval.runScriptsInOrder = function runScriptsInOrder(scripts, index, opt_callback, opt_appendFn) {
		globalEval.runScript(scripts.item(index), function () {
			if (index < scripts.length - 1) {
				globalEval.runScriptsInOrder(scripts, index + 1, opt_callback, opt_appendFn);
			} else if (opt_callback) {
				_metal.async.nextTick(opt_callback);
			}
		}, opt_appendFn);
	};

	return globalEval;
}();

exports.default = globalEval;

},{"../../metal/src/metal":46,"./dom":14}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../metal/src/metal');

var _dom = require('./dom');

var _dom2 = _interopRequireDefault(_dom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Utility functions for running styles.
 */

var globalEvalStyles = function () {
	function globalEvalStyles() {
		_classCallCheck(this, globalEvalStyles);
	}

	/**
  * Evaluates the given style.
  * @param {string} text
  * @param {function()=} opt_appendFn Optional function to append the node
  *   into document.
  * @return {Element} style
  */

	globalEvalStyles.run = function run(text, opt_appendFn) {
		var style = document.createElement('style');
		style.innerHTML = text;
		if (opt_appendFn) {
			opt_appendFn(style);
		} else {
			document.head.appendChild(style);
		}
		return style;
	};

	/**
  * Evaluates the given style file.
  * @param {string} href The file's path.
  * @param {function()=} opt_callback Optional function to be called
  *   when the styles has been run.
  * @param {function()=} opt_appendFn Optional function to append the node
  *   into document.
  * @return {Element} style
  */


	globalEvalStyles.runFile = function runFile(href, opt_callback, opt_appendFn) {
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.href = href;
		globalEvalStyles.runStyle(link, opt_callback, opt_appendFn);
		return link;
	};

	/**
  * Evaluates the code referenced by the given style/link element.
  * @param {!Element} style
  * @param {function()=} opt_callback Optional function to be called
  *   when the script has been run.
  * @param {function()=} opt_appendFn Optional function to append the node
  *   into document.
  *  @return {Element} style
  */


	globalEvalStyles.runStyle = function runStyle(style, opt_callback, opt_appendFn) {
		var callback = function callback() {
			opt_callback && opt_callback();
		};
		if (style.rel && style.rel !== 'stylesheet') {
			_metal.async.nextTick(callback);
			return;
		}

		if (style.tagName === 'STYLE') {
			_metal.async.nextTick(callback);
		} else {
			_dom2.default.on(style, 'load', callback);
			_dom2.default.on(style, 'error', callback);
		}

		if (opt_appendFn) {
			opt_appendFn(style);
		} else {
			document.head.appendChild(style);
		}

		return style;
	};

	/**
  * Evaluates any style present in the given element.
  * @params {!Element} element
  * @param {function()=} opt_callback Optional function to be called when the
  *   style has been run.
  * @param {function()=} opt_appendFn Optional function to append the node
  *   into document.
  */


	globalEvalStyles.runStylesInElement = function runStylesInElement(element, opt_callback, opt_appendFn) {
		var styles = element.querySelectorAll('style,link');
		if (styles.length === 0 && opt_callback) {
			_metal.async.nextTick(opt_callback);
			return;
		}

		var loadCount = 0;
		var callback = function callback() {
			if (opt_callback && ++loadCount === styles.length) {
				_metal.async.nextTick(opt_callback);
			}
		};
		for (var i = 0; i < styles.length; i++) {
			globalEvalStyles.runStyle(styles[i], callback, opt_appendFn);
		}
	};

	return globalEvalStyles;
}();

exports.default = globalEvalStyles;

},{"../../metal/src/metal":46,"./dom":14}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../metal/src/metal');

var _EventHandle = require('./EventHandle');

var _EventHandle2 = _interopRequireDefault(_EventHandle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EventEmitter utility.
 * @constructor
 * @extends {Disposable}
 */

var EventEmitter = function (_Disposable) {
	_inherits(EventEmitter, _Disposable);

	function EventEmitter() {
		_classCallCheck(this, EventEmitter);

		/**
   * Holds event listeners scoped by event type.
   * @type {!Object<string, !Array<!function()>>}
   * @protected
   */

		var _this = _possibleConstructorReturn(this, _Disposable.call(this));

		_this.events_ = [];

		/**
   * The maximum number of listeners allowed for each event type. If the number
   * becomes higher than the max, a warning will be issued.
   * @type {number}
   * @protected
   */
		_this.maxListeners_ = 10;

		/**
   * Configuration option which determines if an event facade should be sent
   * as a param of listeners when emitting events. If set to true, the facade
   * will be passed as the first argument of the listener.
   * @type {boolean}
   * @protected
   */
		_this.shouldUseFacade_ = false;
		return _this;
	}

	/**
  * Adds a listener to the end of the listeners array for the specified events.
  * @param {!(Array|string)} events
  * @param {!Function} listener
  * @param {boolean} opt_default Flag indicating if this listener is a default
  *   action for this event. Default actions are run last, and only if no previous
  *   listener call `preventDefault()` on the received event facade.
  * @return {!EventHandle} Can be used to remove the listener.
  */


	EventEmitter.prototype.addListener = function addListener(events, listener, opt_default) {
		this.validateListener_(listener);

		events = this.normalizeEvents_(events);
		for (var i = 0; i < events.length; i++) {
			this.addSingleListener_(events[i], listener, opt_default);
		}

		return new _EventHandle2.default(this, events, listener);
	};

	/**
  * Adds a listener to the end of the listeners array for a single event.
  * @param {string} event
  * @param {!Function} listener
  * @param {boolean} opt_default Flag indicating if this listener is a default
  *   action for this event. Default actions are run last, and only if no previous
  *   listener call `preventDefault()` on the received event facade.
  * @return {!EventHandle} Can be used to remove the listener.
  * @param {Function=} opt_origin The original function that was added as a
  *   listener, if there is any.
  * @protected
  */


	EventEmitter.prototype.addSingleListener_ = function addSingleListener_(event, listener, opt_default, opt_origin) {
		this.emit('newListener', event, listener);

		if (!this.events_[event]) {
			this.events_[event] = [];
		}
		this.events_[event].push({
			default: opt_default,
			fn: listener,
			origin: opt_origin
		});

		var listeners = this.events_[event];
		if (listeners.length > this.maxListeners_ && !listeners.warned) {
			console.warn('Possible EventEmitter memory leak detected. %d listeners added ' + 'for event %s. Use emitter.setMaxListeners() to increase limit.', listeners.length, event);
			listeners.warned = true;
		}
	};

	/**
  * Disposes of this instance's object references.
  * @override
  */


	EventEmitter.prototype.disposeInternal = function disposeInternal() {
		this.events_ = [];
	};

	/**
  * Execute each of the listeners in order with the supplied arguments.
  * @param {string} event
  * @param {*} opt_args [arg1], [arg2], [...]
  * @return {boolean} Returns true if event had listeners, false otherwise.
  */


	EventEmitter.prototype.emit = function emit(event) {
		var args = _metal.array.slice(arguments, 1);
		var listeners = (this.events_[event] || []).concat();

		var facade;
		if (this.getShouldUseFacade()) {
			facade = {
				preventDefault: function preventDefault() {
					facade.preventedDefault = true;
				},
				target: this,
				type: event
			};
			args.push(facade);
		}

		var defaultListeners = [];
		for (var i = 0; i < listeners.length; i++) {
			if (listeners[i].default) {
				defaultListeners.push(listeners[i]);
			} else {
				listeners[i].fn.apply(this, args);
			}
		}
		if (!facade || !facade.preventedDefault) {
			for (var j = 0; j < defaultListeners.length; j++) {
				defaultListeners[j].fn.apply(this, args);
			}
		}

		if (event !== '*') {
			this.emit.apply(this, ['*', event].concat(args));
		}

		return listeners.length > 0;
	};

	/**
  * Gets the configuration option which determines if an event facade should
  * be sent as a param of listeners when emitting events. If set to true, the
  * facade will be passed as the first argument of the listener.
  * @return {boolean}
  */


	EventEmitter.prototype.getShouldUseFacade = function getShouldUseFacade() {
		return this.shouldUseFacade_;
	};

	/**
  * Returns an array of listeners for the specified event.
  * @param {string} event
  * @return {Array} Array of listeners.
  */


	EventEmitter.prototype.listeners = function listeners(event) {
		return (this.events_[event] || []).map(function (listener) {
			return listener.fn;
		});
	};

	/**
  * Adds a listener that will be invoked a fixed number of times for the
  * events. After each event is triggered the specified amount of times, the
  * listener is removed for it.
  * @param {!(Array|string)} events
  * @param {number} amount The amount of times this event should be listened
  * to.
  * @param {!Function} listener
  * @return {!EventHandle} Can be used to remove the listener.
  */


	EventEmitter.prototype.many = function many(events, amount, listener) {
		events = this.normalizeEvents_(events);
		for (var i = 0; i < events.length; i++) {
			this.many_(events[i], amount, listener);
		}

		return new _EventHandle2.default(this, events, listener);
	};

	/**
  * Adds a listener that will be invoked a fixed number of times for a single
  * event. After the event is triggered the specified amount of times, the
  * listener is removed.
  * @param {string} event
  * @param {number} amount The amount of times this event should be listened
  * to.
  * @param {!Function} listener
  * @protected
  */


	EventEmitter.prototype.many_ = function many_(event, amount, listener) {
		var self = this;

		if (amount <= 0) {
			return;
		}

		function handlerInternal() {
			if (--amount === 0) {
				self.removeListener(event, handlerInternal);
			}
			listener.apply(self, arguments);
		}

		self.addSingleListener_(event, handlerInternal, false, listener);
	};

	/**
  * Checks if a listener object matches the given listener function. To match,
  * it needs to either point to that listener or have it as its origin.
  * @param {!Object} listenerObj
  * @param {!Function} listener
  * @return {boolean}
  * @protected
  */


	EventEmitter.prototype.matchesListener_ = function matchesListener_(listenerObj, listener) {
		return listenerObj.fn === listener || listenerObj.origin && listenerObj.origin === listener;
	};

	/**
  * Converts the parameter to an array if only one event is given.
  * @param  {!(Array|string)} events
  * @return {!Array}
  * @protected
  */


	EventEmitter.prototype.normalizeEvents_ = function normalizeEvents_(events) {
		return _metal.core.isString(events) ? [events] : events;
	};

	/**
  * Removes a listener for the specified events.
  * Caution: changes array indices in the listener array behind the listener.
  * @param {!(Array|string)} events
  * @param {!Function} listener
  * @return {!Object} Returns emitter, so calls can be chained.
  */


	EventEmitter.prototype.off = function off(events, listener) {
		this.validateListener_(listener);

		events = this.normalizeEvents_(events);
		for (var i = 0; i < events.length; i++) {
			var listenerObjs = this.events_[events[i]] || [];
			this.removeMatchingListenerObjs_(listenerObjs, listener);
		}

		return this;
	};

	/**
  * Adds a listener to the end of the listeners array for the specified events.
  * @param {!(Array|string)} events
  * @param {!Function} listener
  * @return {!EventHandle} Can be used to remove the listener.
  */


	EventEmitter.prototype.on = function on() {
		return this.addListener.apply(this, arguments);
	};

	/**
  * Adds a one time listener for the events. This listener is invoked only the
  * next time each event is fired, after which it is removed.
  * @param {!(Array|string)} events
  * @param {!Function} listener
  * @return {!EventHandle} Can be used to remove the listener.
  */


	EventEmitter.prototype.once = function once(events, listener) {
		return this.many(events, 1, listener);
	};

	/**
  * Removes all listeners, or those of the specified events. It's not a good
  * idea to remove listeners that were added elsewhere in the code,
  * especially when it's on an emitter that you didn't create.
  * @param {(Array|string)=} opt_events
  * @return {!Object} Returns emitter, so calls can be chained.
  */


	EventEmitter.prototype.removeAllListeners = function removeAllListeners(opt_events) {
		if (opt_events) {
			var events = this.normalizeEvents_(opt_events);
			for (var i = 0; i < events.length; i++) {
				this.events_[events[i]] = null;
			}
		} else {
			this.events_ = {};
		}
		return this;
	};

	/**
  * Removes all listener objects from the given array that match the given
  * listener function.
  * @param {!Array.<Object>} listenerObjs
  * @param {!Function} listener
  * @protected
  */


	EventEmitter.prototype.removeMatchingListenerObjs_ = function removeMatchingListenerObjs_(listenerObjs, listener) {
		for (var i = listenerObjs.length - 1; i >= 0; i--) {
			if (this.matchesListener_(listenerObjs[i], listener)) {
				listenerObjs.splice(i, 1);
			}
		}
	};

	/**
  * Removes a listener for the specified events.
  * Caution: changes array indices in the listener array behind the listener.
  * @param {!(Array|string)} events
  * @param {!Function} listener
  * @return {!Object} Returns emitter, so calls can be chained.
  */


	EventEmitter.prototype.removeListener = function removeListener() {
		return this.off.apply(this, arguments);
	};

	/**
  * By default EventEmitters will print a warning if more than 10 listeners
  * are added for a particular event. This is a useful default which helps
  * finding memory leaks. Obviously not all Emitters should be limited to 10.
  * This function allows that to be increased. Set to zero for unlimited.
  * @param {number} max The maximum number of listeners.
  * @return {!Object} Returns emitter, so calls can be chained.
  */


	EventEmitter.prototype.setMaxListeners = function setMaxListeners(max) {
		this.maxListeners_ = max;
		return this;
	};

	/**
  * Sets the configuration option which determines if an event facade should
  * be sent as a param of listeners when emitting events. If set to true, the
  * facade will be passed as the first argument of the listener.
  * @param {boolean} shouldUseFacade
  * @return {!Object} Returns emitter, so calls can be chained.
  */


	EventEmitter.prototype.setShouldUseFacade = function setShouldUseFacade(shouldUseFacade) {
		this.shouldUseFacade_ = shouldUseFacade;
		return this;
	};

	/**
  * Checks if the given listener is valid, throwing an exception when it's not.
  * @param  {*} listener
  * @protected
  */


	EventEmitter.prototype.validateListener_ = function validateListener_(listener) {
		if (!_metal.core.isFunction(listener)) {
			throw new TypeError('Listener must be a function');
		}
	};

	return EventEmitter;
}(_metal.Disposable);

exports.default = EventEmitter;

},{"../../metal/src/metal":46,"./EventHandle":21}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../metal/src/metal');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EventEmitterProxy utility. It's responsible for linking two EventEmitter
 * instances together, emitting events from the first emitter through the
 * second one. That means that listening to a supported event on the target
 * emitter will mean listening to it on the origin emitter as well.
 * @param {EventEmitter} originEmitter Events originated on this emitter
 *   will be fired for the target emitter's listeners as well.
 * @param {EventEmitter} targetEmitter Event listeners attached to this emitter
 *   will also be triggered when the event is fired by the origin emitter.
 * @param {Object} opt_blacklist Optional blacklist of events that should not be
 *   proxied.
 * @constructor
 * @extends {Disposable}
 */

var EventEmitterProxy = function (_Disposable) {
	_inherits(EventEmitterProxy, _Disposable);

	function EventEmitterProxy(originEmitter, targetEmitter, opt_blacklist, opt_whitelist) {
		_classCallCheck(this, EventEmitterProxy);

		/**
   * Map of events that should not be proxied.
   * @type {Object}
   * @protected
   */

		var _this = _possibleConstructorReturn(this, _Disposable.call(this));

		_this.blacklist_ = opt_blacklist || {};

		/**
   * The origin emitter. This emitter's events will be proxied through the
   * target emitter.
   * @type {EventEmitter}
   * @protected
   */
		_this.originEmitter_ = originEmitter;

		/**
   * Holds a map of events from the origin emitter that are already being proxied.
   * @type {Object<string, !EventHandle>}
   * @protected
   */
		_this.proxiedEvents_ = {};

		/**
   * The target emitter. This emitter will emit all events that come from
   * the origin emitter.
   * @type {EventEmitter}
   * @protected
   */
		_this.targetEmitter_ = targetEmitter;

		/**
   * Map of events that should be proxied. If whitelist is set blacklist is ignored.
   * @type {Object}
   * @protected
   */
		_this.whitelist_ = opt_whitelist;

		_this.startProxy_();
		return _this;
	}

	/**
  * Adds the given listener for the given event.
  * @param {string} event
  * @param {!function()} listener
  * @return {!EventHandle} The listened event's handle.
  * @protected
  */


	EventEmitterProxy.prototype.addListener_ = function addListener_(event, listener) {
		return this.originEmitter_.on(event, listener);
	};

	/**
  * Adds the proxy listener for the given event.
  * @param {string} event
  * @return {!EventHandle} The listened event's handle.
  * @protected
  */


	EventEmitterProxy.prototype.addListenerForEvent_ = function addListenerForEvent_(event) {
		return this.addListener_(event, this.emitOnTarget_.bind(this, event));
	};

	/**
  * @inheritDoc
  */


	EventEmitterProxy.prototype.disposeInternal = function disposeInternal() {
		this.removeListeners_();
		this.proxiedEvents_ = null;
		this.originEmitter_ = null;
		this.targetEmitter_ = null;
	};

	/**
  * Emits the specified event type on the target emitter.
  * @param {string} eventType
  * @protected
  */


	EventEmitterProxy.prototype.emitOnTarget_ = function emitOnTarget_(eventType) {
		var args = [eventType].concat(_metal.array.slice(arguments, 1));
		this.targetEmitter_.emit.apply(this.targetEmitter_, args);
	};

	/**
  * Proxies the given event from the origin to the target emitter.
  * @param {string} event
  */


	EventEmitterProxy.prototype.proxyEvent = function proxyEvent(event) {
		if (this.shouldProxyEvent_(event)) {
			this.proxiedEvents_[event] = this.addListenerForEvent_(event);
		}
	};

	/**
  * Removes the proxy listener for all events.
  * @protected
  */


	EventEmitterProxy.prototype.removeListeners_ = function removeListeners_() {
		var events = Object.keys(this.proxiedEvents_);
		for (var i = 0; i < events.length; i++) {
			this.proxiedEvents_[events[i]].removeListener();
		}
		this.proxiedEvents_ = {};
	};

	/**
  * Changes the origin emitter. This automatically detaches any events that
  * were already being proxied from the previous emitter, and starts proxying
  * them on the new emitter instead.
  */


	EventEmitterProxy.prototype.setOriginEmitter = function setOriginEmitter(originEmitter) {
		var handles = this.proxiedEvents_;
		this.removeListeners_();
		this.originEmitter_ = originEmitter;

		var events = Object.keys(handles);
		for (var i = 0; i < events.length; i++) {
			this.proxiedEvents_[events[i]] = this.addListenerForEvent_(events[i]);
		}
	};

	/**
  * Checks if the given event should be proxied.
  * @param {string} event
  * @return {boolean}
  * @protected
  */


	EventEmitterProxy.prototype.shouldProxyEvent_ = function shouldProxyEvent_(event) {
		if (this.whitelist_ && !this.whitelist_[event]) {
			return false;
		}
		if (this.blacklist_[event]) {
			return false;
		}
		return !this.proxiedEvents_[event];
	};

	/**
  * Starts proxying all events from the origin to the target emitter.
  * @protected
  */


	EventEmitterProxy.prototype.startProxy_ = function startProxy_() {
		this.targetEmitter_.on('newListener', this.proxyEvent.bind(this));
	};

	return EventEmitterProxy;
}(_metal.Disposable);

exports.default = EventEmitterProxy;

},{"../../metal/src/metal":46}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../metal/src/metal');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EventHandle utility. Holds information about an event subscription, and
 * allows removing them easily.
 * EventHandle is a Disposable, but it's important to note that the
 * EventEmitter that created it is not the one responsible for disposing it.
 * That responsibility is for the code that holds a reference to it.
 * @param {!EventEmitter} emitter Emitter the event was subscribed to.
 * @param {string} event The name of the event that was subscribed to.
 * @param {!Function} listener The listener subscribed to the event.
 * @constructor
 * @extends {Disposable}
 */

var EventHandle = function (_Disposable) {
	_inherits(EventHandle, _Disposable);

	function EventHandle(emitter, event, listener) {
		_classCallCheck(this, EventHandle);

		/**
   * The EventEmitter instance that the event was subscribed to.
   * @type {EventEmitter}
   * @protected
   */

		var _this = _possibleConstructorReturn(this, _Disposable.call(this));

		_this.emitter_ = emitter;

		/**
   * The name of the event that was subscribed to.
   * @type {string}
   * @protected
   */
		_this.event_ = event;

		/**
   * The listener subscribed to the event.
   * @type {Function}
   * @protected
   */
		_this.listener_ = listener;
		return _this;
	}

	/**
  * Disposes of this instance's object references.
  * @override
  */


	EventHandle.prototype.disposeInternal = function disposeInternal() {
		this.removeListener();
		this.emitter_ = null;
		this.listener_ = null;
	};

	/**
  * Removes the listener subscription from the emitter.
  */


	EventHandle.prototype.removeListener = function removeListener() {
		if (!this.emitter_.isDisposed()) {
			this.emitter_.removeListener(this.event_, this.listener_);
		}
	};

	return EventHandle;
}(_metal.Disposable);

exports.default = EventHandle;

},{"../../metal/src/metal":46}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../metal/src/metal');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EventHandler utility. It's useful for easily removing a group of
 * listeners from different EventEmitter instances.
 * @constructor
 * @extends {Disposable}
 */

var EventHandler = function (_Disposable) {
	_inherits(EventHandler, _Disposable);

	function EventHandler() {
		_classCallCheck(this, EventHandler);

		/**
   * An array that holds the added event handles, so the listeners can be
   * removed later.
   * @type {Array.<EventHandle>}
   * @protected
   */

		var _this = _possibleConstructorReturn(this, _Disposable.call(this));

		_this.eventHandles_ = [];
		return _this;
	}

	/**
  * Adds event handles to be removed later through the `removeAllListeners`
  * method.
  * @param {...(!EventHandle)} var_args
  */


	EventHandler.prototype.add = function add() {
		for (var i = 0; i < arguments.length; i++) {
			this.eventHandles_.push(arguments[i]);
		}
	};

	/**
  * Disposes of this instance's object references.
  * @override
  */


	EventHandler.prototype.disposeInternal = function disposeInternal() {
		this.eventHandles_ = null;
	};

	/**
  * Removes all listeners that have been added through the `add` method.
  */


	EventHandler.prototype.removeAllListeners = function removeAllListeners() {
		for (var i = 0; i < this.eventHandles_.length; i++) {
			this.eventHandles_[i].removeListener();
		}

		this.eventHandles_ = [];
	};

	return EventHandler;
}(_metal.Disposable);

exports.default = EventHandler;

},{"../../metal/src/metal":46}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventHandler = exports.EventHandle = exports.EventEmitterProxy = exports.EventEmitter = undefined;

var _EventEmitter = require('./EventEmitter');

var _EventEmitter2 = _interopRequireDefault(_EventEmitter);

var _EventEmitterProxy = require('./EventEmitterProxy');

var _EventEmitterProxy2 = _interopRequireDefault(_EventEmitterProxy);

var _EventHandle = require('./EventHandle');

var _EventHandle2 = _interopRequireDefault(_EventHandle);

var _EventHandler = require('./EventHandler');

var _EventHandler2 = _interopRequireDefault(_EventHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _EventEmitter2.default;
exports.EventEmitter = _EventEmitter2.default;
exports.EventEmitterProxy = _EventEmitterProxy2.default;
exports.EventHandle = _EventHandle2.default;
exports.EventHandler = _EventHandler2.default;

},{"./EventEmitter":19,"./EventEmitterProxy":20,"./EventHandle":21,"./EventHandler":22}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

require('./incremental-dom');

var _metal = require('../../metal/src/metal');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Class responsible for intercepting incremental dom functions through AOP.
 */

var IncrementalDomAop = function () {
	function IncrementalDomAop() {
		_classCallCheck(this, IncrementalDomAop);
	}

	/**
  * Gets the original functions that are intercepted by `IncrementalDomAop`.
  * @return {!Object}
  */

	IncrementalDomAop.getOriginalFns = function getOriginalFns() {
		return fnStack[0];
	};

	/**
  * Starts intercepting calls to incremental dom, replacing them with the given
  * functions. Note that `elementVoid`, `elementOpenStart`, `elementOpenEnd`
  * and `attr` are the only ones that can't be intercepted, since they'll
  * automatically be converted into equivalent calls to `elementOpen` and
  * `elementClose`.
  * @param {!Object} fns Functions to be called instead of the original ones
  *     from incremental DOM. Should be given as a map from the function name
  *     to the function that should intercept it. All interceptors will receive
  *     the original function as the first argument, the actual arguments from
  *     from the original call following it.
  */


	IncrementalDomAop.startInterception = function startInterception(fns) {
		var originals = IncrementalDomAop.getOriginalFns();
		fns = _metal.object.map(fns, function (name, value) {
			return value.bind(null, originals[name]);
		});
		fnStack.push(_metal.object.mixin({}, originals, fns, {
			attr: fnAttr,
			elementOpenEnd: fnOpenEnd,
			elementOpenStart: fnOpenStart,
			elementVoid: fnVoid
		}));
	};

	/**
  * Restores the original `elementOpen` function from incremental dom to the
  * implementation it used before the last call to `startInterception`.
  */


	IncrementalDomAop.stopInterception = function stopInterception() {
		if (fnStack.length > 1) {
			fnStack.pop();
		}
	};

	return IncrementalDomAop;
}();

var fnStack = [{
	attr: IncrementalDOM.attr,
	attributes: IncrementalDOM.attributes[IncrementalDOM.symbols.default],
	elementClose: IncrementalDOM.elementClose,
	elementOpen: IncrementalDOM.elementOpen,
	elementOpenEnd: IncrementalDOM.elementOpenEnd,
	elementOpenStart: IncrementalDOM.elementOpenStart,
	elementVoid: IncrementalDOM.elementVoid,
	text: IncrementalDOM.text
}];

var collectedArgs = [];

function fnAttr(name, value) {
	collectedArgs.push(name, value);
}

function fnOpenStart(tag, key, statics) {
	collectedArgs = [tag, key, statics];
}

function fnOpenEnd() {
	return getFn('elementOpen').apply(null, collectedArgs);
}

function fnVoid(tag) {
	getFn('elementOpen').apply(null, arguments);
	return getFn('elementClose')(tag);
}

function getFn(name) {
	return fnStack[fnStack.length - 1][name];
}

function handleCall(name) {
	return getFn(name).apply(null, _metal.array.slice(arguments, 1));
}

IncrementalDOM.attr = handleCall.bind(null, 'attr');
IncrementalDOM.elementClose = handleCall.bind(null, 'elementClose');
IncrementalDOM.elementOpen = handleCall.bind(null, 'elementOpen');
IncrementalDOM.elementOpenEnd = handleCall.bind(null, 'elementOpenEnd');
IncrementalDOM.elementOpenStart = handleCall.bind(null, 'elementOpenStart');
IncrementalDOM.elementVoid = handleCall.bind(null, 'elementVoid');
IncrementalDOM.text = handleCall.bind(null, 'text');

IncrementalDOM.attributes[IncrementalDOM.symbols.default] = handleCall.bind(null, 'attributes');

exports.default = IncrementalDomAop;

},{"../../metal/src/metal":46,"./incremental-dom":26}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

require('./incremental-dom');

var _metal = require('../../metal/src/metal');

var _dom = require('../../metal-dom/src/all/dom');

var _dom2 = _interopRequireDefault(_dom);

var _component = require('../../metal-component/src/all/component');

var _IncrementalDomAop = require('./IncrementalDomAop');

var _IncrementalDomAop2 = _interopRequireDefault(_IncrementalDomAop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Class responsible for rendering components via incremental dom.
 */

var IncrementalDomRenderer = function (_ComponentRenderer) {
	_inherits(IncrementalDomRenderer, _ComponentRenderer);

	/**
  * @inheritDoc
  */

	function IncrementalDomRenderer(comp) {
		_classCallCheck(this, IncrementalDomRenderer);

		var _this = _possibleConstructorReturn(this, _ComponentRenderer.call(this, comp));

		_this.changes_ = {};
		_this.eventsCollector_ = new _component.EventsCollector(comp);
		comp.on('stateKeyChanged', _this.handleStateKeyChanged_.bind(_this));
		comp.on('detached', _this.handleDetached_.bind(_this));

		// Binds functions that will be used many times, to avoid creating new
		// functions each time.
		_this.handleInterceptedAttributesCall_ = _this.handleInterceptedAttributesCall_.bind(_this);
		_this.handleInterceptedOpenCall_ = _this.handleInterceptedOpenCall_.bind(_this);
		_this.handleInterceptedChildrenCloseCall_ = _this.handleInterceptedChildrenCloseCall_.bind(_this);
		_this.handleInterceptedChildrenOpenCall_ = _this.handleInterceptedChildrenOpenCall_.bind(_this);
		_this.handleInterceptedChildrenTextCall_ = _this.handleInterceptedChildrenTextCall_.bind(_this);
		_this.renderWithoutPatch = _this.renderWithoutPatch.bind(_this);
		return _this;
	}

	/**
  * Adds all inline listener attributes included in the given config.
  * @param {!Array} listeners
  * @protected
  */


	IncrementalDomRenderer.prototype.addInlineListeners_ = function addInlineListeners_(listeners) {
		for (var i = 0; i < listeners.length; i += 2) {
			var name = listeners[i];
			var fn = listeners[i + 1];
			if (name.startsWith('data-on') && _metal.core.isString(fn)) {
				this.listenersToAttach_.push({
					eventName: name.substr(7),
					fn: fn
				});
			}
		}
	};

	/**
  * Attaches any inline listeners found in the contents built via the last
  * incremental dom patch.
  * @protected
  */


	IncrementalDomRenderer.prototype.attachInlineListeners_ = function attachInlineListeners_() {
		this.eventsCollector_.startCollecting();
		for (var i = 0; i < this.listenersToAttach_.length; i++) {
			var listener = this.listenersToAttach_[i];
			this.eventsCollector_.attachListener(listener.eventName, listener.fn);
		}
	};

	/**
  * Builds the "children" config property to be passed to the current
  * component.
  * @param {!Array<!{name: string, args: !Array}>} calls
  * @return {!function()}
  * @protected
  */


	IncrementalDomRenderer.prototype.buildChildrenFn_ = function buildChildrenFn_(calls) {
		var _this2 = this;

		return function () {
			_this2.intercept_();
			for (var i = 0; i < calls.length; i++) {
				IncrementalDOM[calls[i].name].apply(null, _metal.array.slice(calls[i].args, 1));
			}
			_IncrementalDomAop2.default.stopInterception();
		};
	};

	/**
  * Disposes all sub components that were not found after an update anymore.
  * @protected
  */


	IncrementalDomRenderer.prototype.disposeUnusedSubComponents_ = function disposeUnusedSubComponents_() {
		var keys = Object.keys(this.component_.components);
		var unused = [];
		for (var i = 0; i < keys.length; i++) {
			if (!this.subComponentsFound_[keys[i]]) {
				unused.push(keys[i]);
			}
		}
		this.component_.disposeSubComponents(unused);
	};

	/**
  * Gets the sub component referenced by the given tag and config data,
  * creating it if it doesn't yet exist.
  * @param {string} key The sub component's key.
  * @param {string|!Function} tagOrCtor The tag name.
  * @param {!Object} config The config object for the sub component.
  * @return {!Component} The sub component.
  * @protected
  */


	IncrementalDomRenderer.prototype.getSubComponent_ = function getSubComponent_(key, tagOrCtor, config) {
		var comp = this.component_.addSubComponent(key, tagOrCtor, config);
		if (comp.wasRendered) {
			comp.setState(config);
		}
		return comp;
	};

	/**
  * Guarantees that the component's element has a parent. That's necessary
  * when calling incremental dom's `patchOuter` for now, as otherwise it will
  * throw an error if the element needs to be replaced.
  * @return {Element} The parent, in case it was added.
  * @protected
  */


	IncrementalDomRenderer.prototype.guaranteeParent_ = function guaranteeParent_() {
		var element = this.component_.element;
		if (!element || !element.parentNode) {
			var parent = document.createElement('div');
			if (element) {
				_dom2.default.append(parent, element);
			}
			return parent;
		}
	};

	/**
  * Handles the `detached` listener. Removes all inline listeners.
  * @protected
  */


	IncrementalDomRenderer.prototype.handleDetached_ = function handleDetached_() {
		this.eventsCollector_.detachAllListeners();
	};

	/**
  * Handles an intercepted call to the attributes default handler from
  * incremental dom.
  * @param {!function()} originalFn The original function before interception.
  * @param {!Element} element
  * @param {string} name
  * @param {*} value
  * @protected
  */


	IncrementalDomRenderer.prototype.handleInterceptedAttributesCall_ = function handleInterceptedAttributesCall_(originalFn, element, name, value) {
		if (name.startsWith('data-on')) {
			var eventName = name.substr(7);
			if (_metal.core.isFunction(element[name])) {
				element.removeEventListener(eventName, element[name]);
			}
			if (_metal.core.isFunction(value)) {
				_dom2.default.on(element, eventName, value);
			}
		} else if (name === 'checked') {
			// This is a temporary fix to account for incremental dom setting
			// "checked" as an attribute only, which can cause bugs since that won't
			// necessarily check/uncheck the element it's set on. See
			// https://github.com/google/incremental-dom/issues/198 for more details.
			element.checked = _metal.core.isDefAndNotNull(value) && value !== false;
		}
		originalFn(element, name, value);
	};

	/**
  * Handles an intercepted call to the `elementClose` function from incremental
  * dom, while collecting a component's children.
  * @param {!function()} originalFn The original function before interception.
  * @param {string} callTag
  * @protected
  */


	IncrementalDomRenderer.prototype.handleInterceptedChildrenCloseCall_ = function handleInterceptedChildrenCloseCall_(originalFn, callTag) {
		if (this.isCurrentComponentTag_(callTag) && --this.componentToRender_.tagsCount === 0) {
			var _componentToRender_ = this.componentToRender_;
			var calls = _componentToRender_.calls;
			var config = _componentToRender_.config;
			var tag = _componentToRender_.tag;

			config.children = this.buildChildrenFn_(calls);
			this.componentToRender_ = null;
			_IncrementalDomAop2.default.stopInterception();
			return this.renderSubComponent_(tag, config).element;
		}
		this.componentToRender_.calls.push({
			name: 'elementClose',
			args: arguments
		});
	};

	/**
  * Handles an intercepted call to the `elementOpen` function from incremental
  * dom, while collecting a component's children.
  * @param {!function()} originalFn The original function before interception.
  * @param {string} tag
  * @protected
  */


	IncrementalDomRenderer.prototype.handleInterceptedChildrenOpenCall_ = function handleInterceptedChildrenOpenCall_(originalFn, tag) {
		if (this.isCurrentComponentTag_(tag)) {
			this.componentToRender_.tagsCount++;
		}
		this.componentToRender_.calls.push({
			name: 'elementOpen',
			args: arguments
		});
	};

	/**
  * Handles an intercepted call to the `text` function from incremental dom,
  * while collecting a component's children.
  * @protected
  */


	IncrementalDomRenderer.prototype.handleInterceptedChildrenTextCall_ = function handleInterceptedChildrenTextCall_() {
		this.componentToRender_.calls.push({
			name: 'text',
			args: arguments
		});
	};

	/**
  * Handles an intercepted call to the `elementOpen` function from incremental
  * dom.
  * @param {!function()} originalFn The original function before interception.
  * @param {string} tag
  * @protected
  */


	IncrementalDomRenderer.prototype.handleInterceptedOpenCall_ = function handleInterceptedOpenCall_(originalFn, tag) {
		if (this.isComponentTag_(tag)) {
			return this.handleSubComponentCall_.apply(this, arguments);
		} else {
			return this.handleRegularCall_.apply(this, arguments);
		}
	};

	/**
  * Handles an intercepted call to the `elementOpen` function from incremental
  * dom, done for a regular element. Adds any inline listeners found and makes
  * sure that component root elements are always reused.
  * @param {!function()} originalFn The original function before interception.
  * @param {string} tag
  * @param {?string} key
  * @param {?Array} statics
  * @protected
  */


	IncrementalDomRenderer.prototype.handleRegularCall_ = function handleRegularCall_(originalFn, tag, key, statics) {
		var attrsArr = _metal.array.slice(arguments, 4);
		this.addInlineListeners_((statics || []).concat(attrsArr));
		var args = _metal.array.slice(arguments, 1);
		if (!this.rootElementReached_ && this.component_.config.key) {
			args[1] = this.component_.config.key;
		}
		var node = originalFn.apply(null, args);
		if (!this.rootElementReached_) {
			this.rootElementReached_ = true;
			if (this.component_.element !== node) {
				this.component_.element = node;
			}
		}
		return node;
	};

	/**
  * Handles the `stateKeyChanged` event. Makes sure that, when `stateChanged`
  * is fired, the component's contents will only be updated if the changed
  * state key wasn't `element`, since that wouldn't cause a rerender.
  * @param {!Object} data
  * @protected
  */


	IncrementalDomRenderer.prototype.handleStateKeyChanged_ = function handleStateKeyChanged_(data) {
		if (data.key !== 'element') {
			this.changes_[data.key] = data;
		}
	};

	/**
  * Handles an intercepted call to the `elementOpen` function from incremental
  * dom, done for a sub component element. Creates and updates the appropriate
  * sub component.
  * @param {!function()} originalFn The original function before interception.
  * @param {string} tag
  * @param {?string} key
  * @param {?Array} statics
  * @protected
  */


	IncrementalDomRenderer.prototype.handleSubComponentCall_ = function handleSubComponentCall_(originalFn, tag, key, statics) {
		var config = { key: key };
		var attrsArr = (statics || []).concat(_metal.array.slice(arguments, 4));
		for (var i = 0; i < attrsArr.length; i += 2) {
			config[attrsArr[i]] = attrsArr[i + 1];
		}

		this.componentToRender_ = {
			calls: [],
			config: config,
			tag: tag,
			tagsCount: 1
		};
		_IncrementalDomAop2.default.startInterception({
			elementClose: this.handleInterceptedChildrenCloseCall_,
			elementOpen: this.handleInterceptedChildrenOpenCall_,
			text: this.handleInterceptedChildrenTextCall_
		});
	};

	/**
  * Intercepts incremental dom calls from this component.
  * @protected
  */


	IncrementalDomRenderer.prototype.intercept_ = function intercept_() {
		_IncrementalDomAop2.default.startInterception({
			attributes: this.handleInterceptedAttributesCall_,
			elementOpen: this.handleInterceptedOpenCall_
		});
	};

	/**
  * Checks if the given tag represents a metal component.
  * @param {string} tag
  * @protected
  */


	IncrementalDomRenderer.prototype.isComponentTag_ = function isComponentTag_(tag) {
		return !_metal.core.isString(tag) || tag[0] === tag[0].toUpperCase();
	};

	/**
  * Checks if the given tag represents the metal component currently being
  * rendered.
  * @param {string} tag
  * @protected
  */


	IncrementalDomRenderer.prototype.isCurrentComponentTag_ = function isCurrentComponentTag_(tag) {
		return this.isComponentTag_(tag) && this.componentToRender_.tag === tag;
	};

	/**
  * Renders the renderer's component for the first time, patching its element
  * through the incremental dom function calls done by `renderIncDom`.
  */


	IncrementalDomRenderer.prototype.render = function render() {
		this.patch();
	};

	/**
  * Calls functions from `IncrementalDOM` to build the component element's
  * content. Can be overriden by subclasses (for integration with template
  * engines for example).
  */


	IncrementalDomRenderer.prototype.renderIncDom = function renderIncDom() {
		IncrementalDOM.elementVoid('div');
	};

	/**
  * Runs the incremental dom functions for rendering this component, but
  * doesn't call `patch` yet. Rather, this will be the function that should be
  * called by `patch`.
  */


	IncrementalDomRenderer.prototype.renderWithoutPatch = function renderWithoutPatch() {
		// Mark that there shouldn't be an update for state changes so far, since
		// render has already been called.
		this.changes_ = {};

		this.rootElementReached_ = false;
		this.subComponentsFound_ = {};
		this.generatedKeyCount_ = 0;
		this.listenersToAttach_ = [];
		this.intercept_();
		this.renderIncDom();
		_IncrementalDomAop2.default.stopInterception();
		this.attachInlineListeners_();
	};

	/**
  * Checks if the component should be updated with the current state changes.
  * Can be overridden by subclasses to provide customized behavior (only
  * updating when a state key used by the template is changed for example).
  * @param {!Object} changes
  * @return {boolean}
  */


	IncrementalDomRenderer.prototype.shouldUpdate = function shouldUpdate() {
		return true;
	};

	/**
  * Patches the component's element with the incremental dom function calls
  * done by `renderIncDom`.
  */


	IncrementalDomRenderer.prototype.patch = function patch() {
		var tempParent = this.guaranteeParent_();
		if (tempParent) {
			IncrementalDOM.patch(tempParent, this.renderWithoutPatch);
			_dom2.default.exitDocument(this.component_.element);
		} else {
			IncrementalDOM.patchOuter(this.component_.element, this.renderWithoutPatch);
		}
	};

	/**
  * Updates the renderer's component when state changes, patching its element
  * through the incremental dom function calls done by `renderIncDom`.
  */


	IncrementalDomRenderer.prototype.update = function update() {
		var changedKeys = Object.keys(this.changes_);
		if (changedKeys.length > 0 && this.shouldUpdate(this.changes_)) {
			this.patch();
			this.eventsCollector_.detachUnusedListeners();
			this.disposeUnusedSubComponents_();
		}
	};

	/**
  * This updates the sub component that is represented by the given data.
  * The sub component is created, added to its parent and rendered. If it
  * had already been rendered before though, it will only have its state
  * updated instead.
  * @param {string|!function()} tagOrCtor The tag name or constructor function.
  * @param {!Object} config The config object for the sub component.
  * @return {!Component} The updated sub component.
  * @protected
  */


	IncrementalDomRenderer.prototype.renderSubComponent_ = function renderSubComponent_(tagOrCtor, config) {
		var key = config.key || 'sub' + this.generatedKeyCount_++;
		var comp = this.getSubComponent_(key, tagOrCtor, config);
		var renderer = comp.getRenderer();
		if (renderer instanceof IncrementalDomRenderer) {
			renderer.renderWithoutPatch();
		} else {
			console.warn('IncrementalDomRenderer doesn\'t support rendering sub components ' + 'that don\'t use IncrementalDomRenderer as well, like:', comp);
		}
		if (!comp.wasRendered) {
			comp.renderAsSubComponent();
		}
		this.subComponentsFound_[key] = true;
		return comp;
	};

	return IncrementalDomRenderer;
}(_component.ComponentRenderer);

exports.default = IncrementalDomRenderer;

},{"../../metal-component/src/all/component":10,"../../metal-dom/src/all/dom":13,"../../metal/src/metal":46,"./IncrementalDomAop":24,"./incremental-dom":26}],26:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

/* jshint ignore:start */

/**
 * @license
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function (global, factory) {
  factory(global.IncrementalDOM = global.IncrementalDOM || {});
})(window, function (exports) {
  'use strict';

  /**
   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS-IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * A cached reference to the hasOwnProperty function.
   */

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  /**
   * A cached reference to the create function.
   */
  var create = Object.create;

  /**
   * Used to prevent property collisions between our "map" and its prototype.
   * @param {!Object<string, *>} map The map to check.
   * @param {string} property The property to check.
   * @return {boolean} Whether map has property.
   */
  var has = function has(map, property) {
    return hasOwnProperty.call(map, property);
  };

  /**
   * Creates an map object without a prototype.
   * @return {!Object}
   */
  var createMap = function createMap() {
    return create(null);
  };

  /**
   * Keeps track of information needed to perform diffs for a given DOM node.
   * @param {!string} nodeName
   * @param {?string=} key
   * @constructor
   */
  function NodeData(nodeName, key) {
    /**
     * The attributes and their values.
     * @const {!Object<string, *>}
     */
    this.attrs = createMap();

    /**
     * An array of attribute name/value pairs, used for quickly diffing the
     * incomming attributes to see if the DOM node's attributes need to be
     * updated.
     * @const {Array<*>}
     */
    this.attrsArr = [];

    /**
     * The incoming attributes for this Node, before they are updated.
     * @const {!Object<string, *>}
     */
    this.newAttrs = createMap();

    /**
     * The key used to identify this node, used to preserve DOM nodes when they
     * move within their parent.
     * @const
     */
    this.key = key;

    /**
     * Keeps track of children within this node by their key.
     * {?Object<string, !Element>}
     */
    this.keyMap = null;

    /**
     * Whether or not the keyMap is currently valid.
     * {boolean}
     */
    this.keyMapValid = true;

    /**
     * The node name for this node.
     * @const {string}
     */
    this.nodeName = nodeName;

    /**
     * @type {?string}
     */
    this.text = null;
  }

  /**
   * Initializes a NodeData object for a Node.
   *
   * @param {Node} node The node to initialize data for.
   * @param {string} nodeName The node name of node.
   * @param {?string=} key The key that identifies the node.
   * @return {!NodeData} The newly initialized data object
   */
  var initData = function initData(node, nodeName, key) {
    var data = new NodeData(nodeName, key);
    node['__incrementalDOMData'] = data;
    return data;
  };

  /**
   * Retrieves the NodeData object for a Node, creating it if necessary.
   *
   * @param {Node} node The node to retrieve the data for.
   * @return {!NodeData} The NodeData for this Node.
   */
  var getData = function getData(node) {
    var data = node['__incrementalDOMData'];

    if (!data) {
      var nodeName = node.nodeName.toLowerCase();
      var key = null;

      if (node instanceof Element) {
        key = node.getAttribute('key');
      }

      data = initData(node, nodeName, key);
    }

    return data;
  };

  /**
   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS-IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @const */
  var symbols = {
    default: '__default',

    placeholder: '__placeholder'
  };

  /**
   * @param {string} name
   * @return {string|undefined} The namespace to use for the attribute.
   */
  var getNamespace = function getNamespace(name) {
    if (name.lastIndexOf('xml:', 0) === 0) {
      return 'http://www.w3.org/XML/1998/namespace';
    }

    if (name.lastIndexOf('xlink:', 0) === 0) {
      return 'http://www.w3.org/1999/xlink';
    }
  };

  /**
   * Applies an attribute or property to a given Element. If the value is null
   * or undefined, it is removed from the Element. Otherwise, the value is set
   * as an attribute.
   * @param {!Element} el
   * @param {string} name The attribute's name.
   * @param {?(boolean|number|string)=} value The attribute's value.
   */
  var applyAttr = function applyAttr(el, name, value) {
    if (value == null) {
      el.removeAttribute(name);
    } else {
      var attrNS = getNamespace(name);
      if (attrNS) {
        el.setAttributeNS(attrNS, name, value);
      } else {
        el.setAttribute(name, value);
      }
    }
  };

  /**
   * Applies a property to a given Element.
   * @param {!Element} el
   * @param {string} name The property's name.
   * @param {*} value The property's value.
   */
  var applyProp = function applyProp(el, name, value) {
    el[name] = value;
  };

  /**
   * Applies a style to an Element. No vendor prefix expansion is done for
   * property names/values.
   * @param {!Element} el
   * @param {string} name The attribute's name.
   * @param {*} style The style to set. Either a string of css or an object
   *     containing property-value pairs.
   */
  var applyStyle = function applyStyle(el, name, style) {
    if (typeof style === 'string') {
      el.style.cssText = style;
    } else {
      el.style.cssText = '';
      var elStyle = el.style;
      var obj = /** @type {!Object<string,string>} */style;

      for (var prop in obj) {
        if (has(obj, prop)) {
          elStyle[prop] = obj[prop];
        }
      }
    }
  };

  /**
   * Updates a single attribute on an Element.
   * @param {!Element} el
   * @param {string} name The attribute's name.
   * @param {*} value The attribute's value. If the value is an object or
   *     function it is set on the Element, otherwise, it is set as an HTML
   *     attribute.
   */
  var applyAttributeTyped = function applyAttributeTyped(el, name, value) {
    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);

    if (type === 'object' || type === 'function') {
      applyProp(el, name, value);
    } else {
      applyAttr(el, name, /** @type {?(boolean|number|string)} */value);
    }
  };

  /**
   * Calls the appropriate attribute mutator for this attribute.
   * @param {!Element} el
   * @param {string} name The attribute's name.
   * @param {*} value The attribute's value.
   */
  var updateAttribute = function updateAttribute(el, name, value) {
    var data = getData(el);
    var attrs = data.attrs;

    if (attrs[name] === value) {
      return;
    }

    var mutator = attributes[name] || attributes[symbols.default];
    mutator(el, name, value);

    attrs[name] = value;
  };

  /**
   * A publicly mutable object to provide custom mutators for attributes.
   * @const {!Object<string, function(!Element, string, *)>}
   */
  var attributes = createMap();

  // Special generic mutator that's called for any attribute that does not
  // have a specific mutator.
  attributes[symbols.default] = applyAttributeTyped;

  attributes[symbols.placeholder] = function () {};

  attributes['style'] = applyStyle;

  /**
   * Gets the namespace to create an element (of a given tag) in.
   * @param {string} tag The tag to get the namespace for.
   * @param {?Node} parent
   * @return {?string} The namespace to create the tag in.
   */
  var getNamespaceForTag = function getNamespaceForTag(tag, parent) {
    if (tag === 'svg') {
      return 'http://www.w3.org/2000/svg';
    }

    if (getData(parent).nodeName === 'foreignObject') {
      return null;
    }

    return parent.namespaceURI;
  };

  /**
   * Creates an Element.
   * @param {Document} doc The document with which to create the Element.
   * @param {?Node} parent
   * @param {string} tag The tag for the Element.
   * @param {?string=} key A key to identify the Element.
   * @param {?Array<*>=} statics An array of attribute name/value pairs of the
   *     static attributes for the Element.
   * @return {!Element}
   */
  var createElement = function createElement(doc, parent, tag, key, statics) {
    var namespace = getNamespaceForTag(tag, parent);
    var el = undefined;

    if (namespace) {
      el = doc.createElementNS(namespace, tag);
    } else {
      el = doc.createElement(tag);
    }

    initData(el, tag, key);

    if (statics) {
      for (var i = 0; i < statics.length; i += 2) {
        updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);
      }
    }

    return el;
  };

  /**
   * Creates a Text Node.
   * @param {Document} doc The document with which to create the Element.
   * @return {!Text}
   */
  var createText = function createText(doc) {
    var node = doc.createTextNode('');
    initData(node, '#text', null);
    return node;
  };

  /**
   * Creates a mapping that can be used to look up children using a key.
   * @param {?Node} el
   * @return {!Object<string, !Element>} A mapping of keys to the children of the
   *     Element.
   */
  var createKeyMap = function createKeyMap(el) {
    var map = createMap();
    var child = el.firstElementChild;

    while (child) {
      var key = getData(child).key;

      if (key) {
        map[key] = child;
      }

      child = child.nextElementSibling;
    }

    return map;
  };

  /**
   * Retrieves the mapping of key to child node for a given Element, creating it
   * if necessary.
   * @param {?Node} el
   * @return {!Object<string, !Node>} A mapping of keys to child Elements
   */
  var getKeyMap = function getKeyMap(el) {
    var data = getData(el);

    if (!data.keyMap) {
      data.keyMap = createKeyMap(el);
    }

    return data.keyMap;
  };

  /**
   * Retrieves a child from the parent with the given key.
   * @param {?Node} parent
   * @param {?string=} key
   * @return {?Node} The child corresponding to the key.
   */
  var getChild = function getChild(parent, key) {
    return key ? getKeyMap(parent)[key] : null;
  };

  /**
   * Registers an element as being a child. The parent will keep track of the
   * child using the key. The child can be retrieved using the same key using
   * getKeyMap. The provided key should be unique within the parent Element.
   * @param {?Node} parent The parent of child.
   * @param {string} key A key to identify the child with.
   * @param {!Node} child The child to register.
   */
  var registerChild = function registerChild(parent, key, child) {
    getKeyMap(parent)[key] = child;
  };

  /**
   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS-IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @const */
  var notifications = {
    /**
     * Called after patch has compleated with any Nodes that have been created
     * and added to the DOM.
     * @type {?function(Array<!Node>)}
     */
    nodesCreated: null,

    /**
     * Called after patch has compleated with any Nodes that have been removed
     * from the DOM.
     * Note it's an applications responsibility to handle any childNodes.
     * @type {?function(Array<!Node>)}
     */
    nodesDeleted: null
  };

  /**
   * Keeps track of the state of a patch.
   * @constructor
   */
  function Context() {
    /**
     * @type {(Array<!Node>|undefined)}
     */
    this.created = notifications.nodesCreated && [];

    /**
     * @type {(Array<!Node>|undefined)}
     */
    this.deleted = notifications.nodesDeleted && [];
  }

  /**
   * @param {!Node} node
   */
  Context.prototype.markCreated = function (node) {
    if (this.created) {
      this.created.push(node);
    }
  };

  /**
   * @param {!Node} node
   */
  Context.prototype.markDeleted = function (node) {
    if (this.deleted) {
      this.deleted.push(node);
    }
  };

  /**
   * Notifies about nodes that were created during the patch opearation.
   */
  Context.prototype.notifyChanges = function () {
    if (this.created && this.created.length > 0) {
      notifications.nodesCreated(this.created);
    }

    if (this.deleted && this.deleted.length > 0) {
      notifications.nodesDeleted(this.deleted);
    }
  };

  /**
  * Makes sure that keyed Element matches the tag name provided.
  * @param {!string} nodeName The nodeName of the node that is being matched.
  * @param {string=} tag The tag name of the Element.
  * @param {?string=} key The key of the Element.
  */
  var assertKeyedTagMatches = function assertKeyedTagMatches(nodeName, tag, key) {
    if (nodeName !== tag) {
      throw new Error('Was expecting node with key "' + key + '" to be a ' + tag + ', not a ' + nodeName + '.');
    }
  };

  /** @type {?Context} */
  var context = null;

  /** @type {?Node} */
  var currentNode = null;

  /** @type {?Node} */
  var currentParent = null;

  /** @type {?Element|?DocumentFragment} */
  var root = null;

  /** @type {?Document} */
  var doc = null;

  /**
   * Returns a patcher function that sets up and restores a patch context,
   * running the run function with the provided data.
   * @param {function((!Element|!DocumentFragment),!function(T),T=)} run
   * @return {function((!Element|!DocumentFragment),!function(T),T=)}
   * @template T
   */
  var patchFactory = function patchFactory(run) {
    /**
     * TODO(moz): These annotations won't be necessary once we switch to Closure
     * Compiler's new type inference. Remove these once the switch is done.
     *
     * @param {(!Element|!DocumentFragment)} node
     * @param {!function(T)} fn
     * @param {T=} data
     * @template T
     */
    var f = function f(node, fn, data) {
      var prevContext = context;
      var prevRoot = root;
      var prevDoc = doc;
      var prevCurrentNode = currentNode;
      var prevCurrentParent = currentParent;
      var previousInAttributes = false;
      var previousInSkip = false;

      context = new Context();
      root = node;
      doc = node.ownerDocument;
      currentParent = node.parentNode;

      if ('production' !== 'production') {}

      run(node, fn, data);

      if ('production' !== 'production') {}

      context.notifyChanges();

      context = prevContext;
      root = prevRoot;
      doc = prevDoc;
      currentNode = prevCurrentNode;
      currentParent = prevCurrentParent;
    };
    return f;
  };

  /**
   * Patches the document starting at node with the provided function. This
   * function may be called during an existing patch operation.
   * @param {!Element|!DocumentFragment} node The Element or Document
   *     to patch.
   * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.
   *     calls that describe the DOM.
   * @param {T=} data An argument passed to fn to represent DOM state.
   * @template T
   */
  var patchInner = patchFactory(function (node, fn, data) {
    currentNode = node;

    enterNode();
    fn(data);
    exitNode();

    if ('production' !== 'production') {}
  });

  /**
   * Patches an Element with the the provided function. Exactly one top level
   * element call should be made corresponding to `node`.
   * @param {!Element} node The Element where the patch should start.
   * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.
   *     calls that describe the DOM. This should have at most one top level
   *     element call.
   * @param {T=} data An argument passed to fn to represent DOM state.
   * @template T
   */
  var patchOuter = patchFactory(function (node, fn, data) {
    currentNode = /** @type {!Element} */{ nextSibling: node };

    fn(data);

    if ('production' !== 'production') {}
  });

  /**
   * Checks whether or not the current node matches the specified nodeName and
   * key.
   *
   * @param {?string} nodeName The nodeName for this node.
   * @param {?string=} key An optional key that identifies a node.
   * @return {boolean} True if the node matches, false otherwise.
   */
  var matches = function matches(nodeName, key) {
    var data = getData(currentNode);

    // Key check is done using double equals as we want to treat a null key the
    // same as undefined. This should be okay as the only values allowed are
    // strings, null and undefined so the == semantics are not too weird.
    return nodeName === data.nodeName && key == data.key;
  };

  /**
   * Aligns the virtual Element definition with the actual DOM, moving the
   * corresponding DOM node to the correct location or creating it if necessary.
   * @param {string} nodeName For an Element, this should be a valid tag string.
   *     For a Text, this should be #text.
   * @param {?string=} key The key used to identify this element.
   * @param {?Array<*>=} statics For an Element, this should be an array of
   *     name-value pairs.
   */
  var alignWithDOM = function alignWithDOM(nodeName, key, statics) {
    if (currentNode && matches(nodeName, key)) {
      return;
    }

    var node = undefined;

    // Check to see if the node has moved within the parent.
    if (key) {
      node = getChild(currentParent, key);
      if (node && 'production' !== 'production') {
        assertKeyedTagMatches(getData(node).nodeName, nodeName, key);
      }
    }

    // Create the node if it doesn't exist.
    if (!node) {
      if (nodeName === '#text') {
        node = createText(doc);
      } else {
        node = createElement(doc, currentParent, nodeName, key, statics);
      }

      if (key) {
        registerChild(currentParent, key, node);
      }

      context.markCreated(node);
    }

    // If the node has a key, remove it from the DOM to prevent a large number
    // of re-orders in the case that it moved far or was completely removed.
    // Since we hold on to a reference through the keyMap, we can always add it
    // back.
    if (currentNode && getData(currentNode).key) {
      currentParent.replaceChild(node, currentNode);
      getData(currentParent).keyMapValid = false;
    } else {
      currentParent.insertBefore(node, currentNode);
    }

    currentNode = node;
  };

  /**
   * Clears out any unvisited Nodes, as the corresponding virtual element
   * functions were never called for them.
   */
  var clearUnvisitedDOM = function clearUnvisitedDOM() {
    var node = currentParent;
    var data = getData(node);
    var keyMap = data.keyMap;
    var keyMapValid = data.keyMapValid;
    var child = node.lastChild;
    var key = undefined;

    if (child === currentNode && keyMapValid) {
      return;
    }

    if (data.attrs[symbols.placeholder] && node !== root) {
      if ('production' !== 'production') {}
      return;
    }

    while (child !== currentNode) {
      node.removeChild(child);
      context.markDeleted( /** @type {!Node}*/child);

      key = getData(child).key;
      if (key) {
        delete keyMap[key];
      }
      child = node.lastChild;
    }

    // Clean the keyMap, removing any unusued keys.
    if (!keyMapValid) {
      for (key in keyMap) {
        child = keyMap[key];
        if (child.parentNode !== node) {
          context.markDeleted(child);
          delete keyMap[key];
        }
      }

      data.keyMapValid = true;
    }
  };

  /**
   * Changes to the first child of the current node.
   */
  var enterNode = function enterNode() {
    currentParent = currentNode;
    currentNode = null;
  };

  /**
   * Changes to the next sibling of the current node.
   */
  var nextNode = function nextNode() {
    if (currentNode) {
      currentNode = currentNode.nextSibling;
    } else {
      currentNode = currentParent.firstChild;
    }
  };

  /**
   * Changes to the parent of the current node, removing any unvisited children.
   */
  var exitNode = function exitNode() {
    clearUnvisitedDOM();

    currentNode = currentParent;
    currentParent = currentParent.parentNode;
  };

  /**
   * Makes sure that the current node is an Element with a matching tagName and
   * key.
   *
   * @param {string} tag The element's tag.
   * @param {?string=} key The key used to identify this element. This can be an
   *     empty string, but performance may be better if a unique value is used
   *     when iterating over an array of items.
   * @param {?Array<*>=} statics An array of attribute name/value pairs of the
   *     static attributes for the Element. These will only be set once when the
   *     Element is created.
   * @return {!Element} The corresponding Element.
   */
  var coreElementOpen = function coreElementOpen(tag, key, statics) {
    nextNode();
    alignWithDOM(tag, key, statics);
    enterNode();
    return (/** @type {!Element} */currentParent
    );
  };

  /**
   * Closes the currently open Element, removing any unvisited children if
   * necessary.
   *
   * @return {!Element} The corresponding Element.
   */
  var coreElementClose = function coreElementClose() {
    if ('production' !== 'production') {}

    exitNode();
    return (/** @type {!Element} */currentNode
    );
  };

  /**
   * Makes sure the current node is a Text node and creates a Text node if it is
   * not.
   *
   * @return {!Text} The corresponding Text Node.
   */
  var coreText = function coreText() {
    nextNode();
    alignWithDOM('#text', null, null);
    return (/** @type {!Text} */currentNode
    );
  };

  /**
   * Gets the current Element being patched.
   * @return {!Element}
   */
  var currentElement = function currentElement() {
    if ('production' !== 'production') {}
    return (/** @type {!Element} */currentParent
    );
  };

  /**
   * Skips the children in a subtree, allowing an Element to be closed without
   * clearing out the children.
   */
  var skip = function skip() {
    if ('production' !== 'production') {}
    currentNode = currentParent.lastChild;
  };

  /**
   * The offset in the virtual element declaration where the attributes are
   * specified.
   * @const
   */
  var ATTRIBUTES_OFFSET = 3;

  /**
   * Builds an array of arguments for use with elementOpenStart, attr and
   * elementOpenEnd.
   * @const {Array<*>}
   */
  var argsBuilder = [];

  /**
   * @param {string} tag The element's tag.
   * @param {?string=} key The key used to identify this element. This can be an
   *     empty string, but performance may be better if a unique value is used
   *     when iterating over an array of items.
   * @param {?Array<*>=} statics An array of attribute name/value pairs of the
   *     static attributes for the Element. These will only be set once when the
   *     Element is created.
   * @param {...*} const_args Attribute name/value pairs of the dynamic attributes
   *     for the Element.
   * @return {!Element} The corresponding Element.
   */
  var elementOpen = function elementOpen(tag, key, statics, const_args) {
    if ('production' !== 'production') {}

    var node = coreElementOpen(tag, key, statics);
    var data = getData(node);

    /*
     * Checks to see if one or more attributes have changed for a given Element.
     * When no attributes have changed, this is much faster than checking each
     * individual argument. When attributes have changed, the overhead of this is
     * minimal.
     */
    var attrsArr = data.attrsArr;
    var newAttrs = data.newAttrs;
    var attrsChanged = false;
    var i = ATTRIBUTES_OFFSET;
    var j = 0;

    for (; i < arguments.length; i += 1, j += 1) {
      if (attrsArr[j] !== arguments[i]) {
        attrsChanged = true;
        break;
      }
    }

    for (; i < arguments.length; i += 1, j += 1) {
      attrsArr[j] = arguments[i];
    }

    if (j < attrsArr.length) {
      attrsChanged = true;
      attrsArr.length = j;
    }

    /*
     * Actually perform the attribute update.
     */
    if (attrsChanged) {
      for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {
        newAttrs[arguments[i]] = arguments[i + 1];
      }

      for (var _attr in newAttrs) {
        updateAttribute(node, _attr, newAttrs[_attr]);
        newAttrs[_attr] = undefined;
      }
    }

    return node;
  };

  /**
   * Declares a virtual Element at the current location in the document. This
   * corresponds to an opening tag and a elementClose tag is required. This is
   * like elementOpen, but the attributes are defined using the attr function
   * rather than being passed as arguments. Must be folllowed by 0 or more calls
   * to attr, then a call to elementOpenEnd.
   * @param {string} tag The element's tag.
   * @param {?string=} key The key used to identify this element. This can be an
   *     empty string, but performance may be better if a unique value is used
   *     when iterating over an array of items.
   * @param {?Array<*>=} statics An array of attribute name/value pairs of the
   *     static attributes for the Element. These will only be set once when the
   *     Element is created.
   */
  var elementOpenStart = function elementOpenStart(tag, key, statics) {
    if ('production' !== 'production') {}

    argsBuilder[0] = tag;
    argsBuilder[1] = key;
    argsBuilder[2] = statics;
  };

  /***
   * Defines a virtual attribute at this point of the DOM. This is only valid
   * when called between elementOpenStart and elementOpenEnd.
   *
   * @param {string} name
   * @param {*} value
   */
  var attr = function attr(name, value) {
    if ('production' !== 'production') {}

    argsBuilder.push(name, value);
  };

  /**
   * Closes an open tag started with elementOpenStart.
   * @return {!Element} The corresponding Element.
   */
  var elementOpenEnd = function elementOpenEnd() {
    if ('production' !== 'production') {}

    var node = elementOpen.apply(null, argsBuilder);
    argsBuilder.length = 0;
    return node;
  };

  /**
   * Closes an open virtual Element.
   *
   * @param {string} tag The element's tag.
   * @return {!Element} The corresponding Element.
   */
  var elementClose = function elementClose(tag) {
    if ('production' !== 'production') {}

    var node = coreElementClose();

    if ('production' !== 'production') {}

    return node;
  };

  /**
   * Declares a virtual Element at the current location in the document that has
   * no children.
   * @param {string} tag The element's tag.
   * @param {?string=} key The key used to identify this element. This can be an
   *     empty string, but performance may be better if a unique value is used
   *     when iterating over an array of items.
   * @param {?Array<*>=} statics An array of attribute name/value pairs of the
   *     static attributes for the Element. These will only be set once when the
   *     Element is created.
   * @param {...*} const_args Attribute name/value pairs of the dynamic attributes
   *     for the Element.
   * @return {!Element} The corresponding Element.
   */
  var elementVoid = function elementVoid(tag, key, statics, const_args) {
    elementOpen.apply(null, arguments);
    return elementClose(tag);
  };

  /**
   * Declares a virtual Element at the current location in the document that is a
   * placeholder element. Children of this Element can be manually managed and
   * will not be cleared by the library.
   *
   * A key must be specified to make sure that this node is correctly preserved
   * across all conditionals.
   *
   * @param {string} tag The element's tag.
   * @param {string} key The key used to identify this element.
   * @param {?Array<*>=} statics An array of attribute name/value pairs of the
   *     static attributes for the Element. These will only be set once when the
   *     Element is created.
   * @param {...*} const_args Attribute name/value pairs of the dynamic attributes
   *     for the Element.
   * @return {!Element} The corresponding Element.
   */
  var elementPlaceholder = function elementPlaceholder(tag, key, statics, const_args) {
    if ('production' !== 'production') {}

    elementOpen.apply(null, arguments);
    skip();
    return elementClose(tag);
  };

  /**
   * Declares a virtual Text at this point in the document.
   *
   * @param {string|number|boolean} value The value of the Text.
   * @param {...(function((string|number|boolean)):string)} const_args
   *     Functions to format the value which are called only when the value has
   *     changed.
   * @return {!Text} The corresponding text node.
   */
  var text = function text(value, const_args) {
    if ('production' !== 'production') {}

    var node = coreText();
    var data = getData(node);

    if (data.text !== value) {
      data.text = /** @type {string} */value;

      var formatted = value;
      for (var i = 1; i < arguments.length; i += 1) {
        /*
         * Call the formatter function directly to prevent leaking arguments.
         * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574
         */
        var fn = arguments[i];
        formatted = fn(formatted);
      }

      node.data = formatted;
    }

    return node;
  };

  exports.patch = patchInner;
  exports.patchInner = patchInner;
  exports.patchOuter = patchOuter;
  exports.currentElement = currentElement;
  exports.skip = skip;
  exports.elementVoid = elementVoid;
  exports.elementOpenStart = elementOpenStart;
  exports.elementOpenEnd = elementOpenEnd;
  exports.elementOpen = elementOpen;
  exports.elementClose = elementClose;
  exports.elementPlaceholder = elementPlaceholder;
  exports.text = text;
  exports.attr = attr;
  exports.symbols = symbols;
  exports.attributes = attributes;
  exports.applyAttr = applyAttr;
  exports.applyProp = applyProp;
  exports.notifications = notifications;
});

},{}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

require('./iDOMHelpers');

var _IncrementalDomRenderer = require('../../metal-incremental-dom/src/IncrementalDomRenderer');

var _IncrementalDomRenderer2 = _interopRequireDefault(_IncrementalDomRenderer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Allows components to use JSX templates to render their contents. Usage
 * example:
 *
 * class MyComp extends Component {
 *   jsx() {
 *     <div class="my-comp">Hello World</div>;
 *   }
 * }
 * JSX.register(MyComp);
 */

var JSX = function (_IncrementalDomRender) {
	_inherits(JSX, _IncrementalDomRender);

	/**
  * @inheritDoc
  */

	function JSX(comp) {
		_classCallCheck(this, JSX);

		var _this = _possibleConstructorReturn(this, _IncrementalDomRender.call(this, comp));

		_this.fn_ = comp.render && comp.render.bind(comp);
		return _this;
	}

	/**
  * Overrides the original method so the "children" function can be
  * automatically rendered through jsx.
  * @param {!Array<!{name: string, args: !Array}>} calls
  * @return {!function()}
  * @protected
  * @override
  */


	JSX.prototype.buildChildrenFn_ = function buildChildrenFn_(calls) {
		var fn = _IncrementalDomRender.prototype.buildChildrenFn_.call(this, calls);
		return iDOMHelpers.jsxWrapper(fn);
	};

	/**
  * Overrides the default method from `IncrementalDomRenderer` so the
  * component's JSX template can be used for rendering.
  * @override
  */


	JSX.prototype.renderIncDom = function renderIncDom() {
		if (this.fn_) {
			this.fn_();
		} else {
			_IncrementalDomRender.prototype.renderIncDom.call(this);
		}
	};

	return JSX;
}(_IncrementalDomRenderer2.default);

exports.default = JSX;

},{"../../metal-incremental-dom/src/IncrementalDomRenderer":25,"./iDOMHelpers":29}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.JSX = undefined;

var _component = require('../../metal-component/src/all/component');

var _component2 = _interopRequireDefault(_component);

var _JSX = require('./JSX');

var _JSX2 = _interopRequireDefault(_JSX);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var JSXComponent = function (_Component) {
	_inherits(JSXComponent, _Component);

	function JSXComponent() {
		_classCallCheck(this, JSXComponent);

		return _possibleConstructorReturn(this, _Component.apply(this, arguments));
	}

	/**
  * Overrides the original method to create a JSX renderer.
  * @return {!JSX}
  */

	JSXComponent.prototype.createRenderer = function createRenderer() {
		return new _JSX2.default(this);
	};

	return JSXComponent;
}(_component2.default);

exports.default = JSXComponent;
exports.JSX = _JSX2.default;

},{"../../metal-component/src/all/component":10,"./JSX":27}],29:[function(require,module,exports){
'use strict';

/**
 * These helpers are all from "babel-plugin-incremental-dom". See its README
 * file for more details:
 * https://github.com/jridgewell/babel-plugin-incremental-dom#runtime
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

window.iDOMHelpers = window.iDOMHelpers || {};

window.iDOMHelpers.attr = function (value, attrName) {
  IncrementalDOM.attr(attrName, value);
};

window.iDOMHelpers.forOwn = function (object, iterator) {
  var hasOwn = Object.prototype.hasOwnProperty;
  for (var prop in object) {
    if (hasOwn.call(object, prop)) {
      iterator(object[prop], prop);
    }
  }
};

window.iDOMHelpers.jsxWrapper = function (elementClosure, args) {
  var wrapper = args ? function () {
    return elementClosure.apply(this, args);
  } : elementClosure;
  wrapper.__jsxDOMWrapper = true;
  return wrapper;
};

window.iDOMHelpers.renderArbitrary = function (child) {
  var type = typeof child === 'undefined' ? 'undefined' : _typeof(child);
  if (type === 'number' || type === 'string' || child && child instanceof String) {
    IncrementalDOM.text(child);
  } else if (type === 'function' && child.__jsxDOMWrapper) {
    child();
  } else if (Array.isArray(child)) {
    child.forEach(window.iDOMHelpers.renderArbitrary);
  } else if (String(child) === '[object Object]') {
    window.iDOMHelpers.forOwn(child, window.iDOMHelpers.renderArbitrary);
  }
};

exports.default = window.iDOMHelpers;

},{}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../metal/src/metal');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A cached reference to the create function.
 */
var create = Object.create;

/**
 * Case insensitive string Multimap implementation. Allows multiple values for
 * the same key name.
 * @extends {Disposable}
 */

var MultiMap = function (_Disposable) {
	_inherits(MultiMap, _Disposable);

	function MultiMap() {
		_classCallCheck(this, MultiMap);

		var _this = _possibleConstructorReturn(this, _Disposable.call(this));

		_this.keys = create(null);
		_this.values = create(null);
		return _this;
	}

	/**
  * Adds value to a key name.
  * @param {string} name
  * @param {*} value
  * @chainable
  */


	MultiMap.prototype.add = function add(name, value) {
		this.keys[name.toLowerCase()] = name;
		this.values[name.toLowerCase()] = this.values[name.toLowerCase()] || [];
		this.values[name.toLowerCase()].push(value);
		return this;
	};

	/**
  * Clears map names and values.
  * @chainable
  */


	MultiMap.prototype.clear = function clear() {
		this.keys = create(null);
		this.values = create(null);
		return this;
	};

	/**
  * Checks if map contains a value to the key name.
  * @param {string} name
  * @return {boolean}
  * @chainable
  */


	MultiMap.prototype.contains = function contains(name) {
		return name.toLowerCase() in this.values;
	};

	/**
  * @inheritDoc
  */


	MultiMap.prototype.disposeInternal = function disposeInternal() {
		this.values = null;
	};

	/**
  * Gets the first added value from a key name.
  * @param {string} name
  * @return {*}
  * @chainable
  */


	MultiMap.prototype.get = function get(name) {
		var values = this.values[name.toLowerCase()];
		if (values) {
			return values[0];
		}
	};

	/**
  * Gets all values from a key name.
  * @param {string} name
  * @return {Array.<*>}
  */


	MultiMap.prototype.getAll = function getAll(name) {
		return this.values[name.toLowerCase()];
	};

	/**
  * Returns true if the map is empty, false otherwise.
  * @return {boolean}
  */


	MultiMap.prototype.isEmpty = function isEmpty() {
		return this.size() === 0;
	};

	/**
  * Gets array of key names.
  * @return {Array.<string>}
  */


	MultiMap.prototype.names = function names() {
		var _this2 = this;

		return Object.keys(this.values).map(function (key) {
			return _this2.keys[key];
		});
	};

	/**
  * Removes all values from a key name.
  * @param {string} name
  * @chainable
  */


	MultiMap.prototype.remove = function remove(name) {
		delete this.keys[name.toLowerCase()];
		delete this.values[name.toLowerCase()];
		return this;
	};

	/**
  * Sets the value of a key name. Relevant to replace the current values with
  * a new one.
  * @param {string} name
  * @param {*} value
  * @chainable
  */


	MultiMap.prototype.set = function set(name, value) {
		this.keys[name.toLowerCase()] = name;
		this.values[name.toLowerCase()] = [value];
		return this;
	};

	/**
  * Gets the size of the map key names.
  * @return {number}
  */


	MultiMap.prototype.size = function size() {
		return this.names().length;
	};

	/**
  * Returns the parsed values as a string.
  * @return {string}
  */


	MultiMap.prototype.toString = function toString() {
		return JSON.stringify(this.values);
	};

	return MultiMap;
}(_metal.Disposable);

exports.default = MultiMap;

},{"../../metal/src/metal":46}],31:[function(require,module,exports){
/*!
 * Promises polyfill from Google's Closure Library.
 *
 *      Copyright 2013 The Closure Library Authors. All Rights Reserved.
 *
 * NOTE(eduardo): Promise support is not ready on all supported browsers,
 * therefore core.js is temporarily using Google's promises as polyfill. It
 * supports cancellable promises and has clean and fast implementation.
 */

'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CancellablePromise = undefined;

var _metal = require('../../../metal/src/metal');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides a more strict interface for Thenables in terms of
 * http://promisesaplus.com for interop with {@see CancellablePromise}.
 *
 * @interface
 * @extends {IThenable.<TYPE>}
 * @template TYPE
 */
var Thenable = function Thenable() {};

/**
 * Adds callbacks that will operate on the result of the Thenable, returning a
 * new child Promise.
 *
 * If the Thenable is fulfilled, the {@code onFulfilled} callback will be
 * invoked with the fulfillment value as argument, and the child Promise will
 * be fulfilled with the return value of the callback. If the callback throws
 * an exception, the child Promise will be rejected with the thrown value
 * instead.
 *
 * If the Thenable is rejected, the {@code onRejected} callback will be invoked
 * with the rejection reason as argument, and the child Promise will be rejected
 * with the return value of the callback or thrown value.
 *
 * @param {?(function(this:THIS, TYPE):
 *             (RESULT|IThenable.<RESULT>|Thenable))=} opt_onFulfilled A
 *     function that will be invoked with the fulfillment value if the Promise
 *     is fullfilled.
 * @param {?(function(*): *)=} opt_onRejected A function that will be invoked
 *     with the rejection reason if the Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     with the default this.
 * @return {!CancellablePromise.<RESULT>} A new Promise that will receive the
 *     result of the fulfillment or rejection callback.
 * @template RESULT,THIS
 */
Thenable.prototype.then = function () {};

/**
 * An expando property to indicate that an object implements
 * {@code Thenable}.
 *
 * {@see addImplementation}.
 *
 * @const
 */
Thenable.IMPLEMENTED_BY_PROP = '$goog_Thenable';

/**
 * Marks a given class (constructor) as an implementation of Thenable, so
 * that we can query that fact at runtime. The class must have already
 * implemented the interface.
 * Exports a 'then' method on the constructor prototype, so that the objects
 * also implement the extern {@see Thenable} interface for interop with
 * other Promise implementations.
 * @param {function(new:Thenable,...[?])} ctor The class constructor. The
 *     corresponding class must have already implemented the interface.
 */
Thenable.addImplementation = function (ctor) {
  ctor.prototype.then = ctor.prototype.then;
  ctor.prototype.$goog_Thenable = true;
};

/**
 * @param {*} object
 * @return {boolean} Whether a given instance implements {@code Thenable}.
 *     The class/superclass of the instance must call {@code addImplementation}.
 */
Thenable.isImplementedBy = function (object) {
  if (!object) {
    return false;
  }
  try {
    return !!object.$goog_Thenable;
  } catch (e) {
    // Property access seems to be forbidden.
    return false;
  }
};

/**
 * Like bind(), except that a 'this object' is not required. Useful when the
 * target function is already bound.
 *
 * Usage:
 * var g = partial(f, arg1, arg2);
 * g(arg3, arg4);
 *
 * @param {Function} fn A function to partially apply.
 * @param {...*} var_args Additional arguments that are partially applied to fn.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 */
var partial = function partial(fn) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function () {
    // Clone the array (with slice()) and append additional arguments
    // to the existing arguments.
    var newArgs = args.slice();
    newArgs.push.apply(newArgs, arguments);
    return fn.apply(this, newArgs);
  };
};

/**
 * Promises provide a result that may be resolved asynchronously. A Promise may
 * be resolved by being fulfilled or rejected with a value, which will be known
 * as the fulfillment value or the rejection reason. Whether fulfilled or
 * rejected, the Promise result is immutable once it is set.
 *
 * Promises may represent results of any type, including undefined. Rejection
 * reasons are typically Errors, but may also be of any type. Closure Promises
 * allow for optional type annotations that enforce that fulfillment values are
 * of the appropriate types at compile time.
 *
 * The result of a Promise is accessible by calling {@code then} and registering
 * {@code onFulfilled} and {@code onRejected} callbacks. Once the Promise
 * resolves, the relevant callbacks are invoked with the fulfillment value or
 * rejection reason as argument. Callbacks are always invoked in the order they
 * were registered, even when additional {@code then} calls are made from inside
 * another callback. A callback is always run asynchronously sometime after the
 * scope containing the registering {@code then} invocation has returned.
 *
 * If a Promise is resolved with another Promise, the first Promise will block
 * until the second is resolved, and then assumes the same result as the second
 * Promise. This allows Promises to depend on the results of other Promises,
 * linking together multiple asynchronous operations.
 *
 * This implementation is compatible with the Promises/A+ specification and
 * passes that specification's conformance test suite. A Closure Promise may be
 * resolved with a Promise instance (or sufficiently compatible Promise-like
 * object) created by other Promise implementations. From the specification,
 * Promise-like objects are known as "Thenables".
 *
 * @see http://promisesaplus.com/
 *
 * @param {function(
 *             this:RESOLVER_CONTEXT,
 *             function((TYPE|IThenable.<TYPE>|Thenable)),
 *             function(*)): void} resolver
 *     Initialization function that is invoked immediately with {@code resolve}
 *     and {@code reject} functions as arguments. The Promise is resolved or
 *     rejected with the first argument passed to either function.
 * @param {RESOLVER_CONTEXT=} opt_context An optional context for executing the
 *     resolver function. If unspecified, the resolver function will be executed
 *     in the default scope.
 * @constructor
 * @struct
 * @final
 * @implements {Thenable.<TYPE>}
 * @template TYPE,RESOLVER_CONTEXT
 */
var CancellablePromise = function CancellablePromise(resolver, opt_context) {
  /**
   * The internal state of this Promise. Either PENDING, FULFILLED, REJECTED, or
   * BLOCKED.
   * @private {CancellablePromise.State_}
   */
  this.state_ = CancellablePromise.State_.PENDING;

  /**
   * The resolved result of the Promise. Immutable once set with either a
   * fulfillment value or rejection reason.
   * @private {*}
   */
  this.result_ = undefined;

  /**
   * For Promises created by calling {@code then()}, the originating parent.
   * @private {CancellablePromise}
   */
  this.parent_ = null;

  /**
   * The list of {@code onFulfilled} and {@code onRejected} callbacks added to
   * this Promise by calls to {@code then()}.
   * @private {Array.<CancellablePromise.CallbackEntry_>}
   */
  this.callbackEntries_ = null;

  /**
   * Whether the Promise is in the queue of Promises to execute.
   * @private {boolean}
   */
  this.executing_ = false;

  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
    /**
     * A timeout ID used when the {@code UNHANDLED_REJECTION_DELAY} is greater
     * than 0 milliseconds. The ID is set when the Promise is rejected, and
     * cleared only if an {@code onRejected} callback is invoked for the
     * Promise (or one of its descendants) before the delay is exceeded.
     *
     * If the rejection is not handled before the timeout completes, the
     * rejection reason is passed to the unhandled rejection handler.
     * @private {number}
     */
    this.unhandledRejectionId_ = 0;
  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
    /**
     * When the {@code UNHANDLED_REJECTION_DELAY} is set to 0 milliseconds, a
     * boolean that is set if the Promise is rejected, and reset to false if an
     * {@code onRejected} callback is invoked for the Promise (or one of its
     * descendants). If the rejection is not handled before the next timestep,
     * the rejection reason is passed to the unhandled rejection handler.
     * @private {boolean}
     */
    this.hadUnhandledRejection_ = false;
  }

  try {
    var self = this;
    resolver.call(opt_context, function (value) {
      self.resolve_(CancellablePromise.State_.FULFILLED, value);
    }, function (reason) {
      self.resolve_(CancellablePromise.State_.REJECTED, reason);
    });
  } catch (e) {
    this.resolve_(CancellablePromise.State_.REJECTED, e);
  }
};

/**
 * The delay in milliseconds before a rejected Promise's reason is passed to
 * the rejection handler. By default, the rejection handler rethrows the
 * rejection reason so that it appears in the developer console or
 * {@code window.onerror} handler.
 * Rejections are rethrown as quickly as possible by default. A negative value
 * disables rejection handling entirely.
 * @type {number}
 */
CancellablePromise.UNHANDLED_REJECTION_DELAY = 0;

/**
 * The possible internal states for a Promise. These states are not directly
 * observable to external callers.
 * @enum {number}
 * @private
 */
CancellablePromise.State_ = {
  /** The Promise is waiting for resolution. */
  PENDING: 0,

  /** The Promise is blocked waiting for the result of another Thenable. */
  BLOCKED: 1,

  /** The Promise has been resolved with a fulfillment value. */
  FULFILLED: 2,

  /** The Promise has been resolved with a rejection reason. */
  REJECTED: 3
};

/**
 * Typedef for entries in the callback chain. Each call to {@code then},
 * {@code thenCatch}, or {@code thenAlways} creates an entry containing the
 * functions that may be invoked once the Promise is resolved.
 *
 * @typedef {{
 *   child: CancellablePromise,
 *   onFulfilled: function(*),
 *   onRejected: function(*)
 * }}
 * @private
 */
CancellablePromise.CallbackEntry_ = null;

/**
 * @param {(TYPE|Thenable.<TYPE>|Thenable)=} opt_value
 * @return {!CancellablePromise.<TYPE>} A new Promise that is immediately resolved
 *     with the given value.
 * @template TYPE
 */
CancellablePromise.resolve = function (opt_value) {
  return new CancellablePromise(function (resolve) {
    resolve(opt_value);
  });
};

/**
 * @param {*=} opt_reason
 * @return {!CancellablePromise} A new Promise that is immediately rejected with the
 *     given reason.
 */
CancellablePromise.reject = function (opt_reason) {
  return new CancellablePromise(function (resolve, reject) {
    reject(opt_reason);
  });
};

/**
 * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
 * @return {!CancellablePromise.<TYPE>} A Promise that receives the result of the
 *     first Promise (or Promise-like) input to complete.
 * @template TYPE
 */
CancellablePromise.race = function (promises) {
  return new CancellablePromise(function (resolve, reject) {
    if (!promises.length) {
      resolve(undefined);
    }
    for (var i = 0, promise; promise = promises[i]; i++) {
      promise.then(resolve, reject);
    }
  });
};

/**
 * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
 * @return {!CancellablePromise.<!Array.<TYPE>>} A Promise that receives a list of
 *     every fulfilled value once every input Promise (or Promise-like) is
 *     successfully fulfilled, or is rejected by the first rejection result.
 * @template TYPE
 */
CancellablePromise.all = function (promises) {
  return new CancellablePromise(function (resolve, reject) {
    var toFulfill = promises.length;
    var values = [];

    if (!toFulfill) {
      resolve(values);
      return;
    }

    var onFulfill = function onFulfill(index, value) {
      toFulfill--;
      values[index] = value;
      if (toFulfill === 0) {
        resolve(values);
      }
    };

    var onReject = function onReject(reason) {
      reject(reason);
    };

    for (var i = 0, promise; promise = promises[i]; i++) {
      promise.then(partial(onFulfill, i), onReject);
    }
  });
};

/**
 * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
 * @return {!CancellablePromise.<TYPE>} A Promise that receives the value of
 *     the first input to be fulfilled, or is rejected with a list of every
 *     rejection reason if all inputs are rejected.
 * @template TYPE
 */
CancellablePromise.firstFulfilled = function (promises) {
  return new CancellablePromise(function (resolve, reject) {
    var toReject = promises.length;
    var reasons = [];

    if (!toReject) {
      resolve(undefined);
      return;
    }

    var onFulfill = function onFulfill(value) {
      resolve(value);
    };

    var onReject = function onReject(index, reason) {
      toReject--;
      reasons[index] = reason;
      if (toReject === 0) {
        reject(reasons);
      }
    };

    for (var i = 0, promise; promise = promises[i]; i++) {
      promise.then(onFulfill, partial(onReject, i));
    }
  });
};

/**
 * Adds callbacks that will operate on the result of the Promise, returning a
 * new child Promise.
 *
 * If the Promise is fulfilled, the {@code onFulfilled} callback will be invoked
 * with the fulfillment value as argument, and the child Promise will be
 * fulfilled with the return value of the callback. If the callback throws an
 * exception, the child Promise will be rejected with the thrown value instead.
 *
 * If the Promise is rejected, the {@code onRejected} callback will be invoked
 * with the rejection reason as argument, and the child Promise will be rejected
 * with the return value (or thrown value) of the callback.
 *
 * @override
 */
CancellablePromise.prototype.then = function (opt_onFulfilled, opt_onRejected, opt_context) {
  return this.addChildPromise_(_metal.core.isFunction(opt_onFulfilled) ? opt_onFulfilled : null, _metal.core.isFunction(opt_onRejected) ? opt_onRejected : null, opt_context);
};
Thenable.addImplementation(CancellablePromise);

/**
 * Adds a callback that will be invoked whether the Promise is fulfilled or
 * rejected. The callback receives no argument, and no new child Promise is
 * created. This is useful for ensuring that cleanup takes place after certain
 * asynchronous operations. Callbacks added with {@code thenAlways} will be
 * executed in the same order with other calls to {@code then},
 * {@code thenAlways}, or {@code thenCatch}.
 *
 * Since it does not produce a new child Promise, cancellation propagation is
 * not prevented by adding callbacks with {@code thenAlways}. A Promise that has
 * a cleanup handler added with {@code thenAlways} will be canceled if all of
 * its children created by {@code then} (or {@code thenCatch}) are canceled.
 *
 * @param {function(this:THIS): void} onResolved A function that will be invoked
 *     when the Promise is resolved.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     in the global scope.
 * @return {!CancellablePromise.<TYPE>} This Promise, for chaining additional calls.
 * @template THIS
 */
CancellablePromise.prototype.thenAlways = function (onResolved, opt_context) {
  var callback = function callback() {
    try {
      // Ensure that no arguments are passed to onResolved.
      onResolved.call(opt_context);
    } catch (err) {
      CancellablePromise.handleRejection_.call(null, err);
    }
  };

  this.addCallbackEntry_({
    child: null,
    onRejected: callback,
    onFulfilled: callback
  });
  return this;
};

/**
 * Adds a callback that will be invoked only if the Promise is rejected. This
 * is equivalent to {@code then(null, onRejected)}.
 *
 * @param {!function(this:THIS, *): *} onRejected A function that will be
 *     invoked with the rejection reason if the Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     in the global scope.
 * @return {!CancellablePromise} A new Promise that will receive the result of the
 *     callback.
 * @template THIS
 */
CancellablePromise.prototype.thenCatch = function (onRejected, opt_context) {
  return this.addChildPromise_(null, onRejected, opt_context);
};

/**
 * Alias of {@link CancellablePromise.prototype.thenCatch}
 */
CancellablePromise.prototype.catch = CancellablePromise.prototype.thenCatch;

/**
 * Cancels the Promise if it is still pending by rejecting it with a cancel
 * Error. No action is performed if the Promise is already resolved.
 *
 * All child Promises of the canceled Promise will be rejected with the same
 * cancel error, as with normal Promise rejection. If the Promise to be canceled
 * is the only child of a pending Promise, the parent Promise will also be
 * canceled. Cancellation may propagate upward through multiple generations.
 *
 * @param {string=} opt_message An optional debugging message for describing the
 *     cancellation reason.
 */
CancellablePromise.prototype.cancel = function (opt_message) {
  if (this.state_ === CancellablePromise.State_.PENDING) {
    _metal.async.run(function () {
      var err = new CancellablePromise.CancellationError(opt_message);
      err.IS_CANCELLATION_ERROR = true;
      this.cancelInternal_(err);
    }, this);
  }
};

/**
 * Cancels this Promise with the given error.
 *
 * @param {!Error} err The cancellation error.
 * @private
 */
CancellablePromise.prototype.cancelInternal_ = function (err) {
  if (this.state_ === CancellablePromise.State_.PENDING) {
    if (this.parent_) {
      // Cancel the Promise and remove it from the parent's child list.
      this.parent_.cancelChild_(this, err);
    } else {
      this.resolve_(CancellablePromise.State_.REJECTED, err);
    }
  }
};

/**
 * Cancels a child Promise from the list of callback entries. If the Promise has
 * not already been resolved, reject it with a cancel error. If there are no
 * other children in the list of callback entries, propagate the cancellation
 * by canceling this Promise as well.
 *
 * @param {!CancellablePromise} childPromise The Promise to cancel.
 * @param {!Error} err The cancel error to use for rejecting the Promise.
 * @private
 */
CancellablePromise.prototype.cancelChild_ = function (childPromise, err) {
  if (!this.callbackEntries_) {
    return;
  }
  var childCount = 0;
  var childIndex = -1;

  // Find the callback entry for the childPromise, and count whether there are
  // additional child Promises.
  for (var i = 0, entry; entry = this.callbackEntries_[i]; i++) {
    var child = entry.child;
    if (child) {
      childCount++;
      if (child === childPromise) {
        childIndex = i;
      }
      if (childIndex >= 0 && childCount > 1) {
        break;
      }
    }
  }

  // If the child Promise was the only child, cancel this Promise as well.
  // Otherwise, reject only the child Promise with the cancel error.
  if (childIndex >= 0) {
    if (this.state_ === CancellablePromise.State_.PENDING && childCount === 1) {
      this.cancelInternal_(err);
    } else {
      var callbackEntry = this.callbackEntries_.splice(childIndex, 1)[0];
      this.executeCallback_(callbackEntry, CancellablePromise.State_.REJECTED, err);
    }
  }
};

/**
 * Adds a callback entry to the current Promise, and schedules callback
 * execution if the Promise has already been resolved.
 *
 * @param {CancellablePromise.CallbackEntry_} callbackEntry Record containing
 *     {@code onFulfilled} and {@code onRejected} callbacks to execute after
 *     the Promise is resolved.
 * @private
 */
CancellablePromise.prototype.addCallbackEntry_ = function (callbackEntry) {
  if ((!this.callbackEntries_ || !this.callbackEntries_.length) && (this.state_ === CancellablePromise.State_.FULFILLED || this.state_ === CancellablePromise.State_.REJECTED)) {
    this.scheduleCallbacks_();
  }
  if (!this.callbackEntries_) {
    this.callbackEntries_ = [];
  }
  this.callbackEntries_.push(callbackEntry);
};

/**
 * Creates a child Promise and adds it to the callback entry list. The result of
 * the child Promise is determined by the state of the parent Promise and the
 * result of the {@code onFulfilled} or {@code onRejected} callbacks as
 * specified in the Promise resolution procedure.
 *
 * @see http://promisesaplus.com/#the__method
 *
 * @param {?function(this:THIS, TYPE):
 *          (RESULT|CancellablePromise.<RESULT>|Thenable)} onFulfilled A callback that
 *     will be invoked if the Promise is fullfilled, or null.
 * @param {?function(this:THIS, *): *} onRejected A callback that will be
 *     invoked if the Promise is rejected, or null.
 * @param {THIS=} opt_context An optional execution context for the callbacks.
 *     in the default calling context.
 * @return {!CancellablePromise} The child Promise.
 * @template RESULT,THIS
 * @private
 */
CancellablePromise.prototype.addChildPromise_ = function (onFulfilled, onRejected, opt_context) {

  var callbackEntry = {
    child: null,
    onFulfilled: null,
    onRejected: null
  };

  callbackEntry.child = new CancellablePromise(function (resolve, reject) {
    // Invoke onFulfilled, or resolve with the parent's value if absent.
    callbackEntry.onFulfilled = onFulfilled ? function (value) {
      try {
        var result = onFulfilled.call(opt_context, value);
        resolve(result);
      } catch (err) {
        reject(err);
      }
    } : resolve;

    // Invoke onRejected, or reject with the parent's reason if absent.
    callbackEntry.onRejected = onRejected ? function (reason) {
      try {
        var result = onRejected.call(opt_context, reason);
        if (!_metal.core.isDef(result) && reason.IS_CANCELLATION_ERROR) {
          // Propagate cancellation to children if no other result is returned.
          reject(reason);
        } else {
          resolve(result);
        }
      } catch (err) {
        reject(err);
      }
    } : reject;
  });

  callbackEntry.child.parent_ = this;
  this.addCallbackEntry_(
  /** @type {CancellablePromise.CallbackEntry_} */callbackEntry);
  return callbackEntry.child;
};

/**
 * Unblocks the Promise and fulfills it with the given value.
 *
 * @param {TYPE} value
 * @private
 */
CancellablePromise.prototype.unblockAndFulfill_ = function (value) {
  if (this.state_ !== CancellablePromise.State_.BLOCKED) {
    throw new Error('CancellablePromise is not blocked.');
  }
  this.state_ = CancellablePromise.State_.PENDING;
  this.resolve_(CancellablePromise.State_.FULFILLED, value);
};

/**
 * Unblocks the Promise and rejects it with the given rejection reason.
 *
 * @param {*} reason
 * @private
 */
CancellablePromise.prototype.unblockAndReject_ = function (reason) {
  if (this.state_ !== CancellablePromise.State_.BLOCKED) {
    throw new Error('CancellablePromise is not blocked.');
  }
  this.state_ = CancellablePromise.State_.PENDING;
  this.resolve_(CancellablePromise.State_.REJECTED, reason);
};

/**
 * Attempts to resolve a Promise with a given resolution state and value. This
 * is a no-op if the given Promise has already been resolved.
 *
 * If the given result is a Thenable (such as another Promise), the Promise will
 * be resolved with the same state and result as the Thenable once it is itself
 * resolved.
 *
 * If the given result is not a Thenable, the Promise will be fulfilled or
 * rejected with that result based on the given state.
 *
 * @see http://promisesaplus.com/#the_promise_resolution_procedure
 *
 * @param {CancellablePromise.State_} state
 * @param {*} x The result to apply to the Promise.
 * @private
 */
CancellablePromise.prototype.resolve_ = function (state, x) {
  if (this.state_ !== CancellablePromise.State_.PENDING) {
    return;
  }

  if (this === x) {
    state = CancellablePromise.State_.REJECTED;
    x = new TypeError('CancellablePromise cannot resolve to itself');
  } else if (Thenable.isImplementedBy(x)) {
    x = /** @type {!Thenable} */x;
    this.state_ = CancellablePromise.State_.BLOCKED;
    x.then(this.unblockAndFulfill_, this.unblockAndReject_, this);
    return;
  } else if (_metal.core.isObject(x)) {
    try {
      var then = x.then;
      if (_metal.core.isFunction(then)) {
        this.tryThen_(x, then);
        return;
      }
    } catch (e) {
      state = CancellablePromise.State_.REJECTED;
      x = e;
    }
  }

  this.result_ = x;
  this.state_ = state;
  this.scheduleCallbacks_();

  if (state === CancellablePromise.State_.REJECTED && !x.IS_CANCELLATION_ERROR) {
    CancellablePromise.addUnhandledRejection_(this, x);
  }
};

/**
 * Attempts to call the {@code then} method on an object in the hopes that it is
 * a Promise-compatible instance. This allows interoperation between different
 * Promise implementations, however a non-compliant object may cause a Promise
 * to hang indefinitely. If the {@code then} method throws an exception, the
 * dependent Promise will be rejected with the thrown value.
 *
 * @see http://promisesaplus.com/#point-70
 *
 * @param {Thenable} thenable An object with a {@code then} method that may be
 *     compatible with the Promise/A+ specification.
 * @param {!Function} then The {@code then} method of the Thenable object.
 * @private
 */
CancellablePromise.prototype.tryThen_ = function (thenable, then) {
  this.state_ = CancellablePromise.State_.BLOCKED;
  var promise = this;
  var called = false;

  var resolve = function resolve(value) {
    if (!called) {
      called = true;
      promise.unblockAndFulfill_(value);
    }
  };

  var reject = function reject(reason) {
    if (!called) {
      called = true;
      promise.unblockAndReject_(reason);
    }
  };

  try {
    then.call(thenable, resolve, reject);
  } catch (e) {
    reject(e);
  }
};

/**
 * Executes the pending callbacks of a resolved Promise after a timeout.
 *
 * Section 2.2.4 of the Promises/A+ specification requires that Promise
 * callbacks must only be invoked from a call stack that only contains Promise
 * implementation code, which we accomplish by invoking callback execution after
 * a timeout. If {@code startExecution_} is called multiple times for the same
 * Promise, the callback chain will be evaluated only once. Additional callbacks
 * may be added during the evaluation phase, and will be executed in the same
 * event loop.
 *
 * All Promises added to the waiting list during the same browser event loop
 * will be executed in one batch to avoid using a separate timeout per Promise.
 *
 * @private
 */
CancellablePromise.prototype.scheduleCallbacks_ = function () {
  if (!this.executing_) {
    this.executing_ = true;
    _metal.async.run(this.executeCallbacks_, this);
  }
};

/**
 * Executes all pending callbacks for this Promise.
 *
 * @private
 */
CancellablePromise.prototype.executeCallbacks_ = function () {
  while (this.callbackEntries_ && this.callbackEntries_.length) {
    var entries = this.callbackEntries_;
    this.callbackEntries_ = [];

    for (var i = 0; i < entries.length; i++) {
      this.executeCallback_(entries[i], this.state_, this.result_);
    }
  }
  this.executing_ = false;
};

/**
 * Executes a pending callback for this Promise. Invokes an {@code onFulfilled}
 * or {@code onRejected} callback based on the resolved state of the Promise.
 *
 * @param {!CancellablePromise.CallbackEntry_} callbackEntry An entry containing the
 *     onFulfilled and/or onRejected callbacks for this step.
 * @param {CancellablePromise.State_} state The resolution status of the Promise,
 *     either FULFILLED or REJECTED.
 * @param {*} result The resolved result of the Promise.
 * @private
 */
CancellablePromise.prototype.executeCallback_ = function (callbackEntry, state, result) {
  if (state === CancellablePromise.State_.FULFILLED) {
    callbackEntry.onFulfilled(result);
  } else {
    this.removeUnhandledRejection_();
    callbackEntry.onRejected(result);
  }
};

/**
 * Marks this rejected Promise as having being handled. Also marks any parent
 * Promises in the rejected state as handled. The rejection handler will no
 * longer be invoked for this Promise (if it has not been called already).
 *
 * @private
 */
CancellablePromise.prototype.removeUnhandledRejection_ = function () {
  var p;
  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
    for (p = this; p && p.unhandledRejectionId_; p = p.parent_) {
      clearTimeout(p.unhandledRejectionId_);
      p.unhandledRejectionId_ = 0;
    }
  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
    for (p = this; p && p.hadUnhandledRejection_; p = p.parent_) {
      p.hadUnhandledRejection_ = false;
    }
  }
};

/**
 * Marks this rejected Promise as unhandled. If no {@code onRejected} callback
 * is called for this Promise before the {@code UNHANDLED_REJECTION_DELAY}
 * expires, the reason will be passed to the unhandled rejection handler. The
 * handler typically rethrows the rejection reason so that it becomes visible in
 * the developer console.
 *
 * @param {!CancellablePromise} promise The rejected Promise.
 * @param {*} reason The Promise rejection reason.
 * @private
 */
CancellablePromise.addUnhandledRejection_ = function (promise, reason) {
  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
    promise.unhandledRejectionId_ = setTimeout(function () {
      CancellablePromise.handleRejection_.call(null, reason);
    }, CancellablePromise.UNHANDLED_REJECTION_DELAY);
  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
    promise.hadUnhandledRejection_ = true;
    _metal.async.run(function () {
      if (promise.hadUnhandledRejection_) {
        CancellablePromise.handleRejection_.call(null, reason);
      }
    });
  }
};

/**
 * A method that is invoked with the rejection reasons for Promises that are
 * rejected but have no {@code onRejected} callbacks registered yet.
 * @type {function(*)}
 * @private
 */
CancellablePromise.handleRejection_ = _metal.async.throwException;

/**
 * Sets a handler that will be called with reasons from unhandled rejected
 * Promises. If the rejected Promise (or one of its descendants) has an
 * {@code onRejected} callback registered, the rejection will be considered
 * handled, and the rejection handler will not be called.
 *
 * By default, unhandled rejections are rethrown so that the error may be
 * captured by the developer console or a {@code window.onerror} handler.
 *
 * @param {function(*)} handler A function that will be called with reasons from
 *     rejected Promises. Defaults to {@code async.throwException}.
 */
CancellablePromise.setUnhandledRejectionHandler = function (handler) {
  CancellablePromise.handleRejection_ = handler;
};

/**
 * Error used as a rejection reason for canceled Promises.
 *
 * @param {string=} opt_message
 * @constructor
 * @extends {Error}
 * @final
 */
CancellablePromise.CancellationError = function (_Error) {
  _inherits(_class, _Error);

  function _class(opt_message) {
    _classCallCheck(this, _class);

    var _this = _possibleConstructorReturn(this, _Error.call(this, opt_message));

    if (opt_message) {
      _this.message = opt_message;
    }
    return _this;
  }

  return _class;
}(Error);

/** @override */
CancellablePromise.CancellationError.prototype.name = 'cancel';

exports.CancellablePromise = CancellablePromise;
exports.default = CancellablePromise;

},{"../../../metal/src/metal":46}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../metal/src/metal');

var _Promise = require('../../metal-promise/src/promise/Promise');

var _Promise2 = _interopRequireDefault(_Promise);

var _component = require('../../metal-component/src/all/component');

var _App = require('../../senna/src/app/App');

var _App2 = _interopRequireDefault(_App);

var _Route = require('../../senna/src/route/Route');

var _Route2 = _interopRequireDefault(_Route);

var _RequestScreen2 = require('../../senna/src/screen/RequestScreen');

var _RequestScreen3 = _interopRequireDefault(_RequestScreen2);

var _Soy = require('../../metal-soy/src/Soy');

var _Soy2 = _interopRequireDefault(_Soy);

var _Router = require('./Router.soy');

var _Router2 = _interopRequireDefault(_Router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Router class responsible for routing links to components.
 */

var Router = function (_Component) {
	_inherits(Router, _Component);

	function Router() {
		_classCallCheck(this, Router);

		return _possibleConstructorReturn(this, _Component.apply(this, arguments));
	}

	/**
  * Creates a new `Router` instance without rendering its placeholder element.
  * @param {string} path
  * @param {!Function} component
  * @param {Object|function()} initialState
  * @return {!Router}
  */

	Router.route = function route(path, component, initialState, includeCurrentUrl) {
		return new Router({
			path: path,
			component: component,
			initialState: initialState,
			includeCurrentUrl: includeCurrentUrl
		}, false);
	};

	/**
  * Singleton to initializes and retrieve Senna.js application.
  * @return {App}
  * @static
  */


	Router.router = function router() {
		if (!Router.routerInstance) {
			Router.routerInstance = new _App2.default();
		}
		return Router.routerInstance;
	};

	/**
  * Checks if instance of router is being routed to the same active
  * component.
  * @param {Router} router
  * @return {Boolean}
  */


	Router.isRoutingToSameActiveComponent = function isRoutingToSameActiveComponent(router) {
		return Router.activeComponent instanceof router.resolveComponentConstructor();
	};

	/**
  * @inheritDoc
  */


	Router.prototype.created = function created() {
		var _this2 = this;

		this.route = new _Route2.default(this.path, function () {
			return new Router.defaultScreen(_this2);
		});
		this.route.router = this;
		Router.router().addRoutes(this.route);
	};

	/**
  * @inheritDoc
  */


	Router.prototype.disposeInternal = function disposeInternal() {
		Router.router().removeRoute(this.route);
		_Component.prototype.disposeInternal.call(this);
	};

	/**
  * Creates component instance.
  * @param {Object=} opt_config
  * @param {Element=} opt_container
  * @return {Component}
  */


	Router.prototype.createComponent = function createComponent(opt_config, opt_container) {
		return new (this.resolveComponentConstructor())(opt_config, opt_container);
	};

	/**
  * Resolves component constructor from class name or reference.
  * @return {Component}
  */


	Router.prototype.resolveComponentConstructor = function resolveComponentConstructor() {
		var componentConstructor = this.component;
		if (_metal.core.isString(componentConstructor)) {
			componentConstructor = _component.ComponentRegistry.getConstructor(componentConstructor);
		}
		return componentConstructor;
	};

	return Router;
}(_component.Component);

_Soy2.default.register(Router, _Router2.default);

/**
 * Router state definition.
 * @type {!Object}
 * @static
 */
Router.STATE = {
	/**
  * If set to true navigation will cache component state deferred results.
  * @type {boolean}
  * @default true
  */
	cacheable: {
		validator: _metal.core.isBoolean,
		value: true
	},

	/**
  * Metal component to render when path is accessed.
  * @type {Component}
  */
	component: {},

	/**
  * Defines the node that the component will be rendered at.
  * @type {!string|Element}
  * @protected
  */
	container: {},

	/**
  * Flag indicating if the current url should be included in the component's
  * state.
  */
	includeCurrentUrl: {
		value: false
	},

	/**
  * Holds the load initial state value, function or deferred function that
  * resolves the component configurations.
  * @type {?Object|function(?string=)=}
  */
	initialState: {
		setter: function setter(val) {
			return val ? _metal.core.isFunction(val) ? val : function () {
				return val;
			} : null;
		}
	},

	/**
  * Defines the path which will trigger the route handler responsible for
  * rendering the metal component.
  * @type {!string|RegExp|Function}
  * @protected
  */
	path: {},

	/**
  * If set to true active component will be used when routing to same
  * component type.
  * @type {boolean}
  * @default true
  */
	reuseActiveComponent: {
		validator: _metal.core.isBoolean,
		value: true
	}
};

/**
 * Holds the active component.
 * @type {Component}
 * @static
 */
Router.activeComponent = null;

/**
 * Holds the active render state.
 * @type {*}
 * @static
 */
Router.activeState = null;

var ComponentScreen = function (_RequestScreen) {
	_inherits(ComponentScreen, _RequestScreen);

	/**
  * @inheritDoc
  */

	function ComponentScreen(router) {
		_classCallCheck(this, ComponentScreen);

		var _this3 = _possibleConstructorReturn(this, _RequestScreen.call(this));

		if (!router) {
			throw new Error('Router not specified for component screen.');
		}

		/**
   * Router responsible for the screen.
   * @type {Router}
   */
		_this3.router = router;
		return _this3;
	}

	/**
  * @inheritDoc
  */


	ComponentScreen.prototype.evaluateScripts = function evaluateScripts() {};

	/**
  * @inheritDoc
  */


	ComponentScreen.prototype.evaluateStyles = function evaluateStyles() {};

	/**
  * @inheritDoc
  */


	ComponentScreen.prototype.flip = function flip() {
		var router = this.router;
		var redirectRouter = this.maybeFindRedirectRouter();
		if (redirectRouter) {
			router = redirectRouter;
		}

		Router.activeState = this.maybeParseLastLoadedStateAsJson();
		if (router.includeCurrentUrl) {
			Router.activeState = _metal.object.mixin({}, Router.activeState, {
				currentUrl: router.path
			});
		}

		if (this.router.reuseActiveComponent && Router.isRoutingToSameActiveComponent(router)) {
			Router.activeComponent.setState(Router.activeState);
		} else {
			if (Router.activeComponent) {
				Router.activeComponent.dispose();
			}
			Router.activeComponent = router.createComponent(Router.activeState, router.container);
		}
	};

	/**
  * @inheritDoc
  */


	ComponentScreen.prototype.load = function load(path) {
		var _this4 = this;

		this.setCacheable(this.router.cacheable);
		var deferred = _Promise2.default.resolve();
		if (_metal.core.isNull(this.router.initialState)) {
			deferred = deferred.then(function () {
				return _RequestScreen.prototype.load.call(_this4, path);
			});
		} else {
			deferred = deferred.then(function () {
				return _this4.router.initialState(path);
			});
		}
		return deferred.then(function (loadedState) {
			_this4.router.lastPath = path;
			_this4.router.lastLoadedState = loadedState;
			return loadedState;
		});
	};

	/**
  * Some responses made by superclass performs a 302 redirect which will be
  * reflected into the browser history path. When redirected, make sure to
  * render the best component match to new path. If not found any, it will
  * use current router component.
  * @return {Router}
  */


	ComponentScreen.prototype.maybeFindRedirectRouter = function maybeFindRedirectRouter() {
		var redirectPath = this.beforeUpdateHistoryPath(this.router.lastPath);
		if (redirectPath !== this.router.lastPath) {
			var redirectRoute = Router.router().findRoute(redirectPath);
			if (redirectRoute) {
				return redirectRoute.router;
			}
		}
		return null;
	};

	/**
  * Maybe parses last state as Json, if not able to parse an object is
  * returned.
  * @return {object}
  */


	ComponentScreen.prototype.maybeParseLastLoadedStateAsJson = function maybeParseLastLoadedStateAsJson() {
		var state = this.router.lastLoadedState;
		try {
			return JSON.parse(state);
		} catch (err) {
			return _metal.core.isDefAndNotNull(state) ? state : {};
		}
	};

	return ComponentScreen;
}(_RequestScreen3.default);

/**
 * Default screen used for handling components.
 * @type {ComponentScreen}
 */


Router.defaultScreen = ComponentScreen;

exports.default = Router;

},{"../../metal-component/src/all/component":10,"../../metal-promise/src/promise/Promise":31,"../../metal-soy/src/Soy":35,"../../metal/src/metal":46,"../../senna/src/app/App":49,"../../senna/src/route/Route":53,"../../senna/src/screen/RequestScreen":54,"./Router.soy":33}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.templates = exports.Router = undefined;

var _Component2 = require('../../metal-component/src/Component');

var _Component3 = _interopRequireDefault(_Component2);

var _Soy = require('../../metal-soy/src/Soy');

var _Soy2 = _interopRequireDefault(_Soy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint ignore:start */


var templates;
goog.loadModule(function (exports) {

  // This file was automatically generated from Router.soy.
  // Please don't edit this file by hand.

  /**
   * @fileoverview Templates in namespace Router.
   * @public
   */

  goog.module('Router.incrementaldom');

  /** @suppress {extraRequire} */
  var soy = goog.require('soy');
  /** @suppress {extraRequire} */
  var soydata = goog.require('soydata');
  /** @suppress {extraRequire} */
  goog.require('goog.i18n.bidi');
  /** @suppress {extraRequire} */
  goog.require('goog.asserts');
  var IncrementalDom = goog.require('incrementaldom');
  var ie_open = IncrementalDom.elementOpen;
  var ie_close = IncrementalDom.elementClose;
  var ie_void = IncrementalDom.elementVoid;
  var ie_open_start = IncrementalDom.elementOpenStart;
  var ie_open_end = IncrementalDom.elementOpenEnd;
  var itext = IncrementalDom.text;
  var iattr = IncrementalDom.attr;

  /**
   * @param {Object<string, *>=} opt_data
   * @param {(null|undefined)=} opt_ignored
   * @param {Object<string, *>=} opt_ijData
   * @return {void}
   * @suppress {checkTypes}
   */
  function $render(opt_data, opt_ignored, opt_ijData) {
    opt_data = opt_data || {};
    ie_void('link', null, null, 'id', opt_data.id, 'rel', 'metal-route');
  }
  exports.render = $render;
  if (goog.DEBUG) {
    $render.soyTemplateName = 'Router.render';
  }

  exports.render.params = ["id"];
  exports.render.types = { "id": "any" };
  exports.templates = templates = exports;
  return exports;
});

var Router = function (_Component) {
  _inherits(Router, _Component);

  function Router() {
    _classCallCheck(this, Router);

    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  return Router;
}(_Component3.default);

_Soy2.default.register(Router, templates);
exports.default = templates;
exports.Router = Router;
exports.templates = templates;
/* jshint ignore:end */

},{"../../metal-component/src/Component":6,"../../metal-soy/src/Soy":35}],34:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol?"symbol":typeof obj;};require('../../metal-incremental-dom/src/IncrementalDomRenderer');(function(){this.CLOSURE_NO_DEPS=true;this.goog=this.goog||{}; // Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Bootstrap for the Google JS Library (Closure).
 *
 * In uncompiled mode base.js will write out Closure's deps file, unless the
 * global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects to
 * include their own deps file(s) from different locations.
 *
 * @author arv@google.com (Erik Arvidsson)
 *
 * @provideGoog
 */ /**
 * @define {boolean} Overridden to true by the compiler when
 *     --process_closure_primitives is specified.
 */var COMPILED=false; /**
 * Base namespace for the Closure library.  Checks to see goog is already
 * defined in the current scope before assigning to prevent clobbering if
 * base.js is loaded more than once.
 *
 * @const
 */var goog=this.goog||{}; /**
 * Reference to the global context.  In most cases this will be 'window'.
 */goog.global=this; /**
 * A hook for overriding the define values in uncompiled mode.
 *
 * In uncompiled mode, {@code CLOSURE_UNCOMPILED_DEFINES} may be defined before
 * loading base.js.  If a key is defined in {@code CLOSURE_UNCOMPILED_DEFINES},
 * {@code goog.define} will use the value instead of the default value.  This
 * allows flags to be overwritten without compilation (this is normally
 * accomplished with the compiler's "define" flag).
 *
 * Example:
 * <pre>
 *   var CLOSURE_UNCOMPILED_DEFINES = {'goog.DEBUG': false};
 * </pre>
 *
 * @type {Object<string, (string|number|boolean)>|undefined}
 */goog.global.CLOSURE_UNCOMPILED_DEFINES; /**
 * A hook for overriding the define values in uncompiled or compiled mode,
 * like CLOSURE_UNCOMPILED_DEFINES but effective in compiled code.  In
 * uncompiled code CLOSURE_UNCOMPILED_DEFINES takes precedence.
 *
 * Also unlike CLOSURE_UNCOMPILED_DEFINES the values must be number, boolean or
 * string literals or the compiler will emit an error.
 *
 * While any @define value may be set, only those set with goog.define will be
 * effective for uncompiled code.
 *
 * Example:
 * <pre>
 *   var CLOSURE_DEFINES = {'goog.DEBUG': false} ;
 * </pre>
 *
 * @type {Object<string, (string|number|boolean)>|undefined}
 */goog.global.CLOSURE_DEFINES; /**
 * Returns true if the specified value is not undefined.
 * WARNING: Do not use this to test if an object has a property. Use the in
 * operator instead.
 *
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */goog.isDef=function(val){ // void 0 always evaluates to undefined and hence we do not need to depend on
// the definition of the global variable named 'undefined'.
return val!==void 0;}; /**
 * Builds an object structure for the provided namespace path, ensuring that
 * names that already exist are not overwritten. For example:
 * "a.b.c" -> a = {};a.b={};a.b.c={};
 * Used by goog.provide and goog.exportSymbol.
 * @param {string} name name of the object that this file defines.
 * @param {*=} opt_object the object to expose at the end of the path.
 * @param {Object=} opt_objectToExportTo The object to add the path to; default
 *     is |goog.global|.
 * @private
 */goog.exportPath_=function(name,opt_object,opt_objectToExportTo){var parts=name.split('.');var cur=opt_objectToExportTo||goog.global; // Internet Explorer exhibits strange behavior when throwing errors from
// methods externed in this manner.  See the testExportSymbolExceptions in
// base_test.html for an example.
if(!(parts[0] in cur)&&cur.execScript){cur.execScript('var '+parts[0]);} // Certain browsers cannot parse code in the form for((a in b); c;);
// This pattern is produced by the JSCompiler when it collapses the
// statement above into the conditional loop below. To prevent this from
// happening, use a for-loop and reserve the init logic as below.
// Parentheses added to eliminate strict JS warning in Firefox.
for(var part;parts.length&&(part=parts.shift());){if(!parts.length&&goog.isDef(opt_object)){ // last part and we have an object; use it
cur[part]=opt_object;}else if(cur[part]){cur=cur[part];}else {cur=cur[part]={};}}}; /**
 * Defines a named value. In uncompiled mode, the value is retrieved from
 * CLOSURE_DEFINES or CLOSURE_UNCOMPILED_DEFINES if the object is defined and
 * has the property specified, and otherwise used the defined defaultValue.
 * When compiled the default can be overridden using the compiler
 * options or the value set in the CLOSURE_DEFINES object.
 *
 * @param {string} name The distinguished name to provide.
 * @param {string|number|boolean} defaultValue
 */goog.define=function(name,defaultValue){var value=defaultValue;if(!COMPILED){if(goog.global.CLOSURE_UNCOMPILED_DEFINES&&Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_UNCOMPILED_DEFINES,name)){value=goog.global.CLOSURE_UNCOMPILED_DEFINES[name];}else if(goog.global.CLOSURE_DEFINES&&Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES,name)){value=goog.global.CLOSURE_DEFINES[name];}}goog.exportPath_(name,value);}; /**
 * @define {boolean} DEBUG is provided as a convenience so that debugging code
 * that should not be included in a production js_binary can be easily stripped
 * by specifying --define goog.DEBUG=false to the JSCompiler. For example, most
 * toString() methods should be declared inside an "if (goog.DEBUG)" conditional
 * because they are generally used for debugging purposes and it is difficult
 * for the JSCompiler to statically determine whether they are used.
 */goog.define('goog.DEBUG',true); /**
 * @define {string} LOCALE defines the locale being used for compilation. It is
 * used to select locale specific data to be compiled in js binary. BUILD rule
 * can specify this value by "--define goog.LOCALE=<locale_name>" as JSCompiler
 * option.
 *
 * Take into account that the locale code format is important. You should use
 * the canonical Unicode format with hyphen as a delimiter. Language must be
 * lowercase, Language Script - Capitalized, Region - UPPERCASE.
 * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.
 *
 * See more info about locale codes here:
 * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
 *
 * For language codes you should use values defined by ISO 693-1. See it here
 * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from
 * this rule: the Hebrew language. For legacy reasons the old code (iw) should
 * be used instead of the new code (he), see http://wiki/Main/IIISynonyms.
 */goog.define('goog.LOCALE','en'); // default to en
/**
 * @define {boolean} Whether this code is running on trusted sites.
 *
 * On untrusted sites, several native functions can be defined or overridden by
 * external libraries like Prototype, Datejs, and JQuery and setting this flag
 * to false forces closure to use its own implementations when possible.
 *
 * If your JavaScript can be loaded by a third party site and you are wary about
 * relying on non-standard implementations, specify
 * "--define goog.TRUSTED_SITE=false" to the JSCompiler.
 */goog.define('goog.TRUSTED_SITE',true); /**
 * @define {boolean} Whether a project is expected to be running in strict mode.
 *
 * This define can be used to trigger alternate implementations compatible with
 * running in EcmaScript Strict mode or warn about unavailable functionality.
 * @see https://goo.gl/g5EoHI
 *
 */goog.define('goog.STRICT_MODE_COMPATIBLE',false); /**
 * @define {boolean} Whether code that calls {@link goog.setTestOnly} should
 *     be disallowed in the compilation unit.
 */goog.define('goog.DISALLOW_TEST_ONLY_CODE',COMPILED&&!goog.DEBUG); /**
 * @define {boolean} Whether to use a Chrome app CSP-compliant method for
 *     loading scripts via goog.require. @see appendScriptSrcNode_.
 */goog.define('goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING',false); /**
 * Defines a namespace in Closure.
 *
 * A namespace may only be defined once in a codebase. It may be defined using
 * goog.provide() or goog.module().
 *
 * The presence of one or more goog.provide() calls in a file indicates
 * that the file defines the given objects/namespaces.
 * Provided symbols must not be null or undefined.
 *
 * In addition, goog.provide() creates the object stubs for a namespace
 * (for example, goog.provide("goog.foo.bar") will create the object
 * goog.foo.bar if it does not already exist).
 *
 * Build tools also scan for provide/require/module statements
 * to discern dependencies, build dependency files (see deps.js), etc.
 *
 * @see goog.require
 * @see goog.module
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part".
 */goog.provide=function(name){if(!COMPILED){ // Ensure that the same namespace isn't provided twice.
// A goog.module/goog.provide maps a goog.require to a specific file
if(goog.isProvided_(name)){throw Error('Namespace "'+name+'" already declared.');}}goog.constructNamespace_(name);}; /**
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part".
 * @param {Object=} opt_obj The object to embed in the namespace.
 * @private
 */goog.constructNamespace_=function(name,opt_obj){if(!COMPILED){delete goog.implicitNamespaces_[name];var namespace=name;while(namespace=namespace.substring(0,namespace.lastIndexOf('.'))){if(goog.getObjectByName(namespace)){break;}goog.implicitNamespaces_[namespace]=true;}}goog.exportPath_(name,opt_obj);}; /**
 * Module identifier validation regexp.
 * Note: This is a conservative check, it is very possible to be more lenient,
 *   the primary exclusion here is "/" and "\" and a leading ".", these
 *   restrictions are intended to leave the door open for using goog.require
 *   with relative file paths rather than module identifiers.
 * @private
 */goog.VALID_MODULE_RE_=/^[a-zA-Z_$][a-zA-Z0-9._$]*$/; /**
 * Defines a module in Closure.
 *
 * Marks that this file must be loaded as a module and claims the namespace.
 *
 * A namespace may only be defined once in a codebase. It may be defined using
 * goog.provide() or goog.module().
 *
 * goog.module() has three requirements:
 * - goog.module may not be used in the same file as goog.provide.
 * - goog.module must be the first statement in the file.
 * - only one goog.module is allowed per file.
 *
 * When a goog.module annotated file is loaded, it is enclosed in
 * a strict function closure. This means that:
 * - any variables declared in a goog.module file are private to the file
 * (not global), though the compiler is expected to inline the module.
 * - The code must obey all the rules of "strict" JavaScript.
 * - the file will be marked as "use strict"
 *
 * NOTE: unlike goog.provide, goog.module does not declare any symbols by
 * itself. If declared symbols are desired, use
 * goog.module.declareLegacyNamespace().
 *
 *
 * See the public goog.module proposal: http://goo.gl/Va1hin
 *
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part", is expected but not required.
 */goog.module=function(name){if(!goog.isString(name)||!name||name.search(goog.VALID_MODULE_RE_)==-1){throw Error('Invalid module identifier');}if(!goog.isInModuleLoader_()){throw Error('Module '+name+' has been loaded incorrectly.');}if(goog.moduleLoaderState_.moduleName){throw Error('goog.module may only be called once per module.');} // Store the module name for the loader.
goog.moduleLoaderState_.moduleName=name;if(!COMPILED){ // Ensure that the same namespace isn't provided twice.
// A goog.module/goog.provide maps a goog.require to a specific file
if(goog.isProvided_(name)){throw Error('Namespace "'+name+'" already declared.');}delete goog.implicitNamespaces_[name];}}; /**
 * @param {string} name The module identifier.
 * @return {?} The module exports for an already loaded module or null.
 *
 * Note: This is not an alternative to goog.require, it does not
 * indicate a hard dependency, instead it is used to indicate
 * an optional dependency or to access the exports of a module
 * that has already been loaded.
 * @suppress {missingProvide}
 */goog.module.get=function(name){return goog.module.getInternal_(name);}; /**
 * @param {string} name The module identifier.
 * @return {?} The module exports for an already loaded module or null.
 * @private
 */goog.module.getInternal_=function(name){if(!COMPILED){if(goog.isProvided_(name)){ // goog.require only return a value with-in goog.module files.
return name in goog.loadedModules_?goog.loadedModules_[name]:goog.getObjectByName(name);}else {return null;}}}; /**
 * @private {?{moduleName: (string|undefined), declareLegacyNamespace:boolean}}
 */goog.moduleLoaderState_=null; /**
 * @private
 * @return {boolean} Whether a goog.module is currently being initialized.
 */goog.isInModuleLoader_=function(){return goog.moduleLoaderState_!=null;}; /**
 * Provide the module's exports as a globally accessible object under the
 * module's declared name.  This is intended to ease migration to goog.module
 * for files that have existing usages.
 * @suppress {missingProvide}
 */goog.module.declareLegacyNamespace=function(){if(!COMPILED&&!goog.isInModuleLoader_()){throw new Error('goog.module.declareLegacyNamespace must be called from '+'within a goog.module');}if(!COMPILED&&!goog.moduleLoaderState_.moduleName){throw Error('goog.module must be called prior to '+'goog.module.declareLegacyNamespace.');}goog.moduleLoaderState_.declareLegacyNamespace=true;}; /**
 * Marks that the current file should only be used for testing, and never for
 * live code in production.
 *
 * In the case of unit tests, the message may optionally be an exact namespace
 * for the test (e.g. 'goog.stringTest'). The linter will then ignore the extra
 * provide (if not explicitly defined in the code).
 *
 * @param {string=} opt_message Optional message to add to the error that's
 *     raised when used in production code.
 */goog.setTestOnly=function(opt_message){if(goog.DISALLOW_TEST_ONLY_CODE){opt_message=opt_message||'';throw Error('Importing test-only code into non-debug environment'+(opt_message?': '+opt_message:'.'));}};if(!COMPILED){ /**
   * Check if the given name has been goog.provided. This will return false for
   * names that are available only as implicit namespaces.
   * @param {string} name name of the object to look for.
   * @return {boolean} Whether the name has been provided.
   * @private
   */goog.isProvided_=function(name){return name in goog.loadedModules_||!goog.implicitNamespaces_[name]&&goog.isDefAndNotNull(goog.getObjectByName(name));}; /**
   * Namespaces implicitly defined by goog.provide. For example,
   * goog.provide('goog.events.Event') implicitly declares that 'goog' and
   * 'goog.events' must be namespaces.
   *
   * @type {!Object<string, (boolean|undefined)>}
   * @private
   */goog.implicitNamespaces_={'goog.module':true}; // NOTE: We add goog.module as an implicit namespace as goog.module is defined
// here and because the existing module package has not been moved yet out of
// the goog.module namespace. This satisifies both the debug loader and
// ahead-of-time dependency management.
} /**
 * Returns an object based on its fully qualified external name.  The object
 * is not found if null or undefined.  If you are using a compilation pass that
 * renames property names beware that using this function will not find renamed
 * properties.
 *
 * @param {string} name The fully qualified name.
 * @param {Object=} opt_obj The object within which to look; default is
 *     |goog.global|.
 * @return {?} The value (object or primitive) or, if not found, null.
 */goog.getObjectByName=function(name,opt_obj){var parts=name.split('.');var cur=opt_obj||goog.global;for(var part;part=parts.shift();){if(goog.isDefAndNotNull(cur[part])){cur=cur[part];}else {return null;}}return cur;}; /**
 * Globalizes a whole namespace, such as goog or goog.lang.
 *
 * @param {!Object} obj The namespace to globalize.
 * @param {Object=} opt_global The object to add the properties to.
 * @deprecated Properties may be explicitly exported to the global scope, but
 *     this should no longer be done in bulk.
 */goog.globalize=function(obj,opt_global){var global=opt_global||goog.global;for(var x in obj){global[x]=obj[x];}}; /**
 * Adds a dependency from a file to the files it requires.
 * @param {string} relPath The path to the js file.
 * @param {!Array<string>} provides An array of strings with
 *     the names of the objects this file provides.
 * @param {!Array<string>} requires An array of strings with
 *     the names of the objects this file requires.
 * @param {boolean|!Object<string>=} opt_loadFlags Parameters indicating
 *     how the file must be loaded.  The boolean 'true' is equivalent
 *     to {'module': 'goog'} for backwards-compatibility.  Valid properties
 *     and values include {'module': 'goog'} and {'lang': 'es6'}.
 */goog.addDependency=function(relPath,provides,requires,opt_loadFlags){if(goog.DEPENDENCIES_ENABLED){var provide,require;var path=relPath.replace(/\\/g,'/');var deps=goog.dependencies_;if(!opt_loadFlags||typeof opt_loadFlags==='boolean'){opt_loadFlags=opt_loadFlags?{'module':'goog'}:{};}for(var i=0;provide=provides[i];i++){deps.nameToPath[provide]=path;deps.pathIsModule[path]=opt_loadFlags['module']=='goog';}for(var j=0;require=requires[j];j++){if(!(path in deps.requires)){deps.requires[path]={};}deps.requires[path][require]=true;}}}; // NOTE(nnaze): The debug DOM loader was included in base.js as an original way
// to do "debug-mode" development.  The dependency system can sometimes be
// confusing, as can the debug DOM loader's asynchronous nature.
//
// With the DOM loader, a call to goog.require() is not blocking -- the script
// will not load until some point after the current script.  If a namespace is
// needed at runtime, it needs to be defined in a previous script, or loaded via
// require() with its registered dependencies.
//
// User-defined namespaces may need their own deps file. For a reference on
// creating a deps file, see:
// Externally: https://developers.google.com/closure/library/docs/depswriter
//
// Because of legacy clients, the DOM loader can't be easily removed from
// base.js.  Work is being done to make it disableable or replaceable for
// different environments (DOM-less JavaScript interpreters like Rhino or V8,
// for example). See bootstrap/ for more information.
/**
 * @define {boolean} Whether to enable the debug loader.
 *
 * If enabled, a call to goog.require() will attempt to load the namespace by
 * appending a script tag to the DOM (if the namespace has been registered).
 *
 * If disabled, goog.require() will simply assert that the namespace has been
 * provided (and depend on the fact that some outside tool correctly ordered
 * the script).
 */goog.define('goog.ENABLE_DEBUG_LOADER',true); /**
 * @param {string} msg
 * @private
 */goog.logToConsole_=function(msg){if(goog.global.console){goog.global.console['error'](msg);}}; /**
 * Implements a system for the dynamic resolution of dependencies that works in
 * parallel with the BUILD system. Note that all calls to goog.require will be
 * stripped by the JSCompiler when the --process_closure_primitives option is
 * used.
 * @see goog.provide
 * @param {string} name Namespace to include (as was given in goog.provide()) in
 *     the form "goog.package.part".
 * @return {?} If called within a goog.module file, the associated namespace or
 *     module otherwise null.
 */goog.require=function(name){ // If the object already exists we do not need do do anything.
if(!COMPILED){if(goog.ENABLE_DEBUG_LOADER&&goog.IS_OLD_IE_){goog.maybeProcessDeferredDep_(name);}if(goog.isProvided_(name)){if(goog.isInModuleLoader_()){return goog.module.getInternal_(name);}else {return null;}}if(goog.ENABLE_DEBUG_LOADER){var path=goog.getPathFromDeps_(name);if(path){goog.writeScripts_(path);return null;}}var errorMessage='goog.require could not find: '+name;goog.logToConsole_(errorMessage);throw Error(errorMessage);}}; /**
 * Path for included scripts.
 * @type {string}
 */goog.basePath=''; /**
 * A hook for overriding the base path.
 * @type {string|undefined}
 */goog.global.CLOSURE_BASE_PATH; /**
 * Whether to write out Closure's deps file. By default, the deps are written.
 * @type {boolean|undefined}
 */goog.global.CLOSURE_NO_DEPS; /**
 * A function to import a single script. This is meant to be overridden when
 * Closure is being run in non-HTML contexts, such as web workers. It's defined
 * in the global scope so that it can be set before base.js is loaded, which
 * allows deps.js to be imported properly.
 *
 * The function is passed the script source, which is a relative URI. It should
 * return true if the script was imported, false otherwise.
 * @type {(function(string): boolean)|undefined}
 */goog.global.CLOSURE_IMPORT_SCRIPT; /**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */goog.nullFunction=function(){}; /**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = goog.abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * Note: This does not take the name of the function to override as an argument
 * because that would make it more difficult to obfuscate our JavaScript code.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */goog.abstractMethod=function(){throw Error('unimplemented abstract method');}; /**
 * Adds a {@code getInstance} static method that always returns the same
 * instance object.
 * @param {!Function} ctor The constructor for the class to add the static
 *     method to.
 */goog.addSingletonGetter=function(ctor){ctor.getInstance=function(){if(ctor.instance_){return ctor.instance_;}if(goog.DEBUG){ // NOTE: JSCompiler can't optimize away Array#push.
goog.instantiatedSingletons_[goog.instantiatedSingletons_.length]=ctor;}return ctor.instance_=new ctor();};}; /**
 * All singleton classes that have been instantiated, for testing. Don't read
 * it directly, use the {@code goog.testing.singleton} module. The compiler
 * removes this variable if unused.
 * @type {!Array<!Function>}
 * @private
 */goog.instantiatedSingletons_=[]; /**
 * @define {boolean} Whether to load goog.modules using {@code eval} when using
 * the debug loader.  This provides a better debugging experience as the
 * source is unmodified and can be edited using Chrome Workspaces or similar.
 * However in some environments the use of {@code eval} is banned
 * so we provide an alternative.
 */goog.define('goog.LOAD_MODULE_USING_EVAL',true); /**
 * @define {boolean} Whether the exports of goog.modules should be sealed when
 * possible.
 */goog.define('goog.SEAL_MODULE_EXPORTS',goog.DEBUG); /**
 * The registry of initialized modules:
 * the module identifier to module exports map.
 * @private @const {!Object<string, ?>}
 */goog.loadedModules_={}; /**
 * True if goog.dependencies_ is available.
 * @const {boolean}
 */goog.DEPENDENCIES_ENABLED=!COMPILED&&goog.ENABLE_DEBUG_LOADER;if(goog.DEPENDENCIES_ENABLED){ /**
   * This object is used to keep track of dependencies and other data that is
   * used for loading scripts.
   * @private
   * @type {{
   *   pathIsModule: !Object<string, boolean>,
   *   nameToPath: !Object<string, string>,
   *   requires: !Object<string, !Object<string, boolean>>,
   *   visited: !Object<string, boolean>,
   *   written: !Object<string, boolean>,
   *   deferred: !Object<string, string>
   * }}
   */goog.dependencies_={pathIsModule:{}, // 1 to 1
nameToPath:{}, // 1 to 1
requires:{}, // 1 to many
// Used when resolving dependencies to prevent us from visiting file twice.
visited:{},written:{}, // Used to keep track of script files we have written.
deferred:{} // Used to track deferred module evaluations in old IEs
}; /**
   * Tries to detect whether is in the context of an HTML document.
   * @return {boolean} True if it looks like HTML document.
   * @private
   */goog.inHtmlDocument_=function(){ /** @type {Document} */var doc=goog.global.document;return doc!=null&&'write' in doc; // XULDocument misses write.
}; /**
   * Tries to detect the base path of base.js script that bootstraps Closure.
   * @private
   */goog.findBasePath_=function(){if(goog.isDef(goog.global.CLOSURE_BASE_PATH)){goog.basePath=goog.global.CLOSURE_BASE_PATH;return;}else if(!goog.inHtmlDocument_()){return;} /** @type {Document} */var doc=goog.global.document;var scripts=doc.getElementsByTagName('SCRIPT'); // Search backwards since the current script is in almost all cases the one
// that has base.js.
for(var i=scripts.length-1;i>=0;--i){var script= /** @type {!HTMLScriptElement} */scripts[i];var src=script.src;var qmark=src.lastIndexOf('?');var l=qmark==-1?src.length:qmark;if(src.substr(l-7,7)=='base.js'){goog.basePath=src.substr(0,l-7);return;}}}; /**
   * Imports a script if, and only if, that script hasn't already been imported.
   * (Must be called at execution time)
   * @param {string} src Script source.
   * @param {string=} opt_sourceText The optionally source text to evaluate
   * @private
   */goog.importScript_=function(src,opt_sourceText){var importScript=goog.global.CLOSURE_IMPORT_SCRIPT||goog.writeScriptTag_;if(importScript(src,opt_sourceText)){goog.dependencies_.written[src]=true;}}; /** @const @private {boolean} */goog.IS_OLD_IE_=!!(!goog.global.atob&&goog.global.document&&goog.global.document.all); /**
   * Given a URL initiate retrieval and execution of the module.
   * @param {string} src Script source URL.
   * @private
   */goog.importModule_=function(src){ // In an attempt to keep browsers from timing out loading scripts using
// synchronous XHRs, put each load in its own script block.
var bootstrap='goog.retrieveAndExecModule_("'+src+'");';if(goog.importScript_('',bootstrap)){goog.dependencies_.written[src]=true;}}; /** @private {!Array<string>} */goog.queuedModules_=[]; /**
   * Return an appropriate module text. Suitable to insert into
   * a script tag (that is unescaped).
   * @param {string} srcUrl
   * @param {string} scriptText
   * @return {string}
   * @private
   */goog.wrapModule_=function(srcUrl,scriptText){if(!goog.LOAD_MODULE_USING_EVAL||!goog.isDef(goog.global.JSON)){return ''+'goog.loadModule(function(exports) {'+'"use strict";'+scriptText+'\n'+ // terminate any trailing single line comment.
';return exports'+'});'+'\n//# sourceURL='+srcUrl+'\n';}else {return ''+'goog.loadModule('+goog.global.JSON.stringify(scriptText+'\n//# sourceURL='+srcUrl+'\n')+');';}}; // On IE9 and earlier, it is necessary to handle
// deferred module loads. In later browsers, the
// code to be evaluated is simply inserted as a script
// block in the correct order. To eval deferred
// code at the right time, we piggy back on goog.require to call
// goog.maybeProcessDeferredDep_.
//
// The goog.requires are used both to bootstrap
// the loading process (when no deps are available) and
// declare that they should be available.
//
// Here we eval the sources, if all the deps are available
// either already eval'd or goog.require'd.  This will
// be the case when all the dependencies have already
// been loaded, and the dependent module is loaded.
//
// But this alone isn't sufficient because it is also
// necessary to handle the case where there is no root
// that is not deferred.  For that there we register for an event
// and trigger goog.loadQueuedModules_ handle any remaining deferred
// evaluations.
/**
   * Handle any remaining deferred goog.module evals.
   * @private
   */goog.loadQueuedModules_=function(){var count=goog.queuedModules_.length;if(count>0){var queue=goog.queuedModules_;goog.queuedModules_=[];for(var i=0;i<count;i++){var path=queue[i];goog.maybeProcessDeferredPath_(path);}}}; /**
   * Eval the named module if its dependencies are
   * available.
   * @param {string} name The module to load.
   * @private
   */goog.maybeProcessDeferredDep_=function(name){if(goog.isDeferredModule_(name)&&goog.allDepsAreAvailable_(name)){var path=goog.getPathFromDeps_(name);goog.maybeProcessDeferredPath_(goog.basePath+path);}}; /**
   * @param {string} name The module to check.
   * @return {boolean} Whether the name represents a
   *     module whose evaluation has been deferred.
   * @private
   */goog.isDeferredModule_=function(name){var path=goog.getPathFromDeps_(name);if(path&&goog.dependencies_.pathIsModule[path]){var abspath=goog.basePath+path;return abspath in goog.dependencies_.deferred;}return false;}; /**
   * @param {string} name The module to check.
   * @return {boolean} Whether the name represents a
   *     module whose declared dependencies have all been loaded
   *     (eval'd or a deferred module load)
   * @private
   */goog.allDepsAreAvailable_=function(name){var path=goog.getPathFromDeps_(name);if(path&&path in goog.dependencies_.requires){for(var requireName in goog.dependencies_.requires[path]){if(!goog.isProvided_(requireName)&&!goog.isDeferredModule_(requireName)){return false;}}}return true;}; /**
   * @param {string} abspath
   * @private
   */goog.maybeProcessDeferredPath_=function(abspath){if(abspath in goog.dependencies_.deferred){var src=goog.dependencies_.deferred[abspath];delete goog.dependencies_.deferred[abspath];goog.globalEval(src);}}; /**
   * Load a goog.module from the provided URL.  This is not a general purpose
   * code loader and does not support late loading code, that is it should only
   * be used during page load. This method exists to support unit tests and
   * "debug" loaders that would otherwise have inserted script tags. Under the
   * hood this needs to use a synchronous XHR and is not recommeneded for
   * production code.
   *
   * The module's goog.requires must have already been satisified; an exception
   * will be thrown if this is not the case. This assumption is that no
   * "deps.js" file exists, so there is no way to discover and locate the
   * module-to-be-loaded's dependencies and no attempt is made to do so.
   *
   * There should only be one attempt to load a module.  If
   * "goog.loadModuleFromUrl" is called for an already loaded module, an
   * exception will be throw.
   *
   * @param {string} url The URL from which to attempt to load the goog.module.
   */goog.loadModuleFromUrl=function(url){ // Because this executes synchronously, we don't need to do any additional
// bookkeeping. When "goog.loadModule" the namespace will be marked as
// having been provided which is sufficient.
goog.retrieveAndExecModule_(url);}; /**
   * @param {function(?):?|string} moduleDef The module definition.
   */goog.loadModule=function(moduleDef){ // NOTE: we allow function definitions to be either in the from
// of a string to eval (which keeps the original source intact) or
// in a eval forbidden environment (CSP) we allow a function definition
// which in its body must call {@code goog.module}, and return the exports
// of the module.
var previousState=goog.moduleLoaderState_;try{goog.moduleLoaderState_={moduleName:undefined,declareLegacyNamespace:false};var exports;if(goog.isFunction(moduleDef)){exports=moduleDef.call(goog.global,{});}else if(goog.isString(moduleDef)){exports=goog.loadModuleFromSource_.call(goog.global,moduleDef);}else {throw Error('Invalid module definition');}var moduleName=goog.moduleLoaderState_.moduleName;if(!goog.isString(moduleName)||!moduleName){throw Error('Invalid module name \"'+moduleName+'\"');} // Don't seal legacy namespaces as they may be uses as a parent of
// another namespace
if(goog.moduleLoaderState_.declareLegacyNamespace){goog.constructNamespace_(moduleName,exports);}else if(goog.SEAL_MODULE_EXPORTS&&Object.seal){Object.seal(exports);}goog.loadedModules_[moduleName]=exports;}finally {goog.moduleLoaderState_=previousState;}}; /**
   * @private @const {function(string):?}
   *
   * The new type inference warns because this function has no formal
   * parameters, but its jsdoc says that it takes one argument.
   * (The argument is used via arguments[0], but NTI does not detect this.)
   * @suppress {newCheckTypes}
   */goog.loadModuleFromSource_=function(){ // NOTE: we avoid declaring parameters or local variables here to avoid
// masking globals or leaking values into the module definition.
'use strict';var exports={};eval(arguments[0]);return exports;}; /**
   * Writes a new script pointing to {@code src} directly into the DOM.
   *
   * NOTE: This method is not CSP-compliant. @see goog.appendScriptSrcNode_ for
   * the fallback mechanism.
   *
   * @param {string} src The script URL.
   * @private
   */goog.writeScriptSrcNode_=function(src){goog.global.document.write('<script type="text/javascript" src="'+src+'"></'+'script>');}; /**
   * Appends a new script node to the DOM using a CSP-compliant mechanism. This
   * method exists as a fallback for document.write (which is not allowed in a
   * strict CSP context, e.g., Chrome apps).
   *
   * NOTE: This method is not analogous to using document.write to insert a
   * <script> tag; specifically, the user agent will execute a script added by
   * document.write immediately after the current script block finishes
   * executing, whereas the DOM-appended script node will not be executed until
   * the entire document is parsed and executed. That is to say, this script is
   * added to the end of the script execution queue.
   *
   * The page must not attempt to call goog.required entities until after the
   * document has loaded, e.g., in or after the window.onload callback.
   *
   * @param {string} src The script URL.
   * @private
   */goog.appendScriptSrcNode_=function(src){ /** @type {Document} */var doc=goog.global.document;var scriptEl= /** @type {HTMLScriptElement} */doc.createElement('script');scriptEl.type='text/javascript';scriptEl.src=src;scriptEl.defer=false;scriptEl.async=false;doc.head.appendChild(scriptEl);}; /**
   * The default implementation of the import function. Writes a script tag to
   * import the script.
   *
   * @param {string} src The script url.
   * @param {string=} opt_sourceText The optionally source text to evaluate
   * @return {boolean} True if the script was imported, false otherwise.
   * @private
   */goog.writeScriptTag_=function(src,opt_sourceText){if(goog.inHtmlDocument_()){ /** @type {!HTMLDocument} */var doc=goog.global.document; // If the user tries to require a new symbol after document load,
// something has gone terribly wrong. Doing a document.write would
// wipe out the page. This does not apply to the CSP-compliant method
// of writing script tags.
if(!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING&&doc.readyState=='complete'){ // Certain test frameworks load base.js multiple times, which tries
// to write deps.js each time. If that happens, just fail silently.
// These frameworks wipe the page between each load of base.js, so this
// is OK.
var isDeps=/\bdeps.js$/.test(src);if(isDeps){return false;}else {throw Error('Cannot write "'+src+'" after document load');}}var isOldIE=goog.IS_OLD_IE_;if(opt_sourceText===undefined){if(!isOldIE){if(goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING){goog.appendScriptSrcNode_(src);}else {goog.writeScriptSrcNode_(src);}}else {var state=" onreadystatechange='goog.onScriptLoad_(this, "+ ++goog.lastNonModuleScriptIndex_+")' ";doc.write('<script type="text/javascript" src="'+src+'"'+state+'></'+'script>');}}else {doc.write('<script type="text/javascript">'+opt_sourceText+'</'+'script>');}return true;}else {return false;}}; /** @private {number} */goog.lastNonModuleScriptIndex_=0; /**
   * A readystatechange handler for legacy IE
   * @param {!HTMLScriptElement} script
   * @param {number} scriptIndex
   * @return {boolean}
   * @private
   */goog.onScriptLoad_=function(script,scriptIndex){ // for now load the modules when we reach the last script,
// later allow more inter-mingling.
if(script.readyState=='complete'&&goog.lastNonModuleScriptIndex_==scriptIndex){goog.loadQueuedModules_();}return true;}; /**
   * Resolves dependencies based on the dependencies added using addDependency
   * and calls importScript_ in the correct order.
   * @param {string} pathToLoad The path from which to start discovering
   *     dependencies.
   * @private
   */goog.writeScripts_=function(pathToLoad){ /** @type {!Array<string>} The scripts we need to write this time. */var scripts=[];var seenScript={};var deps=goog.dependencies_; /** @param {string} path */function visitNode(path){if(path in deps.written){return;} // We have already visited this one. We can get here if we have cyclic
// dependencies.
if(path in deps.visited){return;}deps.visited[path]=true;if(path in deps.requires){for(var requireName in deps.requires[path]){ // If the required name is defined, we assume that it was already
// bootstrapped by other means.
if(!goog.isProvided_(requireName)){if(requireName in deps.nameToPath){visitNode(deps.nameToPath[requireName]);}else {throw Error('Undefined nameToPath for '+requireName);}}}}if(!(path in seenScript)){seenScript[path]=true;scripts.push(path);}}visitNode(pathToLoad); // record that we are going to load all these scripts.
for(var i=0;i<scripts.length;i++){var path=scripts[i];goog.dependencies_.written[path]=true;} // If a module is loaded synchronously then we need to
// clear the current inModuleLoader value, and restore it when we are
// done loading the current "requires".
var moduleState=goog.moduleLoaderState_;goog.moduleLoaderState_=null;for(var i=0;i<scripts.length;i++){var path=scripts[i];if(path){if(!deps.pathIsModule[path]){goog.importScript_(goog.basePath+path);}else {goog.importModule_(goog.basePath+path);}}else {goog.moduleLoaderState_=moduleState;throw Error('Undefined script input');}} // restore the current "module loading state"
goog.moduleLoaderState_=moduleState;}; /**
   * Looks at the dependency rules and tries to determine the script file that
   * fulfills a particular rule.
   * @param {string} rule In the form goog.namespace.Class or project.script.
   * @return {?string} Url corresponding to the rule, or null.
   * @private
   */goog.getPathFromDeps_=function(rule){if(rule in goog.dependencies_.nameToPath){return goog.dependencies_.nameToPath[rule];}else {return null;}};goog.findBasePath_(); // Allow projects to manage the deps files themselves.
if(!goog.global.CLOSURE_NO_DEPS){goog.importScript_(goog.basePath+'deps.js');}} /**
 * Normalize a file path by removing redundant ".." and extraneous "." file
 * path components.
 * @param {string} path
 * @return {string}
 * @private
 */goog.normalizePath_=function(path){var components=path.split('/');var i=0;while(i<components.length){if(components[i]=='.'){components.splice(i,1);}else if(i&&components[i]=='..'&&components[i-1]&&components[i-1]!='..'){components.splice(--i,2);}else {i++;}}return components.join('/');}; /**
 * Loads file by synchronous XHR. Should not be used in production environments.
 * @param {string} src Source URL.
 * @return {string} File contents.
 * @private
 */goog.loadFileSync_=function(src){if(goog.global.CLOSURE_LOAD_FILE_SYNC){return goog.global.CLOSURE_LOAD_FILE_SYNC(src);}else { /** @type {XMLHttpRequest} */var xhr=new goog.global['XMLHttpRequest']();xhr.open('get',src,false);xhr.send();return xhr.responseText;}}; /**
 * Retrieve and execute a module.
 * @param {string} src Script source URL.
 * @private
 */goog.retrieveAndExecModule_=function(src){if(!COMPILED){ // The full but non-canonicalized URL for later use.
var originalPath=src; // Canonicalize the path, removing any /./ or /../ since Chrome's debugging
// console doesn't auto-canonicalize XHR loads as it does <script> srcs.
src=goog.normalizePath_(src);var importScript=goog.global.CLOSURE_IMPORT_SCRIPT||goog.writeScriptTag_;var scriptText=goog.loadFileSync_(src);if(scriptText!=null){var execModuleScript=goog.wrapModule_(src,scriptText);var isOldIE=goog.IS_OLD_IE_;if(isOldIE){goog.dependencies_.deferred[originalPath]=execModuleScript;goog.queuedModules_.push(originalPath);}else {importScript(src,execModuleScript);}}else {throw new Error('load of '+src+'failed');}}}; //==============================================================================
// Language Enhancements
//==============================================================================
/**
 * This is a "fixed" version of the typeof operator.  It differs from the typeof
 * operator in such a way that null returns 'null' and arrays return 'array'.
 * @param {?} value The value to get the type of.
 * @return {string} The name of the type.
 */goog.typeOf=function(value){var s=typeof value==='undefined'?'undefined':_typeof(value);if(s=='object'){if(value){ // Check these first, so we can avoid calling Object.prototype.toString if
// possible.
//
// IE improperly marshals typeof across execution contexts, but a
// cross-context object will still return false for "instanceof Object".
if(value instanceof Array){return 'array';}else if(value instanceof Object){return s;} // HACK: In order to use an Object prototype method on the arbitrary
//   value, the compiler requires the value be cast to type Object,
//   even though the ECMA spec explicitly allows it.
var className=Object.prototype.toString.call( /** @type {!Object} */value); // In Firefox 3.6, attempting to access iframe window objects' length
// property throws an NS_ERROR_FAILURE, so we need to special-case it
// here.
if(className=='[object Window]'){return 'object';} // We cannot always use constructor == Array or instanceof Array because
// different frames have different Array objects. In IE6, if the iframe
// where the array was created is destroyed, the array loses its
// prototype. Then dereferencing val.splice here throws an exception, so
// we can't use goog.isFunction. Calling typeof directly returns 'unknown'
// so that will work. In this case, this function will return false and
// most array functions will still work because the array is still
// array-like (supports length and []) even though it has lost its
// prototype.
// Mark Miller noticed that Object.prototype.toString
// allows access to the unforgeable [[Class]] property.
//  15.2.4.2 Object.prototype.toString ( )
//  When the toString method is called, the following steps are taken:
//      1. Get the [[Class]] property of this object.
//      2. Compute a string value by concatenating the three strings
//         "[object ", Result(1), and "]".
//      3. Return Result(2).
// and this behavior survives the destruction of the execution context.
if(className=='[object Array]'|| // In IE all non value types are wrapped as objects across window
// boundaries (not iframe though) so we have to do object detection
// for this edge case.
typeof value.length=='number'&&typeof value.splice!='undefined'&&typeof value.propertyIsEnumerable!='undefined'&&!value.propertyIsEnumerable('splice')){return 'array';} // HACK: There is still an array case that fails.
//     function ArrayImpostor() {}
//     ArrayImpostor.prototype = [];
//     var impostor = new ArrayImpostor;
// this can be fixed by getting rid of the fast path
// (value instanceof Array) and solely relying on
// (value && Object.prototype.toString.vall(value) === '[object Array]')
// but that would require many more function calls and is not warranted
// unless closure code is receiving objects from untrusted sources.
// IE in cross-window calls does not correctly marshal the function type
// (it appears just as an object) so we cannot use just typeof val ==
// 'function'. However, if the object has a call property, it is a
// function.
if(className=='[object Function]'||typeof value.call!='undefined'&&typeof value.propertyIsEnumerable!='undefined'&&!value.propertyIsEnumerable('call')){return 'function';}}else {return 'null';}}else if(s=='function'&&typeof value.call=='undefined'){ // In Safari typeof nodeList returns 'function', and on Firefox typeof
// behaves similarly for HTML{Applet,Embed,Object}, Elements and RegExps. We
// would like to return object for those and we can detect an invalid
// function by making sure that the function object has a call method.
return 'object';}return s;}; /**
 * Returns true if the specified value is null.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is null.
 */goog.isNull=function(val){return val===null;}; /**
 * Returns true if the specified value is defined and not null.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined and not null.
 */goog.isDefAndNotNull=function(val){ // Note that undefined == null.
return val!=null;}; /**
 * Returns true if the specified value is an array.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */goog.isArray=function(val){return goog.typeOf(val)=='array';}; /**
 * Returns true if the object looks like an array. To qualify as array like
 * the value needs to be either a NodeList or an object with a Number length
 * property. As a special case, a function value is not array like, because its
 * length property is fixed to correspond to the number of expected arguments.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */goog.isArrayLike=function(val){var type=goog.typeOf(val); // We do not use goog.isObject here in order to exclude function values.
return type=='array'||type=='object'&&typeof val.length=='number';}; /**
 * Returns true if the object looks like a Date. To qualify as Date-like the
 * value needs to be an object and have a getFullYear() function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a like a Date.
 */goog.isDateLike=function(val){return goog.isObject(val)&&typeof val.getFullYear=='function';}; /**
 * Returns true if the specified value is a string.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a string.
 */goog.isString=function(val){return typeof val=='string';}; /**
 * Returns true if the specified value is a boolean.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */goog.isBoolean=function(val){return typeof val=='boolean';}; /**
 * Returns true if the specified value is a number.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */goog.isNumber=function(val){return typeof val=='number';}; /**
 * Returns true if the specified value is a function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */goog.isFunction=function(val){return goog.typeOf(val)=='function';}; /**
 * Returns true if the specified value is an object.  This includes arrays and
 * functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */goog.isObject=function(val){var type=typeof val==='undefined'?'undefined':_typeof(val);return type=='object'&&val!=null||type=='function'; // return Object(val) === val also works, but is slower, especially if val is
// not an object.
}; /**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. The unique ID is
 * guaranteed to be unique across the current session amongst objects that are
 * passed into {@code getUid}. There is no guarantee that the ID is unique or
 * consistent across sessions. It is unsafe to generate unique ID for function
 * prototypes.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */goog.getUid=function(obj){ // TODO(arv): Make the type stricter, do not accept null.
// In Opera window.hasOwnProperty exists but always returns false so we avoid
// using it. As a consequence the unique ID generated for BaseClass.prototype
// and SubClass.prototype will be the same.
return obj[goog.UID_PROPERTY_]||(obj[goog.UID_PROPERTY_]=++goog.uidCounter_);}; /**
 * Whether the given object is already assigned a unique ID.
 *
 * This does not modify the object.
 *
 * @param {!Object} obj The object to check.
 * @return {boolean} Whether there is an assigned unique id for the object.
 */goog.hasUid=function(obj){return !!obj[goog.UID_PROPERTY_];}; /**
 * Removes the unique ID from an object. This is useful if the object was
 * previously mutated using {@code goog.getUid} in which case the mutation is
 * undone.
 * @param {Object} obj The object to remove the unique ID field from.
 */goog.removeUid=function(obj){ // TODO(arv): Make the type stricter, do not accept null.
// In IE, DOM nodes are not instances of Object and throw an exception if we
// try to delete.  Instead we try to use removeAttribute.
if(obj!==null&&'removeAttribute' in obj){obj.removeAttribute(goog.UID_PROPERTY_);} /** @preserveTry */try{delete obj[goog.UID_PROPERTY_];}catch(ex){}}; /**
 * Name for unique ID property. Initialized in a way to help avoid collisions
 * with other closure JavaScript on the same page.
 * @type {string}
 * @private
 */goog.UID_PROPERTY_='closure_uid_'+(Math.random()*1e9>>>0); /**
 * Counter for UID.
 * @type {number}
 * @private
 */goog.uidCounter_=0; /**
 * Adds a hash code field to an object. The hash code is unique for the
 * given object.
 * @param {Object} obj The object to get the hash code for.
 * @return {number} The hash code for the object.
 * @deprecated Use goog.getUid instead.
 */goog.getHashCode=goog.getUid; /**
 * Removes the hash code field from an object.
 * @param {Object} obj The object to remove the field from.
 * @deprecated Use goog.removeUid instead.
 */goog.removeHashCode=goog.removeUid; /**
 * Clones a value. The input may be an Object, Array, or basic type. Objects and
 * arrays will be cloned recursively.
 *
 * WARNINGS:
 * <code>goog.cloneObject</code> does not detect reference loops. Objects that
 * refer to themselves will cause infinite recursion.
 *
 * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies
 * UIDs created by <code>getUid</code> into cloned results.
 *
 * @param {*} obj The value to clone.
 * @return {*} A clone of the input value.
 * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.
 */goog.cloneObject=function(obj){var type=goog.typeOf(obj);if(type=='object'||type=='array'){if(obj.clone){return obj.clone();}var clone=type=='array'?[]:{};for(var key in obj){clone[key]=goog.cloneObject(obj[key]);}return clone;}return obj;}; /**
 * A native implementation of goog.bind.
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which this should
 *     point to when the function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @private
 * @suppress {deprecated} The compiler thinks that Function.prototype.bind is
 *     deprecated because some people have declared a pure-JS version.
 *     Only the pure-JS version is truly deprecated.
 */goog.bindNative_=function(fn,selfObj,var_args){return  (/** @type {!Function} */fn.call.apply(fn.bind,arguments));}; /**
 * A pure-JS implementation of goog.bind.
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which this should
 *     point to when the function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @private
 */goog.bindJs_=function(fn,selfObj,var_args){if(!fn){throw new Error();}if(arguments.length>2){var boundArgs=Array.prototype.slice.call(arguments,2);return function(){ // Prepend the bound arguments to the current arguments.
var newArgs=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(newArgs,boundArgs);return fn.apply(selfObj,newArgs);};}else {return function(){return fn.apply(selfObj,arguments);};}}; /**
 * Partially applies this function to a particular 'this object' and zero or
 * more arguments. The result is a new function with some arguments of the first
 * function pre-filled and the value of this 'pre-specified'.
 *
 * Remaining arguments specified at call-time are appended to the pre-specified
 * ones.
 *
 * Also see: {@link #partial}.
 *
 * Usage:
 * <pre>var barMethBound = goog.bind(myFunction, myObj, 'arg1', 'arg2');
 * barMethBound('arg3', 'arg4');</pre>
 *
 * @param {?function(this:T, ...)} fn A function to partially apply.
 * @param {T} selfObj Specifies the object which this should point to when the
 *     function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function goog.bind() was
 *     invoked as a method of.
 * @template T
 * @suppress {deprecated} See above.
 */goog.bind=function(fn,selfObj,var_args){ // TODO(nicksantos): narrow the type signature.
if(Function.prototype.bind&& // NOTE(nicksantos): Somebody pulled base.js into the default Chrome
// extension environment. This means that for Chrome extensions, they get
// the implementation of Function.prototype.bind that calls goog.bind
// instead of the native one. Even worse, we don't want to introduce a
// circular dependency between goog.bind and Function.prototype.bind, so
// we have to hack this to make sure it works correctly.
Function.prototype.bind.toString().indexOf('native code')!=-1){goog.bind=goog.bindNative_;}else {goog.bind=goog.bindJs_;}return goog.bind.apply(null,arguments);}; /**
 * Like goog.bind(), except that a 'this object' is not required. Useful when
 * the target function is already bound.
 *
 * Usage:
 * var g = goog.partial(f, arg1, arg2);
 * g(arg3, arg4);
 *
 * @param {Function} fn A function to partially apply.
 * @param {...*} var_args Additional arguments that are partially applied to fn.
 * @return {!Function} A partially-applied form of the function goog.partial()
 *     was invoked as a method of.
 */goog.partial=function(fn,var_args){var args=Array.prototype.slice.call(arguments,1);return function(){ // Clone the array (with slice()) and append additional arguments
// to the existing arguments.
var newArgs=args.slice();newArgs.push.apply(newArgs,arguments);return fn.apply(this,newArgs);};}; /**
 * Copies all the members of a source object to a target object. This method
 * does not work on all browsers for all objects that contain keys such as
 * toString or hasOwnProperty. Use goog.object.extend for this purpose.
 * @param {Object} target Target.
 * @param {Object} source Source.
 */goog.mixin=function(target,source){for(var x in source){target[x]=source[x];} // For IE7 or lower, the for-in-loop does not contain any properties that are
// not enumerable on the prototype object (for example, isPrototypeOf from
// Object.prototype) but also it will not include 'replace' on objects that
// extend String and change 'replace' (not that it is common for anyone to
// extend anything except Object).
}; /**
 * @return {number} An integer value representing the number of milliseconds
 *     between midnight, January 1, 1970 and the current time.
 */goog.now=goog.TRUSTED_SITE&&Date.now||function(){ // Unary plus operator converts its operand to a number which in
// the case of
// a date is done by calling getTime().
return +new Date();}; /**
 * Evals JavaScript in the global scope.  In IE this uses execScript, other
 * browsers use goog.global.eval. If goog.global.eval does not evaluate in the
 * global scope (for example, in Safari), appends a script tag instead.
 * Throws an exception if neither execScript or eval is defined.
 * @param {string} script JavaScript string.
 */goog.globalEval=function(script){if(goog.global.execScript){goog.global.execScript(script,'JavaScript');}else if(goog.global.eval){ // Test to see if eval works
if(goog.evalWorksForGlobals_==null){goog.global.eval('var _evalTest_ = 1;');if(typeof goog.global['_evalTest_']!='undefined'){try{delete goog.global['_evalTest_'];}catch(ignore){ // Microsoft edge fails the deletion above in strict mode.
}goog.evalWorksForGlobals_=true;}else {goog.evalWorksForGlobals_=false;}}if(goog.evalWorksForGlobals_){goog.global.eval(script);}else { /** @type {Document} */var doc=goog.global.document;var scriptElt= /** @type {!HTMLScriptElement} */doc.createElement('SCRIPT');scriptElt.type='text/javascript';scriptElt.defer=false; // Note(user): can't use .innerHTML since "t('<test>')" will fail and
// .text doesn't work in Safari 2.  Therefore we append a text node.
scriptElt.appendChild(doc.createTextNode(script));doc.body.appendChild(scriptElt);doc.body.removeChild(scriptElt);}}else {throw Error('goog.globalEval not available');}}; /**
 * Indicates whether or not we can call 'eval' directly to eval code in the
 * global scope. Set to a Boolean by the first call to goog.globalEval (which
 * empirically tests whether eval works for globals). @see goog.globalEval
 * @type {?boolean}
 * @private
 */goog.evalWorksForGlobals_=null; /**
 * Optional map of CSS class names to obfuscated names used with
 * goog.getCssName().
 * @private {!Object<string, string>|undefined}
 * @see goog.setCssNameMapping
 */goog.cssNameMapping_; /**
 * Optional obfuscation style for CSS class names. Should be set to either
 * 'BY_WHOLE' or 'BY_PART' if defined.
 * @type {string|undefined}
 * @private
 * @see goog.setCssNameMapping
 */goog.cssNameMappingStyle_; /**
 * Handles strings that are intended to be used as CSS class names.
 *
 * This function works in tandem with @see goog.setCssNameMapping.
 *
 * Without any mapping set, the arguments are simple joined with a hyphen and
 * passed through unaltered.
 *
 * When there is a mapping, there are two possible styles in which these
 * mappings are used. In the BY_PART style, each part (i.e. in between hyphens)
 * of the passed in css name is rewritten according to the map. In the BY_WHOLE
 * style, the full css name is looked up in the map directly. If a rewrite is
 * not specified by the map, the compiler will output a warning.
 *
 * When the mapping is passed to the compiler, it will replace calls to
 * goog.getCssName with the strings from the mapping, e.g.
 *     var x = goog.getCssName('foo');
 *     var y = goog.getCssName(this.baseClass, 'active');
 *  becomes:
 *     var x = 'foo';
 *     var y = this.baseClass + '-active';
 *
 * If one argument is passed it will be processed, if two are passed only the
 * modifier will be processed, as it is assumed the first argument was generated
 * as a result of calling goog.getCssName.
 *
 * @param {string} className The class name.
 * @param {string=} opt_modifier A modifier to be appended to the class name.
 * @return {string} The class name or the concatenation of the class name and
 *     the modifier.
 */goog.getCssName=function(className,opt_modifier){var getMapping=function getMapping(cssName){return goog.cssNameMapping_[cssName]||cssName;};var renameByParts=function renameByParts(cssName){ // Remap all the parts individually.
var parts=cssName.split('-');var mapped=[];for(var i=0;i<parts.length;i++){mapped.push(getMapping(parts[i]));}return mapped.join('-');};var rename;if(goog.cssNameMapping_){rename=goog.cssNameMappingStyle_=='BY_WHOLE'?getMapping:renameByParts;}else {rename=function rename(a){return a;};}if(opt_modifier){return className+'-'+rename(opt_modifier);}else {return rename(className);}}; /**
 * Sets the map to check when returning a value from goog.getCssName(). Example:
 * <pre>
 * goog.setCssNameMapping({
 *   "goog": "a",
 *   "disabled": "b",
 * });
 *
 * var x = goog.getCssName('goog');
 * // The following evaluates to: "a a-b".
 * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')
 * </pre>
 * When declared as a map of string literals to string literals, the JSCompiler
 * will replace all calls to goog.getCssName() using the supplied map if the
 * --process_closure_primitives flag is set.
 *
 * @param {!Object} mapping A map of strings to strings where keys are possible
 *     arguments to goog.getCssName() and values are the corresponding values
 *     that should be returned.
 * @param {string=} opt_style The style of css name mapping. There are two valid
 *     options: 'BY_PART', and 'BY_WHOLE'.
 * @see goog.getCssName for a description.
 */goog.setCssNameMapping=function(mapping,opt_style){goog.cssNameMapping_=mapping;goog.cssNameMappingStyle_=opt_style;}; /**
 * To use CSS renaming in compiled mode, one of the input files should have a
 * call to goog.setCssNameMapping() with an object literal that the JSCompiler
 * can extract and use to replace all calls to goog.getCssName(). In uncompiled
 * mode, JavaScript code should be loaded before this base.js file that declares
 * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is
 * to ensure that the mapping is loaded before any calls to goog.getCssName()
 * are made in uncompiled mode.
 *
 * A hook for overriding the CSS name mapping.
 * @type {!Object<string, string>|undefined}
 */goog.global.CLOSURE_CSS_NAME_MAPPING;if(!COMPILED&&goog.global.CLOSURE_CSS_NAME_MAPPING){ // This does not call goog.setCssNameMapping() because the JSCompiler
// requires that goog.setCssNameMapping() be called with an object literal.
goog.cssNameMapping_=goog.global.CLOSURE_CSS_NAME_MAPPING;} /**
 * Gets a localized message.
 *
 * This function is a compiler primitive. If you give the compiler a localized
 * message bundle, it will replace the string at compile-time with a localized
 * version, and expand goog.getMsg call to a concatenated string.
 *
 * Messages must be initialized in the form:
 * <code>
 * var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});
 * </code>
 *
 * @param {string} str Translatable string, places holders in the form {$foo}.
 * @param {Object<string, string>=} opt_values Maps place holder name to value.
 * @return {string} message with placeholders filled.
 */goog.getMsg=function(str,opt_values){if(opt_values){str=str.replace(/\{\$([^}]+)}/g,function(match,key){return opt_values!=null&&key in opt_values?opt_values[key]:match;});}return str;}; /**
 * Gets a localized message. If the message does not have a translation, gives a
 * fallback message.
 *
 * This is useful when introducing a new message that has not yet been
 * translated into all languages.
 *
 * This function is a compiler primitive. Must be used in the form:
 * <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>
 * where MSG_A and MSG_B were initialized with goog.getMsg.
 *
 * @param {string} a The preferred message.
 * @param {string} b The fallback message.
 * @return {string} The best translated message.
 */goog.getMsgWithFallback=function(a,b){return a;}; /**
 * Exposes an unobfuscated global namespace path for the given object.
 * Note that fields of the exported object *will* be obfuscated, unless they are
 * exported in turn via this function or goog.exportProperty.
 *
 * Also handy for making public items that are defined in anonymous closures.
 *
 * ex. goog.exportSymbol('public.path.Foo', Foo);
 *
 * ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);
 *     public.path.Foo.staticFunction();
 *
 * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',
 *                       Foo.prototype.myMethod);
 *     new public.path.Foo().myMethod();
 *
 * @param {string} publicPath Unobfuscated name to export.
 * @param {*} object Object the name should point to.
 * @param {Object=} opt_objectToExportTo The object to add the path to; default
 *     is goog.global.
 */goog.exportSymbol=function(publicPath,object,opt_objectToExportTo){goog.exportPath_(publicPath,object,opt_objectToExportTo);}; /**
 * Exports a property unobfuscated into the object's namespace.
 * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);
 * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);
 * @param {Object} object Object whose static property is being exported.
 * @param {string} publicName Unobfuscated name to export.
 * @param {*} symbol Object the name should point to.
 */goog.exportProperty=function(object,publicName,symbol){object[publicName]=symbol;}; /**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 * <pre>
 * function ParentClass(a, b) { }
 * ParentClass.prototype.foo = function(a) { };
 *
 * function ChildClass(a, b, c) {
 *   ChildClass.base(this, 'constructor', a, b);
 * }
 * goog.inherits(ChildClass, ParentClass);
 *
 * var child = new ChildClass('a', 'b', 'see');
 * child.foo(); // This works.
 * </pre>
 *
 * @param {!Function} childCtor Child class.
 * @param {!Function} parentCtor Parent class.
 */goog.inherits=function(childCtor,parentCtor){ /** @constructor */function tempCtor(){}tempCtor.prototype=parentCtor.prototype;childCtor.superClass_=parentCtor.prototype;childCtor.prototype=new tempCtor(); /** @override */childCtor.prototype.constructor=childCtor; /**
   * Calls superclass constructor/method.
   *
   * This function is only available if you use goog.inherits to
   * express inheritance relationships between classes.
   *
   * NOTE: This is a replacement for goog.base and for superClass_
   * property defined in childCtor.
   *
   * @param {!Object} me Should always be "this".
   * @param {string} methodName The method name to call. Calling
   *     superclass constructor can be done with the special string
   *     'constructor'.
   * @param {...*} var_args The arguments to pass to superclass
   *     method/constructor.
   * @return {*} The return value of the superclass method/constructor.
   */childCtor.base=function(me,methodName,var_args){ // Copying using loop to avoid deop due to passing arguments object to
// function. This is faster in many JS engines as of late 2014.
var args=new Array(arguments.length-2);for(var i=2;i<arguments.length;i++){args[i-2]=arguments[i];}return parentCtor.prototype[methodName].apply(me,args);};}; /**
 * Call up to the superclass.
 *
 * If this is called from a constructor, then this calls the superclass
 * constructor with arguments 1-N.
 *
 * If this is called from a prototype method, then you must pass the name of the
 * method as the second argument to this function. If you do not, you will get a
 * runtime error. This calls the superclass' method with arguments 2-N.
 *
 * This function only works if you use goog.inherits to express inheritance
 * relationships between your classes.
 *
 * This function is a compiler primitive. At compile-time, the compiler will do
 * macro expansion to remove a lot of the extra overhead that this function
 * introduces. The compiler will also enforce a lot of the assumptions that this
 * function makes, and treat it as a compiler error if you break them.
 *
 * @param {!Object} me Should always be "this".
 * @param {*=} opt_methodName The method name if calling a super method.
 * @param {...*} var_args The rest of the arguments.
 * @return {*} The return value of the superclass method.
 * @suppress {es5Strict} This method can not be used in strict mode, but
 *     all Closure Library consumers must depend on this file.
 */goog.base=function(me,opt_methodName,var_args){var caller=arguments.callee.caller;if(goog.STRICT_MODE_COMPATIBLE||goog.DEBUG&&!caller){throw Error('arguments.caller not defined.  goog.base() cannot be used '+'with strict mode code. See '+'http://www.ecma-international.org/ecma-262/5.1/#sec-C');}if(caller.superClass_){ // Copying using loop to avoid deop due to passing arguments object to
// function. This is faster in many JS engines as of late 2014.
var ctorArgs=new Array(arguments.length-1);for(var i=1;i<arguments.length;i++){ctorArgs[i-1]=arguments[i];} // This is a constructor. Call the superclass constructor.
return caller.superClass_.constructor.apply(me,ctorArgs);} // Copying using loop to avoid deop due to passing arguments object to
// function. This is faster in many JS engines as of late 2014.
var args=new Array(arguments.length-2);for(var i=2;i<arguments.length;i++){args[i-2]=arguments[i];}var foundCaller=false;for(var ctor=me.constructor;ctor;ctor=ctor.superClass_&&ctor.superClass_.constructor){if(ctor.prototype[opt_methodName]===caller){foundCaller=true;}else if(foundCaller){return ctor.prototype[opt_methodName].apply(me,args);}} // If we did not find the caller in the prototype chain, then one of two
// things happened:
// 1) The caller is an instance method.
// 2) This method was not called by the right caller.
if(me[opt_methodName]===caller){return me.constructor.prototype[opt_methodName].apply(me,args);}else {throw Error('goog.base called from a method of one name '+'to a method of a different name');}}; /**
 * Allow for aliasing within scope functions.  This function exists for
 * uncompiled code - in compiled code the calls will be inlined and the aliases
 * applied.  In uncompiled code the function is simply run since the aliases as
 * written are valid JavaScript.
 *
 *
 * @param {function()} fn Function to call.  This function can contain aliases
 *     to namespaces (e.g. "var dom = goog.dom") or classes
 *     (e.g. "var Timer = goog.Timer").
 */goog.scope=function(fn){fn.call(goog.global);}; /*
 * To support uncompiled, strict mode bundles that use eval to divide source
 * like so:
 *    eval('someSource;//# sourceUrl sourcefile.js');
 * We need to export the globally defined symbols "goog" and "COMPILED".
 * Exporting "goog" breaks the compiler optimizations, so we required that
 * be defined externally.
 * NOTE: We don't use goog.exportSymbol here because we don't want to trigger
 * extern generation when that compiler option is enabled.
 */if(!COMPILED){goog.global['COMPILED']=COMPILED;}goog.string={}; /**
 * Does simple python-style string substitution.
 * subs("foo%s hot%s", "bar", "dog") becomes "foobar hotdog".
 * @param {string} str The string containing the pattern.
 * @param {...*} var_args The items to substitute into the pattern.
 * @return {string} A copy of {@code str} in which each occurrence of
 *     {@code %s} has been replaced an argument from {@code var_args}.
 */goog.string.subs=function(str,var_args){var splitParts=str.split('%s');var returnString='';var subsArguments=Array.prototype.slice.call(arguments,1);while(subsArguments.length&& // Replace up to the last split part. We are inserting in the
// positions between split parts.
splitParts.length>1){returnString+=splitParts.shift()+subsArguments.shift();}return returnString+splitParts.join('%s'); // Join unused '%s'
}; /**
 * Regular expression that matches an ampersand, for use in escaping.
 * @const {!RegExp}
 * @private
 */goog.string.AMP_RE_=/&/g; /**
 * Regular expression that matches a less than sign, for use in escaping.
 * @const {!RegExp}
 * @private
 */goog.string.LT_RE_=/</g; /**
 * Regular expression that matches a greater than sign, for use in escaping.
 * @const {!RegExp}
 * @private
 */goog.string.GT_RE_=/>/g; /**
 * Regular expression that matches a double quote, for use in escaping.
 * @const {!RegExp}
 * @private
 */goog.string.QUOT_RE_=/"/g; /**
 * Regular expression that matches a single quote, for use in escaping.
 * @const {!RegExp}
 * @private
 */goog.string.SINGLE_QUOTE_RE_=/'/g; /**
 * Regular expression that matches null character, for use in escaping.
 * @const {!RegExp}
 * @private
 */goog.string.NULL_RE_=/\x00/g; /**
 * Regular expression that matches a lowercase letter "e", for use in escaping.
 * @const {!RegExp}
 * @private
 */goog.string.E_RE_=/e/g; /**
 * Regular expression that matches any character that needs to be escaped.
 * @const {!RegExp}
 * @private
 */goog.string.ALL_RE_=goog.string.DETECT_DOUBLE_ESCAPING?/[\x00&<>"'e]/:/[\x00&<>"']/; /**
 * Escapes double quote '"' and single quote '\'' characters in addition to
 * '&', '<', and '>' so that a string can be included in an HTML tag attribute
 * value within double or single quotes.
 *
 * It should be noted that > doesn't need to be escaped for the HTML or XML to
 * be valid, but it has been decided to escape it for consistency with other
 * implementations.
 *
 * With goog.string.DETECT_DOUBLE_ESCAPING, this function escapes also the
 * lowercase letter "e".
 *
 * NOTE(user):
 * HtmlEscape is often called during the generation of large blocks of HTML.
 * Using statics for the regular expressions and strings is an optimization
 * that can more than half the amount of time IE spends in this function for
 * large apps, since strings and regexes both contribute to GC allocations.
 *
 * Testing for the presence of a character before escaping increases the number
 * of function calls, but actually provides a speed increase for the average
 * case -- since the average case often doesn't require the escaping of all 4
 * characters and indexOf() is much cheaper than replace().
 * The worst case does suffer slightly from the additional calls, therefore the
 * opt_isLikelyToContainHtmlChars option has been included for situations
 * where all 4 HTML entities are very likely to be present and need escaping.
 *
 * Some benchmarks (times tended to fluctuate +-0.05ms):
 *                                     FireFox                     IE6
 * (no chars / average (mix of cases) / all 4 chars)
 * no checks                     0.13 / 0.22 / 0.22         0.23 / 0.53 / 0.80
 * indexOf                       0.08 / 0.17 / 0.26         0.22 / 0.54 / 0.84
 * indexOf + re test             0.07 / 0.17 / 0.28         0.19 / 0.50 / 0.85
 *
 * An additional advantage of checking if replace actually needs to be called
 * is a reduction in the number of object allocations, so as the size of the
 * application grows the difference between the various methods would increase.
 *
 * @param {string} str string to be escaped.
 * @param {boolean=} opt_isLikelyToContainHtmlChars Don't perform a check to see
 *     if the character needs replacing - use this option if you expect each of
 *     the characters to appear often. Leave false if you expect few html
 *     characters to occur in your strings, such as if you are escaping HTML.
 * @return {string} An escaped copy of {@code str}.
 */goog.string.htmlEscape=function(str,opt_isLikelyToContainHtmlChars){if(opt_isLikelyToContainHtmlChars){str=str.replace(goog.string.AMP_RE_,'&amp;').replace(goog.string.LT_RE_,'&lt;').replace(goog.string.GT_RE_,'&gt;').replace(goog.string.QUOT_RE_,'&quot;').replace(goog.string.SINGLE_QUOTE_RE_,'&#39;').replace(goog.string.NULL_RE_,'&#0;');if(goog.string.DETECT_DOUBLE_ESCAPING){str=str.replace(goog.string.E_RE_,'&#101;');}return str;}else { // quick test helps in the case when there are no chars to replace, in
// worst case this makes barely a difference to the time taken
if(!goog.string.ALL_RE_.test(str))return str; // str.indexOf is faster than regex.test in this case
if(str.indexOf('&')!=-1){str=str.replace(goog.string.AMP_RE_,'&amp;');}if(str.indexOf('<')!=-1){str=str.replace(goog.string.LT_RE_,'&lt;');}if(str.indexOf('>')!=-1){str=str.replace(goog.string.GT_RE_,'&gt;');}if(str.indexOf('"')!=-1){str=str.replace(goog.string.QUOT_RE_,'&quot;');}if(str.indexOf('\'')!=-1){str=str.replace(goog.string.SINGLE_QUOTE_RE_,'&#39;');}if(str.indexOf('\x00')!=-1){str=str.replace(goog.string.NULL_RE_,'&#0;');}if(goog.string.DETECT_DOUBLE_ESCAPING&&str.indexOf('e')!=-1){str=str.replace(goog.string.E_RE_,'&#101;');}return str;}};goog.debug={}; /**
 * Returns the type of a value. If a constructor is passed, and a suitable
 * string cannot be found, 'unknown type name' will be returned.
 *
 * <p>Forked rather than moved from {@link goog.asserts.getType_}
 * to avoid adding a dependency to goog.asserts.
 * @param {*} value A constructor, object, or primitive.
 * @return {string} The best display name for the value, or 'unknown type name'.
 */goog.debug.runtimeType=function(value){if(value instanceof Function){return value.displayName||value.name||'unknown type name';}else if(value instanceof Object){return value.constructor.displayName||value.constructor.name||Object.prototype.toString.call(value);}else {return value===null?'null':typeof value==='undefined'?'undefined':_typeof(value);}}; // Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Provides a base class for custom Error objects such that the
 * stack is correctly maintained.
 *
 * You should never need to throw goog.debug.Error(msg) directly, Error(msg) is
 * sufficient.
 *
 */ /**
 * Base class for custom error objects.
 * @param {*=} opt_msg The message associated with the error.
 * @constructor
 * @extends {Error}
 */goog.debug.Error=function(opt_msg){ // Attempt to ensure there is a stack trace.
if(Error.captureStackTrace){Error.captureStackTrace(this,goog.debug.Error);}else {var stack=new Error().stack;if(stack){this.stack=stack;}}if(opt_msg){this.message=String(opt_msg);} /**
   * Whether to report this error to the server. Setting this to false will
   * cause the error reporter to not report the error back to the server,
   * which can be useful if the client knows that the error has already been
   * logged on the server.
   * @type {boolean}
   */this.reportErrorToServer=true;};goog.inherits(goog.debug.Error,Error); /** @override */goog.debug.Error.prototype.name='CustomError'; /**
 * @fileoverview Definition of goog.dom.NodeType.
 */goog.dom={}; /**
 * Constants for the nodeType attribute in the Node interface.
 *
 * These constants match those specified in the Node interface. These are
 * usually present on the Node object in recent browsers, but not in older
 * browsers (specifically, early IEs) and thus are given here.
 *
 * In some browsers (early IEs), these are not defined on the Node object,
 * so they are provided here.
 *
 * See http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-1950641247
 * @enum {number}
 */goog.dom.NodeType={ELEMENT:1,ATTRIBUTE:2,TEXT:3,CDATA_SECTION:4,ENTITY_REFERENCE:5,ENTITY:6,PROCESSING_INSTRUCTION:7,COMMENT:8,DOCUMENT:9,DOCUMENT_TYPE:10,DOCUMENT_FRAGMENT:11,NOTATION:12}; // Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Utility functions for supporting Bidi issues.
 */ /**
 * Namespace for bidi supporting functions.
 */goog.provide('goog.i18n.bidi');goog.provide('goog.i18n.bidi.Dir');goog.provide('goog.i18n.bidi.DirectionalString');goog.provide('goog.i18n.bidi.Format'); /**
 * @define {boolean} FORCE_RTL forces the {@link goog.i18n.bidi.IS_RTL} constant
 * to say that the current locale is a RTL locale.  This should only be used
 * if you want to override the default behavior for deciding whether the
 * current locale is RTL or not.
 *
 * {@see goog.i18n.bidi.IS_RTL}
 */goog.define('goog.i18n.bidi.FORCE_RTL',false); /**
 * Constant that defines whether or not the current locale is a RTL locale.
 * If {@link goog.i18n.bidi.FORCE_RTL} is not true, this constant will default
 * to check that {@link goog.LOCALE} is one of a few major RTL locales.
 *
 * <p>This is designed to be a maximally efficient compile-time constant. For
 * example, for the default goog.LOCALE, compiling
 * "if (goog.i18n.bidi.IS_RTL) alert('rtl') else {}" should produce no code. It
 * is this design consideration that limits the implementation to only
 * supporting a few major RTL locales, as opposed to the broader repertoire of
 * something like goog.i18n.bidi.isRtlLanguage.
 *
 * <p>Since this constant refers to the directionality of the locale, it is up
 * to the caller to determine if this constant should also be used for the
 * direction of the UI.
 *
 * {@see goog.LOCALE}
 *
 * @type {boolean}
 *
 * TODO(user): write a test that checks that this is a compile-time constant.
 */goog.i18n.bidi.IS_RTL=goog.i18n.bidi.FORCE_RTL||(goog.LOCALE.substring(0,2).toLowerCase()=='ar'||goog.LOCALE.substring(0,2).toLowerCase()=='fa'||goog.LOCALE.substring(0,2).toLowerCase()=='he'||goog.LOCALE.substring(0,2).toLowerCase()=='iw'||goog.LOCALE.substring(0,2).toLowerCase()=='ps'||goog.LOCALE.substring(0,2).toLowerCase()=='sd'||goog.LOCALE.substring(0,2).toLowerCase()=='ug'||goog.LOCALE.substring(0,2).toLowerCase()=='ur'||goog.LOCALE.substring(0,2).toLowerCase()=='yi')&&(goog.LOCALE.length==2||goog.LOCALE.substring(2,3)=='-'||goog.LOCALE.substring(2,3)=='_')||goog.LOCALE.length>=3&&goog.LOCALE.substring(0,3).toLowerCase()=='ckb'&&(goog.LOCALE.length==3||goog.LOCALE.substring(3,4)=='-'||goog.LOCALE.substring(3,4)=='_'); /**
 * Unicode formatting characters and directionality string constants.
 * @enum {string}
 */goog.i18n.bidi.Format={ /** Unicode "Left-To-Right Embedding" (LRE) character. */LRE:'‪', /** Unicode "Right-To-Left Embedding" (RLE) character. */RLE:'‫', /** Unicode "Pop Directional Formatting" (PDF) character. */PDF:'‬', /** Unicode "Left-To-Right Mark" (LRM) character. */LRM:'‎', /** Unicode "Right-To-Left Mark" (RLM) character. */RLM:'‏'}; /**
 * Directionality enum.
 * @enum {number}
 */goog.i18n.bidi.Dir={ /**
   * Left-to-right.
   */LTR:1, /**
   * Right-to-left.
   */RTL:-1, /**
   * Neither left-to-right nor right-to-left.
   */NEUTRAL:0}; /**
 * 'right' string constant.
 * @type {string}
 */goog.i18n.bidi.RIGHT='right'; /**
 * 'left' string constant.
 * @type {string}
 */goog.i18n.bidi.LEFT='left'; /**
 * 'left' if locale is RTL, 'right' if not.
 * @type {string}
 */goog.i18n.bidi.I18N_RIGHT=goog.i18n.bidi.IS_RTL?goog.i18n.bidi.LEFT:goog.i18n.bidi.RIGHT; /**
 * 'right' if locale is RTL, 'left' if not.
 * @type {string}
 */goog.i18n.bidi.I18N_LEFT=goog.i18n.bidi.IS_RTL?goog.i18n.bidi.RIGHT:goog.i18n.bidi.LEFT; /**
 * Convert a directionality given in various formats to a goog.i18n.bidi.Dir
 * constant. Useful for interaction with different standards of directionality
 * representation.
 *
 * @param {goog.i18n.bidi.Dir|number|boolean|null} givenDir Directionality given
 *     in one of the following formats:
 *     1. A goog.i18n.bidi.Dir constant.
 *     2. A number (positive = LTR, negative = RTL, 0 = neutral).
 *     3. A boolean (true = RTL, false = LTR).
 *     4. A null for unknown directionality.
 * @param {boolean=} opt_noNeutral Whether a givenDir of zero or
 *     goog.i18n.bidi.Dir.NEUTRAL should be treated as null, i.e. unknown, in
 *     order to preserve legacy behavior.
 * @return {?goog.i18n.bidi.Dir} A goog.i18n.bidi.Dir constant matching the
 *     given directionality. If given null, returns null (i.e. unknown).
 */goog.i18n.bidi.toDir=function(givenDir,opt_noNeutral){if(typeof givenDir=='number'){ // This includes the non-null goog.i18n.bidi.Dir case.
return givenDir>0?goog.i18n.bidi.Dir.LTR:givenDir<0?goog.i18n.bidi.Dir.RTL:opt_noNeutral?null:goog.i18n.bidi.Dir.NEUTRAL;}else if(givenDir==null){return null;}else { // Must be typeof givenDir == 'boolean'.
return givenDir?goog.i18n.bidi.Dir.RTL:goog.i18n.bidi.Dir.LTR;}}; /**
 * A practical pattern to identify strong LTR characters. This pattern is not
 * theoretically correct according to the Unicode standard. It is simplified for
 * performance and small code size.
 * @type {string}
 * @private
 */goog.i18n.bidi.ltrChars_='A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿'+'‎Ⰰ-﬜︀-﹯﻽-￿'; /**
 * A practical pattern to identify strong RTL character. This pattern is not
 * theoretically correct according to the Unicode standard. It is simplified
 * for performance and small code size.
 * @type {string}
 * @private
 */goog.i18n.bidi.rtlChars_='֑-ۯۺ-߿‏יִ-﷿ﹰ-ﻼ'; /**
 * Simplified regular expression for an HTML tag (opening or closing) or an HTML
 * escape. We might want to skip over such expressions when estimating the text
 * directionality.
 * @type {RegExp}
 * @private
 */goog.i18n.bidi.htmlSkipReg_=/<[^>]*>|&[^;]+;/g; /**
 * Returns the input text with spaces instead of HTML tags or HTML escapes, if
 * opt_isStripNeeded is true. Else returns the input as is.
 * Useful for text directionality estimation.
 * Note: the function should not be used in other contexts; it is not 100%
 * correct, but rather a good-enough implementation for directionality
 * estimation purposes.
 * @param {string} str The given string.
 * @param {boolean=} opt_isStripNeeded Whether to perform the stripping.
 *     Default: false (to retain consistency with calling functions).
 * @return {string} The given string cleaned of HTML tags / escapes.
 * @private
 */goog.i18n.bidi.stripHtmlIfNeeded_=function(str,opt_isStripNeeded){return opt_isStripNeeded?str.replace(goog.i18n.bidi.htmlSkipReg_,''):str;}; /**
 * Regular expression to check for RTL characters.
 * @type {RegExp}
 * @private
 */goog.i18n.bidi.rtlCharReg_=new RegExp('['+goog.i18n.bidi.rtlChars_+']'); /**
 * Regular expression to check for LTR characters.
 * @type {RegExp}
 * @private
 */goog.i18n.bidi.ltrCharReg_=new RegExp('['+goog.i18n.bidi.ltrChars_+']'); /**
 * Test whether the given string has any RTL characters in it.
 * @param {string} str The given string that need to be tested.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether the string contains RTL characters.
 */goog.i18n.bidi.hasAnyRtl=function(str,opt_isHtml){return goog.i18n.bidi.rtlCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str,opt_isHtml));}; /**
 * Test whether the given string has any RTL characters in it.
 * @param {string} str The given string that need to be tested.
 * @return {boolean} Whether the string contains RTL characters.
 * @deprecated Use hasAnyRtl.
 */goog.i18n.bidi.hasRtlChar=goog.i18n.bidi.hasAnyRtl; /**
 * Test whether the given string has any LTR characters in it.
 * @param {string} str The given string that need to be tested.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether the string contains LTR characters.
 */goog.i18n.bidi.hasAnyLtr=function(str,opt_isHtml){return goog.i18n.bidi.ltrCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str,opt_isHtml));}; /**
 * Regular expression pattern to check if the first character in the string
 * is LTR.
 * @type {RegExp}
 * @private
 */goog.i18n.bidi.ltrRe_=new RegExp('^['+goog.i18n.bidi.ltrChars_+']'); /**
 * Regular expression pattern to check if the first character in the string
 * is RTL.
 * @type {RegExp}
 * @private
 */goog.i18n.bidi.rtlRe_=new RegExp('^['+goog.i18n.bidi.rtlChars_+']'); /**
 * Check if the first character in the string is RTL or not.
 * @param {string} str The given string that need to be tested.
 * @return {boolean} Whether the first character in str is an RTL char.
 */goog.i18n.bidi.isRtlChar=function(str){return goog.i18n.bidi.rtlRe_.test(str);}; /**
 * Check if the first character in the string is LTR or not.
 * @param {string} str The given string that need to be tested.
 * @return {boolean} Whether the first character in str is an LTR char.
 */goog.i18n.bidi.isLtrChar=function(str){return goog.i18n.bidi.ltrRe_.test(str);}; /**
 * Check if the first character in the string is neutral or not.
 * @param {string} str The given string that need to be tested.
 * @return {boolean} Whether the first character in str is a neutral char.
 */goog.i18n.bidi.isNeutralChar=function(str){return !goog.i18n.bidi.isLtrChar(str)&&!goog.i18n.bidi.isRtlChar(str);}; /**
 * Regular expressions to check if a piece of text is of LTR directionality
 * on first character with strong directionality.
 * @type {RegExp}
 * @private
 */goog.i18n.bidi.ltrDirCheckRe_=new RegExp('^[^'+goog.i18n.bidi.rtlChars_+']*['+goog.i18n.bidi.ltrChars_+']'); /**
 * Regular expressions to check if a piece of text is of RTL directionality
 * on first character with strong directionality.
 * @type {RegExp}
 * @private
 */goog.i18n.bidi.rtlDirCheckRe_=new RegExp('^[^'+goog.i18n.bidi.ltrChars_+']*['+goog.i18n.bidi.rtlChars_+']'); /**
 * Check whether the first strongly directional character (if any) is RTL.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether RTL directionality is detected using the first
 *     strongly-directional character method.
 */goog.i18n.bidi.startsWithRtl=function(str,opt_isHtml){return goog.i18n.bidi.rtlDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str,opt_isHtml));}; /**
 * Check whether the first strongly directional character (if any) is RTL.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether RTL directionality is detected using the first
 *     strongly-directional character method.
 * @deprecated Use startsWithRtl.
 */goog.i18n.bidi.isRtlText=goog.i18n.bidi.startsWithRtl; /**
 * Check whether the first strongly directional character (if any) is LTR.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether LTR directionality is detected using the first
 *     strongly-directional character method.
 */goog.i18n.bidi.startsWithLtr=function(str,opt_isHtml){return goog.i18n.bidi.ltrDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str,opt_isHtml));}; /**
 * Check whether the first strongly directional character (if any) is LTR.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether LTR directionality is detected using the first
 *     strongly-directional character method.
 * @deprecated Use startsWithLtr.
 */goog.i18n.bidi.isLtrText=goog.i18n.bidi.startsWithLtr; /**
 * Regular expression to check if a string looks like something that must
 * always be LTR even in RTL text, e.g. a URL. When estimating the
 * directionality of text containing these, we treat these as weakly LTR,
 * like numbers.
 * @type {RegExp}
 * @private
 */goog.i18n.bidi.isRequiredLtrRe_=/^http:\/\/.*/; /**
 * Check whether the input string either contains no strongly directional
 * characters or looks like a url.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether neutral directionality is detected.
 */goog.i18n.bidi.isNeutralText=function(str,opt_isHtml){str=goog.i18n.bidi.stripHtmlIfNeeded_(str,opt_isHtml);return goog.i18n.bidi.isRequiredLtrRe_.test(str)||!goog.i18n.bidi.hasAnyLtr(str)&&!goog.i18n.bidi.hasAnyRtl(str);}; /**
 * Regular expressions to check if the last strongly-directional character in a
 * piece of text is LTR.
 * @type {RegExp}
 * @private
 */goog.i18n.bidi.ltrExitDirCheckRe_=new RegExp('['+goog.i18n.bidi.ltrChars_+'][^'+goog.i18n.bidi.rtlChars_+']*$'); /**
 * Regular expressions to check if the last strongly-directional character in a
 * piece of text is RTL.
 * @type {RegExp}
 * @private
 */goog.i18n.bidi.rtlExitDirCheckRe_=new RegExp('['+goog.i18n.bidi.rtlChars_+'][^'+goog.i18n.bidi.ltrChars_+']*$'); /**
 * Check if the exit directionality a piece of text is LTR, i.e. if the last
 * strongly-directional character in the string is LTR.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether LTR exit directionality was detected.
 */goog.i18n.bidi.endsWithLtr=function(str,opt_isHtml){return goog.i18n.bidi.ltrExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str,opt_isHtml));}; /**
 * Check if the exit directionality a piece of text is LTR, i.e. if the last
 * strongly-directional character in the string is LTR.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether LTR exit directionality was detected.
 * @deprecated Use endsWithLtr.
 */goog.i18n.bidi.isLtrExitText=goog.i18n.bidi.endsWithLtr; /**
 * Check if the exit directionality a piece of text is RTL, i.e. if the last
 * strongly-directional character in the string is RTL.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether RTL exit directionality was detected.
 */goog.i18n.bidi.endsWithRtl=function(str,opt_isHtml){return goog.i18n.bidi.rtlExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str,opt_isHtml));}; /**
 * Check if the exit directionality a piece of text is RTL, i.e. if the last
 * strongly-directional character in the string is RTL.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether RTL exit directionality was detected.
 * @deprecated Use endsWithRtl.
 */goog.i18n.bidi.isRtlExitText=goog.i18n.bidi.endsWithRtl; /**
 * A regular expression for matching right-to-left language codes.
 * See {@link #isRtlLanguage} for the design.
 * @type {RegExp}
 * @private
 */goog.i18n.bidi.rtlLocalesRe_=new RegExp('^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|'+'.*[-_](Arab|Hebr|Thaa|Nkoo|Tfng))'+'(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)','i'); /**
 * Check if a BCP 47 / III language code indicates an RTL language, i.e. either:
 * - a language code explicitly specifying one of the right-to-left scripts,
 *   e.g. "az-Arab", or<p>
 * - a language code specifying one of the languages normally written in a
 *   right-to-left script, e.g. "fa" (Farsi), except ones explicitly specifying
 *   Latin or Cyrillic script (which are the usual LTR alternatives).<p>
 * The list of right-to-left scripts appears in the 100-199 range in
 * http://www.unicode.org/iso15924/iso15924-num.html, of which Arabic and
 * Hebrew are by far the most widely used. We also recognize Thaana, N'Ko, and
 * Tifinagh, which also have significant modern usage. The rest (Syriac,
 * Samaritan, Mandaic, etc.) seem to have extremely limited or no modern usage
 * and are not recognized to save on code size.
 * The languages usually written in a right-to-left script are taken as those
 * with Suppress-Script: Hebr|Arab|Thaa|Nkoo|Tfng  in
 * http://www.iana.org/assignments/language-subtag-registry,
 * as well as Central (or Sorani) Kurdish (ckb), Sindhi (sd) and Uyghur (ug).
 * Other subtags of the language code, e.g. regions like EG (Egypt), are
 * ignored.
 * @param {string} lang BCP 47 (a.k.a III) language code.
 * @return {boolean} Whether the language code is an RTL language.
 */goog.i18n.bidi.isRtlLanguage=function(lang){return goog.i18n.bidi.rtlLocalesRe_.test(lang);}; /**
 * Regular expression for bracket guard replacement in text.
 * @type {RegExp}
 * @private
 */goog.i18n.bidi.bracketGuardTextRe_=/(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(<.*?>+)/g; /**
 * Apply bracket guard using LRM and RLM. This is to address the problem of
 * messy bracket display frequently happens in RTL layout.
 * This function works for plain text, not for HTML. In HTML, the opening
 * bracket might be in a different context than the closing bracket (such as
 * an attribute value).
 * @param {string} s The string that need to be processed.
 * @param {boolean=} opt_isRtlContext specifies default direction (usually
 *     direction of the UI).
 * @return {string} The processed string, with all bracket guarded.
 */goog.i18n.bidi.guardBracketInText=function(s,opt_isRtlContext){var useRtl=opt_isRtlContext===undefined?goog.i18n.bidi.hasAnyRtl(s):opt_isRtlContext;var mark=useRtl?goog.i18n.bidi.Format.RLM:goog.i18n.bidi.Format.LRM;return s.replace(goog.i18n.bidi.bracketGuardTextRe_,mark+'$&'+mark);}; /**
 * Enforce the html snippet in RTL directionality regardless overall context.
 * If the html piece was enclosed by tag, dir will be applied to existing
 * tag, otherwise a span tag will be added as wrapper. For this reason, if
 * html snippet start with with tag, this tag must enclose the whole piece. If
 * the tag already has a dir specified, this new one will override existing
 * one in behavior (tested on FF and IE).
 * @param {string} html The string that need to be processed.
 * @return {string} The processed string, with directionality enforced to RTL.
 */goog.i18n.bidi.enforceRtlInHtml=function(html){if(html.charAt(0)=='<'){return html.replace(/<\w+/,'$& dir=rtl');} // '\n' is important for FF so that it won't incorrectly merge span groups
return '\n<span dir=rtl>'+html+'</span>';}; /**
 * Enforce RTL on both end of the given text piece using unicode BiDi formatting
 * characters RLE and PDF.
 * @param {string} text The piece of text that need to be wrapped.
 * @return {string} The wrapped string after process.
 */goog.i18n.bidi.enforceRtlInText=function(text){return goog.i18n.bidi.Format.RLE+text+goog.i18n.bidi.Format.PDF;}; /**
 * Enforce the html snippet in RTL directionality regardless overall context.
 * If the html piece was enclosed by tag, dir will be applied to existing
 * tag, otherwise a span tag will be added as wrapper. For this reason, if
 * html snippet start with with tag, this tag must enclose the whole piece. If
 * the tag already has a dir specified, this new one will override existing
 * one in behavior (tested on FF and IE).
 * @param {string} html The string that need to be processed.
 * @return {string} The processed string, with directionality enforced to RTL.
 */goog.i18n.bidi.enforceLtrInHtml=function(html){if(html.charAt(0)=='<'){return html.replace(/<\w+/,'$& dir=ltr');} // '\n' is important for FF so that it won't incorrectly merge span groups
return '\n<span dir=ltr>'+html+'</span>';}; /**
 * Enforce LTR on both end of the given text piece using unicode BiDi formatting
 * characters LRE and PDF.
 * @param {string} text The piece of text that need to be wrapped.
 * @return {string} The wrapped string after process.
 */goog.i18n.bidi.enforceLtrInText=function(text){return goog.i18n.bidi.Format.LRE+text+goog.i18n.bidi.Format.PDF;}; /**
 * Regular expression to find dimensions such as "padding: .3 0.4ex 5px 6;"
 * @type {RegExp}
 * @private
 */goog.i18n.bidi.dimensionsRe_=/:\s*([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)/g; /**
 * Regular expression for left.
 * @type {RegExp}
 * @private
 */goog.i18n.bidi.leftRe_=/left/gi; /**
 * Regular expression for right.
 * @type {RegExp}
 * @private
 */goog.i18n.bidi.rightRe_=/right/gi; /**
 * Placeholder regular expression for swapping.
 * @type {RegExp}
 * @private
 */goog.i18n.bidi.tempRe_=/%%%%/g; /**
 * Swap location parameters and 'left'/'right' in CSS specification. The
 * processed string will be suited for RTL layout. Though this function can
 * cover most cases, there are always exceptions. It is suggested to put
 * those exceptions in separate group of CSS string.
 * @param {string} cssStr CSS spefication string.
 * @return {string} Processed CSS specification string.
 */goog.i18n.bidi.mirrorCSS=function(cssStr){return cssStr. // reverse dimensions
replace(goog.i18n.bidi.dimensionsRe_,':$1 $4 $3 $2').replace(goog.i18n.bidi.leftRe_,'%%%%'). // swap left and right
replace(goog.i18n.bidi.rightRe_,goog.i18n.bidi.LEFT).replace(goog.i18n.bidi.tempRe_,goog.i18n.bidi.RIGHT);}; /**
 * Regular expression for hebrew double quote substitution, finding quote
 * directly after hebrew characters.
 * @type {RegExp}
 * @private
 */goog.i18n.bidi.doubleQuoteSubstituteRe_=/([\u0591-\u05f2])"/g; /**
 * Regular expression for hebrew single quote substitution, finding quote
 * directly after hebrew characters.
 * @type {RegExp}
 * @private
 */goog.i18n.bidi.singleQuoteSubstituteRe_=/([\u0591-\u05f2])'/g; /**
 * Replace the double and single quote directly after a Hebrew character with
 * GERESH and GERSHAYIM. In such case, most likely that's user intention.
 * @param {string} str String that need to be processed.
 * @return {string} Processed string with double/single quote replaced.
 */goog.i18n.bidi.normalizeHebrewQuote=function(str){return str.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_,'$1״').replace(goog.i18n.bidi.singleQuoteSubstituteRe_,'$1׳');}; /**
 * Regular expression to split a string into "words" for directionality
 * estimation based on relative word counts.
 * @type {RegExp}
 * @private
 */goog.i18n.bidi.wordSeparatorRe_=/\s+/; /**
 * Regular expression to check if a string contains any numerals. Used to
 * differentiate between completely neutral strings and those containing
 * numbers, which are weakly LTR.
 *
 * Native Arabic digits (\u0660 - \u0669) are not included because although they
 * do flow left-to-right inside a number, this is the case even if the  overall
 * directionality is RTL, and a mathematical expression using these digits is
 * supposed to flow right-to-left overall, including unary plus and minus
 * appearing to the right of a number, and this does depend on the overall
 * directionality being RTL. The digits used in Farsi (\u06F0 - \u06F9), on the
 * other hand, are included, since Farsi math (including unary plus and minus)
 * does flow left-to-right.
 *
 * @type {RegExp}
 * @private
 */goog.i18n.bidi.hasNumeralsRe_=/[\d\u06f0-\u06f9]/; /**
 * This constant controls threshold of RTL directionality.
 * @type {number}
 * @private
 */goog.i18n.bidi.rtlDetectionThreshold_=0.40; /**
 * Estimates the directionality of a string based on relative word counts.
 * If the number of RTL words is above a certain percentage of the total number
 * of strongly directional words, returns RTL.
 * Otherwise, if any words are strongly or weakly LTR, returns LTR.
 * Otherwise, returns UNKNOWN, which is used to mean "neutral".
 * Numbers are counted as weakly LTR.
 * @param {string} str The string to be checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {goog.i18n.bidi.Dir} Estimated overall directionality of {@code str}.
 */goog.i18n.bidi.estimateDirection=function(str,opt_isHtml){var rtlCount=0;var totalCount=0;var hasWeaklyLtr=false;var tokens=goog.i18n.bidi.stripHtmlIfNeeded_(str,opt_isHtml).split(goog.i18n.bidi.wordSeparatorRe_);for(var i=0;i<tokens.length;i++){var token=tokens[i];if(goog.i18n.bidi.startsWithRtl(token)){rtlCount++;totalCount++;}else if(goog.i18n.bidi.isRequiredLtrRe_.test(token)){hasWeaklyLtr=true;}else if(goog.i18n.bidi.hasAnyLtr(token)){totalCount++;}else if(goog.i18n.bidi.hasNumeralsRe_.test(token)){hasWeaklyLtr=true;}}return totalCount==0?hasWeaklyLtr?goog.i18n.bidi.Dir.LTR:goog.i18n.bidi.Dir.NEUTRAL:rtlCount/totalCount>goog.i18n.bidi.rtlDetectionThreshold_?goog.i18n.bidi.Dir.RTL:goog.i18n.bidi.Dir.LTR;}; /**
 * Check the directionality of a piece of text, return true if the piece of
 * text should be laid out in RTL direction.
 * @param {string} str The piece of text that need to be detected.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether this piece of text should be laid out in RTL.
 */goog.i18n.bidi.detectRtlDirectionality=function(str,opt_isHtml){return goog.i18n.bidi.estimateDirection(str,opt_isHtml)==goog.i18n.bidi.Dir.RTL;}; /**
 * Sets text input element's directionality and text alignment based on a
 * given directionality. Does nothing if the given directionality is unknown or
 * neutral.
 * @param {Element} element Input field element to set directionality to.
 * @param {goog.i18n.bidi.Dir|number|boolean|null} dir Desired directionality,
 *     given in one of the following formats:
 *     1. A goog.i18n.bidi.Dir constant.
 *     2. A number (positive = LRT, negative = RTL, 0 = neutral).
 *     3. A boolean (true = RTL, false = LTR).
 *     4. A null for unknown directionality.
 */goog.i18n.bidi.setElementDirAndAlign=function(element,dir){if(element){dir=goog.i18n.bidi.toDir(dir);if(dir){element.style.textAlign=dir==goog.i18n.bidi.Dir.RTL?goog.i18n.bidi.RIGHT:goog.i18n.bidi.LEFT;element.dir=dir==goog.i18n.bidi.Dir.RTL?'rtl':'ltr';}}}; /**
 * Sets element dir based on estimated directionality of the given text.
 * @param {!Element} element
 * @param {string} text
 */goog.i18n.bidi.setElementDirByTextDirectionality=function(element,text){switch(goog.i18n.bidi.estimateDirection(text)){case goog.i18n.bidi.Dir.LTR:element.dir='ltr';break;case goog.i18n.bidi.Dir.RTL:element.dir='rtl';break;default: // Default for no direction, inherit from document.
element.removeAttribute('dir');}}; /**
 * Strings that have an (optional) known direction.
 *
 * Implementations of this interface are string-like objects that carry an
 * attached direction, if known.
 * @interface
 */goog.i18n.bidi.DirectionalString=function(){}; /**
 * Interface marker of the DirectionalString interface.
 *
 * This property can be used to determine at runtime whether or not an object
 * implements this interface.  All implementations of this interface set this
 * property to {@code true}.
 * @type {boolean}
 */goog.i18n.bidi.DirectionalString.prototype.implementsGoogI18nBidiDirectionalString; /**
 * Retrieves this object's known direction (if any).
 * @return {?goog.i18n.bidi.Dir} The known direction. Null if unknown.
 */goog.i18n.bidi.DirectionalString.prototype.getDirection; /* jshint ignore:start */ // Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Utilities to check the preconditions, postconditions and
 * invariants runtime.
 *
 * Methods in this package should be given special treatment by the compiler
 * for type-inference. For example, <code>goog.asserts.assert(foo)</code>
 * will restrict <code>foo</code> to a truthy value.
 *
 * The compiler has an option to disable asserts. So code like:
 * <code>
 * var x = goog.asserts.assert(foo()); goog.asserts.assert(bar());
 * </code>
 * will be transformed into:
 * <code>
 * var x = foo();
 * </code>
 * The compiler will leave in foo() (because its return value is used),
 * but it will remove bar() because it assumes it does not have side-effects.
 *
 * @author agrieve@google.com (Andrew Grieve)
 */goog.provide('goog.asserts'); /**
 * @define {boolean} Whether to strip out asserts or to leave them in.
 */goog.define('goog.asserts.ENABLE_ASSERTS',goog.DEBUG); /**
 * Error object for failed assertions.
 * @param {string} messagePattern The pattern that was used to form message.
 * @param {!Array<*>} messageArgs The items to substitute into the pattern.
 * @constructor
 * @extends {goog.debug.Error}
 * @final
 */goog.asserts.AssertionError=function(messagePattern,messageArgs){messageArgs.unshift(messagePattern);goog.debug.Error.call(this,goog.string.subs.apply(null,messageArgs)); // Remove the messagePattern afterwards to avoid permanently modifying the
// passed in array.
messageArgs.shift(); /**
   * The message pattern used to format the error message. Error handlers can
   * use this to uniquely identify the assertion.
   * @type {string}
   */this.messagePattern=messagePattern;};goog.inherits(goog.asserts.AssertionError,goog.debug.Error); /** @override */goog.asserts.AssertionError.prototype.name='AssertionError'; /**
 * The default error handler.
 * @param {!goog.asserts.AssertionError} e The exception to be handled.
 */goog.asserts.DEFAULT_ERROR_HANDLER=function(e){throw e;}; /**
 * The handler responsible for throwing or logging assertion errors.
 * @private {function(!goog.asserts.AssertionError)}
 */goog.asserts.errorHandler_=goog.asserts.DEFAULT_ERROR_HANDLER; /**
 * Throws an exception with the given message and "Assertion failed" prefixed
 * onto it.
 * @param {string} defaultMessage The message to use if givenMessage is empty.
 * @param {Array<*>} defaultArgs The substitution arguments for defaultMessage.
 * @param {string|undefined} givenMessage Message supplied by the caller.
 * @param {Array<*>} givenArgs The substitution arguments for givenMessage.
 * @throws {goog.asserts.AssertionError} When the value is not a number.
 * @private
 */goog.asserts.doAssertFailure_=function(defaultMessage,defaultArgs,givenMessage,givenArgs){var message='Assertion failed';if(givenMessage){message+=': '+givenMessage;var args=givenArgs;}else if(defaultMessage){message+=': '+defaultMessage;args=defaultArgs;} // The '' + works around an Opera 10 bug in the unit tests. Without it,
// a stack trace is added to var message above. With this, a stack trace is
// not added until this line (it causes the extra garbage to be added after
// the assertion message instead of in the middle of it).
var e=new goog.asserts.AssertionError(''+message,args||[]);goog.asserts.errorHandler_(e);}; /**
 * Sets a custom error handler that can be used to customize the behavior of
 * assertion failures, for example by turning all assertion failures into log
 * messages.
 * @param {function(!goog.asserts.AssertionError)} errorHandler
 */goog.asserts.setErrorHandler=function(errorHandler){if(goog.asserts.ENABLE_ASSERTS){goog.asserts.errorHandler_=errorHandler;}}; /**
 * Checks if the condition evaluates to true if goog.asserts.ENABLE_ASSERTS is
 * true.
 * @template T
 * @param {T} condition The condition to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {T} The value of the condition.
 * @throws {goog.asserts.AssertionError} When the condition evaluates to false.
 */goog.asserts.assert=function(condition,opt_message,var_args){if(goog.asserts.ENABLE_ASSERTS&&!condition){goog.asserts.doAssertFailure_('',null,opt_message,Array.prototype.slice.call(arguments,2));}return condition;}; /**
 * Fails if goog.asserts.ENABLE_ASSERTS is true. This function is useful in case
 * when we want to add a check in the unreachable area like switch-case
 * statement:
 *
 * <pre>
 *  switch(type) {
 *    case FOO: doSomething(); break;
 *    case BAR: doSomethingElse(); break;
 *    default: goog.assert.fail('Unrecognized type: ' + type);
 *      // We have only 2 types - "default:" section is unreachable code.
 *  }
 * </pre>
 *
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @throws {goog.asserts.AssertionError} Failure.
 */goog.asserts.fail=function(opt_message,var_args){if(goog.asserts.ENABLE_ASSERTS){goog.asserts.errorHandler_(new goog.asserts.AssertionError('Failure'+(opt_message?': '+opt_message:''),Array.prototype.slice.call(arguments,1)));}}; /**
 * Checks if the value is a number if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {number} The value, guaranteed to be a number when asserts enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a number.
 */goog.asserts.assertNumber=function(value,opt_message,var_args){if(goog.asserts.ENABLE_ASSERTS&&!goog.isNumber(value)){goog.asserts.doAssertFailure_('Expected number but got %s: %s.',[goog.typeOf(value),value],opt_message,Array.prototype.slice.call(arguments,2));}return  (/** @type {number} */value);}; /**
 * Checks if the value is a string if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {string} The value, guaranteed to be a string when asserts enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a string.
 */goog.asserts.assertString=function(value,opt_message,var_args){if(goog.asserts.ENABLE_ASSERTS&&!goog.isString(value)){goog.asserts.doAssertFailure_('Expected string but got %s: %s.',[goog.typeOf(value),value],opt_message,Array.prototype.slice.call(arguments,2));}return  (/** @type {string} */value);}; /**
 * Checks if the value is a function if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Function} The value, guaranteed to be a function when asserts
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a function.
 */goog.asserts.assertFunction=function(value,opt_message,var_args){if(goog.asserts.ENABLE_ASSERTS&&!goog.isFunction(value)){goog.asserts.doAssertFailure_('Expected function but got %s: %s.',[goog.typeOf(value),value],opt_message,Array.prototype.slice.call(arguments,2));}return  (/** @type {!Function} */value);}; /**
 * Checks if the value is an Object if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Object} The value, guaranteed to be a non-null object.
 * @throws {goog.asserts.AssertionError} When the value is not an object.
 */goog.asserts.assertObject=function(value,opt_message,var_args){if(goog.asserts.ENABLE_ASSERTS&&!goog.isObject(value)){goog.asserts.doAssertFailure_('Expected object but got %s: %s.',[goog.typeOf(value),value],opt_message,Array.prototype.slice.call(arguments,2));}return  (/** @type {!Object} */value);}; /**
 * Checks if the value is an Array if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Array<?>} The value, guaranteed to be a non-null array.
 * @throws {goog.asserts.AssertionError} When the value is not an array.
 */goog.asserts.assertArray=function(value,opt_message,var_args){if(goog.asserts.ENABLE_ASSERTS&&!goog.isArray(value)){goog.asserts.doAssertFailure_('Expected array but got %s: %s.',[goog.typeOf(value),value],opt_message,Array.prototype.slice.call(arguments,2));}return  (/** @type {!Array<?>} */value);}; /**
 * Checks if the value is a boolean if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {boolean} The value, guaranteed to be a boolean when asserts are
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a boolean.
 */goog.asserts.assertBoolean=function(value,opt_message,var_args){if(goog.asserts.ENABLE_ASSERTS&&!goog.isBoolean(value)){goog.asserts.doAssertFailure_('Expected boolean but got %s: %s.',[goog.typeOf(value),value],opt_message,Array.prototype.slice.call(arguments,2));}return  (/** @type {boolean} */value);}; /**
 * Checks if the value is a DOM Element if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Element} The value, likely to be a DOM Element when asserts are
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not an Element.
 */goog.asserts.assertElement=function(value,opt_message,var_args){if(goog.asserts.ENABLE_ASSERTS&&(!goog.isObject(value)||value.nodeType!=goog.dom.NodeType.ELEMENT)){goog.asserts.doAssertFailure_('Expected Element but got %s: %s.',[goog.typeOf(value),value],opt_message,Array.prototype.slice.call(arguments,2));}return  (/** @type {!Element} */value);}; /**
 * Checks if the value is an instance of the user-defined type if
 * goog.asserts.ENABLE_ASSERTS is true.
 *
 * The compiler may tighten the type returned by this function.
 *
 * @param {?} value The value to check.
 * @param {function(new: T, ...)} type A user-defined constructor.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @throws {goog.asserts.AssertionError} When the value is not an instance of
 *     type.
 * @return {T}
 * @template T
 */goog.asserts.assertInstanceof=function(value,type,opt_message,var_args){if(goog.asserts.ENABLE_ASSERTS&&!(value instanceof type)){goog.asserts.doAssertFailure_('Expected instanceof %s but got %s.',[goog.asserts.getType_(type),goog.asserts.getType_(value)],opt_message,Array.prototype.slice.call(arguments,3));}return value;}; /**
 * Checks that no enumerable keys are present in Object.prototype. Such keys
 * would break most code that use {@code for (var ... in ...)} loops.
 */goog.asserts.assertObjectPrototypeIsIntact=function(){for(var key in Object.prototype){goog.asserts.fail(key+' should not be enumerable in Object.prototype.');}}; /**
 * Returns the type of a value. If a constructor is passed, and a suitable
 * string cannot be found, 'unknown type name' will be returned.
 * @param {*} value A constructor, object, or primitive.
 * @return {string} The best display name for the value, or 'unknown type name'.
 * @private
 */goog.asserts.getType_=function(value){if(value instanceof Function){return value.displayName||value.name||'unknown type name';}else if(value instanceof Object){return value.constructor.displayName||value.constructor.name||Object.prototype.toString.call(value);}else {return value===null?'null':typeof value==='undefined'?'undefined':_typeof(value);}}; /**
 * @fileoverview Utility for fast string concatenation.
 */ /**
 * Utility class to facilitate string concatenation.
 *
 * @param {*=} opt_a1 Optional first initial item to append.
 * @param {...*} var_args Other initial items to
 *     append, e.g., new goog.string.StringBuffer('foo', 'bar').
 * @constructor
 */goog.string.StringBuffer=function(opt_a1,var_args){if(opt_a1!=null){this.append.apply(this,arguments);}}; /**
 * Internal buffer for the string to be concatenated.
 * @type {string}
 * @private
 */goog.string.StringBuffer.prototype.buffer_=''; /**
 * Sets the contents of the string buffer object, replacing what's currently
 * there.
 *
 * @param {*} s String to set.
 */goog.string.StringBuffer.prototype.set=function(s){this.buffer_=''+s;}; /**
 * Appends one or more items to the buffer.
 *
 * Calling this with null, undefined, or empty arguments is an error.
 *
 * @param {*} a1 Required first string.
 * @param {*=} opt_a2 Optional second string.
 * @param {...?} var_args Other items to append,
 *     e.g., sb.append('foo', 'bar', 'baz').
 * @return {!goog.string.StringBuffer} This same StringBuffer object.
 * @suppress {duplicate}
 */goog.string.StringBuffer.prototype.append=function(a1,opt_a2,var_args){ // Use a1 directly to avoid arguments instantiation for single-arg case.
this.buffer_+=String(a1);if(opt_a2!=null){ // second argument is undefined (null == undefined)
for(var i=1;i<arguments.length;i++){this.buffer_+=arguments[i];}}return this;}; /**
 * Clears the internal buffer.
 */goog.string.StringBuffer.prototype.clear=function(){this.buffer_='';}; /**
 * @return {number} the length of the current contents of the buffer.
 */goog.string.StringBuffer.prototype.getLength=function(){return this.buffer_.length;}; /**
 * @return {string} The concatenated string.
 * @override
 */goog.string.StringBuffer.prototype.toString=function(){return this.buffer_;}; // Copyright 2012 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Soy data primitives.
 *
 * The goal is to encompass data types used by Soy, especially to mark content
 * as known to be "safe".
 *
 * @author gboyer@google.com (Garrett Boyer)
 */goog.soy={};goog.soy.data={}; /**
 * A type of textual content.
 *
 * This is an enum of type Object so that these values are unforgeable.
 *
 * @enum {!Object}
 */goog.soy.data.SanitizedContentKind={ /**
   * A snippet of HTML that does not start or end inside a tag, comment, entity,
   * or DOCTYPE; and that does not contain any executable code
   * (JS, {@code <object>}s, etc.) from a different trust domain.
   */HTML:goog.DEBUG?{sanitizedContentKindHtml:true}:{}, /**
   * Executable Javascript code or expression, safe for insertion in a
   * script-tag or event handler context, known to be free of any
   * attacker-controlled scripts. This can either be side-effect-free
   * Javascript (such as JSON) or Javascript that's entirely under Google's
   * control.
   */JS:goog.DEBUG?{sanitizedContentJsChars:true}:{}, /** A properly encoded portion of a URI. */URI:goog.DEBUG?{sanitizedContentUri:true}:{}, /** A resource URI not under attacker control. */TRUSTED_RESOURCE_URI:goog.DEBUG?{sanitizedContentTrustedResourceUri:true}:{}, /**
   * Repeated attribute names and values. For example,
   * {@code dir="ltr" foo="bar" onclick="trustedFunction()" checked}.
   */ATTRIBUTES:goog.DEBUG?{sanitizedContentHtmlAttribute:true}:{}, // TODO: Consider separating rules, declarations, and values into
// separate types, but for simplicity, we'll treat explicitly blessed
// SanitizedContent as allowed in all of these contexts.
/**
   * A CSS3 declaration, property, value or group of semicolon separated
   * declarations.
   */CSS:goog.DEBUG?{sanitizedContentCss:true}:{}, /**
   * Unsanitized plain-text content.
   *
   * This is effectively the "null" entry of this enum, and is sometimes used
   * to explicitly mark content that should never be used unescaped. Since any
   * string is safe to use as text, being of ContentKind.TEXT makes no
   * guarantees about its safety in any other context such as HTML.
   */TEXT:goog.DEBUG?{sanitizedContentKindText:true}:{}}; /**
 * A string-like object that carries a content-type and a content direction.
 *
 * IMPORTANT! Do not create these directly, nor instantiate the subclasses.
 * Instead, use a trusted, centrally reviewed library as endorsed by your team
 * to generate these objects. Otherwise, you risk accidentally creating
 * SanitizedContent that is attacker-controlled and gets evaluated unescaped in
 * templates.
 *
 * @constructor
 */goog.soy.data.SanitizedContent=function(){throw Error('Do not instantiate directly');}; /**
 * The context in which this content is safe from XSS attacks.
 * @type {goog.soy.data.SanitizedContentKind}
 */goog.soy.data.SanitizedContent.prototype.contentKind; /**
 * The content's direction; null if unknown and thus to be estimated when
 * necessary.
 * @type {?goog.i18n.bidi.Dir}
 */goog.soy.data.SanitizedContent.prototype.contentDir=null; /**
 * The already-safe content.
 * @protected {string}
 */goog.soy.data.SanitizedContent.prototype.content; /**
 * Gets the already-safe content.
 * @return {string}
 */goog.soy.data.SanitizedContent.prototype.getContent=function(){return this.content;}; /** @override */goog.soy.data.SanitizedContent.prototype.toString=function(){return this.content;}; /**
 * An intermediary base class to allow the type system to sepcify text templates
 * without referencing the soydata package.
 * @extends {goog.soy.data.SanitizedContent}
 * @constructor
 */goog.soy.data.UnsanitizedText=function(){ // TODO(gboyer): Delete this class after moving soydata to Closure.
goog.soy.data.UnsanitizedText.base(this,'constructor');};goog.inherits(goog.soy.data.UnsanitizedText,goog.soy.data.SanitizedContent); /*
 * Copyright 2008 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @fileoverview
 * Utility functions and classes for Soy.
 *
 * <p>
 * The top portion of this file contains utilities for Soy users:<ul>
 *   <li> soy.StringBuilder: Compatible with the 'stringbuilder' code style.
 * </ul>
 *
 * <p>
 * The bottom portion of this file contains utilities that should only be called
 * by Soy-generated JS code. Please do not use these functions directly from
 * your hand-writen code. Their names all start with '$$'.
 *
 */ // -----------------------------------------------------------------------------
// StringBuilder (compatible with the 'stringbuilder' code style).
(function(){var soy={};soy.asserts={};soy.esc={};var soydata={}; /**
   * Utility class to facilitate much faster string concatenation in IE,
   * using Array.join() rather than the '+' operator. For other browsers
   * we simply use the '+' operator.
   *
   * @param {Object} var_args Initial items to append,
   *     e.g., new soy.StringBuilder('foo', 'bar').
   * @constructor
   */soy.StringBuilder=goog.string.StringBuffer; // -----------------------------------------------------------------------------
// soydata: Defines typed strings, e.g. an HTML string {@code "a<b>c"} is
// semantically distinct from the plain text string {@code "a<b>c"} and smart
// templates can take that distinction into account.
/**
   * A type of textual content.
   *
   * This is an enum of type Object so that these values are unforgeable.
   *
   * @enum {!Object}
   */soydata.SanitizedContentKind=goog.soy.data.SanitizedContentKind; /**
   * Checks whether a given value is of a given content kind.
   *
   * @param {*} value The value to be examined.
   * @param {soydata.SanitizedContentKind} contentKind The desired content
   *     kind.
   * @return {boolean} Whether the given value is of the given kind.
   * @private
   */soydata.isContentKind=function(value,contentKind){ // TODO(user): This function should really include the assert on
// value.constructor that is currently sprinkled at most of the call sites.
// Unfortunately, that would require a (debug-mode-only) switch statement.
// TODO(user): Perhaps we should get rid of the contentKind property
// altogether and only at the constructor.
return value!=null&&value.contentKind===contentKind;}; /**
   * Content of type {@link soydata.SanitizedContentKind.URI}.
   *
   * The content is a URI chunk that the caller knows is safe to emit in a
   * template. The content direction is LTR.
   *
   * @constructor
   * @extends {goog.soy.data.SanitizedContent}
   */soydata.SanitizedUri=function(){goog.soy.data.SanitizedContent.call(this); // Throws an exception.
};goog.inherits(soydata.SanitizedUri,goog.soy.data.SanitizedContent); /** @override */soydata.SanitizedUri.prototype.contentKind=soydata.SanitizedContentKind.URI; /** @override */soydata.SanitizedUri.prototype.contentDir=goog.i18n.bidi.Dir.LTR; /**
   * Unsanitized plain text string.
   *
   * While all strings are effectively safe to use as a plain text, there are no
   * guarantees about safety in any other context such as HTML. This is
   * sometimes used to mark that should never be used unescaped.
   *
   * @param {*} content Plain text with no guarantees.
   * @param {?goog.i18n.bidi.Dir=} opt_contentDir The content direction; null if
   *     unknown and thus to be estimated when necessary. Default: null.
   * @constructor
   * @extends {goog.soy.data.UnsanitizedText}
   */soydata.UnsanitizedText=function(content,opt_contentDir){ /** @override */this.content=String(content);this.contentDir=opt_contentDir!=null?opt_contentDir:null;};goog.inherits(soydata.UnsanitizedText,goog.soy.data.UnsanitizedText); /** @override */soydata.UnsanitizedText.prototype.contentKind=soydata.SanitizedContentKind.TEXT; /**
   * Empty string, used as a type in Soy templates.
   * @enum {string}
   * @private
   */soydata.$$EMPTY_STRING_={VALUE:''}; /**
   * Creates a factory for SanitizedContent types.
   *
   * This is a hack so that the soydata.VERY_UNSAFE.ordainSanitized* can
   * instantiate Sanitized* classes, without making the Sanitized* constructors
   * publicly usable. Requiring all construction to use the VERY_UNSAFE names
   * helps callers and their reviewers easily tell that creating SanitizedContent
   * is not always safe and calls for careful review.
   *
   * @param {function(new: T)} ctor A constructor.
   * @return {!function(*, ?goog.i18n.bidi.Dir=): T} A factory that takes
   *     content and an optional content direction and returns a new instance. If
   *     the content direction is undefined, ctor.prototype.contentDir is used.
   * @template T
   * @private
   */soydata.$$makeSanitizedContentFactory_=function(ctor){ /**
     * @param {string} content
     * @constructor
     * @extends {goog.soy.data.SanitizedContent}
     */function InstantiableCtor(content){ /** @override */this.content=content;}InstantiableCtor.prototype=ctor.prototype; /**
     * Creates a ctor-type SanitizedContent instance.
     *
     * @param {*} content The content to put in the instance.
     * @param {?goog.i18n.bidi.Dir=} opt_contentDir The content direction. If
     *     undefined, ctor.prototype.contentDir is used.
     * @return {!goog.soy.data.SanitizedContent} The new instance. It is actually
     *     of type T above (ctor's type, a descendant of SanitizedContent), but
     *     there is no way to express that here.
     */function sanitizedContentFactory(content,opt_contentDir){var result=new InstantiableCtor(String(content));if(opt_contentDir!==undefined){result.contentDir=opt_contentDir;}return result;}return sanitizedContentFactory;}; /**
   * Creates a factory for SanitizedContent types that should always have their
   * default directionality.
   *
   * This is a hack so that the soydata.VERY_UNSAFE.ordainSanitized* can
   * instantiate Sanitized* classes, without making the Sanitized* constructors
   * publicly usable. Requiring all construction to use the VERY_UNSAFE names
   * helps callers and their reviewers easily tell that creating SanitizedContent
   * is not always safe and calls for careful review.
   *
   * @param {function(new: T, string)} ctor A constructor.
   * @return {!function(*): T} A factory that takes content and returns a new
   *     instance (with default directionality, i.e. ctor.prototype.contentDir).
   * @template T
   * @private
   */soydata.$$makeSanitizedContentFactoryWithDefaultDirOnly_=function(ctor){ /**
     * @param {string} content
     * @constructor
     * @extends {goog.soy.data.SanitizedContent}
     */function InstantiableCtor(content){ /** @override */this.content=content;}InstantiableCtor.prototype=ctor.prototype; /**
     * Creates a ctor-type SanitizedContent instance.
     *
     * @param {*} content The content to put in the instance.
     * @return {!goog.soy.data.SanitizedContent} The new instance. It is actually
     *     of type T above (ctor's type, a descendant of SanitizedContent), but
     *     there is no way to express that here.
     */function sanitizedContentFactory(content){var result=new InstantiableCtor(String(content));return result;}return sanitizedContentFactory;}; // -----------------------------------------------------------------------------
// Sanitized content ordainers. Please use these with extreme caution (with the
// exception of markUnsanitizedText). A good recommendation is to limit usage
// of these to just a handful of files in your source tree where usages can be
// carefully audited.
/**
   * Protects a string from being used in an noAutoescaped context.
   *
   * This is useful for content where there is significant risk of accidental
   * unescaped usage in a Soy template. A great case is for user-controlled
   * data that has historically been a source of vulernabilities.
   *
   * @param {*} content Text to protect.
   * @param {?goog.i18n.bidi.Dir=} opt_contentDir The content direction; null if
   *     unknown and thus to be estimated when necessary. Default: null.
   * @return {!soydata.UnsanitizedText} A wrapper that is rejected by the
   *     Soy noAutoescape print directive.
   */soydata.markUnsanitizedText=function(content,opt_contentDir){return new soydata.UnsanitizedText(content,opt_contentDir);};soydata.VERY_UNSAFE={}; /**
  * Takes a leap of faith that the provided content is "safe" to use as a URI
  * in a Soy template.
  *
  * This creates a Soy SanitizedContent object which indicates to Soy there is
  * no need to escape it when printed as a URI (e.g. in an href or src
  * attribute), such as if it's already been encoded or  if it's a Javascript:
  * URI.
  *
  * @param {*} content A chunk of URI that the caller knows is safe to
  *     emit in a template.
  * @return {!soydata.SanitizedUri} Sanitized content wrapper that indicates to
  *     Soy not to escape or filter when printed in URI context.
  */soydata.VERY_UNSAFE.ordainSanitizedUri=soydata.$$makeSanitizedContentFactoryWithDefaultDirOnly_(soydata.SanitizedUri); // -----------------------------------------------------------------------------
// Below are private utilities to be used by Soy-generated code only.
/**
   * Builds an augmented map. The returned map will contain mappings from both
   * the base map and the additional map. If the same key appears in both, then
   * the value from the additional map will be visible, while the value from the
   * base map will be hidden. The base map will be used, but not modified.
   *
   * @param {!Object} baseMap The original map to augment.
   * @param {!Object} additionalMap A map containing the additional mappings.
   * @return {!Object} An augmented map containing both the original and
   *     additional mappings.
   */soy.$$augmentMap=function(baseMap,additionalMap){ // Create a new map whose '__proto__' field is set to baseMap.
/** @constructor */function TempCtor(){}TempCtor.prototype=baseMap;var augmentedMap=new TempCtor(); // Add the additional mappings to the new map.
for(var key in additionalMap){augmentedMap[key]=additionalMap[key];}return augmentedMap;}; /**
   * Checks that the given map key is a string.
   * @param {*} key Key to check.
   * @return {string} The given key.
   */soy.$$checkMapKey=function(key){ // TODO: Support map literal with nonstring key.
if(typeof key!='string'){throw Error('Map literal\'s key expression must evaluate to string'+' (encountered type "'+(typeof key==='undefined'?'undefined':_typeof(key))+'").');}return key;}; /**
   * Gets the keys in a map as an array. There are no guarantees on the order.
   * @param {Object} map The map to get the keys of.
   * @return {!Array<string>} The array of keys in the given map.
   */soy.$$getMapKeys=function(map){var mapKeys=[];for(var key in map){mapKeys.push(key);}return mapKeys;}; /**
   * Returns the argument if it is not null.
   *
   * @param {T} val The value to check
   * @return {T} val if is isn't null
   * @template T
   */soy.$$checkNotNull=function(val){if(val==null){throw Error('unexpected null value');}return val;}; /**
   * Gets a consistent unique id for the given delegate template name. Two calls
   * to this function will return the same id if and only if the input names are
   * the same.
   *
   * <p> Important: This function must always be called with a string constant.
   *
   * <p> If Closure Compiler is not being used, then this is just this identity
   * function. If Closure Compiler is being used, then each call to this function
   * will be replaced with a short string constant, which will be consistent per
   * input name.
   *
   * @param {string} delTemplateName The delegate template name for which to get a
   *     consistent unique id.
   * @return {string} A unique id that is consistent per input name.
   *
   * @consistentIdGenerator
   */soy.$$getDelTemplateId=function(delTemplateName){return delTemplateName;}; /**
   * Map from registered delegate template key to the priority of the
   * implementation.
   * @type {Object}
   * @private
   */soy.$$DELEGATE_REGISTRY_PRIORITIES_={}; /**
   * Map from registered delegate template key to the implementation function.
   * @type {Object}
   * @private
   */soy.$$DELEGATE_REGISTRY_FUNCTIONS_={}; /**
   * Registers a delegate implementation. If the same delegate template key (id
   * and variant) has been registered previously, then priority values are
   * compared and only the higher priority implementation is stored (if
   * priorities are equal, an error is thrown).
   *
   * @param {string} delTemplateId The delegate template id.
   * @param {string} delTemplateVariant The delegate template variant (can be
   *     empty string).
   * @param {number} delPriority The implementation's priority value.
   * @param {Function} delFn The implementation function.
   */soy.$$registerDelegateFn=function(delTemplateId,delTemplateVariant,delPriority,delFn){var mapKey='key_'+delTemplateId+':'+delTemplateVariant;var currPriority=soy.$$DELEGATE_REGISTRY_PRIORITIES_[mapKey];if(currPriority===undefined||delPriority>currPriority){ // Registering new or higher-priority function: replace registry entry.
soy.$$DELEGATE_REGISTRY_PRIORITIES_[mapKey]=delPriority;soy.$$DELEGATE_REGISTRY_FUNCTIONS_[mapKey]=delFn;}else if(delPriority==currPriority){ // Registering same-priority function: error.
throw Error('Encountered two active delegates with the same priority ("'+delTemplateId+':'+delTemplateVariant+'").');}else { // Registering lower-priority function: do nothing.
}}; /**
   * Retrieves the (highest-priority) implementation that has been registered for
   * a given delegate template key (id and variant). If no implementation has
   * been registered for the key, then the fallback is the same id with empty
   * variant. If the fallback is also not registered, and allowsEmptyDefault is
   * true, then returns an implementation that is equivalent to an empty template
   * (i.e. rendered output would be empty string).
   *
   * @param {string} delTemplateId The delegate template id.
   * @param {string} delTemplateVariant The delegate template variant (can be
   *     empty string).
   * @param {boolean} allowsEmptyDefault Whether to default to the empty template
   *     function if there's no active implementation.
   * @return {Function} The retrieved implementation function.
   */soy.$$getDelegateFn=function(delTemplateId,delTemplateVariant,allowsEmptyDefault){var delFn=soy.$$DELEGATE_REGISTRY_FUNCTIONS_['key_'+delTemplateId+':'+delTemplateVariant];if(!delFn&&delTemplateVariant!=''){ // Fallback to empty variant.
delFn=soy.$$DELEGATE_REGISTRY_FUNCTIONS_['key_'+delTemplateId+':'];}if(delFn){return delFn;}else if(allowsEmptyDefault){return soy.$$EMPTY_TEMPLATE_FN_;}else {throw Error('Found no active impl for delegate call to "'+delTemplateId+':'+delTemplateVariant+'" (and not allowemptydefault="true").');}}; /**
   * Private helper soy.$$getDelegateFn(). This is the empty template function
   * that is returned whenever there's no delegate implementation found.
   *
   * @param {Object<string, *>=} opt_data
   * @param {soy.StringBuilder=} opt_sb
   * @param {Object<string, *>=} opt_ijData
   * @return {string}
   * @private
   */soy.$$EMPTY_TEMPLATE_FN_=function(opt_data,opt_sb,opt_ijData){return '';}; // -----------------------------------------------------------------------------
// Basic directives/functions.
/**
   * Truncates a string to a given max length (if it's currently longer),
   * optionally adding ellipsis at the end.
   *
   * @param {*} str The string to truncate. Can be other types, but the value will
   *     be coerced to a string.
   * @param {number} maxLen The maximum length of the string after truncation
   *     (including ellipsis, if applicable).
   * @param {boolean} doAddEllipsis Whether to add ellipsis if the string needs
   *     truncation.
   * @return {string} The string after truncation.
   */soy.$$truncate=function(str,maxLen,doAddEllipsis){str=String(str);if(str.length<=maxLen){return str; // no need to truncate
} // If doAddEllipsis, either reduce maxLen to compensate, or else if maxLen is
// too small, just turn off doAddEllipsis.
if(doAddEllipsis){if(maxLen>3){maxLen-=3;}else {doAddEllipsis=false;}} // Make sure truncating at maxLen doesn't cut up a unicode surrogate pair.
if(soy.$$isHighSurrogate_(str.charAt(maxLen-1))&&soy.$$isLowSurrogate_(str.charAt(maxLen))){maxLen-=1;} // Truncate.
str=str.substring(0,maxLen); // Add ellipsis.
if(doAddEllipsis){str+='...';}return str;}; /**
   * Private helper for $$truncate() to check whether a char is a high surrogate.
   * @param {string} ch The char to check.
   * @return {boolean} Whether the given char is a unicode high surrogate.
   * @private
   */soy.$$isHighSurrogate_=function(ch){return 0xD800<=ch&&ch<=0xDBFF;}; /**
   * Private helper for $$truncate() to check whether a char is a low surrogate.
   * @param {string} ch The char to check.
   * @return {boolean} Whether the given char is a unicode low surrogate.
   * @private
   */soy.$$isLowSurrogate_=function(ch){return 0xDC00<=ch&&ch<=0xDFFF;}; // -----------------------------------------------------------------------------
// Assertion methods used by runtime.
/**
   * Checks if the type assertion is true if goog.asserts.ENABLE_ASSERTS is
   * true. Report errors on runtime types if goog.DEBUG is true.
   * @template T
   * @param {T} typeCheck An condition for type checks.
   * @param {string} paramName The Soy name of the parameter.
   * @param {?Object} param The resolved JS object for the parameter.
   * @param {!string} jsDocTypeStr JSDoc type str to cast the value to if the
   *     type test succeeds
   * @param {...*} var_args The items to substitute into the failure message.
   * @return {T} The value of the condition.
   * @throws {goog.asserts.AssertionError} When the condition evaluates to false.
   */soy.asserts.assertType=function(typeCheck,paramName,param,jsDocTypeStr,var_args){var msg='expected param '+paramName+' of type '+jsDocTypeStr+(goog.DEBUG?', but got '+goog.debug.runtimeType(param):'')+'.';return goog.asserts.assert(typeCheck,msg,var_args);}; // -----------------------------------------------------------------------------
// Generated code.
// START GENERATED CODE FOR ESCAPERS.
/**
   * @type {function (*) : string}
   */soy.esc.$$escapeHtmlHelper=function(v){return goog.string.htmlEscape(String(v));}; /**
   * Allows only data-protocol image URI's.
   *
   * @param {*} value The value to process. May not be a string, but the value
   *     will be coerced to a string.
   * @return {!soydata.SanitizedUri} An escaped version of value.
   */soy.$$filterImageDataUri=function(value){ // NOTE: Even if it's a SanitizedUri, we will still filter it.
return soydata.VERY_UNSAFE.ordainSanitizedUri(soy.esc.$$filterImageDataUriHelper(value));}; /**
   * A pattern that vets values produced by the named directives.
   * @private {!RegExp}
   */soy.esc.$$FILTER_FOR_FILTER_IMAGE_DATA_URI_=/^data:image\/(?:bmp|gif|jpe?g|png|tiff|webp);base64,[a-z0-9+\/]+=*$/i; /**
   * A helper for the Soy directive |filterImageDataUri
   * @param {*} value Can be of any type but will be coerced to a string.
   * @return {string} The escaped text.
   */soy.esc.$$filterImageDataUriHelper=function(value){var str=String(value);if(!soy.esc.$$FILTER_FOR_FILTER_IMAGE_DATA_URI_.test(str)){goog.asserts.fail('Bad value `%s` for |filterImageDataUri',[str]);return 'data:image/gif;base64,zSoyz';}return str;}; // END GENERATED CODE
goog.loadModule(function(){goog.module('soy');return soy;});goog.loadModule(function(){goog.module('soydata');return soydata;});goog.loadModule(function(){goog.module('soy.asserts');return soy;});})(); /* jshint ignore:end */goog.loadModule(function(){goog.module('incrementaldom');return IncrementalDOM;});}).call(window);

},{"../../metal-incremental-dom/src/IncrementalDomRenderer":25}],35:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.SoyAop = exports.Soy = undefined;

require('../../metal-soy-bundle/build/bundle');

var _metal = require('../../metal/src/metal');

var _component = require('../../metal-component/src/all/component');

var _withParser = require('../../html2incdom/src/withParser');

var _withParser2 = _interopRequireDefault(_withParser);

var _IncrementalDomRenderer = require('../../metal-incremental-dom/src/IncrementalDomRenderer');

var _IncrementalDomRenderer2 = _interopRequireDefault(_IncrementalDomRenderer);

var _SoyAop = require('./SoyAop');

var _SoyAop2 = _interopRequireDefault(_SoyAop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// The injected data that will be passed to soy templates.
var ijData = {};

var Soy = function (_IncrementalDomRender) {
	_inherits(Soy, _IncrementalDomRender);

	/**
  * @inheritDoc
  */

	function Soy(comp) {
		_classCallCheck(this, Soy);

		var _this = _possibleConstructorReturn(this, _IncrementalDomRender.call(this, comp));

		_this.addMissingStateKeys_();
		return _this;
	}
	/**
  * Adds the template params to the component's state, if they don't exist yet.
  * @protected
  */


	Soy.prototype.addMissingStateKeys_ = function addMissingStateKeys_() {
		var elementTemplate = this.component_.constructor.TEMPLATE;
		if (!_metal.core.isFunction(elementTemplate)) {
			return;
		}

		elementTemplate = _SoyAop2.default.getOriginalFn(elementTemplate);
		this.soyParamTypes_ = elementTemplate.types || {};

		var keys = elementTemplate.params || [];
		var component = this.component_;
		for (var i = 0; i < keys.length; i++) {
			if (!component.getStateKeyConfig(keys[i]) && !component[keys[i]]) {
				component.addToState(keys[i], {}, component.getInitialConfig()[keys[i]]);
			}
		}
	};

	/**
  * Copies the component's state to an object so it can be passed as it's
  * template call's data. The copying needs to be done because, if the component
  * itself is passed directly, some problems occur when soy tries to merge it
  * with other data, due to property getters and setters. This is safer.
  * @param {!Array<string>} params The params used by this template.
  * @return {!Object}
  * @protected
  */


	Soy.prototype.buildTemplateData_ = function buildTemplateData_(params) {
		var _this2 = this;

		var component = this.component_;
		var data = _metal.object.mixin({}, component.config);
		component.getStateKeys().forEach(function (key) {
			// Get all state values except "element", since it helps performance
			// and the element shouldn't be referenced inside a soy template anyway.
			if (key === 'element') {
				return;
			}

			var value = component[key];
			if (_this2.isHtmlParam_(key)) {
				value = Soy.toIncDom(value);
			}
			data[key] = value;
		});
		for (var i = 0; i < params.length; i++) {
			if (!data[params[i]] && _metal.core.isFunction(component[params[i]])) {
				data[params[i]] = component[params[i]].bind(component);
			}
		}
		return data;
	};

	/**
  * Returns the requested template function. This function will be wrapped in
  * another though, just to defer the requirement of the template's module
  * being ready until the function is actually called.
  * @param {string} namespace The soy template's namespace.
  * @param {string} templateName The name of the template function.
  * @return {!function()}
  */


	Soy.getTemplate = function getTemplate(namespace, templateName) {
		return function (opt_data, opt_ignored, opt_ijData) {
			if (!goog.loadedModules_[namespace]) {
				throw new Error('No template with namespace "' + namespace + '" has been loaded yet.');
			}
			return goog.loadedModules_[namespace][templateName](opt_data, opt_ignored, opt_ijData);
		};
	};

	/**
  * Handles an intercepted soy template call. If the call is for a component's
  * main template, then it will be replaced with a call that incremental dom
  * can use for both handling an instance of that component and rendering it.
  * @param {!function()} originalFn The original template function that was
  *     intercepted.
  * @param {Object} data The data the template was called with.
  * @protected
  */


	Soy.handleInterceptedCall_ = function handleInterceptedCall_(originalFn, opt_data) {
		var args = [originalFn.componentCtor, null, []];
		var names = Object.keys(opt_data || {});
		for (var i = 0; i < names.length; i++) {
			args.push(names[i], opt_data[names[i]]);
		}
		IncrementalDOM.elementVoid.apply(null, args);
	};

	/**
  * Checks if the given param type is html.
  * @param {string} name
  * @protected
  */


	Soy.prototype.isHtmlParam_ = function isHtmlParam_(name) {
		if (this.component_.getStateKeyConfig(name).isHtml) {
			return true;
		}
		var type = this.soyParamTypes_[name] || '';
		return type.split('|').indexOf('html') !== -1;
	};

	/**
  * Registers the given templates to be used by `Soy` for the specified
  * component constructor.
  * @param {!Function} componentCtor The constructor of the component that
  *     should use the given templates.
  * @param {!Object} templates Object containing soy template functions.
  * @param {string=} mainTemplate The name of the main template that should be
  *     used to render the component. Defaults to "render".
  */


	Soy.register = function register(componentCtor, templates) {
		var mainTemplate = arguments.length <= 2 || arguments[2] === undefined ? 'render' : arguments[2];

		componentCtor.RENDERER = Soy;
		componentCtor.TEMPLATE = _SoyAop2.default.getOriginalFn(templates[mainTemplate]);
		componentCtor.TEMPLATE.componentCtor = componentCtor;
		_SoyAop2.default.registerForInterception(templates, mainTemplate);
		_component.ComponentRegistry.register(componentCtor);
	};

	/**
  * Overrides the default method from `IncrementalDomRenderer` so the component's
  * soy template can be used for rendering.
  * @param {!Object} data Data passed to the component when rendering it.
  * @override
  */


	Soy.prototype.renderIncDom = function renderIncDom() {
		var elementTemplate = this.component_.constructor.TEMPLATE;
		if (_metal.core.isFunction(elementTemplate)) {
			elementTemplate = _SoyAop2.default.getOriginalFn(elementTemplate);
			_SoyAop2.default.startInterception(Soy.handleInterceptedCall_);
			elementTemplate(this.buildTemplateData_(elementTemplate.params || []), null, ijData);
			_SoyAop2.default.stopInterception();
		} else {
			_IncrementalDomRender.prototype.renderIncDom.call(this);
		}
	};

	/**
  * Sets the injected data object that should be passed to templates.
  * @param {Object} data
  */


	Soy.setInjectedData = function setInjectedData(data) {
		ijData = data || {};
	};

	/**
  * Overrides the original `IncrementalDomRenderer` method so that only
  * state keys used by the main template can cause updates.
  * @param {!Object} changes
  * @return {boolean}
  */


	Soy.prototype.shouldUpdate = function shouldUpdate(changes) {
		var fn = this.component_.constructor.TEMPLATE;
		var params = fn ? _SoyAop2.default.getOriginalFn(fn).params : [];
		for (var i = 0; i < params.length; i++) {
			if (changes[params[i]]) {
				return true;
			}
		}
		return false;
	};

	/**
  * Converts the given incremental dom function into an html string.
  * @param {!function()} incDomFn
  * @return {string}
  */


	Soy.toHtmlString = function toHtmlString(incDomFn) {
		var element = document.createElement('div');
		IncrementalDOM.patch(element, incDomFn);
		return element.innerHTML;
	};

	/**
  * Converts the given html string into an incremental dom function.
  * @param {string|{contentKind: string, content: string}} value
  * @return {!function()}
  */


	Soy.toIncDom = function toIncDom(value) {
		if (_metal.core.isObject(value) && _metal.core.isString(value.content) && value.contentKind === 'HTML') {
			value = value.content;
		}
		if (_metal.core.isString(value)) {
			value = _withParser2.default.buildFn(value);
		}
		return value;
	};

	return Soy;
}(_IncrementalDomRenderer2.default);

exports.default = Soy;
exports.Soy = Soy;
exports.SoyAop = _SoyAop2.default;

},{"../../html2incdom/src/withParser":4,"../../metal-component/src/all/component":10,"../../metal-incremental-dom/src/IncrementalDomRenderer":25,"../../metal-soy-bundle/build/bundle":34,"../../metal/src/metal":46,"./SoyAop":36}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
var SoyAop = {
	/**
  * The functions that should be called instead of a template call. The last
  * function in the array is the one that is intercepting at the moment. If the
  * array is empty, the original function will be called instead.
  * @type {!Array<function()>}
  * @protected
  */
	interceptFns_: [],

	/**
  * Gets the original function of the given template function. If no original exists,
  * returns the given function itself.
  * @param {!function()} fn
  * @return {!function()}
  */
	getOriginalFn: function getOriginalFn(fn) {
		return fn.originalFn ? fn.originalFn : fn;
	},

	/**
  * Handles a template call, calling the current interception function if one
  * is set, or otherwise just calling the original function instead.
  * @param {!function()} originalFn The original template function that was
  *     intercepted.
  * @param {Object} opt_data Template data object.
  * @param {*} opt_ignored
  * @param {Object} opt_ijData Template injected data object.
  * @return {*} The return value of the function that is called to handle this
  *     interception.
  */
	handleTemplateCall_: function handleTemplateCall_(originalFn, opt_data, opt_ignored, opt_ijData) {
		var interceptFn = SoyAop.interceptFns_[SoyAop.interceptFns_.length - 1];
		if (interceptFn) {
			return interceptFn.call(null, originalFn, opt_data, opt_ignored, opt_ijData);
		} else {
			return originalFn.call(null, opt_data, opt_ignored, opt_ijData);
		}
	},

	/**
  * Registers a template function that should be intercepted.
  * @param {!Object} templates The original templates object containing the
  *     function to be intercepted.
  * @param {string} name The name of the template function to intercept.
  */
	registerForInterception: function registerForInterception(templates, name) {
		var originalFn = templates[name];
		if (!originalFn.originalFn) {
			templates[name] = SoyAop.handleTemplateCall_.bind(null, originalFn);
			templates[name].originalFn = originalFn;
		}
	},

	/**
  * Starts intercepting all template calls, replacing them with a call to the
  * given function instead.
  * @param {!function()} fn
  */
	startInterception: function startInterception(fn) {
		SoyAop.interceptFns_.push(fn);
	},

	/**
  * Stops intercepting template calls.
  */
	stopAllInterceptions: function stopAllInterceptions() {
		SoyAop.interceptFns_ = [];
	},

	/**
  * Stops intercepting template calls with the last registered function.
  */
	stopInterception: function stopInterception() {
		SoyAop.interceptFns_.pop();
	}
};

exports.default = SoyAop;

},{}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../metal/src/metal');

var _events = require('../../metal-events/src/events');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * State adds support for having object properties that can be watched for
 * changes, as well as configured with validators, setters and other options.
 * See the `addToState` method for a complete list of available configuration
 * options for each state key.
 * @constructor
 * @extends {EventEmitter}
 */

var State = function (_EventEmitter) {
	_inherits(State, _EventEmitter);

	function State(opt_config) {
		_classCallCheck(this, State);

		/**
   * Object with information about the batch event that is currently
   * scheduled, or null if none is.
   * @type {Object}
   * @protected
   */

		var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

		_this.scheduledBatchData_ = null;

		/**
   * Object that contains information about all this instance's state keys.
   * @type {!Object<string, !Object>}
   * @protected
   */
		_this.stateInfo_ = {};

		/**
   * Object with the most recent values that state properties were set to
   * through either the constructor or setState calls.
   * @type {!Object<string, *>}
   */
		_this.config = _metal.object.mixin({}, opt_config || {});

		_this.setShouldUseFacade(true);
		_this.mergeInvalidKeys_();
		_this.addToStateFromStaticHint_(opt_config);
		return _this;
	}

	/**
  * Adds the given key to the state.
  * @param {string} name The name of the new state key.
  * @param {Object.<string, *>=} config The configuration object for the new
  *     key. See `addToState` for supported settings.
  * @param {*} initialValue The initial value of the new key.
  */


	State.prototype.addKeyToState = function addKeyToState(name, config, initialValue) {
		this.buildKeyInfo_(name, config, initialValue);
		Object.defineProperty(this, name, this.buildKeyPropertyDef_(name));
	};

	/**
  * Adds the given key(s) to the state, together with its(their) configs.
  * Config objects support the given settings:
  *     setter - Function for normalizing state key values. It receives the new
  *     value that was set, and returns the value that should be stored.
  *
  *     validator - Function that validates state key values. When it returns
  *     false, the new value is ignored.
  *
  *     value - The default value for the state key. Note that setting this to
  *     an object will cause all class instances to use the same reference to
  *     the object. To have each instance use a different reference for objects,
  *     use the `valueFn` option instead.
  *
  *     valueFn - A function that returns the default value for a state key.
  *
  *     writeOnce - Ignores writes to the state key after it's been first
  *     written to. That is, allows writes only when setting the value for the
  *     first time.
  * @param {!Object.<string, !Object>|string} configsOrName An object that maps
  *     configuration options for keys to be added to the state or the name of
  *     a single key to be added.
  * @param {Object.<string, *>=} opt_initialValuesOrConfig An object that maps
  *     state keys to their initial values. These values have higher precedence
  *     than the default values specified in the configurations. If a single
  *     key name was passed as the first param instead though, then this should
  *     be the configuration object for that key.
  * @param {boolean|Object|*=} opt_contextOrInitialValue If the first
  *     param passed to this method was a config object, this should be the
  *     context where the added state keys will be defined (defaults to `this`),
  *     or false if they shouldn't be defined at all. If the first param was a
  *     single key name though, this should be its initial value.
  */


	State.prototype.addToState = function addToState(configsOrName, opt_initialValuesOrConfig, opt_contextOrInitialValue) {
		if (_metal.core.isString(configsOrName)) {
			return this.addKeyToState(configsOrName, opt_initialValuesOrConfig, opt_contextOrInitialValue);
		}

		var initialValues = opt_initialValuesOrConfig || {};
		var names = Object.keys(configsOrName);

		var props = {};
		for (var i = 0; i < names.length; i++) {
			var name = names[i];
			this.buildKeyInfo_(name, configsOrName[name], initialValues[name]);
			props[name] = this.buildKeyPropertyDef_(name);
		}

		if (opt_contextOrInitialValue !== false) {
			Object.defineProperties(opt_contextOrInitialValue || this, props);
		}
	};

	/**
  * Adds state keys from super classes static hint `MyClass.STATE = {};`.
  * @param {Object.<string, !Object>=} opt_config An object that maps all the
  *     configurations for state keys.
  * @protected
  */


	State.prototype.addToStateFromStaticHint_ = function addToStateFromStaticHint_(opt_config) {
		var ctor = this.constructor;
		var defineContext = false;
		if (State.mergeStateStatic(ctor)) {
			defineContext = ctor.prototype;
		}
		this.addToState(ctor.STATE_MERGED, opt_config, defineContext);
	};

	/**
  * Checks that the given name is a valid state key name. If it's not, an error
  * will be thrown.
  * @param {string} name The name to be validated.
  * @throws {Error}
  * @protected
  */


	State.prototype.assertValidStateKeyName_ = function assertValidStateKeyName_(name) {
		if (this.constructor.INVALID_KEYS_MERGED[name]) {
			throw new Error('It\'s not allowed to create a state key with the name "' + name + '".');
		}
	};

	/**
  * Builds the info object for the specified state key.
  * @param {string} name The name of the key.
  * @param {Object} config The config object for the key.
  * @param {*} initialValue The initial value of the key.
  * @protected
  */


	State.prototype.buildKeyInfo_ = function buildKeyInfo_(name, config, initialValue) {
		this.assertValidStateKeyName_(name);

		this.stateInfo_[name] = {
			config: config || {},
			initialValue: initialValue,
			state: State.KeyStates.UNINITIALIZED
		};
	};

	/**
  * Builds the property definition object for the specified state key.
  * @param {string} name The name of the key.
  * @return {!Object}
  * @protected
  */


	State.prototype.buildKeyPropertyDef_ = function buildKeyPropertyDef_(name) {
		return {
			configurable: true,
			enumerable: true,
			get: function get() {
				return this.getStateKeyValue_(name);
			},
			set: function set(val) {
				this.setStateKeyValue_(name, val);
			}
		};
	};

	/**
  * Calls the requested function, running the appropriate code for when it's
  * passed as an actual function object or just the function's name.
  * @param {!Function|string} fn Function, or name of the function to run.
  * @param {!Array} An optional array of parameters to be passed to the
  *   function that will be called.
  * @return {*} The return value of the called function.
  * @protected
  */


	State.prototype.callFunction_ = function callFunction_(fn, args) {
		if (_metal.core.isString(fn)) {
			return this[fn].apply(this, args);
		} else if (_metal.core.isFunction(fn)) {
			return fn.apply(this, args);
		}
	};

	/**
  * Calls the state key's setter, if there is one.
  * @param {string} name The name of the key.
  * @param {*} value The value to be set.
  * @param {*} currentValue The current value.
  * @return {*} The final value to be set.
  * @protected
  */


	State.prototype.callSetter_ = function callSetter_(name, value, currentValue) {
		var info = this.stateInfo_[name];
		var config = info.config;
		if (config.setter) {
			value = this.callFunction_(config.setter, [value, currentValue]);
		}
		return value;
	};

	/**
  * Calls the state key's validator, if there is one.
  * @param {string} name The name of the key.
  * @param {*} value The value to be validated.
  * @return {boolean} Flag indicating if value is valid or not.
  * @protected
  */


	State.prototype.callValidator_ = function callValidator_(name, value) {
		var info = this.stateInfo_[name];
		var config = info.config;
		if (config.validator) {
			return this.callFunction_(config.validator, [value]);
		}
		return true;
	};

	/**
  * Checks if the it's allowed to write on the requested state key.
  * @param {string} name The name of the key.
  * @return {boolean}
  */


	State.prototype.canSetState = function canSetState(name) {
		var info = this.stateInfo_[name];
		return !info.config.writeOnce || !info.written;
	};

	/**
  * @inheritDoc
  */


	State.prototype.disposeInternal = function disposeInternal() {
		_EventEmitter.prototype.disposeInternal.call(this);
		this.stateInfo_ = null;
		this.scheduledBatchData_ = null;
	};

	/**
  * Emits the state change batch event.
  * @protected
  */


	State.prototype.emitBatchEvent_ = function emitBatchEvent_() {
		if (!this.isDisposed()) {
			var data = this.scheduledBatchData_;
			this.scheduledBatchData_ = null;
			this.emit('stateChanged', data);
		}
	};

	/**
  * Returns the value of the requested state key.
  * Note: this can and should be accomplished by accessing the value as a
  * regular property. This should only be used in cases where a function is
  * actually needed.
  * @param {string} name
  * @return {*}
  */


	State.prototype.get = function get(name) {
		return this[name];
	};

	/**
  * Returns an object that maps state keys to their values.
  * @param {Array<string>=} opt_names A list of names of the keys that should
  *   be returned. If none is given, the whole state will be returned.
  * @return {Object.<string, *>}
  */


	State.prototype.getState = function getState(opt_names) {
		var state = {};
		var names = opt_names || this.getStateKeys();

		for (var i = 0; i < names.length; i++) {
			state[names[i]] = this[names[i]];
		}

		return state;
	};

	/**
  * Gets the config object for the requested state key.
  * @param {string} name The key's name.
  * @return {Object}
  * @protected
  */


	State.prototype.getStateKeyConfig = function getStateKeyConfig(name) {
		return (this.stateInfo_[name] || {}).config;
	};

	/**
  * Returns an array with all state keys.
  * @return {Array.<string>}
  */


	State.prototype.getStateKeys = function getStateKeys() {
		return Object.keys(this.stateInfo_);
	};

	/**
  * Gets the value of the specified state key. This is passed as that key's
  * getter to the `Object.defineProperty` call inside the `addKeyToState` method.
  * @param {string} name The name of the key.
  * @return {*}
  * @protected
  */


	State.prototype.getStateKeyValue_ = function getStateKeyValue_(name) {
		this.initStateKey_(name);
		return this.stateInfo_[name].value;
	};

	/**
  * Checks if the value of the state key with the given name has already been
  * set. Note that this doesn't run the key's getter.
  * @param {string} name The name of the key.
  * @return {boolean}
  */


	State.prototype.hasBeenSet = function hasBeenSet(name) {
		var info = this.stateInfo_[name];
		return info.state === State.KeyStates.INITIALIZED || info.initialValue;
	};

	/**
  * Informs of changes to a state key's value through an event. Won't trigger
  * the event if the value hasn't changed or if it's being initialized.
  * @param {string} name The name of the key.
  * @param {*} prevVal The previous value of the key.
  * @protected
  */


	State.prototype.informChange_ = function informChange_(name, prevVal) {
		if (this.shouldInformChange_(name, prevVal)) {
			var data = {
				key: name,
				newVal: this[name],
				prevVal: prevVal
			};
			this.emit(name + 'Changed', data);
			this.emit('stateKeyChanged', data);
			this.scheduleBatchEvent_(data);
		}
	};

	/**
  * Initializes the specified state key, giving it a first value.
  * @param {string} name The name of the key.
  * @protected
  */


	State.prototype.initStateKey_ = function initStateKey_(name) {
		var info = this.stateInfo_[name];
		if (info.state !== State.KeyStates.UNINITIALIZED) {
			return;
		}

		info.state = State.KeyStates.INITIALIZING;
		this.setInitialValue_(name);
		if (!info.written) {
			info.state = State.KeyStates.INITIALIZING_DEFAULT;
			this.setDefaultValue_(name);
		}
		info.state = State.KeyStates.INITIALIZED;
	};

	/**
  * Merges an array of values for the STATE property into a single object.
  * @param {!Array} values The values to be merged.
  * @return {!Object} The merged value.
  * @static
  * @protected
  */


	State.mergeState_ = function mergeState_(values) {
		return _metal.object.mixin.apply(null, [{}].concat(values.reverse()));
	};

	/**
  * Merges the STATE static variable for the given constructor function.
  * @param  {!Function} ctor Constructor function.
  * @return {boolean} Returns true if merge happens, false otherwise.
  * @static
  */


	State.mergeStateStatic = function mergeStateStatic(ctor) {
		return _metal.core.mergeSuperClassesProperty(ctor, 'STATE', State.mergeState_);
	};

	/**
  * Merges the values of the `INVALID_KEYS` static for the whole hierarchy of
  * the current instance.
  * @protected
  */


	State.prototype.mergeInvalidKeys_ = function mergeInvalidKeys_() {
		_metal.core.mergeSuperClassesProperty(this.constructor, 'INVALID_KEYS', function (values) {
			return _metal.array.flatten(values).reduce(function (merged, val) {
				if (val) {
					merged[val] = true;
				}
				return merged;
			}, {});
		});
	};

	/**
  * Removes the requested state key.
  * @param {string} name The name of the key.
  */


	State.prototype.removeStateKey = function removeStateKey(name) {
		this.stateInfo_[name] = null;
		delete this[name];
	};

	/**
  * Schedules a state change batch event to be emitted asynchronously.
  * @param {!Object} changeData Information about a state key's update.
  * @protected
  */


	State.prototype.scheduleBatchEvent_ = function scheduleBatchEvent_(changeData) {
		if (!this.scheduledBatchData_) {
			_metal.async.nextTick(this.emitBatchEvent_, this);
			this.scheduledBatchData_ = {
				changes: {}
			};
		}

		var name = changeData.key;
		var changes = this.scheduledBatchData_.changes;
		if (changes[name]) {
			changes[name].newVal = changeData.newVal;
		} else {
			changes[name] = changeData;
		}
	};

	/**
  * Sets the value of the requested state key.
  * Note: this can and should be accomplished by setting the state key as a
  * regular property. This should only be used in cases where a function is
  * actually needed.
  * @param {string} name
  * @param {*} value
  * @return {*}
  */


	State.prototype.set = function set(name, value) {
		this[name] = value;
	};

	/**
  * Sets the default value of the requested state key.
  * @param {string} name The name of the key.
  * @return {*}
  * @protected
  */


	State.prototype.setDefaultValue_ = function setDefaultValue_(name) {
		var config = this.stateInfo_[name].config;

		if (config.value !== undefined) {
			this[name] = config.value;
		} else {
			this[name] = this.callFunction_(config.valueFn);
		}
	};

	/**
  * Sets the initial value of the requested state key.
  * @param {string} name The name of the key.
  * @return {*}
  * @protected
  */


	State.prototype.setInitialValue_ = function setInitialValue_(name) {
		var info = this.stateInfo_[name];
		if (info.initialValue !== undefined) {
			this[name] = info.initialValue;
			info.initialValue = undefined;
		}
	};

	/**
  * Sets the value of all the specified state keys.
  * @param {!Object.<string,*>} values A map of state keys to the values they
  *   should be set to.
  */


	State.prototype.setState = function setState(values) {
		_metal.object.mixin(this.config, values);

		var names = Object.keys(values);
		for (var i = 0; i < names.length; i++) {
			this[names[i]] = values[names[i]];
		}
	};

	/**
  * Sets the value of the specified state key. This is passed as that key's
  * setter to the `Object.defineProperty` call inside the `addKeyToState`
  * method.
  * @param {string} name The name of the key.
  * @param {*} value The new value of the key.
  * @protected
  */


	State.prototype.setStateKeyValue_ = function setStateKeyValue_(name, value) {
		if (!this.canSetState(name) || !this.validateKeyValue_(name, value)) {
			return;
		}

		var info = this.stateInfo_[name];
		if (info.initialValue === undefined && info.state === State.KeyStates.UNINITIALIZED) {
			info.state = State.KeyStates.INITIALIZED;
		}

		var prevVal = this[name];
		info.value = this.callSetter_(name, value, prevVal);
		info.written = true;
		this.informChange_(name, prevVal);
	};

	/**
  * Checks if we should inform about a state update. Updates are ignored during
  * state initialization. Otherwise, updates to primitive values are only
  * informed when the new value is different from the previous one. Updates to
  * objects (which includes functions and arrays) are always informed outside
  * initialization though, since we can't be sure if all of the internal data
  * has stayed the same.
  * @param {string} name The name of the key.
  * @param {*} prevVal The previous value of the key.
  * @return {boolean}
  * @protected
  */


	State.prototype.shouldInformChange_ = function shouldInformChange_(name, prevVal) {
		var info = this.stateInfo_[name];
		return info.state === State.KeyStates.INITIALIZED && (_metal.core.isObject(prevVal) || prevVal !== this[name]);
	};

	/**
  * Validates the state key's value, which includes calling the validator
  * defined in the key's configuration object, if there is one.
  * @param {string} name The name of the key.
  * @param {*} value The value to be validated.
  * @return {boolean} Flag indicating if value is valid or not.
  * @protected
  */


	State.prototype.validateKeyValue_ = function validateKeyValue_(name, value) {
		var info = this.stateInfo_[name];

		return info.state === State.KeyStates.INITIALIZING_DEFAULT || this.callValidator_(name, value);
	};

	return State;
}(_events.EventEmitter);

/**
 * A list with state key names that will automatically be rejected as invalid.
 * Subclasses can define their own invalid keys by setting this static on their
 * constructors, which will be merged together and handled automatically.
 * @type {!Array<string>}
 */


State.INVALID_KEYS = ['config', 'state', 'stateKey'];

/**
 * Constants that represent the states that an a state key can be in.
 * @type {!Object}
 */
State.KeyStates = {
	UNINITIALIZED: 0,
	INITIALIZING: 1,
	INITIALIZING_DEFAULT: 2,
	INITIALIZED: 3
};

exports.default = State;

},{"../../metal-events/src/events":23,"../../metal/src/metal":46}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _metal = require('../../metal/src/metal');

var _parse = require('./parse');

var _parse2 = _interopRequireDefault(_parse);

var _MultiMap = require('../../metal-multimap/src/MultiMap');

var _MultiMap2 = _interopRequireDefault(_MultiMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var parseFn_ = _parse2.default;

var Uri = function () {

	/**
  * This class contains setters and getters for the parts of the URI.
  * The following figure displays an example URIs and their component parts.
  *
  *                                  path
  *	                             ┌───┴────┐
  *	  abc://example.com:123/path/data?key=value#fragid1
  *	  └┬┘   └────┬────┘ └┬┘           └───┬───┘ └──┬──┘
  * protocol  hostname  port            search    hash
  *          └──────┬───────┘
  *                host
  *
  * @param {*=} opt_uri Optional string URI to parse
  * @constructor
  */

	function Uri() {
		var opt_uri = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

		_classCallCheck(this, Uri);

		this.url = Uri.parse(this.maybeAddProtocolAndHostname_(opt_uri));
	}

	/**
  * Adds parameters to uri from a <code>MultiMap</code> as source.
  * @param {MultiMap} multimap The <code>MultiMap</code> containing the
  *   parameters.
  * @protected
  * @chainable
  */


	Uri.prototype.addParametersFromMultiMap = function addParametersFromMultiMap(multimap) {
		var _this = this;

		multimap.names().forEach(function (name) {
			multimap.getAll(name).forEach(function (value) {
				_this.addParameterValue(name, value);
			});
		});
		return this;
	};

	/**
  * Adds the value of the named query parameters.
  * @param {string} key The parameter to set.
  * @param {*} value The new value. Will be explicitly casted to String.
  * @chainable
  */


	Uri.prototype.addParameterValue = function addParameterValue(name, value) {
		this.ensureQueryInitialized_();
		if (_metal.core.isDef(value)) {
			value = String(value);
		}
		this.query.add(name, value);
		return this;
	};

	/**
  * Adds the values of the named query parameter.
  * @param {string} key The parameter to set.
  * @param {*} value The new value.
  * @chainable
  */


	Uri.prototype.addParameterValues = function addParameterValues(name, values) {
		var _this2 = this;

		values.forEach(function (value) {
			return _this2.addParameterValue(name, value);
		});
		return this;
	};

	/**
  * Ensures query internal map is initialized and synced with initial value
  * extracted from URI search part.
  * @protected
  */


	Uri.prototype.ensureQueryInitialized_ = function ensureQueryInitialized_() {
		var _this3 = this;

		if (this.query) {
			return;
		}
		this.query = new _MultiMap2.default();
		var search = this.url.search;
		if (search) {
			search.substring(1).split('&').forEach(function (param) {
				var _param$split = param.split('=');

				var _param$split2 = _slicedToArray(_param$split, 2);

				var key = _param$split2[0];
				var value = _param$split2[1];

				if (_metal.core.isDef(value)) {
					value = Uri.urlDecode(value);
				}
				_this3.addParameterValue(key, value);
			});
		}
	};

	/**
  * Gets the hash part of uri.
  * @return {string}
  */


	Uri.prototype.getHash = function getHash() {
		return this.url.hash || '';
	};

	/**
  * Gets the host part of uri. E.g. <code>[hostname]:[port]</code>.
  * @return {string}
  */


	Uri.prototype.getHost = function getHost() {
		var host = this.getHostname();
		if (host) {
			var port = this.getPort();
			if (port && port !== '80') {
				host += ':' + port;
			}
		}
		return host;
	};

	/**
  * Gets the hostname part of uri without protocol and port.
  * @return {string}
  */


	Uri.prototype.getHostname = function getHostname() {
		var hostname = this.url.hostname;
		if (hostname === Uri.HOSTNAME_PLACEHOLDER) {
			return '';
		}
		return hostname;
	};

	/**
  * Gets the origin part of uri. E.g. <code>http://[hostname]:[port]</code>.
  * @return {string}
  */


	Uri.prototype.getOrigin = function getOrigin() {
		var host = this.getHost();
		if (host) {
			return this.getProtocol() + '//' + host;
		}
		return '';
	};

	/**
  * Returns the first value for a given parameter or undefined if the given
  * parameter name does not appear in the query string.
  * @param {string} paramName Unescaped parameter name.
  * @return {string|undefined} The first value for a given parameter or
  *   undefined if the given parameter name does not appear in the query
  *   string.
  */


	Uri.prototype.getParameterValue = function getParameterValue(name) {
		this.ensureQueryInitialized_();
		return this.query.get(name);
	};

	/**
  * Returns the value<b>s</b> for a given parameter as a list of decoded
  * query parameter values.
  * @param {string} name The parameter to get values for.
  * @return {!Array<?>} The values for a given parameter as a list of decoded
  *   query parameter values.
  */


	Uri.prototype.getParameterValues = function getParameterValues(name) {
		this.ensureQueryInitialized_();
		return this.query.getAll(name);
	};

	/**
  * Returns the name<b>s</b> of the parameters.
  * @return {!Array<string>} The names for the parameters as a list of
  *   strings.
  */


	Uri.prototype.getParameterNames = function getParameterNames() {
		this.ensureQueryInitialized_();
		return this.query.names();
	};

	/**
  * Gets the function currently being used to parse URIs.
  * @return {!function()}
  */


	Uri.getParseFn = function getParseFn() {
		return parseFn_;
	};

	/**
  * Gets the pathname part of uri.
  * @return {string}
  */


	Uri.prototype.getPathname = function getPathname() {
		return this.url.pathname;
	};

	/**
  * Gets the port number part of uri as string.
  * @return {string}
  */


	Uri.prototype.getPort = function getPort() {
		return this.url.port;
	};

	/**
  * Gets the protocol part of uri. E.g. <code>http:</code>.
  * @return {string}
  */


	Uri.prototype.getProtocol = function getProtocol() {
		return this.url.protocol;
	};

	/**
  * Gets the search part of uri. Search value is retrieved from query
  * parameters.
  * @return {string}
  */


	Uri.prototype.getSearch = function getSearch() {
		var _this4 = this;

		var search = '';
		var querystring = '';
		this.getParameterNames().forEach(function (name) {
			_this4.getParameterValues(name).forEach(function (value) {
				querystring += name;
				if (_metal.core.isDef(value)) {
					querystring += '=' + encodeURIComponent(value);
				}
				querystring += '&';
			});
		});
		querystring = querystring.slice(0, -1);
		if (querystring) {
			search += '?' + querystring;
		}
		return search;
	};

	/**
  * Checks if uri contains the parameter.
  * @param {string} name
  * @return {boolean}
  */


	Uri.prototype.hasParameter = function hasParameter(name) {
		this.ensureQueryInitialized_();
		return this.query.contains(name);
	};

	/**
  * Makes this URL unique by adding a random param to it. Useful for avoiding
  * cache.
  */


	Uri.prototype.makeUnique = function makeUnique() {
		this.setParameterValue(Uri.RANDOM_PARAM, _metal.string.getRandomString());
		return this;
	};

	/**
  * Maybe adds protocol and a hostname placeholder on a parial URI if needed.
  * Relevent for compatibility with <code>URL</code> native object.
  * @param {string=} opt_uri
  * @return {string} URI with protocol and hostname placeholder.
  */


	Uri.prototype.maybeAddProtocolAndHostname_ = function maybeAddProtocolAndHostname_(opt_uri) {
		var url = opt_uri;
		if (opt_uri.indexOf('://') === -1 && opt_uri.indexOf('javascript:') !== 0) {
			// jshint ignore:line

			url = Uri.DEFAULT_PROTOCOL;
			if (opt_uri[0] !== '/' || opt_uri[1] !== '/') {
				url += '//';
			}

			switch (opt_uri.charAt(0)) {
				case '.':
				case '?':
				case '#':
					url += Uri.HOSTNAME_PLACEHOLDER;
					url += '/';
					url += opt_uri;
					break;
				case '':
				case '/':
					if (opt_uri[1] !== '/') {
						url += Uri.HOSTNAME_PLACEHOLDER;
					}
					url += opt_uri;
					break;
				default:
					url += opt_uri;
			}
		}
		return url;
	};

	/**
  * Normalizes the parsed object to be in the expected standard.
  * @param {!Object}
  */


	Uri.normalizeObject = function normalizeObject(parsed) {
		var length = parsed.pathname ? parsed.pathname.length : 0;
		if (length > 1 && parsed.pathname[length - 1] === '/') {
			parsed.pathname = parsed.pathname.substr(0, length - 1);
		}
		return parsed;
	};

	/**
  * Parses the given uri string into an object.
  * @param {*=} opt_uri Optional string URI to parse
  */


	Uri.parse = function parse(opt_uri) {
		return Uri.normalizeObject(parseFn_(opt_uri));
	};

	/**
  * Removes the named query parameter.
  * @param {string} name The parameter to remove.
  * @chainable
  */


	Uri.prototype.removeParameter = function removeParameter(name) {
		this.ensureQueryInitialized_();
		this.query.remove(name);
		return this;
	};

	/**
  * Removes uniqueness parameter of the uri.
  * @chainable
  */


	Uri.prototype.removeUnique = function removeUnique() {
		this.removeParameter(Uri.RANDOM_PARAM);
		return this;
	};

	/**
  * Sets the hash.
  * @param {string} hash
  * @chainable
  */


	Uri.prototype.setHash = function setHash(hash) {
		this.url.hash = hash;
		return this;
	};

	/**
  * Sets the hostname.
  * @param {string} hostname
  * @chainable
  */


	Uri.prototype.setHostname = function setHostname(hostname) {
		this.url.hostname = hostname;
		return this;
	};

	/**
  * Sets the value of the named query parameters, clearing previous values
  * for that key.
  * @param {string} key The parameter to set.
  * @param {*} value The new value.
  * @chainable
  */


	Uri.prototype.setParameterValue = function setParameterValue(name, value) {
		this.removeParameter(name);
		this.addParameterValue(name, value);
		return this;
	};

	/**
  * Sets the values of the named query parameters, clearing previous values
  * for that key.
  * @param {string} key The parameter to set.
  * @param {*} value The new value.
  * @chainable
  */


	Uri.prototype.setParameterValues = function setParameterValues(name, values) {
		var _this5 = this;

		this.removeParameter(name);
		values.forEach(function (value) {
			return _this5.addParameterValue(name, value);
		});
		return this;
	};

	/**
  * Sets the pathname.
  * @param {string} pathname
  * @chainable
  */


	Uri.prototype.setPathname = function setPathname(pathname) {
		this.url.pathname = pathname;
		return this;
	};

	/**
  * Sets the port number.
  * @param {*} port Port number.
  * @chainable
  */


	Uri.prototype.setPort = function setPort(port) {
		this.url.port = port;
		return this;
	};

	/**
  * Sets the function that will be used for parsing the original string uri
  * into an object.
  * @param {!function()} parseFn
  */


	Uri.setParseFn = function setParseFn(parseFn) {
		parseFn_ = parseFn;
	};

	/**
  * Sets the protocol. If missing <code>http:</code> is used as default.
  * @param {string} protocol
  * @chainable
  */


	Uri.prototype.setProtocol = function setProtocol(protocol) {
		this.url.protocol = protocol;
		if (this.url.protocol[this.url.protocol.length - 1] !== ':') {
			this.url.protocol += ':';
		}
		return this;
	};

	/**
  * @return {string} The string form of the url.
  * @override
  */


	Uri.prototype.toString = function toString() {
		var href = '';
		var host = this.getHost();
		if (host) {
			href += this.getProtocol() + '//';
		}
		href += host + this.getPathname() + this.getSearch() + this.getHash();
		return href;
	};

	/**
  * Joins the given paths.
  * @param {string} basePath
  * @param {...string} ...paths Any number of paths to be joined with the base url.
  * @static
  */


	Uri.joinPaths = function joinPaths(basePath) {
		for (var _len = arguments.length, paths = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			paths[_key - 1] = arguments[_key];
		}

		if (basePath.charAt(basePath.length - 1) === '/') {
			basePath = basePath.substring(0, basePath.length - 1);
		}
		paths = paths.map(function (path) {
			return path.charAt(0) === '/' ? path.substring(1) : path;
		});
		return [basePath].concat(paths).join('/').replace(/\/$/, '');
	};

	/**
  * URL-decodes the string. We need to specially handle '+'s because
  * the javascript library doesn't convert them to spaces.
  * @param {string} str The string to url decode.
  * @return {string} The decoded {@code str}.
  */


	Uri.urlDecode = function urlDecode(str) {
		return decodeURIComponent(str.replace(/\+/g, ' '));
	};

	return Uri;
}();

/**
 * Default protocol value.
 * @type {string}
 * @default http:
 * @static
 */


Uri.DEFAULT_PROTOCOL = 'http:';

/**
 * Hostname placeholder. Relevant to internal usage only.
 * @type {string}
 * @static
 */
Uri.HOSTNAME_PLACEHOLDER = 'hostname' + Date.now();

/**
 * Name used by the param generated by `makeUnique`.
 * @type {string}
 * @static
 */
Uri.RANDOM_PARAM = 'zx';

exports.default = Uri;

},{"../../metal-multimap/src/MultiMap":30,"../../metal/src/metal":46,"./parse":39}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../metal/src/metal');

var _parseFromAnchor = require('./parseFromAnchor');

var _parseFromAnchor2 = _interopRequireDefault(_parseFromAnchor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Parses the given uri string into an object. The URL function will be used
 * when present, otherwise we'll fall back to the anchor node element.
 * @param {*=} opt_uri Optional string URI to parse
 */
function parse(opt_uri) {
	if (_metal.core.isFunction(URL) && URL.length) {
		return new URL(opt_uri);
	} else {
		return (0, _parseFromAnchor2.default)(opt_uri);
	}
}

exports.default = parse;

},{"../../metal/src/metal":46,"./parseFromAnchor":40}],40:[function(require,module,exports){
'use strict';

/**
 * Parses the given uri string into an object.
 * @param {*=} opt_uri Optional string URI to parse
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});
function parseFromAnchor(opt_uri) {
	var link = document.createElement('a');
	link.href = opt_uri;
	return {
		hash: link.hash,
		hostname: link.hostname,
		password: link.password,
		pathname: link.pathname[0] === '/' ? link.pathname : '/' + link.pathname,
		port: link.port,
		protocol: link.protocol,
		search: link.search,
		username: link.username
	};
}

exports.default = parseFromAnchor;

},{}],41:[function(require,module,exports){
'use strict';

/**
 * Metal.js browser user agent detection. It's extremely recommended the usage
 * of feature checking over browser user agent sniffing. Unfortunately, in some
 * situations feature checking can be slow or even impossible, therefore use
 * this utility with caution.
 * @see <a href="http://www.useragentstring.com/">User agent strings</a>.
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UA = function () {
	function UA() {
		_classCallCheck(this, UA);
	}

	/**
  * Gets the native userAgent string from navigator if it exists. If
  * navigator or navigator.userAgent string is missing, returns an empty
  * string.
  * @return {string}
  * @private
  * @static
  */

	UA.getNativeUserAgent = function getNativeUserAgent() {
		var navigator = UA.globals.window.navigator;
		if (navigator) {
			var userAgent = navigator.userAgent;
			if (userAgent) {
				return userAgent;
			}
		}
		return '';
	};

	/**
  * Whether the user agent contains the given string, ignoring case.
  * @param {string} str
  * @return {boolean}
  * @private
  * @static
 */


	UA.matchUserAgent = function matchUserAgent(str) {
		return UA.userAgent.indexOf(str) !== -1;
	};

	/**
  * Tests the user agent.
  * @param {string} userAgent The user agent string.
  * @static
  */


	UA.testUserAgent = function testUserAgent(userAgent) {
		/**
   * Holds the user agent value extracted from browser native user agent.
   * @type {string}
   * @static
   */
		UA.userAgent = userAgent;

		/**
   * Whether the user's browser is Opera.
   * @type {boolean}
   * @static
   */
		UA.isOpera = UA.matchUserAgent('Opera') || UA.matchUserAgent('OPR');

		/**
   * Whether the user's browser is IE.
   * @type {boolean}
   * @static
   */
		UA.isIe = UA.matchUserAgent('Trident') || UA.matchUserAgent('MSIE');

		/**
   * Whether the user's browser is Edge.
   * @type {boolean}
   * @static
   */
		UA.isEdge = UA.matchUserAgent('Edge');

		/**
   * Whether the user's browser is IE or Edge.
   * @type {boolean}
   * @static
   */
		UA.isIeOrEdge = UA.isIe || UA.isEdge;

		/**
   * Whether the user's browser is Chrome.
   * @type {boolean}
   * @static
   */
		UA.isChrome = (UA.matchUserAgent('Chrome') || UA.matchUserAgent('CriOS')) && !UA.isOpera && !UA.isEdge;

		/**
   * Whether the user's browser is Safari.
   * @type {boolean}
   * @static
   */
		UA.isSafari = UA.matchUserAgent('Safari') && !(UA.isChrome || UA.isOpera || UA.isEdge);

		/**
   * Whether the user's browser is Firefox.
   * @type {boolean}
   * @static
   */
		UA.isFirefox = UA.matchUserAgent('Firefox');
	};

	return UA;
}();

/**
 * Exposes global references.
 * @type {object}
 * @static
 */


UA.globals = {
	window: window
};

UA.testUserAgent(UA.getNativeUserAgent());

exports.default = UA;

},{}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _core = require('../core');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var array = function () {
	function array() {
		_classCallCheck(this, array);
	}

	/**
  * Checks if the given arrays have the same content.
  * @param {!Array<*>} arr1
  * @param {!Array<*>} arr2
  * @return {boolean}
  */

	array.equal = function equal(arr1, arr2) {
		if (arr1.length !== arr2.length) {
			return false;
		}
		for (var i = 0; i < arr1.length; i++) {
			if (arr1[i] !== arr2[i]) {
				return false;
			}
		}
		return true;
	};

	/**
  * Returns the first value in the given array that isn't undefined.
  * @param {!Array} arr
  * @return {*}
  */


	array.firstDefinedValue = function firstDefinedValue(arr) {
		for (var i = 0; i < arr.length; i++) {
			if (arr[i] !== undefined) {
				return arr[i];
			}
		}
	};

	/**
  * Transforms the input nested array to become flat.
  * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
  * @param {Array.<*>} opt_output Optional output array.
  * @return {Array.<*>} Flat array.
  */


	array.flatten = function flatten(arr, opt_output) {
		var output = opt_output || [];
		for (var i = 0; i < arr.length; i++) {
			if (Array.isArray(arr[i])) {
				array.flatten(arr[i], output);
			} else {
				output.push(arr[i]);
			}
		}
		return output;
	};

	/**
  * Removes the first occurrence of a particular value from an array.
  * @param {Array.<T>} arr Array from which to remove value.
  * @param {T} obj Object to remove.
  * @return {boolean} True if an element was removed.
  * @template T
  */


	array.remove = function remove(arr, obj) {
		var i = arr.indexOf(obj);
		var rv;
		if (rv = i >= 0) {
			array.removeAt(arr, i);
		}
		return rv;
	};

	/**
  * Removes from an array the element at index i
  * @param {Array} arr Array or array like object from which to remove value.
  * @param {number} i The index to remove.
  * @return {boolean} True if an element was removed.
  */


	array.removeAt = function removeAt(arr, i) {
		return Array.prototype.splice.call(arr, i, 1).length === 1;
	};

	/**
  * Slices the given array, just like Array.prototype.slice, but this
  * is faster and working on all array-like objects (like arguments).
  * @param {!Object} arr Array-like object to slice.
  * @param {number} start The index that should start the slice.
  * @param {number=} opt_end The index where the slice should end, not
  *   included in the final array. If not given, all elements after the
  *   start index will be included.
  * @return {!Array}
  */


	array.slice = function slice(arr, start, opt_end) {
		var sliced = [];
		var end = _core2.default.isDef(opt_end) ? opt_end : arr.length;
		for (var i = start; i < end; i++) {
			sliced.push(arr[i]);
		}
		return sliced;
	};

	return array;
}();

exports.default = array;

},{"../core":44}],43:[function(require,module,exports){
/*!
 * Polyfill from Google's Closure Library.
 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
 */

'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
var async = {};

/**
 * Throw an item without interrupting the current execution context.  For
 * example, if processing a group of items in a loop, sometimes it is useful
 * to report an error while still allowing the rest of the batch to be
 * processed.
 * @param {*} exception
 */
async.throwException = function (exception) {
	// Each throw needs to be in its own context.
	async.nextTick(function () {
		throw exception;
	});
};

/**
 * Fires the provided callback just before the current callstack unwinds, or as
 * soon as possible after the current JS execution context.
 * @param {function(this:THIS)} callback
 * @param {THIS=} opt_context Object to use as the "this value" when calling
 *     the provided function.
 * @template THIS
 */
async.run = function (callback, opt_context) {
	if (!async.run.workQueueScheduled_) {
		// Nothing is currently scheduled, schedule it now.
		async.nextTick(async.run.processWorkQueue);
		async.run.workQueueScheduled_ = true;
	}

	async.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));
};

/** @private {boolean} */
async.run.workQueueScheduled_ = false;

/** @private {!Array.<!async.run.WorkItem_>} */
async.run.workQueue_ = [];

/**
 * Run any pending async.run work items. This function is not intended
 * for general use, but for use by entry point handlers to run items ahead of
 * async.nextTick.
 */
async.run.processWorkQueue = function () {
	// NOTE: additional work queue items may be pushed while processing.
	while (async.run.workQueue_.length) {
		// Don't let the work queue grow indefinitely.
		var workItems = async.run.workQueue_;
		async.run.workQueue_ = [];
		for (var i = 0; i < workItems.length; i++) {
			var workItem = workItems[i];
			try {
				workItem.fn.call(workItem.scope);
			} catch (e) {
				async.throwException(e);
			}
		}
	}

	// There are no more work items, reset the work queue.
	async.run.workQueueScheduled_ = false;
};

/**
 * @constructor
 * @final
 * @struct
 * @private
 *
 * @param {function()} fn
 * @param {Object|null|undefined} scope
 */
async.run.WorkItem_ = function (fn, scope) {
	/** @const */
	this.fn = fn;
	/** @const */
	this.scope = scope;
};

/**
 * Fires the provided callbacks as soon as possible after the current JS
 * execution context. setTimeout(…, 0) always takes at least 5ms for legacy
 * reasons.
 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
 *     possible.
 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
 * @template SCOPE
 */
async.nextTick = function (callback, opt_context) {
	var cb = callback;
	if (opt_context) {
		cb = callback.bind(opt_context);
	}
	cb = async.nextTick.wrapCallback_(cb);
	// Introduced and currently only supported by IE10.
	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof setImmediate === 'function') {
		setImmediate(cb);
		return;
	}
	// Look for and cache the custom fallback version of setImmediate.
	if (!async.nextTick.setImmediate_) {
		async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
	}
	async.nextTick.setImmediate_(cb);
};

/**
 * Cache for the setImmediate implementation.
 * @type {function(function())}
 * @private
 */
async.nextTick.setImmediate_ = null;

/**
 * Determines the best possible implementation to run a function as soon as
 * the JS event loop is idle.
 * @return {function(function())} The "setImmediate" implementation.
 * @private
 */
async.nextTick.getSetImmediateEmulator_ = function () {
	// Create a private message channel and use it to postMessage empty messages
	// to ourselves.
	var Channel;

	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof MessageChannel === 'function') {
		Channel = MessageChannel;
	}

	// If MessageChannel is not available and we are in a browser, implement
	// an iframe based polyfill in browsers that have postMessage and
	// document.addEventListener. The latter excludes IE8 because it has a
	// synchronous postMessage implementation.
	if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
		/** @constructor */
		Channel = function Channel() {
			// Make an empty, invisible iframe.
			var iframe = document.createElement('iframe');
			iframe.style.display = 'none';
			iframe.src = '';
			document.documentElement.appendChild(iframe);
			var win = iframe.contentWindow;
			var doc = win.document;
			doc.open();
			doc.write('');
			doc.close();
			var message = 'callImmediate' + Math.random();
			var origin = win.location.protocol + '//' + win.location.host;
			var onmessage = function (e) {
				// Validate origin and message to make sure that this message was
				// intended for us.
				if (e.origin !== origin && e.data !== message) {
					return;
				}
				this.port1.onmessage();
			}.bind(this);
			win.addEventListener('message', onmessage, false);
			this.port1 = {};
			this.port2 = {
				postMessage: function postMessage() {
					win.postMessage(message, origin);
				}
			};
		};
	}
	if (typeof Channel !== 'undefined') {
		var channel = new Channel();
		// Use a fifo linked list to call callbacks in the right order.
		var head = {};
		var tail = head;
		channel.port1.onmessage = function () {
			head = head.next;
			var cb = head.cb;
			head.cb = null;
			cb();
		};
		return function (cb) {
			tail.next = {
				cb: cb
			};
			tail = tail.next;
			channel.port2.postMessage(0);
		};
	}
	// Implementation for IE6-8: Script elements fire an asynchronous
	// onreadystatechange event when inserted into the DOM.
	if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
		return function (cb) {
			var script = document.createElement('script');
			script.onreadystatechange = function () {
				// Clean up and call the callback.
				script.onreadystatechange = null;
				script.parentNode.removeChild(script);
				script = null;
				cb();
				cb = null;
			};
			document.documentElement.appendChild(script);
		};
	}
	// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
	// or more.
	return function (cb) {
		setTimeout(cb, 0);
	};
};

/**
 * Helper function that is overrided to protect callbacks with entry point
 * monitor if the application monitors entry points.
 * @param {function()} callback Callback function to fire as soon as possible.
 * @return {function()} The wrapped callback.
 * @private
 */
async.nextTick.wrapCallback_ = function (opt_returnValue) {
	return opt_returnValue;
};

exports.default = async;

},{}],44:[function(require,module,exports){
'use strict';

/**
 * A collection of core utility functions.
 * @const
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var core = function () {
	function core() {
		_classCallCheck(this, core);
	}

	/**
  * When defining a class Foo with an abstract method bar(), you can do:
  * Foo.prototype.bar = core.abstractMethod
  *
  * Now if a subclass of Foo fails to override bar(), an error will be thrown
  * when bar() is invoked.
  *
  * @type {!Function}
  * @throws {Error} when invoked to indicate the method should be overridden.
  */

	core.abstractMethod = function abstractMethod() {
		throw Error('Unimplemented abstract method');
	};

	/**
  * Loops constructor super classes collecting its properties values. If
  * property is not available on the super class `undefined` will be
  * collected as value for the class hierarchy position.
  * @param {!function()} constructor Class constructor.
  * @param {string} propertyName Property name to be collected.
  * @return {Array.<*>} Array of collected values.
  * TODO(*): Rethink superclass loop.
  */


	core.collectSuperClassesProperty = function collectSuperClassesProperty(constructor, propertyName) {
		var propertyValues = [constructor[propertyName]];
		while (constructor.__proto__ && !constructor.__proto__.isPrototypeOf(Function)) {
			constructor = constructor.__proto__;
			propertyValues.push(constructor[propertyName]);
		}
		return propertyValues;
	};

	/**
  * Gets the name of the given function. If the current browser doesn't
  * support the `name` property, this will calculate it from the function's
  * content string.
  * @param {!function()} fn
  * @return {string}
  */


	core.getFunctionName = function getFunctionName(fn) {
		if (!fn.name) {
			var str = fn.toString();
			fn.name = str.substring(9, str.indexOf('('));
		}
		return fn.name;
	};

	/**
  * Gets an unique id. If `opt_object` argument is passed, the object is
  * mutated with an unique id. Consecutive calls with the same object
  * reference won't mutate the object again, instead the current object uid
  * returns. See {@link core.UID_PROPERTY}.
  * @type {opt_object} Optional object to be mutated with the uid. If not
  *     specified this method only returns the uid.
  * @throws {Error} when invoked to indicate the method should be overridden.
  */


	core.getUid = function getUid(opt_object) {
		if (opt_object) {
			return opt_object[core.UID_PROPERTY] || (opt_object[core.UID_PROPERTY] = core.uniqueIdCounter_++);
		}
		return core.uniqueIdCounter_++;
	};

	/**
  * The identity function. Returns its first argument.
  * @param {*=} opt_returnValue The single value that will be returned.
  * @return {?} The first argument.
  */


	core.identityFunction = function identityFunction(opt_returnValue) {
		return opt_returnValue;
	};

	/**
  * Returns true if the specified value is a boolean.
  * @param {?} val Variable to test.
  * @return {boolean} Whether variable is boolean.
  */


	core.isBoolean = function isBoolean(val) {
		return typeof val === 'boolean';
	};

	/**
  * Returns true if the specified value is not undefined.
  * @param {?} val Variable to test.
  * @return {boolean} Whether variable is defined.
  */


	core.isDef = function isDef(val) {
		return val !== undefined;
	};

	/**
  * Returns true if value is not undefined or null.
  * @param {*} val
  * @return {Boolean}
  */


	core.isDefAndNotNull = function isDefAndNotNull(val) {
		return core.isDef(val) && !core.isNull(val);
	};

	/**
  * Returns true if value is a document.
  * @param {*} val
  * @return {Boolean}
  */


	core.isDocument = function isDocument(val) {
		return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
	};

	/**
  * Returns true if value is a dom element.
  * @param {*} val
  * @return {Boolean}
  */


	core.isElement = function isElement(val) {
		return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
	};

	/**
  * Returns true if the specified value is a function.
  * @param {?} val Variable to test.
  * @return {boolean} Whether variable is a function.
  */


	core.isFunction = function isFunction(val) {
		return typeof val === 'function';
	};

	/**
  * Returns true if value is null.
  * @param {*} val
  * @return {Boolean}
  */


	core.isNull = function isNull(val) {
		return val === null;
	};

	/**
  * Returns true if the specified value is a number.
  * @param {?} val Variable to test.
  * @return {boolean} Whether variable is a number.
  */


	core.isNumber = function isNumber(val) {
		return typeof val === 'number';
	};

	/**
  * Returns true if value is a window.
  * @param {*} val
  * @return {Boolean}
  */


	core.isWindow = function isWindow(val) {
		return val !== null && val === val.window;
	};

	/**
  * Returns true if the specified value is an object. This includes arrays
  * and functions.
  * @param {?} val Variable to test.
  * @return {boolean} Whether variable is an object.
  */


	core.isObject = function isObject(val) {
		var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
		return type === 'object' && val !== null || type === 'function';
	};

	/**
  * Returns true if value is a Promise.
  * @param {*} val
  * @return {Boolean}
  */


	core.isPromise = function isPromise(val) {
		return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
	};

	/**
  * Returns true if value is a string.
  * @param {*} val
  * @return {Boolean}
  */


	core.isString = function isString(val) {
		return typeof val === 'string';
	};

	/**
  * Merges the values of a static property a class with the values of that
  * property for all its super classes, and stores it as a new static
  * property of that class. If the static property already existed, it won't
  * be recalculated.
  * @param {!function()} constructor Class constructor.
  * @param {string} propertyName Property name to be collected.
  * @param {function(*, *):*=} opt_mergeFn Function that receives an array filled
  *   with the values of the property for the current class and all its super classes.
  *   Should return the merged value to be stored on the current class.
  * @return {boolean} Returns true if merge happens, false otherwise.
  */


	core.mergeSuperClassesProperty = function mergeSuperClassesProperty(constructor, propertyName, opt_mergeFn) {
		var mergedName = propertyName + '_MERGED';
		if (constructor.hasOwnProperty(mergedName)) {
			return false;
		}

		var merged = core.collectSuperClassesProperty(constructor, propertyName);
		if (opt_mergeFn) {
			merged = opt_mergeFn(merged);
		}
		constructor[mergedName] = merged;
		return true;
	};

	/**
  * Null function used for default values of callbacks, etc.
  * @return {void} Nothing.
  */


	core.nullFunction = function nullFunction() {};

	return core;
}();

/**
 * Unique id property prefix.
 * @type {String}
 * @protected
 */


core.UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);

/**
 * Counter for unique id.
 * @type {Number}
 * @private
 */
core.uniqueIdCounter_ = 1;

exports.default = core;

},{}],45:[function(require,module,exports){
'use strict';

/**
 * Disposable utility. When inherited provides the `dispose` function to its
 * subclass, which is responsible for disposing of any object references
 * when an instance won't be used anymore. Subclasses should override
 * `disposeInternal` to implement any specific disposing logic.
 * @constructor
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Disposable = function () {
	function Disposable() {
		_classCallCheck(this, Disposable);

		/**
   * Flag indicating if this instance has already been disposed.
   * @type {boolean}
   * @protected
   */
		this.disposed_ = false;
	}

	/**
  * Disposes of this instance's object references. Calls `disposeInternal`.
  */


	Disposable.prototype.dispose = function dispose() {
		if (!this.disposed_) {
			this.disposeInternal();
			this.disposed_ = true;
		}
	};

	/**
  * Subclasses should override this method to implement any specific
  * disposing logic (like clearing references and calling `dispose` on other
  * disposables).
  */


	Disposable.prototype.disposeInternal = function disposeInternal() {};

	/**
  * Checks if this instance has already been disposed.
  * @return {boolean}
  */


	Disposable.prototype.isDisposed = function isDisposed() {
		return this.disposed_;
	};

	return Disposable;
}();

exports.default = Disposable;

},{}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.string = exports.object = exports.Disposable = exports.async = exports.array = exports.core = undefined;

var _core = require('./core');

var _core2 = _interopRequireDefault(_core);

var _array = require('./array/array');

var _array2 = _interopRequireDefault(_array);

var _async = require('./async/async');

var _async2 = _interopRequireDefault(_async);

var _Disposable = require('./disposable/Disposable');

var _Disposable2 = _interopRequireDefault(_Disposable);

var _object = require('./object/object');

var _object2 = _interopRequireDefault(_object);

var _string = require('./string/string');

var _string2 = _interopRequireDefault(_string);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _core2.default;
exports.core = _core2.default;
exports.array = _array2.default;
exports.async = _async2.default;
exports.Disposable = _Disposable2.default;
exports.object = _object2.default;
exports.string = _string2.default;

},{"./array/array":42,"./async/async":43,"./core":44,"./disposable/Disposable":45,"./object/object":47,"./string/string":48}],47:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var object = function () {
	function object() {
		_classCallCheck(this, object);
	}

	/**
  * Copies all the members of a source object to a target object.
  * @param {Object} target Target object.
  * @param {...Object} var_args The objects from which values will be copied.
  * @return {Object} Returns the target object reference.
  */

	object.mixin = function mixin(target) {
		var key, source;
		for (var i = 1; i < arguments.length; i++) {
			source = arguments[i];
			for (key in source) {
				target[key] = source[key];
			}
		}
		return target;
	};

	/**
  * Returns an object based on its fully qualified external name.
  * @param {string} name The fully qualified name.
  * @param {object=} opt_obj The object within which to look; default is
  *     <code>window</code>.
  * @return {?} The value (object or primitive) or, if not found, undefined.
  */


	object.getObjectByName = function getObjectByName(name, opt_obj) {
		var scope = opt_obj || window;
		var parts = name.split('.');
		return parts.reduce(function (part, key) {
			return part[key];
		}, scope);
	};

	/**
  * Returns a new object with the same keys as the given one, but with
  * their values set to the return values of the specified function.
  * @param {!Object} obj
  * @param {!function(string, *)} fn
  * @return {!Object}
  */


	object.map = function map(obj, fn) {
		var mappedObj = {};
		var keys = Object.keys(obj);
		for (var i = 0; i < keys.length; i++) {
			mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
		}
		return mappedObj;
	};

	return object;
}();

exports.default = object;

},{}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var string = function () {
	function string() {
		_classCallCheck(this, string);
	}

	/**
  * Removes the breaking spaces from the left and right of the string and
  * collapses the sequences of breaking spaces in the middle into single spaces.
  * The original and the result strings render the same way in HTML.
  * @param {string} str A string in which to collapse spaces.
  * @return {string} Copy of the string with normalized breaking spaces.
  */

	string.collapseBreakingSpaces = function collapseBreakingSpaces(str) {
		return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
	};

	/**
 * Returns a string with at least 64-bits of randomness.
 * @return {string} A random string, e.g. sn1s7vb4gcic.
 */


	string.getRandomString = function getRandomString() {
		var x = 2147483648;
		return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
	};

	/**
  * Calculates the hashcode for a string. The hashcode value is computed by
  * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
  * property of using 31 prime is that the multiplication can be replaced by
  * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
  * Modern VMs do this sort of optimization automatically.
  * @param {String} val Target string.
  * @return {Number} Returns the string hashcode.
  */


	string.hashCode = function hashCode(val) {
		var hash = 0;
		for (var i = 0, len = val.length; i < len; i++) {
			hash = 31 * hash + val.charCodeAt(i);
			hash %= 0x100000000;
		}
		return hash;
	};

	/**
  * Replaces interval into the string with specified value, e.g.
  * `replaceInterval("abcde", 1, 4, "")` returns "ae".
  * @param {string} str The input string.
  * @param {Number} start Start interval position to be replaced.
  * @param {Number} end End interval position to be replaced.
  * @param {string} value The value that replaces the specified interval.
  * @return {string}
  */


	string.replaceInterval = function replaceInterval(str, start, end, value) {
		return str.substring(0, start) + value + str.substring(end);
	};

	return string;
}();

exports.default = string;

},{}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../../metal/src/metal');

var _dom = require('../../../metal-dom/src/all/dom');

var _dom2 = _interopRequireDefault(_dom);

var _Promise = require('../../../metal-promise/src/promise/Promise');

var _Promise2 = _interopRequireDefault(_Promise);

var _events = require('../../../metal-events/src/events');

var _utils = require('../utils/utils');

var _utils2 = _interopRequireDefault(_utils);

var _globals = require('../globals/globals');

var _globals2 = _interopRequireDefault(_globals);

var _Route = require('../route/Route');

var _Route2 = _interopRequireDefault(_Route);

var _Screen = require('../screen/Screen');

var _Screen2 = _interopRequireDefault(_Screen);

var _Surface = require('../surface/Surface');

var _Surface2 = _interopRequireDefault(_Surface);

var _Uri = require('../../../metal-uri/src/Uri');

var _Uri2 = _interopRequireDefault(_Uri);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App = function (_EventEmitter) {
	_inherits(App, _EventEmitter);

	/**
  * App class that handle routes and screens lifecycle.
  * @constructor
  * @extends {EventEmitter}
  */

	function App() {
		_classCallCheck(this, App);

		/**
   * Holds the active screen.
   * @type {?Screen}
   * @protected
   */

		var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

		_this.activeScreen = null;

		/**
   * Holds the active path containing the query parameters.
   * @type {?string}
   * @protected
   */
		_this.activePath = null;

		/**
   * Allows prevent navigate from dom prevented event.
   * @type {boolean}
   * @default true
   * @protected
   */
		_this.allowPreventNavigate = true;

		/**
   * Holds link base path.
   * @type {!string}
   * @default ''
   * @protected
   */
		_this.basePath = '';

		/**
   * Captures scroll position from scroll event.
   * @type {!boolean}
   * @default true
   * @protected
   */
		_this.captureScrollPositionFromScrollEvent = true;

		/**
   * Holds the default page title.
   * @type {string}
   * @default null
   * @protected
   */
		_this.defaultTitle = _globals2.default.document.title;

		/**
   * Holds the form selector to define forms that are routed.
   * @type {!string}
   * @default form[enctype="multipart/form-data"]:not([data-senna-off])
   * @protected
   */
		_this.formSelector = 'form[enctype="multipart/form-data"]:not([data-senna-off])';

		/**
   * Holds the link selector to define links that are routed.
   * @type {!string}
   * @default a:not([data-senna-off])
   * @protected
   */
		_this.linkSelector = 'a:not([data-senna-off])';

		/**
   * Holds the loading css class.
   * @type {!string}
   * @default senna-loading
   * @protected
   */
		_this.loadingCssClass = 'senna-loading';

		/**
   * Using the History API to manage your URLs is awesome and, as it happens,
   * a crucial feature of good web apps. One of its downsides, however, is
   * that scroll positions are stored and then, more importantly, restored
   * whenever you traverse the history. This often means unsightly jumps as
   * the scroll position changes automatically, and especially so if your app
   * does transitions, or changes the contents of the page in any way.
   * Ultimately this leads to an horrible user experience. The good news is,
   * however, that there’s a potential fix: history.scrollRestoration.
   * https://developers.google.com/web/updates/2015/09/history-api-scroll-restoration
   * @type {boolean}
   * @protected
   */
		_this.nativeScrollRestorationSupported = 'scrollRestoration' in _globals2.default.window.history;

		/**
   * Holds a deferred with the current navigation.
   * @type {?CancellablePromise}
   * @default null
   * @protected
   */
		_this.pendingNavigate = null;

		/**
   * Holds the window horizontal scroll position when the navigation using
   * back or forward happens to be restored after the surfaces are updated.
   * @type {!Number}
   * @default 0
   * @protected
   */
		_this.popstateScrollLeft = 0;

		/**
   * Holds the window vertical scroll position when the navigation using
   * back or forward happens to be restored after the surfaces are updated.
   * @type {!Number}
   * @default 0
   * @protected
   */
		_this.popstateScrollTop = 0;

		/**
   * Holds the redirect path containing the query parameters.
   * @type {?string}
   * @protected
   */
		_this.redirectPath = null;

		/**
   * Holds the screen routes configuration.
   * @type {?Array}
   * @default []
   * @protected
   */
		_this.routes = [];

		/**
   * Maps the screen instances by the url containing the parameters.
   * @type {?Object}
   * @default {}
   * @protected
   */
		_this.screens = {};

		/**
   * When set to true the first erroneous popstate fired on page load will be
   * ignored, only if <code>globals.window.history.state</code> is also
   * <code>null</code>.
   * @type {boolean}
   * @default false
   * @protected
   */
		_this.skipLoadPopstate = false;

		/**
   * Maps that index the surfaces instances by the surface id.
   * @type {?Object}
   * @default {}
   * @protected
   */
		_this.surfaces = {};

		/**
   * When set to true, moves the scroll position after popstate, or to the
   * top of the viewport for new navigation. If false, the browser will
   * take care of scroll restoration.
   * @type {!boolean}
   * @default true
   * @protected
   */
		_this.updateScrollPosition = true;

		_this.appEventHandlers_ = new _events.EventHandler();

		_this.appEventHandlers_.add(_dom2.default.on(_globals2.default.window, 'scroll', _this.onScroll_.bind(_this)), _dom2.default.on(_globals2.default.window, 'load', _this.onLoad_.bind(_this)), _dom2.default.on(_globals2.default.window, 'popstate', _this.onPopstate_.bind(_this)));

		_this.on('startNavigate', _this.onStartNavigate_);
		_this.on('beforeNavigate', _this.onBeforeNavigate_);
		_this.on('beforeNavigate', _this.onBeforeNavigateDefault_, true);

		_this.setLinkSelector(_this.linkSelector);
		_this.setFormSelector(_this.formSelector);
		return _this;
	}

	/**
  * Adds one or more screens to the application.
  *
  * Example:
  *
  * <code>
  *   app.addRoutes({ path: '/foo', handler: FooScreen });
  *   or
  *   app.addRoutes([{ path: '/foo', handler: function(route) { return new FooScreen(); } }]);
  * </code>
  *
  * @param {Object} or {Array} routes Single object or an array of object.
  *     Each object should contain <code>path</code> and <code>screen</code>.
  *     The <code>path</code> should be a string or a regex that maps the
  *     navigation route to a screen class definition (not an instance), e.g:
  *         <code>{ path: "/home:param1", handler: MyScreen }</code>
  *         <code>{ path: /foo.+/, handler: MyScreen }</code>
  * @chainable
  */


	App.prototype.addRoutes = function addRoutes(routes) {
		var _this2 = this;

		if (!Array.isArray(routes)) {
			routes = [routes];
		}
		routes.forEach(function (route) {
			if (!(route instanceof _Route2.default)) {
				route = new _Route2.default(route.path, route.handler);
			}
			_this2.routes.push(route);
		});
		return this;
	};

	/**
  * Adds one or more surfaces to the application.
  * @param {Surface|String|Array.<Surface|String>} surfaces
  *     Surface element id or surface instance. You can also pass an Array
  *     whichcontains surface instances or id. In case of ID, these should be
  *     the id of surface element.
  * @chainable
  */


	App.prototype.addSurfaces = function addSurfaces(surfaces) {
		var _this3 = this;

		if (!Array.isArray(surfaces)) {
			surfaces = [surfaces];
		}
		surfaces.forEach(function (surface) {
			if (_metal.core.isString(surface)) {
				surface = new _Surface2.default(surface);
			}
			_this3.surfaces[surface.getId()] = surface;
		});
		return this;
	};

	/**
  * Returns if can navigate to path.
  * @param {!string} url
  * @return {boolean}
  */


	App.prototype.canNavigate = function canNavigate(url) {
		var path = _utils2.default.getUrlPath(url);
		var uri = new _Uri2.default(url);

		if (!this.isLinkSameOrigin_(uri.getHostname())) {
			console.log('Offsite link clicked');
			return false;
		}
		if (!this.isSameBasePath_(path)) {
			console.log('Link clicked outside app\'s base path');
			return false;
		}
		if (!this.findRoute(path)) {
			console.log('No route for ' + path);
			return false;
		}

		return true;
	};

	/**
  * Clear screens cache.
  * @chainable
  */


	App.prototype.clearScreensCache = function clearScreensCache() {
		var _this4 = this;

		Object.keys(this.screens).forEach(function (path) {
			if (path === _this4.activePath) {
				_this4.activeScreen.clearCache();
			} else {
				_this4.removeScreen(path);
			}
		});
	};

	/**
  * Retrieves or create a screen instance to a path.
  * @param {!string} path Path containing the querystring part.
  * @return {Screen}
  */


	App.prototype.createScreenInstance = function createScreenInstance(path, route) {
		if (!this.pendingNavigate && path === this.activePath) {
			console.log('Already at destination, refresh navigation');
			return this.activeScreen;
		}
		/* jshint newcap: false */
		var screen = this.screens[path];
		if (!screen) {
			var handler = route.getHandler();
			if (handler === _Screen2.default || _Screen2.default.isImplementedBy(handler.prototype)) {
				screen = new handler();
			} else {
				screen = handler(route) || new _Screen2.default();
			}
			console.log('Create screen for [' + path + '] [' + screen + ']');
		}
		return screen;
	};

	/**
  * @inheritDoc
  */


	App.prototype.disposeInternal = function disposeInternal() {
		if (this.activeScreen) {
			this.removeScreen(this.activePath);
		}
		this.clearScreensCache();
		this.formEventHandler_.removeListener();
		this.linkEventHandler_.removeListener();
		this.appEventHandlers_.removeAllListeners();
		_EventEmitter.prototype.disposeInternal.call(this);
	};

	/**
  * Dispatches to the first route handler that matches the current path, if
  * any.
  * @return {CancellablePromise} Returns a pending request cancellable promise.
  */


	App.prototype.dispatch = function dispatch() {
		return this.navigate(_utils2.default.getCurrentBrowserPath(), true);
	};

	/**
  * Starts navigation to a path.
  * @param {!string} path Path containing the querystring part.
  * @param {boolean=} opt_replaceHistory Replaces browser history.
  * @return {CancellablePromise} Returns a pending request cancellable promise.
  */


	App.prototype.doNavigate_ = function doNavigate_(path, opt_replaceHistory) {
		var _this5 = this;

		if (this.activeScreen && this.activeScreen.beforeDeactivate()) {
			this.pendingNavigate = _Promise2.default.reject(new _Promise2.default.CancellationError('Cancelled by active screen'));
			return this.pendingNavigate;
		}

		var route = this.findRoute(path);
		if (!route) {
			this.pendingNavigate = _Promise2.default.reject(new _Promise2.default.CancellationError('No route for ' + path));
			return this.pendingNavigate;
		}

		console.log('Navigate to [' + path + ']');

		this.stopPendingNavigate_();

		var nextScreen = this.createScreenInstance(path, route);

		return nextScreen.load(path).then(function () {
			if (_this5.activeScreen) {
				_this5.activeScreen.deactivate();
			}
			_this5.prepareNavigateHistory_(path, nextScreen, opt_replaceHistory);
			_this5.prepareNavigateSurfaces_(nextScreen, _this5.surfaces);
		}).then(function () {
			return nextScreen.evaluateStyles(_this5.surfaces);
		}).then(function () {
			return nextScreen.flip(_this5.surfaces);
		}).then(function () {
			return nextScreen.evaluateScripts(_this5.surfaces);
		}).then(function () {
			return _this5.syncScrollPositionSyncThenAsync_();
		}).then(function () {
			return _this5.finalizeNavigate_(path, nextScreen);
		}).catch(function (reason) {
			_this5.handleNavigateError_(path, nextScreen, reason);
			throw reason;
		});
	};

	/**
  * Finalizes a screen navigation.
  * @param {!string} path Path containing the querystring part.
  * @param {!Screen} nextScreen
  * @protected
  */


	App.prototype.finalizeNavigate_ = function finalizeNavigate_(path, nextScreen) {
		nextScreen.activate();

		if (this.activeScreen && !this.activeScreen.isCacheable()) {
			if (this.activeScreen !== nextScreen) {
				this.removeScreen(this.activePath);
			}
		}

		this.activePath = path;
		this.activeScreen = nextScreen;
		this.screens[path] = nextScreen;
		this.pendingNavigate = null;
		_globals2.default.capturedFormElement = null;
		console.log('Navigation done');
	};

	/**
  * Finds a route for the test path. Returns true if matches has a route,
  * otherwise returns null.
  * @param {!string} path Path containing the querystring part.
  * @return {?Object} Route handler if match any or <code>null</code> if the
  *     path is the same as the current url and the path contains a fragment.
  */


	App.prototype.findRoute = function findRoute(path) {
		// Prevents navigation if it's a hash change on the same url.
		if (path.lastIndexOf('#') > -1 && _utils2.default.isCurrentBrowserPath(path)) {
			return null;
		}

		path = _utils2.default.getUrlPathWithoutHash(path);

		// Makes sure that the path substring will be in the expected format
		// (that is, will end with a "/").
		path = _utils2.default.getUrlPathWithoutHash(path.substr(this.basePath.length));

		for (var i = 0; i < this.routes.length; i++) {
			var route = this.routes[i];
			if (route.matchesPath(path)) {
				return route;
			}
		}

		return null;
	};

	/**
  * Gets allow prevent navigate.
  * @return {boolean}
  */


	App.prototype.getAllowPreventNavigate = function getAllowPreventNavigate() {
		return this.allowPreventNavigate;
	};

	/**
  * Gets link base path.
  * @return {!string}
  */


	App.prototype.getBasePath = function getBasePath() {
		return this.basePath;
	};

	/**
  * Gets the default page title.
  * @return {string} defaultTitle
  */


	App.prototype.getDefaultTitle = function getDefaultTitle() {
		return this.defaultTitle;
	};

	/**
  * Gets the form selector.
  * @return {!string}
  */


	App.prototype.getFormSelector = function getFormSelector() {
		return this.formSelector;
	};

	/**
  * Gets the link selector.
  * @return {!string}
  */


	App.prototype.getLinkSelector = function getLinkSelector() {
		return this.linkSelector;
	};

	/**
  * Gets the loading css class.
  * @return {!string}
  */


	App.prototype.getLoadingCssClass = function getLoadingCssClass() {
		return this.loadingCssClass;
	};

	/**
  * Gets the update scroll position value.
  * @return {boolean}
  */


	App.prototype.getUpdateScrollPosition = function getUpdateScrollPosition() {
		return this.updateScrollPosition;
	};

	/**
  * Handle navigation error.
  * @param {!string} path Path containing the querystring part.
  * @param {!Screen} nextScreen
  * @param {!Error} error
  * @protected
  */


	App.prototype.handleNavigateError_ = function handleNavigateError_(path, nextScreen, err) {
		console.log('Navigation error for [' + nextScreen + '] (' + err + ')');
		if (!_utils2.default.isCurrentBrowserPath(path)) {
			this.removeScreen(path);
		}
	};

	/**
  * Checks if app has routes.
  * @return {boolean}
  */


	App.prototype.hasRoutes = function hasRoutes() {
		return this.routes.length > 0;
	};

	/**
  * Tests if hostname is an offsite link.
  * @param {!string} hostname Link hostname to compare with
  *     <code>globals.window.location.hostname</code>.
  * @return {boolean}
  * @protected
  */


	App.prototype.isLinkSameOrigin_ = function isLinkSameOrigin_(hostname) {
		return hostname === _globals2.default.window.location.hostname;
	};

	/**
  * Tests if link element has the same app's base path.
  * @param {!string} path Link path containing the querystring part.
  * @return {boolean}
  * @protected
  */


	App.prototype.isSameBasePath_ = function isSameBasePath_(path) {
		return path.indexOf(this.basePath) === 0;
	};

	/**
  * Lock the document scroll in order to avoid the browser native back and
  * forward navigation to change the scroll position. In the end of
  * navigation lifecycle scroll is repositioned.
  * @protected
  */


	App.prototype.lockHistoryScrollPosition_ = function lockHistoryScrollPosition_() {
		var state = _globals2.default.window.history.state;
		if (!state) {
			return;
		}
		// Browsers are inconsistent when re-positioning the scroll history on
		// popstate. At some browsers, history scroll happens before popstate, then
		// lock the scroll on the last known position as soon as possible after the
		// current JS execution context and capture the current value. Some others,
		// history scroll happens after popstate, in this case, we bind an once
		// scroll event to lock the las known position. Lastly, the previous two
		// behaviors can happen even on the same browser, hence the race will decide
		// the winner.
		var winner = false;
		var switchScrollPositionRace = function switchScrollPositionRace() {
			_globals2.default.document.removeEventListener('scroll', switchScrollPositionRace, false);
			if (!winner) {
				_globals2.default.window.scrollTo(state.scrollLeft, state.scrollTop);
				winner = true;
			}
		};
		_metal.async.nextTick(switchScrollPositionRace);
		_globals2.default.document.addEventListener('scroll', switchScrollPositionRace, false);
	};

	/**
  * If supported by the browser, disables native scroll restoration and
  * stores current value.
  */


	App.prototype.maybeDisableNativeScrollRestoration = function maybeDisableNativeScrollRestoration() {
		if (this.nativeScrollRestorationSupported) {
			this.nativeScrollRestoration_ = _globals2.default.window.history.scrollRestoration;
			_globals2.default.window.history.scrollRestoration = 'manual';
		}
	};

	/**
  * Maybe navigate to a path.
  * @param {string} href Information about the link's href.
  * @param {Event} event Dom event that initiated the navigation.
  */


	App.prototype.maybeNavigate_ = function maybeNavigate_(href, event) {
		if (!this.canNavigate(href)) {
			return;
		}

		if (this.allowPreventNavigate && event.defaultPrevented) {
			console.log('Navigate prevented');
			return;
		}

		_globals2.default.capturedFormElement = event.capturedFormElement;

		var navigateFailed = false;
		try {
			this.navigate(_utils2.default.getUrlPath(href));
		} catch (err) {
			// Do not prevent link navigation in case some synchronous error occurs
			navigateFailed = true;
		}

		if (!navigateFailed) {
			event.preventDefault();
		}
	};

	/**
  * Maybe reposition scroll to hashed anchor.
  */


	App.prototype.maybeRepositionScrollToHashedAnchor = function maybeRepositionScrollToHashedAnchor() {
		var hash = _globals2.default.window.location.hash;
		if (hash) {
			var anchorElement = _globals2.default.document.getElementById(hash.substring(1));
			if (anchorElement) {
				_globals2.default.window.scrollTo(anchorElement.offsetLeft, anchorElement.offsetTop);
			}
		}
	};

	/**
  * If supported by the browser, restores native scroll restoration to the
  * value captured by `maybeDisableNativeScrollRestoration`.
  */


	App.prototype.maybeRestoreNativeScrollRestoration = function maybeRestoreNativeScrollRestoration() {
		if (this.nativeScrollRestorationSupported && this.nativeScrollRestoration_) {
			_globals2.default.window.history.scrollRestoration = this.nativeScrollRestoration_;
		}
	};

	/**
  * Navigates to the specified path if there is a route handler that matches.
  * @param {!string} path Path to navigate containing the base path.
  * @param {boolean=} opt_replaceHistory Replaces browser history.
  * @return {CancellablePromise} Returns a pending request cancellable promise.
  */


	App.prototype.navigate = function navigate(path, opt_replaceHistory) {
		if (!_utils2.default.isHtml5HistorySupported()) {
			throw new Error('HTML5 History is not supported. Senna will not intercept navigation.');
		}

		// When reloading the same path do replaceState instead of pushState to
		// avoid polluting history with states with the same path.
		if (path === this.activePath) {
			opt_replaceHistory = true;
		}

		this.emit('beforeNavigate', {
			path: path,
			replaceHistory: !!opt_replaceHistory
		});

		return this.pendingNavigate;
	};

	/**
  * Befores navigation to a path.
  * @param {!Event} event Event facade containing <code>path</code> and
  *     <code>replaceHistory</code>.
  * @protected
  */


	App.prototype.onBeforeNavigate_ = function onBeforeNavigate_(event) {
		if (_globals2.default.capturedFormElement) {
			event.form = _globals2.default.capturedFormElement;
		}
	};

	/**
  * Befores navigation to a path. Runs after external listeners.
  * @param {!Event} event Event facade containing <code>path</code> and
  *     <code>replaceHistory</code>.
  * @protected
  */


	App.prototype.onBeforeNavigateDefault_ = function onBeforeNavigateDefault_(event) {
		if (this.pendingNavigate) {
			if (this.pendingNavigate.path === event.path) {
				console.log('Waiting...');
				return;
			}
		}

		this.emit('startNavigate', {
			form: event.form,
			path: event.path,
			replaceHistory: event.replaceHistory
		});
	};

	/**
  * Intercepts document clicks and test link elements in order to decide
  * whether Surface app can navigate.
  * @param {!Event} event Event facade
  * @protected
  */


	App.prototype.onDocClickDelegate_ = function onDocClickDelegate_(event) {
		if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey || event.button) {
			console.log('Navigate aborted, invalid mouse button or modifier key pressed.');
			return;
		}
		this.maybeNavigate_(event.delegateTarget.href, event);
	};

	/**
  * Intercepts document form submits and test action path in order to decide
  * whether Surface app can navigate.
  * @param {!Event} event Event facade
  * @protected
  */


	App.prototype.onDocSubmitDelegate_ = function onDocSubmitDelegate_(event) {
		var form = event.delegateTarget;
		if (form.method === 'get') {
			console.log('GET method not supported');
			return;
		}
		event.capturedFormElement = form;
		this.maybeNavigate_(form.action, event);
	};

	/**
  * Listens to the window's load event in order to avoid issues with some browsers
  * that trigger popstate calls on the first load. For more information see
  * http://stackoverflow.com/questions/6421769/popstate-on-pages-load-in-chrome.
  * @protected
  */


	App.prototype.onLoad_ = function onLoad_() {
		var _this6 = this;

		this.skipLoadPopstate = true;
		setTimeout(function () {
			// The timeout ensures that popstate events will be unblocked right
			// after the load event occured, but not in the same event-loop cycle.
			_this6.skipLoadPopstate = false;
		}, 0);
		// Try to reposition scroll to the hashed anchor when page loads.
		this.maybeRepositionScrollToHashedAnchor();
	};

	/**
  * Handles browser history changes and fires app's navigation if the state
  * belows to us. If we detect a popstate and the state is <code>null</code>,
  * assume it is navigating to an external page or to a page we don't have
  * route, then <code>globals.window.location.reload()</code> is invoked in order to
  * reload the content to the current url.
  * @param {!Event} event Event facade
  * @protected
  */


	App.prototype.onPopstate_ = function onPopstate_(event) {
		if (this.skipLoadPopstate) {
			return;
		}

		var state = event.state;

		if (!state) {
			if (_globals2.default.window.location.hash) {
				// If senna is on an redirect path and a hash popstate happens
				// to a different url, reload the browser. This behavior doesn't
				// require senna to route hashed links and is closer to native
				// browser behavior.
				if (this.redirectPath && !_utils2.default.isCurrentBrowserPath(this.redirectPath)) {
					this.reloadPage();
				}
				// Always try to reposition scroll to the hashed anchor when
				// hash popstate happens.
				this.maybeRepositionScrollToHashedAnchor();
			} else {
				this.reloadPage();
			}
			return;
		}

		if (state.senna) {
			console.log('History navigation to [' + state.path + ']');
			this.popstateScrollTop = state.scrollTop;
			this.popstateScrollLeft = state.scrollLeft;
			if (!this.nativeScrollRestorationSupported) {
				this.lockHistoryScrollPosition_();
			}
			this.navigate(state.path, true);
		}
	};

	/**
  * Listens document scroll changes in order to capture the possible lock
  * scroll position for history scrolling.
  * @protected
  */


	App.prototype.onScroll_ = function onScroll_() {
		if (this.captureScrollPositionFromScrollEvent) {
			this.saveHistoryCurrentPageScrollPosition_();
		}
	};

	/**
  * Starts navigation to a path.
  * @param {!Event} event Event facade containing <code>path</code> and
  *     <code>replaceHistory</code>.
  * @protected
  */


	App.prototype.onStartNavigate_ = function onStartNavigate_(event) {
		var _this7 = this;

		this.maybeDisableNativeScrollRestoration();
		this.captureScrollPositionFromScrollEvent = false;
		_dom2.default.addClasses(_globals2.default.document.documentElement, this.loadingCssClass);

		var endNavigatePayload = {
			form: event.form,
			path: event.path
		};

		this.pendingNavigate = this.doNavigate_(event.path, event.replaceHistory).catch(function (reason) {
			endNavigatePayload.error = reason;
			throw reason;
		}).thenAlways(function () {
			if (!_this7.pendingNavigate) {
				_dom2.default.removeClasses(_globals2.default.document.documentElement, _this7.loadingCssClass);
				_this7.maybeRestoreNativeScrollRestoration();
				_this7.captureScrollPositionFromScrollEvent = true;
			}
			_this7.emit('endNavigate', endNavigatePayload);
		});

		this.pendingNavigate.path = event.path;
	};

	/**
  * Prefetches the specified path if there is a route handler that matches.
  * @param {!string} path Path to navigate containing the base path.
  * @return {CancellablePromise} Returns a pending request cancellable promise.
  */


	App.prototype.prefetch = function prefetch(path) {
		var _this8 = this;

		var route = this.findRoute(path);
		if (!route) {
			return _Promise2.default.reject(new _Promise2.default.CancellationError('No route for ' + path));
		}

		console.log('Prefetching [' + path + ']');

		var nextScreen = this.createScreenInstance(path, route);

		return nextScreen.load(path).then(function () {
			return _this8.screens[path] = nextScreen;
		}).catch(function (reason) {
			_this8.handleNavigateError_(path, nextScreen, reason);
			throw reason;
		});
	};

	/**
  * Prepares screen flip. Updates history state and surfaces content.
  * @param {!string} path Path containing the querystring part.
  * @param {!Screen} nextScreen
  * @param {boolean=} opt_replaceHistory Replaces browser history.
  */


	App.prototype.prepareNavigateHistory_ = function prepareNavigateHistory_(path, nextScreen, opt_replaceHistory) {
		var title = nextScreen.getTitle();
		if (!_metal.core.isString(title)) {
			title = this.getDefaultTitle();
		}
		var redirectPath = nextScreen.beforeUpdateHistoryPath(path);
		var historyState = {
			form: _metal.core.isDefAndNotNull(_globals2.default.capturedFormElement),
			redirectPath: redirectPath,
			path: path,
			senna: true,
			scrollTop: 0,
			scrollLeft: 0
		};
		if (opt_replaceHistory) {
			historyState.scrollTop = this.popstateScrollTop;
			historyState.scrollLeft = this.popstateScrollLeft;
		}
		this.updateHistory_(title, redirectPath, nextScreen.beforeUpdateHistoryState(historyState), opt_replaceHistory);
		this.redirectPath = redirectPath;
	};

	/**
  * Prepares screen flip. Updates history state and surfaces content.
  * @param {!Screen} nextScreen
  * @param {!object} surfaces Map of surfaces to flip keyed by surface id.
  */


	App.prototype.prepareNavigateSurfaces_ = function prepareNavigateSurfaces_(nextScreen, surfaces) {
		Object.keys(surfaces).forEach(function (id) {
			var surfaceContent = nextScreen.getSurfaceContent(id);
			surfaces[id].addContent(nextScreen.getId(), surfaceContent);
			console.log('Screen [' + nextScreen.getId() + '] add content to surface ' + '[' + surfaces[id] + '] [' + (_metal.core.isDefAndNotNull(surfaceContent) ? '...' : 'empty') + ']');
		});
	};

	/**
  * Reloads the page by performing `window.location.reload()`.
  */


	App.prototype.reloadPage = function reloadPage() {
		_globals2.default.window.location.reload();
	};

	/**
  * Removes route instance from app routes.
  * @param {Route} route
  * @return {boolean} True if an element was removed.
  */


	App.prototype.removeRoute = function removeRoute(route) {
		return _metal.array.remove(this.routes, route);
	};

	/**
  * Removes a screen.
  * @param {!string} path Path containing the querystring part.
  */


	App.prototype.removeScreen = function removeScreen(path) {
		var _this9 = this;

		var screen = this.screens[path];
		if (screen) {
			Object.keys(this.surfaces).forEach(function (surfaceId) {
				return _this9.surfaces[surfaceId].remove(screen.getId());
			});
			screen.dispose();
			delete this.screens[path];
		}
	};

	/**
  * Saves scroll position from page offset into history state.
  */


	App.prototype.saveHistoryCurrentPageScrollPosition_ = function saveHistoryCurrentPageScrollPosition_() {
		var state = _globals2.default.window.history.state;
		if (state && state.senna) {
			state.scrollTop = _globals2.default.window.pageYOffset;
			state.scrollLeft = _globals2.default.window.pageXOffset;
			_globals2.default.window.history.replaceState(state, null, null);
		}
	};

	/**
  * Sets allow prevent navigate.
  * @param {boolean} allowPreventNavigate
  */


	App.prototype.setAllowPreventNavigate = function setAllowPreventNavigate(allowPreventNavigate) {
		this.allowPreventNavigate = allowPreventNavigate;
	};

	/**
  * Sets link base path.
  * @param {!string} path
  */


	App.prototype.setBasePath = function setBasePath(basePath) {
		this.basePath = basePath;
	};

	/**
  * Sets the default page title.
  * @param {string} defaultTitle
  */


	App.prototype.setDefaultTitle = function setDefaultTitle(defaultTitle) {
		this.defaultTitle = defaultTitle;
	};

	/**
  * Sets the form selector.
  * @param {!string} formSelector
  */


	App.prototype.setFormSelector = function setFormSelector(formSelector) {
		this.formSelector = formSelector;
		if (this.formEventHandler_) {
			this.formEventHandler_.removeListener();
		}
		this.formEventHandler_ = _dom2.default.delegate(document, 'submit', this.formSelector, this.onDocSubmitDelegate_.bind(this));
	};

	/**
  * Sets the link selector.
  * @param {!string} linkSelector
  */


	App.prototype.setLinkSelector = function setLinkSelector(linkSelector) {
		this.linkSelector = linkSelector;
		if (this.linkEventHandler_) {
			this.linkEventHandler_.removeListener();
		}
		this.linkEventHandler_ = _dom2.default.delegate(document, 'click', this.linkSelector, this.onDocClickDelegate_.bind(this));
	};

	/**
  * Sets the loading css class.
  * @param {!string} loadingCssClass
  */


	App.prototype.setLoadingCssClass = function setLoadingCssClass(loadingCssClass) {
		this.loadingCssClass = loadingCssClass;
	};

	/**
  * Sets the update scroll position value.
  * @param {boolean} updateScrollPosition
  */


	App.prototype.setUpdateScrollPosition = function setUpdateScrollPosition(updateScrollPosition) {
		this.updateScrollPosition = updateScrollPosition;
	};

	/**
  * Cancels pending navigate with <code>Cancel pending navigation</code> error.
  * @protected
  */


	App.prototype.stopPendingNavigate_ = function stopPendingNavigate_() {
		if (this.pendingNavigate) {
			this.pendingNavigate.cancel('Cancel pending navigation');
			this.pendingNavigate = null;
		}
	};

	/**
  * Sync document scroll position twice, the first one synchronous and then
  * one inside <code>async.nextTick</code>. Relevant to browsers that fires
  * scroll restoration asynchronously after popstate.
  * @protected
  * @return {?CancellablePromise=}
  */


	App.prototype.syncScrollPositionSyncThenAsync_ = function syncScrollPositionSyncThenAsync_() {
		var _this10 = this;

		var state = _globals2.default.window.history.state;
		if (!state) {
			return;
		}

		var scrollTop = state.scrollTop;
		var scrollLeft = state.scrollLeft;

		var sync = function sync() {
			if (_this10.updateScrollPosition) {
				_globals2.default.window.scrollTo(scrollLeft, scrollTop);
			}
		};

		return new _Promise2.default(function (resolve) {
			return sync() & _metal.async.nextTick(function () {
				return sync() & resolve();
			});
		});
	};

	/**
  * Updates or replace browser history.
  * @param {?string} title Document title.
  * @param {!string} path Path containing the querystring part.
  * @param {!object} state
  * @param {boolean=} opt_replaceHistory Replaces browser history.
  * @protected
  */


	App.prototype.updateHistory_ = function updateHistory_(title, path, state, opt_replaceHistory) {
		if (opt_replaceHistory) {
			_globals2.default.window.history.replaceState(state, title, path);
		} else {
			_globals2.default.window.history.pushState(state, title, path);
		}
		_globals2.default.document.title = title;
	};

	return App;
}(_events.EventEmitter);

exports.default = App;

},{"../../../metal-dom/src/all/dom":13,"../../../metal-events/src/events":23,"../../../metal-promise/src/promise/Promise":31,"../../../metal-uri/src/Uri":38,"../../../metal/src/metal":46,"../globals/globals":52,"../route/Route":53,"../screen/Screen":55,"../surface/Surface":56,"../utils/utils":57}],50:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../../metal/src/metal');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Cacheable = function (_Disposable) {
	_inherits(Cacheable, _Disposable);

	/**
  * Abstract class for defining cacheable behavior.
  * @constructor
  */

	function Cacheable() {
		_classCallCheck(this, Cacheable);

		/**
   * Holds the cached data.
   * @type {!Object}
   * @default null
   * @protected
   */

		var _this = _possibleConstructorReturn(this, _Disposable.call(this));

		_this.cache = null;

		/**
   * Holds whether class is cacheable.
   * @type {boolean}
   * @default false
   * @protected
   */
		_this.cacheable = false;
		return _this;
	}

	/**
  * Adds content to the cache.
  * @param {string} content Content to be cached.
  * @chainable
  */


	Cacheable.prototype.addCache = function addCache(content) {
		if (this.cacheable) {
			this.cache = content;
		}
		return this;
	};

	/**
  * Clears the cache.
  * @chainable
  */


	Cacheable.prototype.clearCache = function clearCache() {
		this.cache = null;
		return this;
	};

	/**
  * Disposes of this instance's object references.
  * @override
  */


	Cacheable.prototype.disposeInternal = function disposeInternal() {
		this.clearCache();
	};

	/**
  * Gets the cached content.
  * @return {Object} Cached content.
  * @protected
  */


	Cacheable.prototype.getCache = function getCache() {
		return this.cache;
	};

	/**
  * Whether the class is cacheable.
  * @return {boolean} Returns true when class is cacheable, false otherwise.
  */


	Cacheable.prototype.isCacheable = function isCacheable() {
		return this.cacheable;
	};

	/**
  * Sets whether the class is cacheable.
  * @param {boolean} cacheable
  */


	Cacheable.prototype.setCacheable = function setCacheable(cacheable) {
		if (!cacheable) {
			this.clearCache();
		}
		this.cacheable = cacheable;
	};

	return Cacheable;
}(_metal.Disposable);

exports.default = Cacheable;

},{"../../../metal/src/metal":46}],51:[function(require,module,exports){
'use strict';

/**
 * Holds value error messages.
 * @const
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var errors = function errors() {
  _classCallCheck(this, errors);
};

/**
 * Invalid status error message.
 * @type {string}
 * @static
 */


errors.INVALID_STATUS = 'Invalid status code';

/**
 * Request error message.
 * @type {string}
 * @static
 */
errors.REQUEST_ERROR = 'Request error';

/**
 * Request timeout error message.
 * @type {string}
 * @static
 */
errors.REQUEST_TIMEOUT = 'Request timeout';

exports.default = errors;

},{}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
var globals = {
	document: document,
	window: window
};

exports.default = globals;

},{}],53:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../../metal/src/metal');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Route = function () {

	/**
  * Route class.
  * @param {!string|RegExp|Function} path
  * @param {!Function} handler
  * @constructor
  */

	function Route(path, handler) {
		_classCallCheck(this, Route);

		if (!_metal.core.isDefAndNotNull(path)) {
			throw new Error('Route path not specified.');
		}
		if (!_metal.core.isFunction(handler)) {
			throw new Error('Route handler is not a function.');
		}

		/**
   * Defines the handler which will execute once a URL in the application
   * matches the path.
   * @type {!Function}
   * @protected
   */
		this.handler = handler;

		/**
   * Defines the path which will trigger the route handler.
   * @type {!string|RegExp|Function}
   * @protected
   */
		this.path = path;
	}

	/**
  * Gets the route handler.
  * @return {!Function}
  */


	Route.prototype.getHandler = function getHandler() {
		return this.handler;
	};

	/**
  * Gets the route path.
  * @return {!string|RegExp|Function}
  */


	Route.prototype.getPath = function getPath() {
		return this.path;
	};

	/**
  * Matches if the router can handle the tested path.
  * @param {!string} value Path to test and may contains the querystring
  *     part.
  * @return {Boolean} Returns true if matches any route.
  */


	Route.prototype.matchesPath = function matchesPath(value) {
		var path = this.path;

		if (_metal.core.isString(path)) {
			return value === path;
		}
		if (_metal.core.isFunction(path)) {
			return path(value);
		}
		if (path instanceof RegExp) {
			return value.search(path) > -1;
		}

		return false;
	};

	return Route;
}();

exports.default = Route;

},{"../../../metal/src/metal":46}],54:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../../metal/src/metal');

var _Ajax = require('../../../metal-ajax/src/Ajax');

var _Ajax2 = _interopRequireDefault(_Ajax);

var _MultiMap = require('../../../metal-multimap/src/MultiMap');

var _MultiMap2 = _interopRequireDefault(_MultiMap);

var _Promise = require('../../../metal-promise/src/promise/Promise');

var _Promise2 = _interopRequireDefault(_Promise);

var _errors = require('../errors/errors');

var _errors2 = _interopRequireDefault(_errors);

var _utils = require('../utils/utils');

var _utils2 = _interopRequireDefault(_utils);

var _globals = require('../globals/globals');

var _globals2 = _interopRequireDefault(_globals);

var _Screen2 = require('./Screen');

var _Screen3 = _interopRequireDefault(_Screen2);

var _Uri = require('../../../metal-uri/src/Uri');

var _Uri2 = _interopRequireDefault(_Uri);

var _UA = require('../../../metal-useragent/src/UA');

var _UA2 = _interopRequireDefault(_UA);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RequestScreen = function (_Screen) {
	_inherits(RequestScreen, _Screen);

	/**
  * Request screen abstract class to perform io operations on descendant
  * screens.
  * @constructor
  * @extends {Screen}
  */

	function RequestScreen() {
		_classCallCheck(this, RequestScreen);

		/**
   * @inheritDoc
   * @default true
   */

		var _this = _possibleConstructorReturn(this, _Screen.call(this));

		_this.cacheable = true;

		/**
   * Holds default http headers to set on request.
   * @type {?Object=}
   * @default {
   *   'X-PJAX': 'true',
   *   'X-Requested-With': 'XMLHttpRequest'
   * }
   * @protected
   */
		_this.httpHeaders = {
			'X-PJAX': 'true',
			'X-Requested-With': 'XMLHttpRequest'
		};

		/**
   * Holds default http method to perform the request.
   * @type {!string}
   * @default RequestScreen.GET
   * @protected
   */
		_this.httpMethod = RequestScreen.GET;

		/**
   * Holds the XHR object responsible for the request.
   * @type {XMLHttpRequest}
   * @default null
   * @protected
   */
		_this.request = null;

		/**
   * Holds the request timeout in milliseconds.
   * @type {!number}
   * @default 30000
   * @protected
   */
		_this.timeout = 30000;
		return _this;
	}

	/**
  * Asserts that response status code is valid.
  * @param {number} status
  * @protected
  */


	RequestScreen.prototype.assertValidResponseStatusCode = function assertValidResponseStatusCode(status) {
		if (!this.isValidResponseStatusCode(status)) {
			var error = new Error(_errors2.default.INVALID_STATUS);
			error.invalidStatus = true;
			throw error;
		}
	};

	/**
  * @inheritDoc
  */


	RequestScreen.prototype.beforeUpdateHistoryPath = function beforeUpdateHistoryPath(path) {
		var redirectPath = this.getRequestPath();
		if (redirectPath && redirectPath !== path) {
			return redirectPath;
		}
		return path;
	};

	/**
  * @inheritDoc
  */


	RequestScreen.prototype.beforeUpdateHistoryState = function beforeUpdateHistoryState(state) {
		// If state is ours and navigate to post-without-redirect-get set
		// history state to null, that way Senna will reload the page on
		// popstate since it cannot predict post data.
		if (state.senna && state.form && state.redirectPath === state.path) {
			return null;
		}
		return state;
	};

	/**
  * Formats load path before invoking ajax call.
  * @param {string} path
  * @return {string} Formatted path;
  * @protected
  */


	RequestScreen.prototype.formatLoadPath = function formatLoadPath(path) {
		if (_UA2.default.isIeOrEdge && this.httpMethod === RequestScreen.GET) {
			return new _Uri2.default(path).makeUnique().toString();
		}
		return path;
	};

	/**
  * Gets the http headers.
  * @return {?Object=}
  */


	RequestScreen.prototype.getHttpHeaders = function getHttpHeaders() {
		return this.httpHeaders;
	};

	/**
  * Gets the http method.
  * @return {!string}
  */


	RequestScreen.prototype.getHttpMethod = function getHttpMethod() {
		return this.httpMethod;
	};

	/**
  * Gets request path.
  * @return {string=}
  */


	RequestScreen.prototype.getRequestPath = function getRequestPath() {
		var request = this.getRequest();
		if (request) {
			var requestPath = request.requestPath;
			var responseUrl = this.maybeExtractResponseUrlFromRequest(request);
			if (responseUrl) {
				requestPath = responseUrl;
			}
			if (_UA2.default.isIeOrEdge && this.httpMethod === RequestScreen.GET) {
				requestPath = new _Uri2.default(requestPath).removeUnique().toString();
			}
			return _utils2.default.getUrlPath(requestPath);
		}
		return null;
	};

	/**
  * Gets the request object.
  * @return {?Object}
  */


	RequestScreen.prototype.getRequest = function getRequest() {
		return this.request;
	};

	/**
  * Gets the request timeout.
  * @return {!number}
  */


	RequestScreen.prototype.getTimeout = function getTimeout() {
		return this.timeout;
	};

	/**
  * Checks if response succeeded. Any status code 2xx or 3xx is considered
  * valid.
  * @param {number} statusCode
  */


	RequestScreen.prototype.isValidResponseStatusCode = function isValidResponseStatusCode(statusCode) {
		return statusCode >= 200 && statusCode <= 399;
	};

	/**
  * @inheritDoc
  */


	RequestScreen.prototype.load = function load(path) {
		var _this2 = this;

		var cache = this.getCache();
		if (_metal.core.isDefAndNotNull(cache)) {
			return _Promise2.default.resolve(cache);
		}

		var body = null;
		var httpMethod = this.httpMethod;

		var headers = new _MultiMap2.default();
		Object.keys(this.httpHeaders).forEach(function (header) {
			return headers.add(header, _this2.httpHeaders[header]);
		});

		if (_globals2.default.capturedFormElement) {
			body = new FormData(_globals2.default.capturedFormElement);
			httpMethod = RequestScreen.POST;
			if (_UA2.default.isIeOrEdge) {
				headers.add('If-None-Match', '"0"');
			}
		}

		var requestPath = this.formatLoadPath(path);
		return _Ajax2.default.request(requestPath, httpMethod, body, headers, null, this.timeout).then(function (xhr) {
			_this2.setRequest(xhr);
			_this2.assertValidResponseStatusCode(xhr.status);
			if (httpMethod === RequestScreen.GET && _this2.isCacheable()) {
				_this2.addCache(xhr.responseText);
			}
			xhr.requestPath = requestPath;
			return xhr.responseText;
		}).catch(function (reason) {
			switch (reason.message) {
				case _errors2.default.REQUEST_TIMEOUT:
					reason.timeout = true;
					break;
				case _errors2.default.REQUEST_ERROR:
					reason.requestError = true;
					break;
			}
			throw reason;
		});
	};

	/**
  * The following method tries to extract the response url value by checking
  * the custom response header 'X-Request-URL' if proper value is not present
  * in XMLHttpRequest. The value of responseURL will be the final URL
  * obtained after any redirects. Internet Explorer, Edge and Safari <= 7
  * does not yet support the feature. For more information see:
  * https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseURL
  * https://xhr.spec.whatwg.org/#the-responseurl-attribute
  * @param {XMLHttpRequest} request
  * @return {?string} Response url best match.
  */


	RequestScreen.prototype.maybeExtractResponseUrlFromRequest = function maybeExtractResponseUrlFromRequest(request) {
		var responseUrl = request.responseURL;
		if (responseUrl) {
			return responseUrl;
		}
		return request.getResponseHeader(RequestScreen.X_REQUEST_URL_HEADER);
	};

	/**
  * Sets the http headers.
  * @param {?Object=} httpHeaders
  */


	RequestScreen.prototype.setHttpHeaders = function setHttpHeaders(httpHeaders) {
		this.httpHeaders = httpHeaders;
	};

	/**
  * Sets the http method.
  * @param {!string} httpMethod
  */


	RequestScreen.prototype.setHttpMethod = function setHttpMethod(httpMethod) {
		this.httpMethod = httpMethod.toLowerCase();
	};

	/**
  * Sets the request object.
  * @param {?Object} request
  */


	RequestScreen.prototype.setRequest = function setRequest(request) {
		this.request = request;
	};

	/**
  * Sets the request timeout in milliseconds.
  * @param {!number} timeout
  */


	RequestScreen.prototype.setTimeout = function setTimeout(timeout) {
		this.timeout = timeout;
	};

	return RequestScreen;
}(_Screen3.default);

/**
 * Holds value for method get.
 * @type {string}
 * @default 'get'
 * @static
 */


RequestScreen.GET = 'get';

/**
 * Holds value for method post.
 * @type {string}
 * @default 'post'
 * @static
 */
RequestScreen.POST = 'post';

/**
 * Fallback http header to retrieve response request url.
 * @type {string}
 * @default 'X-Request-URL'
 * @static
 */
RequestScreen.X_REQUEST_URL_HEADER = 'X-Request-URL';

exports.default = RequestScreen;

},{"../../../metal-ajax/src/Ajax":5,"../../../metal-multimap/src/MultiMap":30,"../../../metal-promise/src/promise/Promise":31,"../../../metal-uri/src/Uri":38,"../../../metal-useragent/src/UA":41,"../../../metal/src/metal":46,"../errors/errors":51,"../globals/globals":52,"../utils/utils":57,"./Screen":55}],55:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../../metal/src/metal');

var _dom = require('../../../metal-dom/src/all/dom');

var _Cacheable2 = require('../cacheable/Cacheable');

var _Cacheable3 = _interopRequireDefault(_Cacheable2);

var _Promise = require('../../../metal-promise/src/promise/Promise');

var _Promise2 = _interopRequireDefault(_Promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Screen = function (_Cacheable) {
	_inherits(Screen, _Cacheable);

	/**
  * Screen class is a special type of route handler that provides helper
  * utilities that adds lifecycle and methods to provide content to each
  * registered surface.
  * @constructor
  * @extends {Cacheable}
  */

	function Screen() {
		_classCallCheck(this, Screen);

		/**
   * Holds the screen id.
   * @type {string}
   * @protected
   */

		var _this = _possibleConstructorReturn(this, _Cacheable.call(this));

		_this.id = _this.makeId_(_metal.core.getUid());

		/**
   * Holds the screen title. Relevant when the page title should be
   * upadated when screen is rendered.
   * @type {?string=}
   * @default null
   * @protected
   */
		_this.title = null;
		return _this;
	}

	/**
  * Fires when the screen is active. Allows a screen to perform any setup
  * that requires its DOM to be visible. Lifecycle.
  */


	Screen.prototype.activate = function activate() {
		console.log('Screen [' + this + '] activate');
	};

	/**
  * Gives the Screen a chance to cancel the navigation and stop itself from
  * being deactivated. Can be used, for example, if the screen has unsaved
  * state. Lifecycle. Clean-up should not be preformed here, since the
  * navigation may still be cancelled. Do clean-up in deactivate.
  * @return {boolean=} If returns true, the current screen is locked and the
  *     next nagivation interrupted.
  */


	Screen.prototype.beforeDeactivate = function beforeDeactivate() {
		console.log('Screen [' + this + '] beforeDeactivate');
	};

	/**
  * Gives the Screen a chance format the path before history update.
  * @path {!string} path Navigation path.
  * @return {!string} Navigation path to use on history.
  */


	Screen.prototype.beforeUpdateHistoryPath = function beforeUpdateHistoryPath(path) {
		return path;
	};

	/**
  * Gives the Screen a chance format the state before history update.
  * @path {!object} state History state.
  * @return {!object} History state to use on history.
  */


	Screen.prototype.beforeUpdateHistoryState = function beforeUpdateHistoryState(state) {
		return state;
	};

	/**
  * Allows a screen to do any cleanup necessary after it has been
  * deactivated, for example cancelling outstanding requests or stopping
  * timers. Lifecycle.
  */


	Screen.prototype.deactivate = function deactivate() {
		console.log('Screen [' + this + '] deactivate');
	};

	/**
  * Dispose a screen, either after it is deactivated (in the case of a
  * non-cacheable view) or when the App is itself disposed for whatever
  * reason. Lifecycle.
  */


	Screen.prototype.disposeInternal = function disposeInternal() {
		_Cacheable.prototype.disposeInternal.call(this);
		console.log('Screen [' + this + '] dispose');
	};

	/**
  * Allows a screen to evaluate scripts before the element is made visible.
  * Lifecycle.
  * @param {!object} surfaces Map of surfaces to flip keyed by surface id.
  * @return {?CancellablePromise=} This can return a promise, which will
  *     pause the navigation until it is resolved.
  */


	Screen.prototype.evaluateScripts = function evaluateScripts(surfaces) {
		Object.keys(surfaces).forEach(function (sId) {
			if (surfaces[sId].activeChild) {
				_dom.globalEval.runScriptsInElement(surfaces[sId].activeChild);
			}
		});
		return _Promise2.default.resolve();
	};

	/**
  * Allows a screen to evaluate styles before the element is made visible.
  * Lifecycle.
  * @param {!object} surfaces Map of surfaces to flip keyed by surface id.
  * @return {?CancellablePromise=} This can return a promise, which will
  *     pause the navigation until it is resolved.
  */


	Screen.prototype.evaluateStyles = function evaluateStyles() {
		return _Promise2.default.resolve();
	};

	/**
  * Allows a screen to perform any setup immediately before the element is
  * made visible. Lifecycle.
  * @param {!object} surfaces Map of surfaces to flip keyed by surface id.
  * @return {?CancellablePromise=} This can return a promise, which will pause the
  *     navigation until it is resolved.
  */


	Screen.prototype.flip = function flip(surfaces) {
		var _this2 = this;

		console.log('Screen [' + this + '] flip');

		var transitions = [];

		Object.keys(surfaces).forEach(function (sId) {
			var surface = surfaces[sId];
			var deferred = surface.show(_this2.id);
			transitions.push(deferred);
		});

		return _Promise2.default.all(transitions);
	};

	/**
  * Gets the screen id.
  * @return {string}
  */


	Screen.prototype.getId = function getId() {
		return this.id;
	};

	/**
  * Returns the content for the given surface, or null if the surface isn't
  * used by this screen. This will be called when a screen is initially
  * constructed or, if a screen is non-cacheable, when navigated.
  * @param {!string} surfaceId The id of the surface DOM element.
  * @return {?string|Element=} This can return a string or node representing
  *     the content of the surface. If returns falsy values surface default
  *     content is restored.
  */


	Screen.prototype.getSurfaceContent = function getSurfaceContent() {
		console.log('Screen [' + this + '] getSurfaceContent');
	};

	/**
  * Gets the screen title.
  * @return {?string=}
  */


	Screen.prototype.getTitle = function getTitle() {
		return this.title;
	};

	/**
  * Returns all contents for the surfaces. This will pass the loaded content
  * to <code>Screen.load</code> with all information you
  * need to fulfill the surfaces. Lifecycle.
  * @param {!string=} path The requested path.
  * @return {!CancellablePromise} This can return a string representing the
  *     contents of the surfaces or a promise, which will pause the navigation
  *     until it is resolved. This is useful for loading async content.
  */


	Screen.prototype.load = function load() {
		console.log('Screen [' + this + '] load');
		return _Promise2.default.resolve();
	};

	/**
  * Makes the id for the screen.
  * @param {!string} id The screen id the content belongs too.
  * @return {string}
  * @private
  */


	Screen.prototype.makeId_ = function makeId_(id) {
		return 'screen_' + id;
	};

	/**
  * Sets the screen id.
  * @param {!string} id
  */


	Screen.prototype.setId = function setId(id) {
		this.id = id;
	};

	/**
  * Sets the screen title.
  * @param {?string=} title
  */


	Screen.prototype.setTitle = function setTitle(title) {
		this.title = title;
	};

	/**
  * @return {string}
  */


	Screen.prototype.toString = function toString() {
		return this.id;
	};

	return Screen;
}(_Cacheable3.default);

/**
 * @param {*} object
 * @return {boolean} Whether a given instance implements
 * <code>Screen</code>.
 */


Screen.isImplementedBy = function (object) {
	return object instanceof Screen;
};

exports.default = Screen;

},{"../../../metal-dom/src/all/dom":13,"../../../metal-promise/src/promise/Promise":31,"../../../metal/src/metal":46,"../cacheable/Cacheable":50}],56:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _globals = require('../globals/globals');

var _globals2 = _interopRequireDefault(_globals);

var _metal = require('../../../metal/src/metal');

var _dom = require('../../../metal-dom/src/all/dom');

var _dom2 = _interopRequireDefault(_dom);

var _Promise = require('../../../metal-promise/src/promise/Promise');

var _Promise2 = _interopRequireDefault(_Promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Surface = function (_Disposable) {
	_inherits(Surface, _Disposable);

	/**
  * Surface class representing the references to elements on the page that
  * can potentially be updated by <code>App</code>.
  * @param {string} id
  * @constructor
  */

	function Surface(id) {
		_classCallCheck(this, Surface);

		var _this = _possibleConstructorReturn(this, _Disposable.call(this));

		if (!id) {
			throw new Error('Surface element id not specified. A surface element requires a valid id.');
		}

		/**
   * Holds the active child element.
   * @type {Element}
   * @default null
   * @protected
   */
		_this.activeChild = null;

		/**
   * Holds the default child element.
   * @type {Element}
   * @default null
   * @protected
   */
		_this.defaultChild = null;

		/**
   * Holds the element with the specified surface id, if not found creates a
   * new element with the specified id.
   * @type {Element}
   * @default null
   * @protected
   */
		_this.element = null;

		/**
   * Holds the surface id.
   * @type {String}
   * @default null
   * @protected
   */
		_this.id = id;

		/**
   * Holds the default transitionFn for the surfaces.
   * @param {?Element=} from The visible surface element.
   * @param {?Element=} to The surface element to be flipped.
   * @default null
   */
		_this.transitionFn = null;

		_this.defaultChild = _this.getChild(Surface.DEFAULT);
		_this.maybeWrapContentAsDefault_();
		_this.activeChild = _this.defaultChild;
		return _this;
	}

	/**
  * Adds screen content to a surface. If content hasn't been passed, see if
  * an element exists in the DOM that matches the id. By convention, the
  * element should already be nested in the right element and should have an
  * id that is a concatentation of the surface id + '-' + the screen id.
  * @param {!string} screenId The screen id the content belongs too.
  * @param {?string|Element=} opt_content The string content or element to
  *     add be added as surface content.
  * @return {Element}
  */


	Surface.prototype.addContent = function addContent(screenId, opt_content) {
		var child = this.defaultChild;

		if (_metal.core.isDefAndNotNull(opt_content)) {
			child = this.getChild(screenId);
			if (child) {
				_dom2.default.removeChildren(child);
			} else {
				child = this.createChild(screenId);
				this.transition(child, null);
			}
			_dom2.default.append(child, opt_content);
		}

		var element = this.getElement();

		if (element && child) {
			_dom2.default.append(element, child);
		}

		return child;
	};

	/**
  * Creates child node for the surface.
  * @param {!string} screenId The screen id.
  * @return {Element}
  */


	Surface.prototype.createChild = function createChild(screenId) {
		var child = _globals2.default.document.createElement('div');
		child.setAttribute('id', this.makeId_(screenId));
		return child;
	};

	/**
  * Gets child node of the surface.
  * @param {!string} screenId The screen id.
  * @return {?Element}
  */


	Surface.prototype.getChild = function getChild(screenId) {
		return _globals2.default.document.getElementById(this.makeId_(screenId));
	};

	/**
  * Gets the surface element from element, and sets it to the el property of
  * the current instance.
  * <code>this.element</code> will be used.
  * @return {?Element} The current surface element.
  */


	Surface.prototype.getElement = function getElement() {
		if (this.element) {
			return this.element;
		}
		this.element = _globals2.default.document.getElementById(this.id);
		return this.element;
	};

	/**
  * Gets the surface id.
  * @return {String}
  */


	Surface.prototype.getId = function getId() {
		return this.id;
	};

	/**
  * Gets the surface transition function.
  * See <code>Surface.defaultTransition</code>.
  * @return {?Function=} The transition function.
  */


	Surface.prototype.getTransitionFn = function getTransitionFn() {
		return this.transitionFn;
	};

	/**
  * Makes the id for the element that holds content for a screen.
  * @param {!string} screenId The screen id the content belongs too.
  * @return {String}
  * @private
  */


	Surface.prototype.makeId_ = function makeId_(screenId) {
		return this.id + '-' + screenId;
	};

	/**
  * If default child is missing, wraps surface content as default child. If
  * surface have static content, make sure to place a
  * <code>surfaceId-default</code> element inside surface, only contents
  * inside the default child will be replaced by navigation.
  */


	Surface.prototype.maybeWrapContentAsDefault_ = function maybeWrapContentAsDefault_() {
		var element = this.getElement();
		if (element && !this.defaultChild) {
			var fragment = _globals2.default.document.createDocumentFragment();
			while (element.firstChild) {
				fragment.appendChild(element.firstChild);
			}
			this.defaultChild = this.addContent(Surface.DEFAULT, fragment);
			this.transition(null, this.defaultChild);
		}
	};

	/**
  * Sets the surface id.
  * @param {!string} id
  */


	Surface.prototype.setId = function setId(id) {
		this.id = id;
	};

	/**
  * Sets the surface transition function.
  * See <code>Surface.defaultTransition</code>.
  * @param {?Function=} transitionFn The transition function.
  */


	Surface.prototype.setTransitionFn = function setTransitionFn(transitionFn) {
		this.transitionFn = transitionFn;
	};

	/**
  * Shows screen content from a surface.
  * @param {String} screenId The screen id to show.
  * @return {CancellablePromise} Pauses the navigation until it is resolved.
  */


	Surface.prototype.show = function show(screenId) {
		var from = this.activeChild;
		var to = this.getChild(screenId);
		if (!to) {
			to = this.defaultChild;
		}
		this.activeChild = to;
		return this.transition(from, to).thenAlways(function () {
			if (from && from !== to) {
				_dom2.default.exitDocument(from);
			}
		});
	};

	/**
  * Removes screen content from a surface.
  * @param {!string} screenId The screen id to remove.
  */


	Surface.prototype.remove = function remove(screenId) {
		var child = this.getChild(screenId);
		if (child) {
			_dom2.default.exitDocument(child);
		}
	};

	/**
  * @return {String}
  */


	Surface.prototype.toString = function toString() {
		return this.id;
	};

	/**
  * Invokes the transition function specified on <code>transition</code> attribute.
  * @param {?Element=} from
  * @param {?Element=} to
  * @return {?CancellablePromise=} This can return a promise, which will pause the
  *     navigation until it is resolved.
  */


	Surface.prototype.transition = function transition(from, to) {
		var transitionFn = this.transitionFn || Surface.defaultTransition;
		return _Promise2.default.resolve(transitionFn.call(this, from, to));
	};

	return Surface;
}(_metal.Disposable);

/**
   * Holds the default surface name. Elements on the page must contain a child
   * element containing the default content, this element must be as following:
   *
   * Example:
   * <code>
   *   <div id="mysurface">
   *     <div id="mysurface-default">Default surface content.</div>
   *   </div>
   * </code>
   *
   * The default content is relevant for the initial page content. When a
   * screen doesn't provide content for the surface the default content is
   * restored into the page.
   *
   * @type {!String}
   * @default default
   * @static
   */


Surface.DEFAULT = 'default';

/**
 * Holds the default transition for all surfaces. Each surface could have its
 * own transition.
 *
 * Example:
 *
 * <code>
 * surface.setTransitionFn(function(from, to) {
 *   if (from) {
 *     from.style.display = 'none';
 *     from.classList.remove('flipped');
 *   }
 *   if (to) {
 *     to.style.display = 'block';
 *     to.classList.add('flipped');
 *   }
 *   return null;
 * });
 * </code>
 *
 * @param {?Element=} from The visible surface element.
 * @param {?Element=} to The surface element to be flipped.
 * @static
 */
Surface.defaultTransition = function (from, to) {
	if (from) {
		from.style.display = 'none';
		from.classList.remove('flipped');
	}
	if (to) {
		to.style.display = 'block';
		to.classList.add('flipped');
	}
};

exports.default = Surface;

},{"../../../metal-dom/src/all/dom":13,"../../../metal-promise/src/promise/Promise":31,"../../../metal/src/metal":46,"../globals/globals":52}],57:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _globals = require('../globals/globals');

var _globals2 = _interopRequireDefault(_globals);

var _Uri = require('../../../metal-uri/src/Uri');

var _Uri2 = _interopRequireDefault(_Uri);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A collection of static utility functions.
 * @const
 */

var utils = function () {
	function utils() {
		_classCallCheck(this, utils);
	}

	/**
  * Gets the current browser path including hashbang.
  * @return {!string}
  * @static
  */

	utils.getCurrentBrowserPath = function getCurrentBrowserPath() {
		return this.getCurrentBrowserPathWithoutHash() + _globals2.default.window.location.hash;
	};

	/**
  * Gets the current browser path excluding hashbang.
  * @return {!string}
  * @static
  */


	utils.getCurrentBrowserPathWithoutHash = function getCurrentBrowserPathWithoutHash() {
		return _globals2.default.window.location.pathname + _globals2.default.window.location.search;
	};

	/**
  * Extracts the path part of an url.
  * @return {!string}
  * @static
  */


	utils.getUrlPath = function getUrlPath(url) {
		var uri = new _Uri2.default(url);
		return uri.getPathname() + uri.getSearch() + uri.getHash();
	};

	/**
  * Extracts the path part of an url without hashbang.
  * @return {!string}
  * @static
  */


	utils.getUrlPathWithoutHash = function getUrlPathWithoutHash(url) {
		var uri = new _Uri2.default(url);
		return uri.getPathname() + uri.getSearch();
	};

	/**
  * Checks if url is in the same browser current url excluding the hashbang.
  * @param  {!string} url
  * @return {boolean}
  * @static
  */


	utils.isCurrentBrowserPath = function isCurrentBrowserPath(url) {
		if (url) {
			return utils.getUrlPathWithoutHash(url) === this.getCurrentBrowserPathWithoutHash();
		}
		return false;
	};

	/**
  * Returns true if HTML5 History api is supported.
  * @return {boolean}
  * @static
  */


	utils.isHtml5HistorySupported = function isHtml5HistorySupported() {
		return !!(_globals2.default.window.history && _globals2.default.window.history.pushState);
	};

	return utils;
}();

exports.default = utils;

},{"../../../metal-uri/src/Uri":38,"../globals/globals":52}],58:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _store = require('./store/store');

var _store2 = _interopRequireDefault(_store);

var _Actions = require('./actions/Actions');

var _Actions2 = _interopRequireDefault(_Actions);

var _Dashboard = require('./components/pages/Dashboard');

var _Dashboard2 = _interopRequireDefault(_Dashboard);

var _EditCampaign = require('./components/pages/EditCampaign');

var _EditCampaign2 = _interopRequireDefault(_EditCampaign);

var _ManageCampaigns = require('./components/pages/ManageCampaigns');

var _ManageCampaigns2 = _interopRequireDefault(_ManageCampaigns);

var _Router = require('../../node_modules/metal-router/src/Router');

var _Router2 = _interopRequireDefault(_Router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Main = function () {
	function Main() {
		_classCallCheck(this, Main);
	}

	Main.run = function run() {
		var opt_data = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

		_store2.default.dispatch(_Actions2.default.updateState(opt_data));

		var basePath = _store2.default.getState().basePath;
		_Router2.default.router().setBasePath(basePath);
		_Router2.default.route('/dashboard', _Dashboard2.default, _store2.default.getState, true);
		_Router2.default.route('/manage-campaigns', _ManageCampaigns2.default, _store2.default.getState, true);
		_Router2.default.route('/create-campaign', _EditCampaign2.default, _store2.default.getState, true);
		_Router2.default.route(/\/edit-campaign(\/\d*)?/, _EditCampaign2.default, _store2.default.getState, true);
		_Router2.default.router().navigate(basePath + '/dashboard', true);

		_store2.default.subscribe(Main.refreshState);
		return this;
	};

	Main.refreshState = function refreshState() {
		_Router2.default.activeComponent.setState(_store2.default.getState());
	};

	return Main;
}();

exports.default = Main;

},{"../../node_modules/metal-router/src/Router":32,"./actions/Actions":60,"./components/pages/Dashboard":70,"./components/pages/EditCampaign":71,"./components/pages/ManageCampaigns":72,"./store/store":80}],59:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = {
	SAVE_CAMPAIGN: 'save-campaign',
	START_CAMPAIGN_CREATION: 'start-campaign-creation',
	START_CAMPAIGN_EDITION: 'start-campaign-edition',
	REMOVE_CAMPAIGN: 'remove-campaign',
	UPDATE_DATA: 'update-data'
};

},{}],60:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _ActionTypes = require('./ActionTypes');

var _ActionTypes2 = _interopRequireDefault(_ActionTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
	saveCampaign: function saveCampaign(campaign) {
		return {
			type: _ActionTypes2.default.SAVE_CAMPAIGN,
			campaign: campaign
		};
	},
	startCampaignCreation: function startCampaignCreation(sourceUrl) {
		return {
			type: _ActionTypes2.default.START_CAMPAIGN_CREATION,
			sourceUrl: sourceUrl
		};
	},
	startCampaignEdition: function startCampaignEdition(id, sourceUrl) {
		return {
			type: _ActionTypes2.default.START_CAMPAIGN_EDITION,
			id: id,
			sourceUrl: sourceUrl
		};
	},
	removeCampaign: function removeCampaign(id) {
		return {
			type: _ActionTypes2.default.REMOVE_CAMPAIGN,
			id: id
		};
	},
	updateState: function updateState(state) {
		return {
			type: _ActionTypes2.default.UPDATE_DATA,
			state: state
		};
	}
};

},{"./ActionTypes":59}],61:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _JSXComponent2 = require('../../../node_modules/metal-jsx/src/JSXComponent');

var _JSXComponent3 = _interopRequireDefault(_JSXComponent2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BackArrow = function (_JSXComponent) {
	_inherits(BackArrow, _JSXComponent);

	function BackArrow() {
		_classCallCheck(this, BackArrow);

		return _possibleConstructorReturn(this, _JSXComponent.apply(this, arguments));
	}

	BackArrow.prototype.render = function render() {
		IncrementalDOM.elementOpen('a', null, ['class', 'back-arrow'], 'href', this.config.basePath + this.config.sourceUrl);
		IncrementalDOM.elementOpen('span', null, ['class', 'glyphicon glyphicon-menu-left']);
		IncrementalDOM.elementClose('span');
		return IncrementalDOM.elementClose('a');
	};

	return BackArrow;
}(_JSXComponent3.default);

exports.default = BackArrow;

},{"../../../node_modules/metal-jsx/src/JSXComponent":28}],62:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _store = require('../store/store');

var _store2 = _interopRequireDefault(_store);

var _Actions = require('../actions/Actions');

var _Actions2 = _interopRequireDefault(_Actions);

var _JSXComponent2 = require('../../../node_modules/metal-jsx/src/JSXComponent');

var _JSXComponent3 = _interopRequireDefault(_JSXComponent2);

var _Tabs = require('./Tabs');

var _Tabs2 = _interopRequireDefault(_Tabs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Header = function (_JSXComponent) {
	_inherits(Header, _JSXComponent);

	function Header() {
		_classCallCheck(this, Header);

		return _possibleConstructorReturn(this, _JSXComponent.apply(this, arguments));
	}

	Header.prototype.render = function render() {
		var tabs = [{
			name: 'Dashboard',
			href: this.config.basePath + '/dashboard'
		}, {
			name: 'Manage Campaigns',
			href: this.config.basePath + '/manage-campaigns'
		}];

		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-header row']);
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-12']);
		IncrementalDOM.elementOpen('a', null, ['class', 'btn btn-primary campaign-manager-button-new pull-right'], 'href', this.config.basePath + '/create-campaign', 'data-onclick', this.startCampaignCreation_.bind(this));
		IncrementalDOM.text(' New Campaign ');
		IncrementalDOM.elementClose('a');
		IncrementalDOM.elementOpen('h4', null, ['class', 'campaign-manager-title campaign-manager-page-title']);
		IncrementalDOM.text('Campaign Manager');
		IncrementalDOM.elementClose('h4');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-12']);
		IncrementalDOM.elementVoid(_Tabs2.default, null, null, 'tabs', tabs, 'selectedIndex', this.config.currentUrl == '/manage-campaigns' ? 1 : 0);
		IncrementalDOM.elementClose('div');
		return IncrementalDOM.elementClose('div');
	};

	Header.prototype.startCampaignCreation_ = function startCampaignCreation_() {
		_store2.default.dispatch(_Actions2.default.startCampaignCreation(this.config.currentUrl));
	};

	return Header;
}(_JSXComponent3.default);

exports.default = Header;

},{"../../../node_modules/metal-jsx/src/JSXComponent":28,"../actions/Actions":60,"../store/store":80,"./Tabs":63}],63:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _JSXComponent2 = require('../../../node_modules/metal-jsx/src/JSXComponent');

var _JSXComponent3 = _interopRequireDefault(_JSXComponent2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Tabs = function (_JSXComponent) {
	_inherits(Tabs, _JSXComponent);

	function Tabs() {
		_classCallCheck(this, Tabs);

		return _possibleConstructorReturn(this, _JSXComponent.apply(this, arguments));
	}

	Tabs.prototype.render = function render() {
		var _this2 = this;

		var items = this.config.tabs.map(function (tab, index) {
			return iDOMHelpers.jsxWrapper(function (_ref, _tab$href, _tab$name) {
				IncrementalDOM.elementOpen('li', null, null, 'class', _ref);
				IncrementalDOM.elementOpen('a', null, null, 'href', _tab$href);
				iDOMHelpers.renderArbitrary(_tab$name);
				IncrementalDOM.elementClose('a');
				return IncrementalDOM.elementClose('li');
			}, [_this2.config.selectedIndex == index ? 'active' : '', tab.href, tab.name]);
		});
		IncrementalDOM.elementOpen('ul', null, ['class', 'campaign-manager-tabs nav nav-tabs']);
		iDOMHelpers.renderArbitrary(items);
		return IncrementalDOM.elementClose('ul');
	};

	return Tabs;
}(_JSXComponent3.default);

exports.default = Tabs;

},{"../../../node_modules/metal-jsx/src/JSXComponent":28}],64:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../../../node_modules/metal/src/metal');

var _metal2 = _interopRequireDefault(_metal);

var _JSXComponent2 = require('../../../../node_modules/metal-jsx/src/JSXComponent');

var _JSXComponent3 = _interopRequireDefault(_JSXComponent2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Card = function (_JSXComponent) {
	_inherits(Card, _JSXComponent);

	function Card() {
		_classCallCheck(this, Card);

		return _possibleConstructorReturn(this, _JSXComponent.apply(this, arguments));
	}

	Card.prototype.render = function render() {
		IncrementalDOM.elementOpen('div', null, null, 'class', 'campaign-manager-card ' + (this.config.cssClass || ''));
		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-card-body clearfix']);
		iDOMHelpers.renderArbitrary(this.config.children);
		IncrementalDOM.elementClose('div');
		return IncrementalDOM.elementClose('div');
	};

	return Card;
}(_JSXComponent3.default);

exports.default = Card;

},{"../../../../node_modules/metal-jsx/src/JSXComponent":28,"../../../../node_modules/metal/src/metal":46}],65:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Card = require('./Card');

var _Card2 = _interopRequireDefault(_Card);

var _JSXComponent2 = require('../../../../node_modules/metal-jsx/src/JSXComponent');

var _JSXComponent3 = _interopRequireDefault(_JSXComponent2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ImageCard = function (_JSXComponent) {
	_inherits(ImageCard, _JSXComponent);

	function ImageCard() {
		_classCallCheck(this, ImageCard);

		return _possibleConstructorReturn(this, _JSXComponent.apply(this, arguments));
	}

	ImageCard.prototype.render = function render() {
		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-image-card']);
		IncrementalDOM.elementOpen(_Card2.default);
		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-card-title']);
		iDOMHelpers.renderArbitrary(this.config.title);
		IncrementalDOM.elementOpen('span', null, ['class', 'highlight count']);
		iDOMHelpers.renderArbitrary(this.config.count);
		IncrementalDOM.elementClose('span');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div');
		IncrementalDOM.elementVoid('img', null, null, 'src', this.config.imageUrl);
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose(_Card2.default);
		return IncrementalDOM.elementClose('div');
	};

	return ImageCard;
}(_JSXComponent3.default);

exports.default = ImageCard;

},{"../../../../node_modules/metal-jsx/src/JSXComponent":28,"./Card":64}],66:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Card = require('./Card');

var _Card2 = _interopRequireDefault(_Card);

var _JSXComponent2 = require('../../../../node_modules/metal-jsx/src/JSXComponent');

var _JSXComponent3 = _interopRequireDefault(_JSXComponent2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TableCard = function (_JSXComponent) {
	_inherits(TableCard, _JSXComponent);

	function TableCard() {
		_classCallCheck(this, TableCard);

		return _possibleConstructorReturn(this, _JSXComponent.apply(this, arguments));
	}

	TableCard.prototype.render = function render() {
		var headers = this.config.headers.map(function (header, index) {
			return iDOMHelpers.jsxWrapper(function (_ref, _header) {
				IncrementalDOM.elementOpen('th', null, null, 'class', _ref);
				iDOMHelpers.renderArbitrary(_header);
				return IncrementalDOM.elementClose('th');
			}, ['light-gray' + (index === 0 ? '' : ' text-center'), header]);
		});
		var data = this.config.data.map(function (row) {
			var cells = row.map(function (cell, index) {
				return iDOMHelpers.jsxWrapper(function (_ref2, _cell) {
					IncrementalDOM.elementOpen('td', null, null, 'class', _ref2);
					iDOMHelpers.renderArbitrary(_cell);
					return IncrementalDOM.elementClose('td');
				}, [index === 0 ? '' : 'text-center', cell]);
			});
			return iDOMHelpers.jsxWrapper(function (_cells) {
				IncrementalDOM.elementOpen('tr');
				iDOMHelpers.renderArbitrary(_cells);
				return IncrementalDOM.elementClose('tr');
			}, [cells]);
		});

		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-table-card']);
		IncrementalDOM.elementOpen(_Card2.default);
		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-card-title']);
		iDOMHelpers.renderArbitrary(this.config.title);
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('table', null, ['class', 'table table-clean']);
		IncrementalDOM.elementOpen('thead');
		IncrementalDOM.elementOpen('tr');
		iDOMHelpers.renderArbitrary(headers);
		IncrementalDOM.elementClose('tr');
		IncrementalDOM.elementClose('thead');
		IncrementalDOM.elementOpen('tbody');
		iDOMHelpers.renderArbitrary(data);
		IncrementalDOM.elementClose('tbody');
		IncrementalDOM.elementClose('table');
		IncrementalDOM.elementClose(_Card2.default);
		return IncrementalDOM.elementClose('div');
	};

	return TableCard;
}(_JSXComponent3.default);

exports.default = TableCard;

},{"../../../../node_modules/metal-jsx/src/JSXComponent":28,"./Card":64}],67:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../../../node_modules/metal/src/metal');

var _metal2 = _interopRequireDefault(_metal);

var _JSXComponent2 = require('../../../../node_modules/metal-jsx/src/JSXComponent');

var _JSXComponent3 = _interopRequireDefault(_JSXComponent2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditCampaignDetails = function (_JSXComponent) {
	_inherits(EditCampaignDetails, _JSXComponent);

	function EditCampaignDetails() {
		_classCallCheck(this, EditCampaignDetails);

		return _possibleConstructorReturn(this, _JSXComponent.apply(this, arguments));
	}

	EditCampaignDetails.prototype.addLeading0 = function addLeading0(num) {
		return num < 10 ? '0' + num : num;
	};

	EditCampaignDetails.prototype.render = function render() {
		var editMode = _metal2.default.isDefAndNotNull(this.config.editCampaignId);
		var campaign = editMode ? this.config.campaigns[this.config.editCampaignId] : {};

		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-edit-campaign-details container-fluid white-bg campaign-manager session session-merged-next']);
		IncrementalDOM.elementOpen('h2');
		IncrementalDOM.text('Details');
		IncrementalDOM.elementClose('h2');
		IncrementalDOM.elementOpen('div', null, ['class', 'form-group']);
		IncrementalDOM.elementOpen('label', null, ['for', '', 'class', 'col-md-1 control-label']);
		IncrementalDOM.text('Name:');
		IncrementalDOM.elementClose('label');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-4']);
		IncrementalDOM.elementVoid('input', null, ['type', 'text', 'class', 'form-control', 'name', 'name'], 'value', campaign.name || '');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementVoid('br', null, ['class', 'hidden-md hidden-lg']);
		IncrementalDOM.elementOpen('label', null, ['class', 'col-md-1 col-md-offset-2 control-label']);
		IncrementalDOM.text('Budget:');
		IncrementalDOM.elementClose('label');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-2']);
		IncrementalDOM.elementVoid('input', null, ['type', 'text', 'class', 'form-control', 'name', 'budget'], 'value', campaign.budget || '');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-2']);
		IncrementalDOM.elementOpen('select', null, ['class', 'form-control']);
		IncrementalDOM.elementOpen('option');
		IncrementalDOM.text('($) Dollars');
		IncrementalDOM.elementClose('option');
		IncrementalDOM.elementClose('select');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'form-group']);
		IncrementalDOM.elementOpen('label', null, ['for', '', 'class', 'col-md-1 control-label']);
		IncrementalDOM.text('Description:');
		IncrementalDOM.elementClose('label');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-11']);
		IncrementalDOM.elementOpen('textarea', null, ['class', 'form-control', 'rows', '8', 'cols', '40', 'name', 'description']);
		iDOMHelpers.renderArbitrary(campaign.description || '');
		IncrementalDOM.elementClose('textarea');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'form-group']);
		iDOMHelpers.renderArbitrary(this.renderDateFields_('Starts on:', 'startDate', campaign.startDate));
		IncrementalDOM.elementVoid('br', null, ['class', 'hidden-md hidden-lg']);
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-2']);
		IncrementalDOM.elementClose('div');
		iDOMHelpers.renderArbitrary(this.renderDateFields_('Ends:', 'endDate', campaign.endDate));
		IncrementalDOM.elementClose('div');
		return IncrementalDOM.elementClose('div');
	};

	EditCampaignDetails.prototype.renderDateFields_ = function renderDateFields_(label, inputName, date) {
		var timeOptions = [];
		for (var i = 0; i < 24; i++) {
			timeOptions.push(iDOMHelpers.jsxWrapper(function (_i, _ref, _ref2, _ref3) {
				IncrementalDOM.elementOpen('option', null, null, 'value', _i, 'selected', _ref);
				iDOMHelpers.renderArbitrary(_ref2);
				IncrementalDOM.text(':00 ');
				iDOMHelpers.renderArbitrary(_ref3);
				return IncrementalDOM.elementClose('option');
			}, [i, date && date.hours === i || undefined, i > 12 ? i - 12 : i, i >= 12 ? 'PM' : 'AM']));
		}

		console.log('tried', inputName, date ? date.year + '-' + date.month + '-' + date.date : '');
		IncrementalDOM.elementOpen('div');
		IncrementalDOM.elementOpen('label', null, ['for', '', 'class', 'col-md-1 control-label']);
		iDOMHelpers.renderArbitrary(label);
		IncrementalDOM.elementClose('label');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-2']);
		IncrementalDOM.elementVoid('input', null, ['type', 'date', 'class', 'form-control'], 'name', inputName, 'value', date ? date.year + '-' + this.addLeading0(date.month) + '-' + this.addLeading0(date.date) : '');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-1']);
		IncrementalDOM.elementOpen('select', null, ['class', 'form-control'], 'name', inputName + 'Time');
		iDOMHelpers.renderArbitrary(timeOptions);
		IncrementalDOM.elementClose('select');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-1']);
		IncrementalDOM.elementOpen('select', null, ['class', 'form-control']);
		IncrementalDOM.elementOpen('option');
		IncrementalDOM.text('GMT');
		IncrementalDOM.elementClose('option');
		IncrementalDOM.elementClose('select');
		IncrementalDOM.elementClose('div');
		return IncrementalDOM.elementClose('div');
	};

	return EditCampaignDetails;
}(_JSXComponent3.default);

exports.default = EditCampaignDetails;

},{"../../../../node_modules/metal-jsx/src/JSXComponent":28,"../../../../node_modules/metal/src/metal":46}],68:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../../../node_modules/metal/src/metal');

var _metal2 = _interopRequireDefault(_metal);

var _JSXComponent2 = require('../../../../node_modules/metal-jsx/src/JSXComponent');

var _JSXComponent3 = _interopRequireDefault(_JSXComponent2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditCampaignGoal = function (_JSXComponent) {
	_inherits(EditCampaignGoal, _JSXComponent);

	function EditCampaignGoal() {
		_classCallCheck(this, EditCampaignGoal);

		return _possibleConstructorReturn(this, _JSXComponent.apply(this, arguments));
	}

	EditCampaignGoal.prototype.render = function render() {
		var editMode = _metal2.default.isDefAndNotNull(this.config.editCampaignId);
		var campaign = editMode ? this.config.campaigns[this.config.editCampaignId] : {};

		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-edit-campaign-goal container-fluid campaign-manager session']);
		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-card']);
		IncrementalDOM.elementOpen('h2');
		IncrementalDOM.text('Goal');
		IncrementalDOM.elementClose('h2');
		IncrementalDOM.elementOpen('div', null, ['class', 'session-description']);
		IncrementalDOM.elementOpen('p');
		IncrementalDOM.elementOpen('em');
		IncrementalDOM.text('Here you can define the goal of this stage. This will be used to generate smart reports in your campaign dashboard');
		IncrementalDOM.elementClose('em');
		IncrementalDOM.elementClose('p');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'form-group']);
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-2']);
		IncrementalDOM.elementOpen('select', null, ['class', 'form-control']);
		IncrementalDOM.elementOpen('option');
		IncrementalDOM.text('Lead Generation');
		IncrementalDOM.elementClose('option');
		IncrementalDOM.elementClose('select');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-2']);
		IncrementalDOM.elementVoid('input', null, ['type', 'text', 'class', 'form-control', 'name', 'generation.count'], 'value', campaign.goal ? campaign.goal.generation.count : 0);
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('label', null, ['for', '', 'class', 'col-md-2 control-label']);
		IncrementalDOM.elementOpen('div', null, ['class', 'text-right']);
		IncrementalDOM.text('new contacts in: ');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose('label');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-2']);
		IncrementalDOM.elementOpen('select', null, ['class', 'form-control']);
		IncrementalDOM.elementOpen('option');
		IncrementalDOM.text('2');
		IncrementalDOM.elementClose('option');
		IncrementalDOM.elementClose('select');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-2']);
		IncrementalDOM.elementOpen('select', null, ['class', 'form-control']);
		IncrementalDOM.elementOpen('option');
		IncrementalDOM.text('Weeks');
		IncrementalDOM.elementClose('option');
		IncrementalDOM.elementClose('select');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose('div');
		return IncrementalDOM.elementClose('div');
	};

	return EditCampaignGoal;
}(_JSXComponent3.default);

exports.default = EditCampaignGoal;

},{"../../../../node_modules/metal-jsx/src/JSXComponent":28,"../../../../node_modules/metal/src/metal":46}],69:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../../../node_modules/metal/src/metal');

var _metal2 = _interopRequireDefault(_metal);

var _JSXComponent2 = require('../../../../node_modules/metal-jsx/src/JSXComponent');

var _JSXComponent3 = _interopRequireDefault(_JSXComponent2);

var _TacticsTable = require('../table/TacticsTable');

var _TacticsTable2 = _interopRequireDefault(_TacticsTable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditCampaignTactics = function (_JSXComponent) {
	_inherits(EditCampaignTactics, _JSXComponent);

	function EditCampaignTactics() {
		_classCallCheck(this, EditCampaignTactics);

		return _possibleConstructorReturn(this, _JSXComponent.apply(this, arguments));
	}

	EditCampaignTactics.prototype.render = function render() {
		var editMode = _metal2.default.isDefAndNotNull(this.config.editCampaignId);
		var campaign = editMode ? this.config.campaigns[this.config.editCampaignId] : {};

		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-edit-campaign-tactics container-fluid campaign-manager white-bg session session-merged-next']);
		IncrementalDOM.elementOpen('h2');
		IncrementalDOM.text('Tactics');
		IncrementalDOM.elementClose('h2');
		IncrementalDOM.elementOpen('div', null, ['class', 'session-description']);
		IncrementalDOM.elementOpen('p');
		IncrementalDOM.elementOpen('b');
		IncrementalDOM.text('What are tactics? ');
		IncrementalDOM.elementClose('b');
		IncrementalDOM.elementOpen('em');
		IncrementalDOM.text(' Tactics are the different ways to achive your marketing goals. They usually include publishing destinations like landing pages or blog, defining broadcast prmotion on social media or via personalized banner ads in your webs and also one to one promotions like emails, SMS or Push notifications to the right audience. ');
		IncrementalDOM.elementClose('em');
		IncrementalDOM.elementClose('p');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementVoid(_TacticsTable2.default, null, null, 'destinations', this.config.destinations, 'selectedTacticIds', this.config.selectedTacticIds, 'tactics', this.config.tactics);
		IncrementalDOM.elementVoid('input', null, ['type', 'hidden', 'name', 'tacticIds'], 'value', this.config.selectedTacticIds.join(','));
		return IncrementalDOM.elementClose('div');
	};

	return EditCampaignTactics;
}(_JSXComponent3.default);

exports.default = EditCampaignTactics;

},{"../../../../node_modules/metal-jsx/src/JSXComponent":28,"../../../../node_modules/metal/src/metal":46,"../table/TacticsTable":75}],70:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Card = require('../cards/Card');

var _Card2 = _interopRequireDefault(_Card);

var _Header = require('../Header');

var _Header2 = _interopRequireDefault(_Header);

var _ImageCard = require('../cards/ImageCard');

var _ImageCard2 = _interopRequireDefault(_ImageCard);

var _JSXComponent2 = require('../../../../node_modules/metal-jsx/src/JSXComponent');

var _JSXComponent3 = _interopRequireDefault(_JSXComponent2);

var _TableCard = require('../cards/TableCard');

var _TableCard2 = _interopRequireDefault(_TableCard);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Dashboard = function (_JSXComponent) {
	_inherits(Dashboard, _JSXComponent);

	function Dashboard() {
		_classCallCheck(this, Dashboard);

		return _possibleConstructorReturn(this, _JSXComponent.apply(this, arguments));
	}

	Dashboard.prototype.addDots_ = function addDots_(number) {
		var str = number.toString();
		var finalStr = '';

		for (var i = 0; i < str.length; i++) {
			if (i > 0 && i < str.length - 1 && i % 3 === str.length % 3) {
				finalStr += '.';
			}
			finalStr += str[i];
		}
		return finalStr;
	};

	Dashboard.prototype.render = function render() {
		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager container-fluid']);
		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-dashboard']);
		IncrementalDOM.elementVoid(_Header2.default, null, null, 'currentUrl', this.config.currentUrl, 'basePath', this.config.basePath);
		IncrementalDOM.elementOpen('div', null, ['class', 'row']);
		IncrementalDOM.elementOpen('div', null, ['id', 'campaign-manager-active-card', 'class', 'col-md-4 campaign-manager-card-wrapper']);
		IncrementalDOM.elementOpen(_Card2.default, null, ['cssClass', 'clearfix']);
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-4']);
		IncrementalDOM.elementVoid('img', null, ['height', '100'], 'src', this.config.baseResourceUrl + 'images/target.png');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-8']);
		IncrementalDOM.elementOpen('div', null, ['class', 'highlight big']);
		iDOMHelpers.renderArbitrary(this.config.campaigns.length);
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-card-label']);
		IncrementalDOM.text('Active Campaigns');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose(_Card2.default);
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['id', 'campaign-manager-amount-card', 'class', 'col-md-4 campaign-manager-group campaign-manager-card-wrapper']);
		IncrementalDOM.elementOpen(_Card2.default, null, ['cssClass', 'clearfix']);
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-6']);
		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-amount-value']);
		IncrementalDOM.elementOpen('span', null, ['class', 'highlight']);
		iDOMHelpers.renderArbitrary(this.addDots_(this.sum_('influencedWins')));
		IncrementalDOM.elementClose('span');
		IncrementalDOM.elementOpen('span', null, ['class', 'light-gray']);
		IncrementalDOM.text('$');
		IncrementalDOM.elementClose('span');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-card-label']);
		IncrementalDOM.text('Influenced wins');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-6']);
		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-amount-value']);
		IncrementalDOM.elementOpen('span', null, ['class', 'highlight']);
		iDOMHelpers.renderArbitrary(this.addDots_(this.sum_('budget')));
		IncrementalDOM.elementClose('span');
		IncrementalDOM.elementOpen('span', null, ['class', 'light-gray']);
		IncrementalDOM.text('$');
		IncrementalDOM.elementClose('span');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-card-label']);
		IncrementalDOM.text('Total assigned budget');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose(_Card2.default);
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['id', 'campaign-manager-leads-card', 'class', 'col-md-4 campaign-manager-card-wrapper']);
		IncrementalDOM.elementOpen(_Card2.default, null, ['cssClass', 'clearfix']);
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-5']);
		IncrementalDOM.elementOpen('div', null, ['class', 'highlight big']);
		iDOMHelpers.renderArbitrary(this.sum_('leadsCount'));
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('p', null, ['class', 'campaign-manager-card-label']);
		IncrementalDOM.text(' Total leads ');
		IncrementalDOM.elementOpen('span');
		IncrementalDOM.text('(Lead Cost 1.26%)');
		IncrementalDOM.elementClose('span');
		IncrementalDOM.elementClose('p');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-2 hidden-sm campaign-manager-card-people']);
		IncrementalDOM.elementVoid('img', null, null, 'src', this.config.baseResourceUrl + 'images/people.png');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-5']);
		IncrementalDOM.elementOpen('div', null, ['class', 'highlight big']);
		iDOMHelpers.renderArbitrary(this.sum_('influencedCustomers'));
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('p', null, ['class', 'campaign-manager-card-label']);
		IncrementalDOM.text('Influenced customers');
		IncrementalDOM.elementClose('p');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose(_Card2.default);
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'row row-destinations']);
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-4 campaign-manager-card-wrapper']);
		IncrementalDOM.elementVoid(_ImageCard2.default, null, ['count', 2894, 'title', 'Destinations views'], 'imageUrl', this.config.baseResourceUrl + 'images/chart.png');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-4 campaign-manager-card-wrapper']);
		IncrementalDOM.elementVoid(_TableCard2.default, null, ['title', 'Top 5 Destinations'], 'headers', ['Name', 'Views', 'CTR'], 'data', [['Destination name 001', '12k', '7%'], ['Destination name 001', '12k', '7%'], ['Destination name 001', '12k', '7%'], ['Destination name 001', '12k', '7%'], ['Destination name 001', '12k', '7%']]);
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-4 campaign-manager-card-wrapper']);
		IncrementalDOM.elementVoid(_ImageCard2.default, null, ['count', 2894, 'title', 'Destinations conversions'], 'imageUrl', this.config.baseResourceUrl + 'images/chartWithLabels.png');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'row row-promotions']);
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-4 campaign-manager-card-wrapper']);
		IncrementalDOM.elementVoid(_ImageCard2.default, null, ['count', 2894, 'title', 'Banner Ads views'], 'imageUrl', this.config.baseResourceUrl + 'images/chart.png');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-4 campaign-manager-card-wrapper']);
		IncrementalDOM.elementVoid(_TableCard2.default, null, ['title', 'One to One promotions'], 'headers', ['Name', '# Promotions', '# Reach', 'CTR'], 'data', [['SMS', '150', '150', '7%'], ['Email', '860', '860', '5%'], ['Push', '75', '260', '3%']]);
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-4 campaign-manager-card-wrapper']);
		IncrementalDOM.elementVoid(_TableCard2.default, null, ['title', 'Social Promotions'], 'headers', ['Channel', '# Post', 'Reach', 'CTR'], 'data', [['Facebook', '150', '150', '7%'], ['Twitter', '150', '150', '7%'], ['LinkedIn', '150', '150', '7%']]);
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose('div');
		return IncrementalDOM.elementClose('div');
	};

	Dashboard.prototype.sum_ = function sum_(name) {
		return this.config.campaigns.reduce(function (prev, curr) {
			return prev + curr[name];
		}, 0);
	};

	return Dashboard;
}(_JSXComponent3.default);

exports.default = Dashboard;

},{"../../../../node_modules/metal-jsx/src/JSXComponent":28,"../Header":62,"../cards/Card":64,"../cards/ImageCard":65,"../cards/TableCard":66}],71:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../../../node_modules/metal/src/metal');

var _store = require('../../store/store');

var _store2 = _interopRequireDefault(_store);

var _Actions = require('../../actions/Actions');

var _Actions2 = _interopRequireDefault(_Actions);

var _BackArrow = require('../BackArrow');

var _BackArrow2 = _interopRequireDefault(_BackArrow);

var _EditCampaignDetails = require('../edit/EditCampaignDetails');

var _EditCampaignDetails2 = _interopRequireDefault(_EditCampaignDetails);

var _EditCampaignGoal = require('../edit/EditCampaignGoal');

var _EditCampaignGoal2 = _interopRequireDefault(_EditCampaignGoal);

var _EditCampaignTactics = require('../edit/EditCampaignTactics');

var _EditCampaignTactics2 = _interopRequireDefault(_EditCampaignTactics);

var _JSXComponent2 = require('../../../../node_modules/metal-jsx/src/JSXComponent');

var _JSXComponent3 = _interopRequireDefault(_JSXComponent2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditCampaign = function (_JSXComponent) {
	_inherits(EditCampaign, _JSXComponent);

	function EditCampaign() {
		_classCallCheck(this, EditCampaign);

		return _possibleConstructorReturn(this, _JSXComponent.apply(this, arguments));
	}

	EditCampaign.prototype.buildDate_ = function buildDate_(dateStr, time) {
		var date = new Date(dateStr ? dateStr : Date.now());
		date.setHours(time);
		return {
			date: date.getDate(),
			month: date.getMonth() + 1,
			year: date.getFullYear(),
			hours: date.getHours(),
			minutes: date.getMinutes()
		};
	};

	EditCampaign.prototype.getData_ = function getData_() {
		var data = {};
		var namedFields = this.element.querySelectorAll('form [name]');
		for (var i = 0; i < namedFields.length; i++) {
			var name = namedFields[i].getAttribute('name');
			data[name] = namedFields[i].text ? namedFields[i].text : namedFields[i].value;
		}
		return data;
	};

	EditCampaign.prototype.render = function render() {
		var editMode = _metal.core.isDefAndNotNull(this.config.editCampaignId);
		var editCampaign = editMode ? this.config.campaigns[this.config.editCampaignId] : null;

		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-edit-campaign']);
		IncrementalDOM.elementOpen('div', null, ['class', 'container-fluid white-bg campaign-manager']);
		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-page-title']);
		IncrementalDOM.elementVoid(_BackArrow2.default, null, null, 'basePath', this.config.basePath, 'sourceUrl', this.config.sourceUrl);
		IncrementalDOM.elementOpen('h1');
		iDOMHelpers.renderArbitrary(editMode ? 'Edit' : 'New');
		IncrementalDOM.text(' Campaign ');
		IncrementalDOM.elementClose('h1');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('form', null, ['class', 'form-horizontal']);
		IncrementalDOM.elementVoid(_EditCampaignDetails2.default, null, null, 'campaigns', this.config.campaigns, 'editCampaignId', this.config.editCampaignId);
		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-edit-campaign-journey container-fluid white-bg campaign-manager session']);
		IncrementalDOM.elementOpen('h2');
		IncrementalDOM.text('Journey');
		IncrementalDOM.elementClose('h2');
		IncrementalDOM.elementOpen('div', null, ['class', 'session-description']);
		IncrementalDOM.elementOpen('p');
		IncrementalDOM.elementOpen('b');
		IncrementalDOM.text('What\'s the journey? ');
		IncrementalDOM.elementClose('b');
		IncrementalDOM.elementOpen('em');
		IncrementalDOM.text('The journey defines the steps or stages of your campaign. If you don\'t have stages, just use the single step journey. If you are using multi-step journeys you\'ll be able to define goals for each stage and program tactic that depend on information from the previous stage. ');
		IncrementalDOM.elementClose('em');
		IncrementalDOM.elementClose('p');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'form-group']);
		IncrementalDOM.elementOpen('label', null, ['for', '', 'class', 'col-md-1 control-label']);
		IncrementalDOM.text('Journey');
		IncrementalDOM.elementClose('label');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-2']);
		IncrementalDOM.elementOpen('select', null, ['class', 'form-control', 'name', 'journey']);
		IncrementalDOM.elementOpen('option', null, ['value', '1']);
		IncrementalDOM.text('Sales Funnel');
		IncrementalDOM.elementClose('option');
		IncrementalDOM.elementClose('select');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-4']);
		IncrementalDOM.elementOpen('a', null, ['class', 'btn-manage-journey']);
		IncrementalDOM.text('Manage journeys');
		IncrementalDOM.elementClose('a');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementVoid(_EditCampaignGoal2.default, null, null, 'campaigns', this.config.campaigns, 'editCampaignId', this.config.editCampaignId);
		IncrementalDOM.elementVoid(_EditCampaignTactics2.default, null, null, 'destinations', this.config.destinations, 'selectedTacticIds', editCampaign ? editCampaign.tacticIds : [], 'tactics', this.config.tactics);
		IncrementalDOM.elementOpen('div', null, ['class', 'container-fluid campaign-manager white-bg session']);
		IncrementalDOM.elementOpen('div', null, ['class', 'form-group']);
		IncrementalDOM.elementOpen('div', null, ['class', 'col-sm-10']);
		IncrementalDOM.elementOpen('a', null, ['class', 'btn btn-lg btn-success'], 'href', this.config.basePath + this.config.sourceUrl, 'data-onclick', this.save_.bind(this));
		iDOMHelpers.renderArbitrary(editMode ? 'Save' : 'Create');
		IncrementalDOM.text(' Campaign ');
		IncrementalDOM.elementClose('a');
		IncrementalDOM.elementOpen('a', null, ['class', 'btn btn-lg btn-lighter'], 'href', this.config.basePath + this.config.sourceUrl);
		IncrementalDOM.text(' Cancel ');
		IncrementalDOM.elementClose('a');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose('form');
		return IncrementalDOM.elementClose('div');
	};

	EditCampaign.prototype.save_ = function save_() {
		var data = this.getData_();
		_store2.default.dispatch(_Actions2.default.saveCampaign(_metal.object.mixin(data, {
			id: _metal.core.isNumber(this.config.editCampaignId) ? this.config.editCampaignId : undefined,
			budget: parseInt(data.budget, 10) || 0,
			startDate: this.buildDate_(data.startDate, data.startDateTime),
			endDate: this.buildDate_(data.endDate, data.endDateTime),
			goal: {
				generation: {
					count: data['generation.count']
				}
			},
			journey: parseInt(data.journey, 10),
			tacticIds: data.tacticIds.split(',').map(function (id) {
				return parseInt(id, 10);
			}).filter(function (id) {
				return !!id;
			})
		})));
	};

	return EditCampaign;
}(_JSXComponent3.default);

exports.default = EditCampaign;

},{"../../../../node_modules/metal-jsx/src/JSXComponent":28,"../../../../node_modules/metal/src/metal":46,"../../actions/Actions":60,"../../store/store":80,"../BackArrow":61,"../edit/EditCampaignDetails":67,"../edit/EditCampaignGoal":68,"../edit/EditCampaignTactics":69}],72:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../../../node_modules/metal/src/metal');

var _metal2 = _interopRequireDefault(_metal);

var _CampaignTable = require('../table/CampaignTable');

var _CampaignTable2 = _interopRequireDefault(_CampaignTable);

var _Card = require('../cards/Card');

var _Card2 = _interopRequireDefault(_Card);

var _Header = require('../Header');

var _Header2 = _interopRequireDefault(_Header);

var _JSXComponent2 = require('../../../../node_modules/metal-jsx/src/JSXComponent');

var _JSXComponent3 = _interopRequireDefault(_JSXComponent2);

var _Search = require('../search/Search');

var _Search2 = _interopRequireDefault(_Search);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ManageCampaigns = function (_JSXComponent) {
	_inherits(ManageCampaigns, _JSXComponent);

	function ManageCampaigns() {
		_classCallCheck(this, ManageCampaigns);

		return _possibleConstructorReturn(this, _JSXComponent.apply(this, arguments));
	}

	ManageCampaigns.prototype.filterCampaigns_ = function filterCampaigns_() {
		var _this2 = this;

		return this.campaigns.filter(function (campaign) {
			return !_this2.searchBy || campaign.name.toLowerCase().startsWith(_this2.searchBy.toLowerCase());
		}).sort(function (c1, c2) {
			if (_this2.sortBy === 'date') {
				var start = _this2.toDate_(c1.startDate) - _this2.toDate_(c2.startDate);
				return start !== 0 ? start : _this2.toDate_(c1.endDate) - _this2.toDate_(c2.endDate);
			} else {
				return c1.name.localeCompare(c2.name);
			}
		});
	};

	ManageCampaigns.prototype.render = function render() {
		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager container-fluid']);
		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-manage-campaigns']);
		IncrementalDOM.elementVoid(_Header2.default, null, null, 'currentUrl', this.config.currentUrl, 'basePath', this.config.basePath);
		IncrementalDOM.elementOpen('div', null, ['class', 'row']);
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-4']);
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'col-md-4']);
		IncrementalDOM.elementVoid(_Search2.default, null, null, 'onInput', this.search_.bind(this));
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen(_Card2.default);
		IncrementalDOM.elementOpen('div', null, ['class', 'form-inline select pull-right']);
		IncrementalDOM.elementOpen('label');
		IncrementalDOM.text('View Mode:');
		IncrementalDOM.elementClose('label');
		IncrementalDOM.elementOpen('select', null, ['class', 'form-control']);
		IncrementalDOM.elementOpen('option', null, ['value', 'name']);
		IncrementalDOM.text('List');
		IncrementalDOM.elementClose('option');
		IncrementalDOM.elementClose('select');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementOpen('div', null, ['class', 'form-inline select']);
		IncrementalDOM.elementOpen('label');
		IncrementalDOM.text('Order by:');
		IncrementalDOM.elementClose('label');
		IncrementalDOM.elementOpen('select', null, ['class', 'form-control'], 'data-onchange', this.sort_.bind(this));
		IncrementalDOM.elementOpen('option', null, ['value', 'name']);
		IncrementalDOM.text('Name');
		IncrementalDOM.elementClose('option');
		IncrementalDOM.elementOpen('option', null, ['value', 'date']);
		IncrementalDOM.text('Scheduled Date');
		IncrementalDOM.elementClose('option');
		IncrementalDOM.elementClose('select');
		IncrementalDOM.elementClose('div');
		IncrementalDOM.elementVoid(_CampaignTable2.default, null, null, 'basePath', this.config.basePath, 'campaigns', this.filterCampaigns_(), 'currentUrl', this.config.currentUrl);
		IncrementalDOM.elementClose(_Card2.default);
		IncrementalDOM.elementClose('div');
		return IncrementalDOM.elementClose('div');
	};

	ManageCampaigns.prototype.search_ = function search_(event) {
		this.searchBy = event.target.value;
	};

	ManageCampaigns.prototype.sort_ = function sort_(event) {
		this.sortBy = event.target.value;
	};

	ManageCampaigns.prototype.toDate_ = function toDate_(obj) {
		return new Date(obj.year, obj.month, obj.date, obj.hours, obj.minutes);
	};

	return ManageCampaigns;
}(_JSXComponent3.default);

ManageCampaigns.STATE = {
	campaigns: {
		validator: Array.isArray
	},
	searchBy: {
		validator: _metal2.default.isString
	},
	sortBy: {
		validator: _metal2.default.isString
	}
};

exports.default = ManageCampaigns;

},{"../../../../node_modules/metal-jsx/src/JSXComponent":28,"../../../../node_modules/metal/src/metal":46,"../Header":62,"../cards/Card":64,"../search/Search":73,"../table/CampaignTable":74}],73:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _JSXComponent2 = require('../../../../node_modules/metal-jsx/src/JSXComponent');

var _JSXComponent3 = _interopRequireDefault(_JSXComponent2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Search = function (_JSXComponent) {
	_inherits(Search, _JSXComponent);

	function Search() {
		_classCallCheck(this, Search);

		return _possibleConstructorReturn(this, _JSXComponent.apply(this, arguments));
	}

	Search.prototype.render = function render() {
		IncrementalDOM.elementOpen('div', null, ['class', 'input-group campaign-manager-search']);
		IncrementalDOM.elementVoid('input', null, ['type', 'text', 'class', 'form-control input-lg', 'placeholder', 'Search'], 'value', this.config.value || '', 'data-oninput', this.config.onInput);
		IncrementalDOM.elementOpen('div', null, ['class', 'input-group-addon input-group-addon-clean']);
		IncrementalDOM.elementOpen('span', null, ['class', 'glyphicon glyphicon-search']);
		IncrementalDOM.elementClose('span');
		IncrementalDOM.elementClose('div');
		return IncrementalDOM.elementClose('div');
	};

	return Search;
}(_JSXComponent3.default);

exports.default = Search;

},{"../../../../node_modules/metal-jsx/src/JSXComponent":28}],74:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _dom = require('../../../../node_modules/metal-dom/src/all/dom');

var _dom2 = _interopRequireDefault(_dom);

var _store = require('../../store/store');

var _store2 = _interopRequireDefault(_store);

var _Actions = require('../../actions/Actions');

var _Actions2 = _interopRequireDefault(_Actions);

var _JSXComponent2 = require('../../../../node_modules/metal-jsx/src/JSXComponent');

var _JSXComponent3 = _interopRequireDefault(_JSXComponent2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CampaignTable = function (_JSXComponent) {
	_inherits(CampaignTable, _JSXComponent);

	function CampaignTable() {
		_classCallCheck(this, CampaignTable);

		return _possibleConstructorReturn(this, _JSXComponent.apply(this, arguments));
	}

	CampaignTable.prototype.edit_ = function edit_(event) {
		var id = this.getRowId_(event);
		_store2.default.dispatch(_Actions2.default.startCampaignEdition(id, this.config.currentUrl));
	};

	CampaignTable.prototype.getRowId_ = function getRowId_(event) {
		return parseInt(_dom2.default.parent(event.target, 'tr').getAttribute('data-id'), 10);
	};

	CampaignTable.prototype.remove_ = function remove_(event) {
		var id = this.getRowId_(event);
		_store2.default.dispatch(_Actions2.default.removeCampaign(id));
	};

	CampaignTable.prototype.render = function render() {
		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-campaign-table campaign-manager-table']);
		IncrementalDOM.elementOpen('table', null, ['class', 'table table-box']);
		IncrementalDOM.elementOpen('thead');
		IncrementalDOM.elementOpen('tr');
		IncrementalDOM.elementOpen('th', null, ['class', 'light-gray']);
		IncrementalDOM.text('Name');
		IncrementalDOM.elementClose('th');
		IncrementalDOM.elementOpen('th', null, ['class', 'light-gray']);
		IncrementalDOM.text('Scheduled Date');
		IncrementalDOM.elementClose('th');
		IncrementalDOM.elementOpen('th', null, ['class', 'light-gray']);
		IncrementalDOM.text('Goal');
		IncrementalDOM.elementClose('th');
		IncrementalDOM.elementOpen('th', null, ['class', 'light-gray']);
		IncrementalDOM.text('Edit');
		IncrementalDOM.elementClose('th');
		IncrementalDOM.elementOpen('th', null, ['class', 'light-gray']);
		IncrementalDOM.text('Remove');
		IncrementalDOM.elementClose('th');
		IncrementalDOM.elementClose('tr');
		IncrementalDOM.elementClose('thead');
		IncrementalDOM.elementOpen('tbody');
		iDOMHelpers.renderArbitrary(this.renderRows_());
		IncrementalDOM.elementClose('tbody');
		IncrementalDOM.elementClose('table');
		return IncrementalDOM.elementClose('div');
	};

	CampaignTable.prototype.renderDate_ = function renderDate_(date) {
		IncrementalDOM.elementOpen('span');
		iDOMHelpers.renderArbitrary(MONTHS[date.month - 1] + ' ' + date.date + ', ' + date.year);
		return IncrementalDOM.elementClose('span');
	};

	CampaignTable.prototype.renderRows_ = function renderRows_() {
		var _this2 = this;

		return this.config.campaigns.map(function (campaign) {
			IncrementalDOM.elementOpen('tr', null, null, 'data-id', campaign.id);
			IncrementalDOM.elementOpen('td');
			IncrementalDOM.elementOpen('span');
			iDOMHelpers.renderArbitrary(campaign.name);
			IncrementalDOM.elementClose('span');
			IncrementalDOM.elementClose('td');
			IncrementalDOM.elementOpen('td');
			IncrementalDOM.elementOpen('span');
			iDOMHelpers.renderArbitrary(_this2.renderDate_(campaign.startDate));
			IncrementalDOM.text(' to ');
			iDOMHelpers.renderArbitrary(_this2.renderDate_(campaign.endDate));
			IncrementalDOM.elementClose('span');
			IncrementalDOM.elementClose('td');
			IncrementalDOM.elementOpen('td');
			IncrementalDOM.elementOpen('span');
			IncrementalDOM.text('Lead Generation - ');
			iDOMHelpers.renderArbitrary(campaign.goal.generation.count);
			IncrementalDOM.text(' new contacts in 2 weeks');
			IncrementalDOM.elementClose('span');
			IncrementalDOM.elementClose('td');
			IncrementalDOM.elementOpen('td');
			IncrementalDOM.elementOpen('a', null, null, 'href', _this2.config.basePath + '/edit-campaign/' + campaign.id, 'data-onclick', _this2.edit_.bind(_this2));
			IncrementalDOM.elementOpen('span', null, ['class', 'glyphicon glyphicon-cog table-action-icon table-action-edit']);
			IncrementalDOM.elementClose('span');
			IncrementalDOM.elementClose('a');
			IncrementalDOM.elementClose('td');
			IncrementalDOM.elementOpen('td');
			IncrementalDOM.elementOpen('span', null, ['class', 'glyphicon glyphicon-trash table-action-icon table-action-remove'], 'data-onclick', _this2.remove_.bind(_this2));
			IncrementalDOM.elementClose('span');
			IncrementalDOM.elementClose('td');
			return IncrementalDOM.elementClose('tr');
		});
	};

	return CampaignTable;
}(_JSXComponent3.default);

var MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

exports.default = CampaignTable;

},{"../../../../node_modules/metal-dom/src/all/dom":13,"../../../../node_modules/metal-jsx/src/JSXComponent":28,"../../actions/Actions":60,"../../store/store":80}],75:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _dom = require('../../../../node_modules/metal-dom/src/all/dom');

var _dom2 = _interopRequireDefault(_dom);

var _JSXComponent2 = require('../../../../node_modules/metal-jsx/src/JSXComponent');

var _JSXComponent3 = _interopRequireDefault(_JSXComponent2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TacticsTable = function (_JSXComponent) {
	_inherits(TacticsTable, _JSXComponent);

	function TacticsTable() {
		_classCallCheck(this, TacticsTable);

		return _possibleConstructorReturn(this, _JSXComponent.apply(this, arguments));
	}

	TacticsTable.prototype.remove_ = function remove_() {
		var row = parseInt(_dom2.default.parent(event.target, 'tr').getAttribute('data-row'), 10);
		var tacticIds = this.selectedTacticIds.concat();
		tacticIds.splice(row, 1);
		this.selectedTacticIds = tacticIds;
	};

	TacticsTable.prototype.render = function render() {
		IncrementalDOM.elementOpen('div', null, ['class', 'campaign-manager-tactics-table campaign-manager-table']);
		IncrementalDOM.elementOpen('table', null, ['class', 'table table-box']);
		IncrementalDOM.elementOpen('thead');
		IncrementalDOM.elementOpen('tr');
		IncrementalDOM.elementOpen('th', null, ['class', 'light-gray']);
		IncrementalDOM.text('Name');
		IncrementalDOM.elementClose('th');
		IncrementalDOM.elementOpen('th', null, ['class', 'light-gray']);
		IncrementalDOM.text('Destination');
		IncrementalDOM.elementClose('th');
		IncrementalDOM.elementOpen('th', null, ['class', 'light-gray']);
		IncrementalDOM.text('Promos');
		IncrementalDOM.elementClose('th');
		IncrementalDOM.elementOpen('th', null, ['class', 'light-gray']);
		IncrementalDOM.text('Audience');
		IncrementalDOM.elementClose('th');
		IncrementalDOM.elementOpen('th', null, ['class', 'light-gray']);
		IncrementalDOM.text('Banners');
		IncrementalDOM.elementClose('th');
		IncrementalDOM.elementOpen('th', null, ['class', 'light-gray']);
		IncrementalDOM.text('Remove');
		IncrementalDOM.elementClose('th');
		IncrementalDOM.elementClose('tr');
		IncrementalDOM.elementClose('thead');
		IncrementalDOM.elementOpen('tbody');
		iDOMHelpers.renderArbitrary(this.renderRows_());
		IncrementalDOM.elementClose('tbody');
		IncrementalDOM.elementClose('table');
		return IncrementalDOM.elementClose('div');
	};

	TacticsTable.prototype.renderRows_ = function renderRows_() {
		var _this2 = this;

		return this.selectedTacticIds.map(function (id, index) {
			IncrementalDOM.elementOpen('tr', null, null, 'data-row', index);
			IncrementalDOM.elementOpen('td');
			IncrementalDOM.elementOpen('span');
			iDOMHelpers.renderArbitrary(_this2.config.destinations[_this2.config.tactics[id].destinationId].name);
			IncrementalDOM.elementClose('span');
			IncrementalDOM.elementClose('td');
			IncrementalDOM.elementOpen('td');
			IncrementalDOM.elementOpen('span');
			iDOMHelpers.renderArbitrary(_this2.config.tactics[id].name);
			IncrementalDOM.elementClose('span');
			IncrementalDOM.elementClose('td');
			IncrementalDOM.elementOpen('td');
			IncrementalDOM.elementOpen('span', null, null, 'class', _this2.config.tactics[id].oneToOnePromos.length > 0 ? 'glyphicon glyphicon-ok' : '');
			IncrementalDOM.elementClose('span');
			IncrementalDOM.elementClose('td');
			IncrementalDOM.elementOpen('td');
			IncrementalDOM.elementOpen('span', null, null, 'class', _this2.config.tactics[id].oneToOnePromos.length > 0 ? 'glyphicon glyphicon-ok' : '');
			IncrementalDOM.elementClose('span');
			IncrementalDOM.elementClose('td');
			IncrementalDOM.elementOpen('td');
			IncrementalDOM.elementOpen('span', null, null, 'class', _this2.config.tactics[id].promotionalAds.length > 0 ? 'glyphicon glyphicon-ok' : '');
			IncrementalDOM.elementClose('span');
			IncrementalDOM.elementClose('td');
			IncrementalDOM.elementOpen('td');
			IncrementalDOM.elementOpen('span', null, ['class', 'glyphicon glyphicon-trash table-action-icon table-action-remove'], 'data-onclick', _this2.remove_.bind(_this2));
			IncrementalDOM.elementClose('span');
			IncrementalDOM.elementClose('td');
			return IncrementalDOM.elementClose('tr');
		});
	};

	return TacticsTable;
}(_JSXComponent3.default);

TacticsTable.STATE = {
	selectedTacticIds: {
		validator: Array.isArray
	}
};

exports.default = TacticsTable;

},{"../../../../node_modules/metal-dom/src/all/dom":13,"../../../../node_modules/metal-jsx/src/JSXComponent":28}],76:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = require('../../../node_modules/metal/src/metal');

var _ActionTypes = require('../actions/ActionTypes');

var _ActionTypes2 = _interopRequireDefault(_ActionTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function campaigns(state, action) {
	switch (action.type) {
		case _ActionTypes2.default.REMOVE_CAMPAIGN:
			state = state.concat();
			state.splice(action.id, 1);
			return state;
		case _ActionTypes2.default.SAVE_CAMPAIGN:
			state = state.concat();
			if (_metal.core.isDefAndNotNull(action.campaign.id)) {
				state[action.campaign.id] = _metal.object.mixin(state[action.campaign.id], action.campaign);
			} else {
				state.push(_metal.object.mixin(action.campaign, {
					id: state.length,
					influencedCustomers: 0,
					influencedWins: 0,
					leadsCount: 0
				}));
			}
			return state;
	}
	return state || [];
}

exports.default = campaigns;

},{"../../../node_modules/metal/src/metal":46,"../actions/ActionTypes":59}],77:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _ActionTypes = require('../actions/ActionTypes');

var _ActionTypes2 = _interopRequireDefault(_ActionTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function editCampaignId(state, action) {
	switch (action.type) {
		case _ActionTypes2.default.START_CAMPAIGN_EDITION:
			return action.id;
		case _ActionTypes2.default.START_CAMPAIGN_CREATION:
			return null;
	}
	return state || null;
}

exports.default = editCampaignId;

},{"../actions/ActionTypes":59}],78:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _ActionTypes = require('../actions/ActionTypes');

var _ActionTypes2 = _interopRequireDefault(_ActionTypes);

var _campaigns = require('./campaigns');

var _campaigns2 = _interopRequireDefault(_campaigns);

var _editCampaignId = require('./editCampaignId');

var _editCampaignId2 = _interopRequireDefault(_editCampaignId);

var _sourceUrl = require('./sourceUrl');

var _sourceUrl2 = _interopRequireDefault(_sourceUrl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function basePath(state) {
	return state || '';
}

function baseResourceUrl(state) {
	return state || '/';
}

function destinations(state) {
	return state || [];
}

function audiences(state) {
	return state || [];
}

function banners(state) {
	return state || [];
}

function displays(state) {
	return state || [];
}

function tactics(state) {
	return state || [];
}

var combined = Redux.combineReducers({
	basePath: basePath,
	baseResourceUrl: baseResourceUrl,
	campaigns: _campaigns2.default,
	editCampaignId: _editCampaignId2.default,
	destinations: destinations,
	audiences: audiences,
	banners: banners,
	displays: displays,
	tactics: tactics,
	sourceUrl: _sourceUrl2.default
});

function rootReducer(state, action) {
	switch (action.type) {
		case _ActionTypes2.default.UPDATE_DATA:
			return action.state;
	}
	return combined(state, action);
}

exports.default = rootReducer;

},{"../actions/ActionTypes":59,"./campaigns":76,"./editCampaignId":77,"./sourceUrl":79}],79:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _ActionTypes = require('../actions/ActionTypes');

var _ActionTypes2 = _interopRequireDefault(_ActionTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function sourceUrl(state, action) {
	switch (action.type) {
		case _ActionTypes2.default.START_CAMPAIGN_CREATION:
		case _ActionTypes2.default.START_CAMPAIGN_EDITION:
			return action.sourceUrl || '/';
	}
	return state || '/';
}

exports.default = sourceUrl;

},{"../actions/ActionTypes":59}],80:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _rootReducer = require('../reducers/rootReducer');

var _rootReducer2 = _interopRequireDefault(_rootReducer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = Redux.createStore(_rootReducer2.default);

},{"../reducers/rootReducer":78}]},{},[58])(58)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvaHRtbDJpbmNkb20vc3JjL0hUTUwySW5jRG9tLmpzIiwibm9kZV9tb2R1bGVzL2h0bWwyaW5jZG9tL3NyYy9IVE1MUGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL2h0bWwyaW5jZG9tL3NyYy91bmVzY2FwZS5qcyIsIm5vZGVfbW9kdWxlcy9odG1sMmluY2RvbS9zcmMvd2l0aFBhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC1hamF4L3NyYy9BamF4LmpzIiwibm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9zcmMvQ29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9zcmMvQ29tcG9uZW50UmVnaXN0cnkuanMiLCJub2RlX21vZHVsZXMvbWV0YWwtY29tcG9uZW50L3NyYy9Db21wb25lbnRSZW5kZXJlci5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC1jb21wb25lbnQvc3JjL0V2ZW50c0NvbGxlY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC1jb21wb25lbnQvc3JjL2FsbC9jb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvbWV0YWwtZG9tL3NyYy9Eb21FdmVudEVtaXR0ZXJQcm94eS5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC1kb20vc3JjL0RvbUV2ZW50SGFuZGxlLmpzIiwibm9kZV9tb2R1bGVzL21ldGFsLWRvbS9zcmMvYWxsL2RvbS5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC1kb20vc3JjL2RvbS5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC1kb20vc3JjL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC1kb20vc3JjL2ZlYXR1cmVzLmpzIiwibm9kZV9tb2R1bGVzL21ldGFsLWRvbS9zcmMvZ2xvYmFsRXZhbC5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC1kb20vc3JjL2dsb2JhbEV2YWxTdHlsZXMuanMiLCJub2RlX21vZHVsZXMvbWV0YWwtZXZlbnRzL3NyYy9FdmVudEVtaXR0ZXIuanMiLCJub2RlX21vZHVsZXMvbWV0YWwtZXZlbnRzL3NyYy9FdmVudEVtaXR0ZXJQcm94eS5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC1ldmVudHMvc3JjL0V2ZW50SGFuZGxlLmpzIiwibm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9zcmMvRXZlbnRIYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9zcmMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9zcmMvSW5jcmVtZW50YWxEb21Bb3AuanMiLCJub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL3NyYy9JbmNyZW1lbnRhbERvbVJlbmRlcmVyLmpzIiwibm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9zcmMvaW5jcmVtZW50YWwtZG9tLmpzIiwibm9kZV9tb2R1bGVzL21ldGFsLWpzeC9zcmMvSlNYLmpzIiwibm9kZV9tb2R1bGVzL21ldGFsLWpzeC9zcmMvSlNYQ29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL21ldGFsLWpzeC9zcmMvaURPTUhlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvbWV0YWwtbXVsdGltYXAvc3JjL011bHRpTWFwLmpzIiwibm9kZV9tb2R1bGVzL21ldGFsLXByb21pc2Uvc3JjL3Byb21pc2UvUHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC1yb3V0ZXIvc3JjL1JvdXRlci5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC1yb3V0ZXIvc3JjL1JvdXRlci5zb3kuanMiLCJub2RlX21vZHVsZXMvbWV0YWwtc295LWJ1bmRsZS9idWlsZC9idW5kbGUuanMiLCJub2RlX21vZHVsZXMvbWV0YWwtc295L3NyYy9Tb3kuanMiLCJub2RlX21vZHVsZXMvbWV0YWwtc295L3NyYy9Tb3lBb3AuanMiLCJub2RlX21vZHVsZXMvbWV0YWwtc3RhdGUvc3JjL1N0YXRlLmpzIiwibm9kZV9tb2R1bGVzL21ldGFsLXVyaS9zcmMvVXJpLmpzIiwibm9kZV9tb2R1bGVzL21ldGFsLXVyaS9zcmMvcGFyc2UuanMiLCJub2RlX21vZHVsZXMvbWV0YWwtdXJpL3NyYy9wYXJzZUZyb21BbmNob3IuanMiLCJub2RlX21vZHVsZXMvbWV0YWwtdXNlcmFnZW50L3NyYy9VQS5qcyIsIm5vZGVfbW9kdWxlcy9tZXRhbC9zcmMvYXJyYXkvYXJyYXkuanMiLCJub2RlX21vZHVsZXMvbWV0YWwvc3JjL2FzeW5jL2FzeW5jLmpzIiwibm9kZV9tb2R1bGVzL21ldGFsL3NyYy9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL21ldGFsL3NyYy9kaXNwb3NhYmxlL0Rpc3Bvc2FibGUuanMiLCJub2RlX21vZHVsZXMvbWV0YWwvc3JjL21ldGFsLmpzIiwibm9kZV9tb2R1bGVzL21ldGFsL3NyYy9vYmplY3Qvb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL21ldGFsL3NyYy9zdHJpbmcvc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL3Nlbm5hL3NyYy9hcHAvQXBwLmpzIiwibm9kZV9tb2R1bGVzL3Nlbm5hL3NyYy9jYWNoZWFibGUvQ2FjaGVhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3Nlbm5hL3NyYy9lcnJvcnMvZXJyb3JzLmpzIiwibm9kZV9tb2R1bGVzL3Nlbm5hL3NyYy9nbG9iYWxzL2dsb2JhbHMuanMiLCJub2RlX21vZHVsZXMvc2VubmEvc3JjL3JvdXRlL1JvdXRlLmpzIiwibm9kZV9tb2R1bGVzL3Nlbm5hL3NyYy9zY3JlZW4vUmVxdWVzdFNjcmVlbi5qcyIsIm5vZGVfbW9kdWxlcy9zZW5uYS9zcmMvc2NyZWVuL1NjcmVlbi5qcyIsIm5vZGVfbW9kdWxlcy9zZW5uYS9zcmMvc3VyZmFjZS9TdXJmYWNlLmpzIiwibm9kZV9tb2R1bGVzL3Nlbm5hL3NyYy91dGlscy91dGlscy5qcyIsInNyYy9qcy9NYWluLmpzIiwic3JjL2pzL2FjdGlvbnMvQWN0aW9uVHlwZXMuanMiLCJzcmMvanMvYWN0aW9ucy9BY3Rpb25zLmpzIiwic3JjL2pzL2NvbXBvbmVudHMvQmFja0Fycm93LmpzIiwic3JjL2pzL2NvbXBvbmVudHMvSGVhZGVyLmpzIiwic3JjL2pzL2NvbXBvbmVudHMvVGFicy5qcyIsInNyYy9qcy9jb21wb25lbnRzL2NhcmRzL0NhcmQuanMiLCJzcmMvanMvY29tcG9uZW50cy9jYXJkcy9JbWFnZUNhcmQuanMiLCJzcmMvanMvY29tcG9uZW50cy9jYXJkcy9UYWJsZUNhcmQuanMiLCJzcmMvanMvY29tcG9uZW50cy9lZGl0L0VkaXRDYW1wYWlnbkRldGFpbHMuanMiLCJzcmMvanMvY29tcG9uZW50cy9lZGl0L0VkaXRDYW1wYWlnbkdvYWwuanMiLCJzcmMvanMvY29tcG9uZW50cy9lZGl0L0VkaXRDYW1wYWlnblRhY3RpY3MuanMiLCJzcmMvanMvY29tcG9uZW50cy9wYWdlcy9EYXNoYm9hcmQuanMiLCJzcmMvanMvY29tcG9uZW50cy9wYWdlcy9FZGl0Q2FtcGFpZ24uanMiLCJzcmMvanMvY29tcG9uZW50cy9wYWdlcy9NYW5hZ2VDYW1wYWlnbnMuanMiLCJzcmMvanMvY29tcG9uZW50cy9zZWFyY2gvU2VhcmNoLmpzIiwic3JjL2pzL2NvbXBvbmVudHMvdGFibGUvQ2FtcGFpZ25UYWJsZS5qcyIsInNyYy9qcy9jb21wb25lbnRzL3RhYmxlL1RhY3RpY3NUYWJsZS5qcyIsInNyYy9qcy9yZWR1Y2Vycy9jYW1wYWlnbnMuanMiLCJzcmMvanMvcmVkdWNlcnMvZWRpdENhbXBhaWduSWQuanMiLCJzcmMvanMvcmVkdWNlcnMvcm9vdFJlZHVjZXIuanMiLCJzcmMvanMvcmVkdWNlcnMvc291cmNlVXJsLmpzIiwic3JjL2pzL3N0b3JlL3N0b3JlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7Ozs7OztBQUVBOzs7Ozs7OztBQUVBLElBQUksT0FBSjs7SUFFTSxXOzs7Ozs7Ozs7Ozs7O2FBUUUsTyxvQkFBUSxJLEVBQU07QUFDcEIsU0FBTztBQUFBLFVBQU0sWUFBWSxHQUFaLENBQWdCLElBQWhCLENBQU47QUFBQSxHQUFQO0FBQ0EsRTs7Ozs7Ozs7YUFNTSxTLHdCQUFZO0FBQ2xCLFNBQU8sV0FBVyxPQUFPLFVBQXpCO0FBQ0EsRTs7Ozs7Ozs7YUFNTSxHLGdCQUFJLEksRUFBTTtBQUNoQixjQUFZLFNBQVosR0FBd0IsSUFBeEIsRUFBOEI7QUFDN0IsVUFBTyxlQUFTLEdBQVQsRUFBYyxLQUFkLEVBQXFCLEtBQXJCLEVBQTRCO0FBQ2xDLFFBQUksS0FBSyxRQUFRLGVBQWUsV0FBdkIsR0FBcUMsZUFBZSxXQUE3RDtBQUNBLFFBQUksT0FBTyxDQUNWLEdBRFUsRUFFVixJQUZVLEVBR1YsRUFIVSxDQUFYO0FBS0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE1BQU0sTUFBMUIsRUFBa0MsR0FBbEMsRUFBdUM7QUFDdEMsVUFBSyxJQUFMLENBQVUsTUFBTSxDQUFOLEVBQVMsSUFBbkIsRUFBeUIsTUFBTSxDQUFOLEVBQVMsS0FBbEM7QUFDQTtBQUNELE9BQUcsS0FBSCxDQUFTLElBQVQsRUFBZSxJQUFmO0FBQ0EsSUFaNEI7O0FBYzdCLFFBQUssYUFBUyxHQUFULEVBQWM7QUFDbEIsbUJBQWUsWUFBZixDQUE0QixHQUE1QjtBQUNBLElBaEI0Qjs7QUFrQjdCLFVBQU8sZUFBUyxJQUFULEVBQWU7QUFDckIsbUJBQWUsSUFBZixDQUFvQixJQUFwQjtBQUNBO0FBcEI0QixHQUE5QjtBQXNCQSxFOzs7Ozs7Ozs7Ozs7O2FBV00sUyxzQkFBVSxTLEVBQVc7QUFDM0IsWUFBVSxTQUFWO0FBQ0EsRTs7Ozs7a0JBR2EsVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNrQmYsQ0FBQyxZQUFZOztBQUVaLEtBQUksV0FBVyxnSEFBZjtLQUNDLFNBQVMsNEJBRFY7S0FFQyxPQUFPLG9HQUZSOzs7QUFLQSxLQUFJLFFBQVEsUUFBUSxvR0FBUixDQUFaOzs7QUFHQSxLQUFJLFFBQVEsUUFBUSwrU0FBUixDQUFaOzs7QUFHQSxLQUFJLFNBQVMsUUFBUSxrTUFBUixDQUFiOzs7O0FBSUEsS0FBSSxZQUFZLFFBQVEsa0RBQVIsQ0FBaEI7OztBQUdBLEtBQUksWUFBWSxRQUFRLHdHQUFSLENBQWhCOzs7QUFHQSxLQUFJLFVBQVUsUUFBUSxjQUFSLENBQWQ7O0FBRUEsS0FBSSxhQUFhLE9BQU8sVUFBUCxHQUFvQixVQUFVLElBQVYsRUFBZ0IsT0FBaEIsRUFBeUI7QUFDN0QsTUFBSSxLQUFKO01BQVcsS0FBWDtNQUFrQixLQUFsQjtNQUF5QixRQUFRLEVBQWpDO01BQXFDLE9BQU8sSUFBNUM7QUFDQSxRQUFNLElBQU4sR0FBYSxZQUFZO0FBQ3hCLFVBQU8sS0FBSyxLQUFLLE1BQUwsR0FBYyxDQUFuQixDQUFQO0FBQ0EsR0FGRDs7QUFJQSxTQUFPLElBQVAsRUFBYTtBQUNaLFdBQVEsSUFBUjs7O0FBR0EsT0FBSSxDQUFDLE1BQU0sSUFBTixFQUFELElBQWlCLENBQUMsUUFBUSxNQUFNLElBQU4sRUFBUixDQUF0QixFQUE2Qzs7O0FBRzVDLFFBQUksS0FBSyxPQUFMLENBQWEsTUFBYixLQUF3QixDQUE1QixFQUErQjtBQUM5QixhQUFRLEtBQUssT0FBTCxDQUFhLEtBQWIsQ0FBUjs7QUFFQSxTQUFJLFNBQVMsQ0FBYixFQUFnQjtBQUNmLFVBQUksUUFBUSxPQUFaLEVBQ0MsUUFBUSxPQUFSLENBQWdCLEtBQUssU0FBTCxDQUFlLENBQWYsRUFBa0IsS0FBbEIsQ0FBaEI7QUFDRCxhQUFPLEtBQUssU0FBTCxDQUFlLFFBQVEsQ0FBdkIsQ0FBUDtBQUNBLGNBQVEsS0FBUjtBQUNBOzs7QUFHRCxLQVhELE1BV08sSUFBSSxLQUFLLE9BQUwsQ0FBYSxJQUFiLEtBQXNCLENBQTFCLEVBQTZCO0FBQ25DLGNBQVEsS0FBSyxLQUFMLENBQVcsTUFBWCxDQUFSOztBQUVBLFVBQUksS0FBSixFQUFXO0FBQ1YsY0FBTyxLQUFLLFNBQUwsQ0FBZSxNQUFNLENBQU4sRUFBUyxNQUF4QixDQUFQO0FBQ0EsYUFBTSxDQUFOLEVBQVMsT0FBVCxDQUFpQixNQUFqQixFQUF5QixXQUF6QjtBQUNBLGVBQVEsS0FBUjtBQUNBOzs7QUFHRCxNQVZNLE1BVUEsSUFBSSxLQUFLLE9BQUwsQ0FBYSxHQUFiLEtBQXFCLENBQXpCLEVBQTRCO0FBQ2xDLGVBQVEsS0FBSyxLQUFMLENBQVcsUUFBWCxDQUFSOztBQUVBLFdBQUksS0FBSixFQUFXO0FBQ1YsZUFBTyxLQUFLLFNBQUwsQ0FBZSxNQUFNLENBQU4sRUFBUyxNQUF4QixDQUFQO0FBQ0EsY0FBTSxDQUFOLEVBQVMsT0FBVCxDQUFpQixRQUFqQixFQUEyQixhQUEzQjtBQUNBLGdCQUFRLEtBQVI7QUFDQTtBQUNEOztBQUVELFFBQUksS0FBSixFQUFXO0FBQ1YsYUFBUSxLQUFLLE9BQUwsQ0FBYSxHQUFiLENBQVI7O0FBRUEsU0FBSSxPQUFPLFFBQVEsQ0FBUixHQUFZLElBQVosR0FBbUIsS0FBSyxTQUFMLENBQWUsQ0FBZixFQUFrQixLQUFsQixDQUE5QjtBQUNBLFlBQU8sUUFBUSxDQUFSLEdBQVksRUFBWixHQUFpQixLQUFLLFNBQUwsQ0FBZSxLQUFmLENBQXhCOztBQUVBLFNBQUksUUFBUSxLQUFaLEVBQ0MsUUFBUSxLQUFSLENBQWMsSUFBZDtBQUNEO0FBRUQsSUE1Q0QsTUE0Q087QUFDTixXQUFPLEtBQUssT0FBTCxDQUFhLElBQUksTUFBSixDQUFXLG9CQUFvQixNQUFNLElBQU4sRUFBcEIsR0FBbUMsUUFBOUMsQ0FBYixFQUFzRSxVQUFVLEdBQVYsRUFBZSxJQUFmLEVBQXFCO0FBQ2pHLFlBQU8sS0FBSyxPQUFMLENBQWEsNkNBQWIsRUFBNEQsTUFBNUQsQ0FBUDtBQUNBLFNBQUksUUFBUSxLQUFaLEVBQ0MsUUFBUSxLQUFSLENBQWMsSUFBZDs7QUFFRCxZQUFPLEVBQVA7QUFDQSxLQU5NLENBQVA7O0FBUUEsZ0JBQVksRUFBWixFQUFnQixNQUFNLElBQU4sRUFBaEI7QUFDQTs7QUFFRCxPQUFJLFFBQVEsSUFBWixFQUNDLE1BQU0sa0JBQWtCLElBQXhCO0FBQ0QsVUFBTyxJQUFQO0FBQ0E7OztBQUdEOztBQUVBLFdBQVMsYUFBVCxDQUF1QixHQUF2QixFQUE0QixPQUE1QixFQUFxQyxJQUFyQyxFQUEyQyxLQUEzQyxFQUFrRDtBQUNqRCxhQUFVLFFBQVEsV0FBUixFQUFWOztBQUVBLE9BQUksTUFBTSxPQUFOLENBQUosRUFBb0I7QUFDbkIsV0FBTyxNQUFNLElBQU4sTUFBZ0IsT0FBTyxNQUFNLElBQU4sRUFBUCxDQUF2QixFQUE2QztBQUM1QyxpQkFBWSxFQUFaLEVBQWdCLE1BQU0sSUFBTixFQUFoQjtBQUNBO0FBQ0Q7O0FBRUQsT0FBSSxVQUFVLE9BQVYsS0FBc0IsTUFBTSxJQUFOLE1BQWdCLE9BQTFDLEVBQW1EO0FBQ2xELGdCQUFZLEVBQVosRUFBZ0IsT0FBaEI7QUFDQTs7QUFFRCxXQUFRLE1BQU0sT0FBTixLQUFrQixDQUFDLENBQUMsS0FBNUI7O0FBRUEsT0FBSSxDQUFDLEtBQUwsRUFDQyxNQUFNLElBQU4sQ0FBVyxPQUFYOztBQUVELE9BQUksUUFBUSxLQUFaLEVBQW1CO0FBQ2xCLFFBQUksUUFBUSxFQUFaOztBQUVBLFNBQUssT0FBTCxDQUFhLElBQWIsRUFBbUIsVUFBVSxLQUFWLEVBQWlCLElBQWpCLEVBQXVCO0FBQ3pDLFNBQUksUUFBUSxVQUFVLENBQVYsSUFBZSxVQUFVLENBQVYsQ0FBZixHQUNYLFVBQVUsQ0FBVixJQUFlLFVBQVUsQ0FBVixDQUFmLEdBQ0EsVUFBVSxDQUFWLElBQWUsVUFBVSxDQUFWLENBQWYsR0FDQSxVQUFVLElBQVYsSUFBa0IsSUFBbEIsR0FBeUIsRUFIMUI7O0FBS0EsV0FBTSxJQUFOLENBQVc7QUFDVixZQUFNLElBREk7QUFFVixhQUFPLEtBRkc7QUFHVixlQUFTLE1BQU0sT0FBTixDQUFjLGFBQWQsRUFBNkIsUUFBN0IsQztBQUhDLE1BQVg7QUFLQSxLQVhEOztBQWFBLFFBQUksUUFBUSxLQUFaLEVBQ0MsUUFBUSxLQUFSLENBQWMsT0FBZCxFQUF1QixLQUF2QixFQUE4QixLQUE5QjtBQUNEO0FBQ0Q7O0FBRUQsV0FBUyxXQUFULENBQXFCLEdBQXJCLEVBQTBCLE9BQTFCLEVBQW1DOztBQUVsQyxPQUFJLENBQUMsT0FBTCxFQUNDLElBQUksTUFBTSxDQUFWOzs7QUFERCxRQUtDLEtBQUssSUFBSSxNQUFNLE1BQU0sTUFBTixHQUFlLENBQTlCLEVBQWlDLE9BQU8sQ0FBeEMsRUFBMkMsS0FBM0M7QUFDQyxTQUFJLE1BQU0sR0FBTixLQUFjLE9BQWxCLEVBQ0M7QUFGRixLQUlELElBQUksT0FBTyxDQUFYLEVBQWM7O0FBRWIsU0FBSyxJQUFJLElBQUksTUFBTSxNQUFOLEdBQWUsQ0FBNUIsRUFBK0IsS0FBSyxHQUFwQyxFQUF5QyxHQUF6QztBQUNDLFNBQUksUUFBUSxHQUFaLEVBQ0MsUUFBUSxHQUFSLENBQVksTUFBTSxDQUFOLENBQVo7QUFGRixLO0FBS0EsVUFBTSxNQUFOLEdBQWUsR0FBZjtBQUNBO0FBQ0Q7QUFDRCxFQXRJRDs7QUF3SUEsVUFBUyxPQUFULENBQWlCLEdBQWpCLEVBQXNCO0FBQ3JCLE1BQUksTUFBTSxFQUFWO01BQWMsUUFBUSxJQUFJLEtBQUosQ0FBVSxHQUFWLENBQXRCO0FBQ0EsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE1BQU0sTUFBMUIsRUFBa0MsR0FBbEM7QUFDQyxPQUFJLE1BQU0sQ0FBTixDQUFKLElBQWdCLElBQWhCO0FBREQsR0FFQSxPQUFPLEdBQVA7QUFDQTtBQUNELENBdktELEVBdUtHLElBdktIOzs7OztBQ3ZGQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJDLFNBQVMsUUFBVCxDQUFrQixHQUFsQixFQUF1Qjs7QUFFckIsTUFBSSxPQUFPLEVBQUMsU0FBUyxHQUFWLEVBQWUsUUFBUSxHQUF2QixFQUE0QixRQUFRLEdBQXBDLEVBQXlDLFVBQVUsR0FBbkQsRUFBWDtBQUNBLE1BQUksTUFBTSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBVjs7Ozs7OztBQU9BLFNBQU8sSUFBSSxPQUFKLENBQVksb0JBQVosRUFBa0MsVUFBUyxDQUFULEVBQVksTUFBWixFQUFvQjs7QUFFM0QsUUFBSSxRQUFRLEtBQUssQ0FBTCxDQUFaO0FBQ0EsUUFBSSxLQUFKLEVBQVc7QUFDVCxhQUFPLEtBQVA7QUFDRDs7QUFFRCxRQUFJLE9BQU8sTUFBUCxDQUFjLENBQWQsTUFBcUIsR0FBekIsRUFBOEI7O0FBRTVCLFVBQUksSUFBSSxPQUFPLE1BQU0sT0FBTyxNQUFQLENBQWMsQ0FBZCxDQUFiLENBQVI7QUFDQSxVQUFJLENBQUMsTUFBTSxDQUFOLENBQUwsRUFBZTtBQUNiLGdCQUFRLE9BQU8sWUFBUCxDQUFvQixDQUFwQixDQUFSO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJLENBQUMsS0FBTCxFQUFZOzs7QUFHVixVQUFJLFNBQUosR0FBZ0IsSUFBSSxHQUFwQjs7QUFFQSxjQUFRLElBQUksVUFBSixDQUFlLFNBQWYsQ0FBeUIsS0FBekIsQ0FBK0IsQ0FBL0IsRUFBa0MsQ0FBQyxDQUFuQyxDQUFSO0FBQ0Q7O0FBRUQsU0FBSyxDQUFMLElBQVUsS0FBVjtBQUNBLFdBQU8sS0FBUDtBQUNELEdBekJNLENBQVA7QUEwQkQ7O2tCQUVhLFE7Ozs7Ozs7QUFNZixJQUFJLHVCQUF1QixpQkFBM0I7Ozs7Ozs7OztBQ25FQTs7QUFDQTs7Ozs7Ozs7O0FDREE7Ozs7OztBQUVBOztBQUNBOzs7O0FBQ0E7Ozs7OztJQUVNLEk7Ozs7Ozs7Ozs7Ozs7OztNQVdFLG9CLGlDQUFxQixVLEVBQVk7QUFDdkMsTUFBSSxVQUFVLEVBQWQ7QUFDQSxNQUFJLENBQUMsVUFBTCxFQUFpQjtBQUNoQixVQUFPLE9BQVA7QUFDQTtBQUNELE1BQUksUUFBUSxXQUFXLEtBQVgsQ0FBaUIsTUFBakIsQ0FBWjtBQUNBLE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFNLE1BQTFCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ3RDLE9BQUksUUFBUSxNQUFNLENBQU4sRUFBUyxPQUFULENBQWlCLElBQWpCLENBQVo7QUFDQSxPQUFJLFFBQVEsQ0FBWixFQUFlO0FBQ2QsUUFBSSxPQUFPLE1BQU0sQ0FBTixFQUFTLFNBQVQsQ0FBbUIsQ0FBbkIsRUFBc0IsS0FBdEIsQ0FBWDtBQUNBLFFBQUksUUFBUSxNQUFNLENBQU4sRUFBUyxTQUFULENBQW1CLFFBQVEsQ0FBM0IsQ0FBWjtBQUNBLFlBQVEsSUFBUixDQUFhO0FBQ1osV0FBTSxJQURNO0FBRVosWUFBTztBQUZLLEtBQWI7QUFJQTtBQUNEO0FBQ0QsU0FBTyxPQUFQO0FBQ0EsRTs7Ozs7Ozs7Ozs7Ozs7OztNQWNNLE8sb0JBQVEsRyxFQUFLLE0sRUFBUSxJLEVBQU0sVyxFQUFhLFUsRUFBWSxXLEVBQWEsUSxFQUFVO0FBQ2pGLE1BQUksVUFBVSxJQUFJLGNBQUosRUFBZDs7QUFFQSxNQUFJLFVBQVUsZ0NBQVksVUFBUyxPQUFULEVBQWtCLE1BQWxCLEVBQTBCO0FBQ25ELFdBQVEsTUFBUixHQUFpQixZQUFXO0FBQzNCLFFBQUksUUFBUSxPQUFaLEVBQXFCO0FBQ3BCLGFBQVEsT0FBUjtBQUNBO0FBQ0E7QUFDRCxZQUFRLE9BQVI7QUFDQSxJQU5EO0FBT0EsV0FBUSxPQUFSLEdBQWtCLFlBQVc7QUFDNUIsUUFBSSxRQUFRLElBQUksS0FBSixDQUFVLGVBQVYsQ0FBWjtBQUNBLFVBQU0sT0FBTixHQUFnQixPQUFoQjtBQUNBLFdBQU8sS0FBUDtBQUNBLElBSkQ7QUFLQSxHQWJhLEVBYVgsU0FiVyxDQWFELFVBQVMsTUFBVCxFQUFpQjtBQUM3QixXQUFRLEtBQVI7QUFDQSxTQUFNLE1BQU47QUFDQSxHQWhCYSxFQWdCWCxVQWhCVyxDQWdCQSxZQUFXO0FBQ3hCLGdCQUFhLE9BQWI7QUFDQSxHQWxCYSxDQUFkOztBQW9CQSxNQUFJLFVBQUosRUFBZ0I7QUFDZixTQUFNLGtCQUFRLEdBQVIsRUFBYSx5QkFBYixDQUF1QyxVQUF2QyxFQUFtRCxRQUFuRCxFQUFOO0FBQ0E7O0FBRUQsVUFBUSxJQUFSLENBQWEsTUFBYixFQUFxQixHQUFyQixFQUEwQixDQUFDLFFBQTNCOztBQUVBLE1BQUksV0FBSixFQUFpQjtBQUNoQixlQUFZLEtBQVosR0FBb0IsT0FBcEIsQ0FBNEIsVUFBUyxJQUFULEVBQWU7QUFDMUMsWUFBUSxnQkFBUixDQUF5QixJQUF6QixFQUErQixZQUFZLE1BQVosQ0FBbUIsSUFBbkIsRUFBeUIsSUFBekIsQ0FBOEIsSUFBOUIsQ0FBL0I7QUFDQSxJQUZEO0FBR0E7O0FBRUQsVUFBUSxJQUFSLENBQWEsWUFBSyxLQUFMLENBQVcsSUFBWCxJQUFtQixJQUFuQixHQUEwQixJQUF2Qzs7QUFFQSxNQUFJLFlBQUssZUFBTCxDQUFxQixXQUFyQixDQUFKLEVBQXVDO0FBQ3RDLE9BQUksVUFBVSxXQUFXLFlBQVc7QUFDbkMsWUFBUSxNQUFSLENBQWUsaUJBQWY7QUFDQSxJQUZhLEVBRVgsV0FGVyxDQUFkO0FBR0E7O0FBRUQsU0FBTyxPQUFQO0FBQ0EsRTs7Ozs7a0JBSWEsSTs7O0FDakdmOzs7Ozs7QUFFQTs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTJDTSxTOzs7Ozs7Ozs7Ozs7OztBQVdMLG9CQUFZLFVBQVosRUFBd0IsaUJBQXhCLEVBQTJDO0FBQUE7Ozs7Ozs7OztBQUFBLCtDQUMxQyxrQkFBTSxVQUFOLENBRDBDOztBQVMxQyxRQUFLLGtCQUFMLEdBQTBCLEVBQTFCOzs7Ozs7QUFNQSxRQUFLLFVBQUwsR0FBa0IsRUFBbEI7Ozs7Ozs7O0FBUUEsUUFBSyxrQkFBTCxHQUEwQixJQUExQjs7Ozs7OztBQU9BLFFBQUssc0JBQUwsR0FBOEIsMEJBQTlCOzs7Ozs7QUFNQSxRQUFLLFVBQUwsR0FBa0IsS0FBbEI7Ozs7Ozs7QUFPQSxRQUFLLGNBQUwsR0FBc0IsY0FBYyxFQUFwQzs7Ozs7O0FBTUEsUUFBSyxXQUFMLEdBQW1CLEtBQW5COzs7Ozs7OztBQVFBLFFBQUssc0JBQUwsR0FBOEIsU0FBUyxJQUF2Qzs7QUFFQSxjQUFLLHlCQUFMLENBQStCLE1BQUssV0FBcEMsRUFBaUQsaUJBQWpELEVBQW9FLE1BQUssb0JBQXpFOztBQUVBLFFBQUssU0FBTCxHQUFpQixNQUFLLGNBQUwsRUFBakI7O0FBRUEsUUFBSyxFQUFMLENBQVEsY0FBUixFQUF3QixNQUFLLG1CQUE3QjtBQUNBLFFBQUssa0JBQUwsR0FBMEIsTUFBSyxFQUFMLENBQVEsYUFBUixFQUF1QixNQUFLLGtCQUE1QixDQUExQjtBQUNBLFFBQUssRUFBTCxDQUFRLGVBQVIsRUFBeUIsTUFBSyxnQkFBOUI7QUFDQSxRQUFLLG9CQUFMLENBQTBCLE1BQUssTUFBL0I7O0FBRUEsUUFBSyxPQUFMO0FBQ0EsTUFBSSxzQkFBc0IsS0FBMUIsRUFBaUM7QUFDaEMsU0FBSyxPQUFMLENBQWEsaUJBQWI7QUFDQTtBQUNELFFBQUssRUFBTCxDQUFRLGdCQUFSLEVBQTBCLE1BQUssaUJBQS9CO0FBeEUwQztBQXlFMUM7Ozs7Ozs7O3FCQU1ELGtCLGlDQUFxQjtBQUNwQixNQUFJLGVBQWUsS0FBSyxXQUFMLENBQWlCLHNCQUFwQztBQUNBLE1BQUksS0FBSyxjQUFULEVBQXlCO0FBQ3hCLGtCQUFlLGVBQWUsR0FBZixHQUFxQixLQUFLLGNBQXpDO0FBQ0E7QUFDRCxXQUFJLFVBQUosQ0FBZSxLQUFLLE9BQXBCLEVBQTZCLFlBQTdCO0FBQ0EsRTs7Ozs7Ozs7O3FCQU9ELG9CLGlDQUFxQixNLEVBQVE7QUFDNUIsTUFBSSxhQUFhLE9BQU8sSUFBUCxDQUFZLFVBQVUsRUFBdEIsQ0FBakI7QUFDQSxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksV0FBVyxNQUEvQixFQUF1QyxHQUF2QyxFQUE0QztBQUMzQyxPQUFJLE9BQU8sS0FBSyxvQkFBTCxDQUEwQixPQUFPLFdBQVcsQ0FBWCxDQUFQLENBQTFCLENBQVg7QUFDQSxPQUFJLEtBQUssRUFBVCxFQUFhO0FBQ1osUUFBSSxPQUFKO0FBQ0EsUUFBSSxLQUFLLFFBQVQsRUFBbUI7QUFDbEIsZUFBVSxLQUFLLFFBQUwsQ0FBYyxXQUFXLENBQVgsQ0FBZCxFQUE2QixLQUFLLFFBQWxDLEVBQTRDLEtBQUssRUFBakQsQ0FBVjtBQUNBLEtBRkQsTUFFTztBQUNOLGVBQVUsS0FBSyxFQUFMLENBQVEsV0FBVyxDQUFYLENBQVIsRUFBdUIsS0FBSyxFQUE1QixDQUFWO0FBQ0E7QUFDRCxTQUFLLHNCQUFMLENBQTRCLEdBQTVCLENBQWdDLE9BQWhDO0FBQ0E7QUFDRDtBQUNELEU7Ozs7Ozs7Ozs7Ozs7Ozs7O3FCQWVELE0sbUJBQU8saUIsRUFBbUIsa0IsRUFBb0I7QUFDN0MsTUFBSSxDQUFDLEtBQUssT0FBVixFQUFtQjtBQUNsQixTQUFNLElBQUksS0FBSixDQUFVLFVBQVUsS0FBVixDQUFnQixtQkFBMUIsQ0FBTjtBQUNBO0FBQ0QsTUFBSSxDQUFDLEtBQUssVUFBVixFQUFzQjtBQUNyQixRQUFLLGNBQUwsQ0FBb0IsaUJBQXBCLEVBQXVDLGtCQUF2QztBQUNBLFFBQUssVUFBTCxHQUFrQixJQUFsQjtBQUNBLFFBQUssSUFBTCxDQUFVLFVBQVY7QUFDQSxRQUFLLFFBQUw7QUFDQTtBQUNELFNBQU8sSUFBUDtBQUNBLEU7Ozs7Ozs7Ozs7O3FCQVNELFEsdUJBQVcsQ0FBRSxDOzs7Ozs7Ozs7OztxQkFTYixlLDRCQUFnQixHLEVBQUssbUIsRUFBcUIsUSxFQUFVO0FBQ25ELE1BQUksQ0FBQyxLQUFLLFVBQUwsQ0FBZ0IsR0FBaEIsQ0FBTCxFQUEyQjtBQUMxQixPQUFJLGdCQUFnQixtQkFBcEI7QUFDQSxPQUFJLFlBQUssUUFBTCxDQUFjLGFBQWQsQ0FBSixFQUFrQztBQUNqQyxvQkFBZ0IsNEJBQWtCLGNBQWxCLENBQWlDLG1CQUFqQyxDQUFoQjtBQUNBO0FBQ0QsUUFBSyxVQUFMLENBQWdCLEdBQWhCLElBQXVCLElBQUksYUFBSixDQUFrQixRQUFsQixFQUE0QixLQUE1QixDQUF2QjtBQUNBO0FBQ0QsU0FBTyxLQUFLLFVBQUwsQ0FBZ0IsR0FBaEIsQ0FBUDtBQUNBLEU7Ozs7Ozs7O3FCQU1ELE8sc0JBQVUsQ0FDVCxDOzs7Ozs7Ozs7cUJBT0QsYyw2QkFBaUI7QUFDaEIsY0FBSyx5QkFBTCxDQUErQixLQUFLLFdBQXBDLEVBQWlELFVBQWpELEVBQTZELGFBQU0saUJBQW5FO0FBQ0EsU0FBTyxJQUFJLEtBQUssV0FBTCxDQUFpQixlQUFyQixDQUFxQyxJQUFyQyxDQUFQO0FBQ0EsRTs7Ozs7Ozs7Ozs7OztxQkFXRCxRLHFCQUFTLFMsRUFBVyxRLEVBQVUsUSxFQUFVO0FBQ3ZDLFNBQU8sS0FBSyxFQUFMLENBQVEsY0FBYyxTQUFkLEdBQTBCLEdBQTFCLEdBQWdDLFFBQXhDLEVBQWtELFFBQWxELENBQVA7QUFDQSxFOzs7Ozs7Ozs7OztxQkFTRCxNLHFCQUFTO0FBQ1IsTUFBSSxLQUFLLFVBQVQsRUFBcUI7QUFDcEIsT0FBSSxLQUFLLE9BQUwsQ0FBYSxVQUFqQixFQUE2QjtBQUM1QixTQUFLLE9BQUwsQ0FBYSxVQUFiLENBQXdCLFdBQXhCLENBQW9DLEtBQUssT0FBekM7QUFDQTtBQUNELFFBQUssVUFBTCxHQUFrQixLQUFsQjtBQUNBLFFBQUssUUFBTDtBQUNBO0FBQ0QsT0FBSyxJQUFMLENBQVUsVUFBVjtBQUNBLFNBQU8sSUFBUDtBQUNBLEU7Ozs7Ozs7Ozs7O3FCQVNELFEsdUJBQVcsQ0FBRSxDOzs7Ozs7O3FCQUtiLGUsOEJBQWtCO0FBQ2pCLE9BQUssTUFBTDs7QUFFQSxNQUFJLEtBQUssa0JBQVQsRUFBNkI7QUFDNUIsUUFBSyxrQkFBTCxDQUF3QixPQUF4QjtBQUNBLFFBQUssa0JBQUwsR0FBMEIsSUFBMUI7QUFDQTs7QUFFRCxPQUFLLG9CQUFMLENBQTBCLE9BQU8sSUFBUCxDQUFZLEtBQUssVUFBakIsQ0FBMUI7QUFDQSxPQUFLLFVBQUwsR0FBa0IsSUFBbEI7O0FBRUEsT0FBSyxTQUFMLENBQWUsT0FBZjtBQUNBLE9BQUssU0FBTCxHQUFpQixJQUFqQjs7QUFFQSxtQkFBTSxlQUFOO0FBQ0EsRTs7Ozs7Ozs7cUJBTUQsb0IsaUNBQXFCLEksRUFBTTtBQUMxQixPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxNQUF6QixFQUFpQyxHQUFqQyxFQUFzQztBQUNyQyxPQUFJLFlBQVksS0FBSyxVQUFMLENBQWdCLEtBQUssQ0FBTCxDQUFoQixDQUFoQjtBQUNBLE9BQUksQ0FBQyxVQUFVLFVBQVYsRUFBTCxFQUE2QjtBQUM1QixjQUFVLE9BQVY7QUFDQSxXQUFPLEtBQUssVUFBTCxDQUFnQixLQUFLLENBQUwsQ0FBaEIsQ0FBUDtBQUNBO0FBQ0Q7QUFDRCxFOzs7Ozs7Ozs7O3FCQVFELG9CLGlDQUFxQixLLEVBQU87QUFDM0IsTUFBSSxPQUFPO0FBQ1YsT0FBSTtBQURNLEdBQVg7QUFHQSxNQUFJLFlBQUssUUFBTCxDQUFjLEtBQWQsS0FBd0IsQ0FBQyxZQUFLLFVBQUwsQ0FBZ0IsS0FBaEIsQ0FBN0IsRUFBcUQ7QUFDcEQsUUFBSyxRQUFMLEdBQWdCLE1BQU0sUUFBdEI7QUFDQSxRQUFLLEVBQUwsR0FBVSxNQUFNLEVBQWhCO0FBQ0E7QUFDRCxNQUFJLFlBQUssUUFBTCxDQUFjLEtBQUssRUFBbkIsQ0FBSixFQUE0QjtBQUMzQixRQUFLLEVBQUwsR0FBVSxLQUFLLGFBQUwsQ0FBbUIsS0FBSyxFQUF4QixDQUFWO0FBQ0E7QUFDRCxTQUFPLElBQVA7QUFDQSxFOzs7Ozs7OztxQkFNRCxnQiwrQkFBbUI7QUFDbEIsU0FBTyxLQUFLLGNBQVo7QUFDQSxFOzs7Ozs7Ozs7OztxQkFTRCxhLDBCQUFjLE0sRUFBUTtBQUNyQixNQUFJLFlBQUssVUFBTCxDQUFnQixLQUFLLE1BQUwsQ0FBaEIsQ0FBSixFQUFtQztBQUNsQyxVQUFPLEtBQUssTUFBTCxFQUFhLElBQWIsQ0FBa0IsSUFBbEIsQ0FBUDtBQUNBLEdBRkQsTUFFTztBQUNOLFdBQVEsS0FBUixDQUFjLHdCQUF3QixNQUF4QixHQUFpQyxxQkFBakMsR0FDWixhQURZLEdBQ0ksWUFBSyxlQUFMLENBQXFCLEtBQUssV0FBMUIsQ0FESixHQUM2QyxVQUQ3QyxHQUViLDBFQUZEO0FBSUE7QUFDRCxFOzs7Ozs7Ozs7OztxQkFTRCxtQixnQ0FBb0IsRyxFQUFLLFUsRUFBWTtBQUNwQyxNQUFJLEtBQUssS0FBSyxTQUFTLElBQUksTUFBSixDQUFXLENBQVgsRUFBYyxXQUFkLEVBQVQsR0FBdUMsSUFBSSxLQUFKLENBQVUsQ0FBVixDQUE1QyxDQUFUO0FBQ0EsTUFBSSxZQUFLLFVBQUwsQ0FBZ0IsRUFBaEIsQ0FBSixFQUF5QjtBQUN4QixPQUFJLENBQUMsVUFBTCxFQUFpQjtBQUNoQixpQkFBYTtBQUNaLGFBQVEsS0FBSyxHQUFMLENBREk7QUFFWixjQUFTO0FBRkcsS0FBYjtBQUlBO0FBQ0QsTUFBRyxJQUFILENBQVEsSUFBUixFQUFjLFdBQVcsTUFBekIsRUFBaUMsV0FBVyxPQUE1QztBQUNBO0FBQ0QsRTs7Ozs7Ozs7cUJBTUQsVywwQkFBYztBQUNiLFNBQU8sS0FBSyxTQUFaO0FBQ0EsRTs7Ozs7Ozs7OztxQkFRRCxtQixnQ0FBb0IsSyxFQUFPO0FBQzFCLE9BQUsscUJBQUwsQ0FBMkIsTUFBTSxPQUFqQztBQUNBLE9BQUssSUFBTCxDQUFVLGFBQVYsRUFBeUIsS0FBekI7QUFDQSxFOzs7Ozs7Ozs7O3FCQVFELGtCLCtCQUFtQixLLEVBQU87QUFDekIsT0FBSyxrQkFBTCxDQUF3QixLQUF4QixJQUFpQyxJQUFqQztBQUNBLEU7Ozs7Ozs7Ozs7cUJBUUQsb0IsaUNBQXFCLE0sRUFBUTtBQUM1QixNQUFJLFNBQVMsRUFBYjtBQUNBLFNBQU8sT0FBTyxNQUFQLENBQWMsVUFBUyxHQUFULEVBQWM7QUFDbEMsT0FBSSxDQUFDLEdBQUQsSUFBUSxPQUFPLEdBQVAsQ0FBWixFQUF5QjtBQUN4QixXQUFPLEtBQVA7QUFDQSxJQUZELE1BRU87QUFDTixXQUFPLEdBQVAsSUFBYyxJQUFkO0FBQ0EsV0FBTyxJQUFQO0FBQ0E7QUFDRCxHQVBNLEVBT0osSUFQSSxDQU9DLEdBUEQsQ0FBUDtBQVFBLEU7Ozs7Ozs7OztxQkFPRCxpQiw4QkFBa0IsSyxFQUFPO0FBQ3hCLE1BQUksTUFBTSxPQUFOLEtBQWtCLE1BQU0sTUFBNUIsRUFBb0M7Ozs7QUFJbkM7QUFDQTs7QUFFRCxPQUFLLFdBQUw7QUFDQSxPQUFLLGtCQUFMLENBQXdCLGdCQUF4QixDQUF5QyxNQUFNLE1BQS9DO0FBQ0EsT0FBSyxrQkFBTDtBQUNBLE9BQUssV0FBTCxDQUFpQixLQUFLLE9BQXRCO0FBQ0EsRTs7Ozs7Ozs7O3FCQU9ELGdCLDZCQUFpQixLLEVBQU87QUFDdkIsT0FBSyxzQkFBTCxDQUE0QixrQkFBNUI7QUFDQSxPQUFLLG9CQUFMLENBQTBCLE1BQU0sTUFBaEM7QUFDQSxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FCQW9CRCxPLG9CQUFRLGlCLEVBQW1CLGMsRUFBZ0I7QUFDMUMsTUFBSSxDQUFDLGNBQUwsRUFBcUI7QUFDcEIsUUFBSyxJQUFMLENBQVUsUUFBVjtBQUNBO0FBQ0QsT0FBSyxXQUFMO0FBQ0EsT0FBSyxVQUFMO0FBQ0EsT0FBSyxNQUFMLENBQVksaUJBQVo7QUFDQSxPQUFLLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxFOzs7Ozs7Ozs7O3FCQVFELG9CLG1DQUF1QjtBQUN0QixPQUFLLE9BQUwsQ0FBYSxJQUFiLEVBQW1CLElBQW5CO0FBQ0EsRTs7Ozs7Ozs7Ozs7Ozs7cUJBWUQsYywyQkFBZSxpQixFQUFtQixrQixFQUFvQjtBQUNyRCxNQUFJLFVBQVUsS0FBSyxPQUFuQjtBQUNBLE1BQUksc0JBQXNCLENBQUMsUUFBUSxVQUFuQyxFQUErQztBQUM5QyxPQUFJLFNBQVMsU0FBSSxTQUFKLENBQWMsaUJBQWQsS0FBb0MsS0FBSyxzQkFBdEQ7QUFDQSxVQUFPLFlBQVAsQ0FBb0IsT0FBcEIsRUFBNkIsU0FBSSxTQUFKLENBQWMsa0JBQWQsQ0FBN0I7QUFDQTtBQUNELEU7Ozs7Ozs7Ozs7O3FCQVNELGdCLDZCQUFpQixNLEVBQVEsVSxFQUFZO0FBQ3BDLFNBQU8sU0FBSSxTQUFKLENBQWMsTUFBZCxLQUF5QixVQUFoQztBQUNBLEU7Ozs7Ozs7OztxQkFPRCxXLDBCQUFjO0FBQ2IsTUFBSSxLQUFLLGtCQUFULEVBQTZCO0FBQzVCO0FBQ0E7O0FBRUQsTUFBSSxRQUFRLDhCQUF5QixLQUFLLE9BQTlCLEVBQXVDLElBQXZDLENBQVo7QUFDQSxPQUFLLGtCQUFMLEdBQTBCLEtBQTFCOztBQUVBLGdCQUFPLEdBQVAsQ0FBVyxLQUFLLGtCQUFoQixFQUFvQyxNQUFNLFVBQU4sQ0FBaUIsSUFBakIsQ0FBc0IsS0FBdEIsQ0FBcEM7QUFDQSxPQUFLLGtCQUFMLEdBQTBCLElBQTFCOztBQUVBLE9BQUssa0JBQUwsQ0FBd0IsY0FBeEI7QUFDQSxPQUFLLGtCQUFMLEdBQTBCLElBQTFCO0FBQ0EsRTs7Ozs7Ozs7cUJBTUQsVSx5QkFBYTtBQUNaLE1BQUksT0FBTyxLQUFLLFlBQUwsRUFBWDtBQUNBLE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE1BQXpCLEVBQWlDLEdBQWpDLEVBQXNDO0FBQ3JDLFFBQUssbUJBQUwsQ0FBeUIsS0FBSyxDQUFMLENBQXpCO0FBQ0E7QUFDRCxFOzs7Ozs7Ozs7O3FCQVFELHFCLGtDQUFzQixPLEVBQVM7QUFDOUIsT0FBSyxJQUFJLEdBQVQsSUFBZ0IsT0FBaEIsRUFBeUI7QUFDeEIsUUFBSyxtQkFBTCxDQUF5QixHQUF6QixFQUE4QixRQUFRLEdBQVIsQ0FBOUI7QUFDQTtBQUNELEU7Ozs7Ozs7OztxQkFPRCxrQiwrQkFBbUIsTSxFQUFRLE8sRUFBUztBQUNuQyxNQUFJLEtBQUssT0FBTCxJQUFnQixPQUFwQixFQUE2QjtBQUM1QixZQUFJLGFBQUosQ0FBa0IsS0FBSyxPQUF2QixFQUFnQyxPQUFoQztBQUNBO0FBQ0QsT0FBSyxrQkFBTDtBQUNBLEU7Ozs7Ozs7OztxQkFPRCxXLHdCQUFZLE0sRUFBUTtBQUNuQixNQUFJLEtBQUssT0FBVCxFQUFrQjtBQUNqQixRQUFLLE9BQUwsQ0FBYSxLQUFiLENBQW1CLE9BQW5CLEdBQTZCLFNBQVMsRUFBVCxHQUFjLE1BQTNDO0FBQ0E7QUFDRCxFOzs7Ozs7Ozs7O3FCQVFELDBCLHVDQUEyQixHLEVBQUs7QUFDL0IsU0FBTyxZQUFLLFFBQUwsQ0FBYyxHQUFkLENBQVA7QUFDQSxFOzs7Ozs7Ozs7O3FCQVFELG1CLGdDQUFvQixHLEVBQUs7QUFDeEIsU0FBTyxZQUFLLFNBQUwsQ0FBZSxHQUFmLEtBQXVCLFlBQUssUUFBTCxDQUFjLEdBQWQsQ0FBOUI7QUFDQSxFOzs7Ozs7Ozs7O3FCQVFELGtCLCtCQUFtQixHLEVBQUs7QUFDdkIsU0FBTyxDQUFDLFlBQUssZUFBTCxDQUFxQixHQUFyQixDQUFELElBQThCLFlBQUssUUFBTCxDQUFjLEdBQWQsQ0FBckM7QUFDQSxFOzs7Ozs7Ozs7Ozs7QUFRRixVQUFVLEtBQVYsR0FBa0I7Ozs7OztBQU1qQixVQUFTO0FBQ1IsVUFBUSxrQkFEQTtBQUVSLGFBQVc7QUFGSCxFQU5ROzs7Ozs7QUFlakIsaUJBQWdCO0FBQ2YsYUFBVztBQURJLEVBZkM7Ozs7Ozs7O0FBeUJqQixTQUFRO0FBQ1AsYUFBVyxvQkFESjtBQUVQLFNBQU87QUFGQSxFQXpCUzs7Ozs7O0FBa0NqQixVQUFTO0FBQ1IsYUFBVyxZQUFLLFNBRFI7QUFFUixTQUFPO0FBRkM7QUFsQ1EsQ0FBbEI7Ozs7Ozs7O0FBOENBLFVBQVUsZUFBVixHQUE0QixFQUE1Qjs7Ozs7Ozs7O0FBU0EsVUFBVSxRQUFWOzs7Ozs7QUFNQSxVQUFVLEtBQVYsR0FBa0I7Ozs7QUFJakIsc0JBQXFCO0FBSkosQ0FBbEI7Ozs7OztBQVdBLFVBQVUsWUFBVixHQUF5QixDQUFDLFlBQUQsQ0FBekI7O2tCQUVlLFM7OztBQzNyQmY7Ozs7OztBQUVBOzs7Ozs7Ozs7O0lBT00saUI7Ozs7Ozs7Ozs7Ozs7bUJBUUUsYywyQkFBZSxJLEVBQU07QUFDM0IsTUFBSSxnQkFBZ0Isa0JBQWtCLFdBQWxCLENBQThCLElBQTlCLENBQXBCO0FBQ0EsTUFBSSxDQUFDLGFBQUwsRUFBb0I7QUFDbkIsV0FBUSxLQUFSLENBQ0MsMERBQ0EsUUFEQSxHQUNXLElBRFgsR0FDa0IseUNBRGxCLEdBRUEsNkJBSEQ7QUFLQTtBQUNELFNBQU8sYUFBUDtBQUNBLEU7Ozs7Ozs7Ozs7OzttQkFVTSxRLHFCQUFTLGEsRUFBZSxRLEVBQVU7QUFDeEMsTUFBSSxPQUFPLFFBQVg7QUFDQSxNQUFJLENBQUMsSUFBTCxFQUFXO0FBQ1YsT0FBSSxjQUFjLGNBQWQsQ0FBNkIsTUFBN0IsQ0FBSixFQUEwQztBQUN6QyxXQUFPLGNBQWMsSUFBckI7QUFDQSxJQUZELE1BRU87QUFDTixXQUFPLFlBQUssZUFBTCxDQUFxQixhQUFyQixDQUFQO0FBQ0E7QUFDRDtBQUNELGdCQUFjLElBQWQsR0FBcUIsSUFBckI7QUFDQSxvQkFBa0IsV0FBbEIsQ0FBOEIsSUFBOUIsSUFBc0MsYUFBdEM7QUFDQSxFOzs7Ozs7Ozs7Ozs7O0FBU0Ysa0JBQWtCLFdBQWxCLEdBQWdDLEVBQWhDOztrQkFFZSxpQjs7O0FDM0RmOzs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7OztJQU1NLGlCOzs7Ozs7Ozs7QUFNTCw0QkFBWSxTQUFaLEVBQXVCO0FBQUE7O0FBQUEsK0NBQ3RCLHdCQURzQjs7QUFFdEIsUUFBSyxVQUFMLEdBQWtCLFNBQWxCO0FBQ0EsUUFBSyx3QkFBTCxHQUFnQywwQkFBaEM7QUFDQSxRQUFLLHdCQUFMLENBQThCLEdBQTlCLENBQ0MsTUFBSyxVQUFMLENBQWdCLEVBQWhCLENBQW1CLGNBQW5CLEVBQW1DLE1BQUssb0NBQUwsQ0FBMEMsSUFBMUMsT0FBbkMsQ0FERCxFQUVDLE1BQUssVUFBTCxDQUFnQixJQUFoQixDQUFxQixRQUFyQixFQUErQixNQUFLLE1BQUwsQ0FBWSxJQUFaLE9BQS9CLENBRkQ7QUFKc0I7QUFRdEI7Ozs7Ozs7NkJBS0QsZSw4QkFBa0I7QUFDakIsT0FBSyx3QkFBTCxDQUE4QixrQkFBOUI7QUFDQSxPQUFLLHdCQUFMLEdBQWdDLElBQWhDO0FBQ0EsRTs7Ozs7Ozs7Ozs7OzZCQVVELG9DLGlEQUFxQyxPLEVBQVM7QUFDN0MsTUFBSSxLQUFLLFVBQUwsQ0FBZ0IsV0FBcEIsRUFBaUM7QUFDaEMsUUFBSyxNQUFMLENBQVksT0FBWjtBQUNBO0FBQ0QsRTs7Ozs7Ozs2QkFLRCxNLHFCQUFTO0FBQ1IsTUFBSSxDQUFDLEtBQUssVUFBTCxDQUFnQixPQUFyQixFQUE4QjtBQUM3QixRQUFLLFVBQUwsQ0FBZ0IsT0FBaEIsR0FBMEIsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQTFCO0FBQ0E7QUFDRCxFOzs7Ozs7Ozs7Ozs2QkFTRCxNLHFCQUFTLENBQUUsQzs7Ozs7a0JBR0csaUI7OztBQ2pFZjs7Ozs7O0FBRUE7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7SUFTTSxlOzs7QUFDTCwwQkFBWSxTQUFaLEVBQXVCO0FBQUE7O0FBQUEsK0NBQ3RCLHNCQURzQjs7QUFHdEIsTUFBSSxDQUFDLFNBQUwsRUFBZ0I7QUFDZixTQUFNLElBQUksS0FBSixDQUFVLHFDQUFWLENBQU47QUFDQTs7Ozs7OztBQU9ELFFBQUssVUFBTCxHQUFrQixTQUFsQjs7Ozs7OztBQU9BLFFBQUssYUFBTCxHQUFxQixFQUFyQjs7Ozs7OztBQU9BLFFBQUssWUFBTCxHQUFvQixFQUFwQjtBQTFCc0I7QUEyQnRCOzs7Ozs7Ozs7OzJCQVFELGMsMkJBQWUsUyxFQUFXLGEsRUFBZTtBQUN4QyxNQUFJLFdBQVcsYUFBYSxTQUFiLEdBQXlCLElBQXpCLEdBQWdDLGFBQWhDLEdBQWdELElBQS9EOztBQUVBLE9BQUssWUFBTCxDQUFrQixRQUFsQixJQUE4QixJQUE5Qjs7QUFFQSxNQUFJLENBQUMsS0FBSyxhQUFMLENBQW1CLFFBQW5CLENBQUwsRUFBbUM7QUFDbEMsUUFBSyxhQUFMLENBQW1CLFFBQW5CLElBQStCLDBCQUEvQjtBQUNBLE9BQUksVUFBVSxjQUFjLEtBQWQsQ0FBb0IsR0FBcEIsQ0FBZDtBQUNBLFFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxRQUFRLE1BQTVCLEVBQW9DLEdBQXBDLEVBQXlDO0FBQ3hDLFFBQUksS0FBSyxLQUFLLFVBQUwsQ0FBZ0IsYUFBaEIsQ0FBOEIsUUFBUSxDQUFSLENBQTlCLENBQVQ7QUFDQSxRQUFJLEVBQUosRUFBUTtBQUNQLFVBQUssYUFBTCxDQUFtQixRQUFuQixFQUE2QixHQUE3QixDQUFpQyxLQUFLLFVBQUwsQ0FBZ0IsUUFBaEIsQ0FBeUIsU0FBekIsRUFBb0MsUUFBcEMsRUFBOEMsS0FBSyxRQUFMLENBQWMsSUFBZCxDQUFtQixJQUFuQixFQUF5QixFQUF6QixDQUE5QyxDQUFqQztBQUNBO0FBQ0Q7QUFDRDtBQUNELEU7Ozs7Ozs7MkJBS0Qsa0IsaUNBQXFCO0FBQ3BCLE9BQUssSUFBSSxRQUFULElBQXFCLEtBQUssYUFBMUIsRUFBeUM7QUFDeEMsT0FBSSxLQUFLLGFBQUwsQ0FBbUIsUUFBbkIsQ0FBSixFQUFrQztBQUNqQyxTQUFLLGFBQUwsQ0FBbUIsUUFBbkIsRUFBNkIsa0JBQTdCO0FBQ0E7QUFDRDtBQUNELE9BQUssYUFBTCxHQUFxQixFQUFyQjtBQUNBLE9BQUssZUFBTCxHQUF1QixFQUF2QjtBQUNBLEU7Ozs7Ozs7OzJCQU1ELHFCLG9DQUF3QjtBQUN2QixPQUFLLElBQUksUUFBVCxJQUFxQixLQUFLLGFBQTFCLEVBQXlDO0FBQ3hDLE9BQUksS0FBSyxhQUFMLENBQW1CLFFBQW5CLEtBQWdDLENBQUMsS0FBSyxZQUFMLENBQWtCLFFBQWxCLENBQXJDLEVBQWtFO0FBQ2pFLFNBQUssYUFBTCxDQUFtQixRQUFuQixFQUE2QixrQkFBN0I7QUFDQSxTQUFLLGFBQUwsQ0FBbUIsUUFBbkIsSUFBK0IsSUFBL0I7QUFDQTtBQUNEO0FBQ0QsRTs7Ozs7OzsyQkFLRCxlLDhCQUFrQjtBQUNqQixPQUFLLGtCQUFMO0FBQ0EsT0FBSyxVQUFMLEdBQWtCLElBQWxCO0FBQ0EsRTs7Ozs7Ozs7Ozs7Ozs7MkJBWUQsUSxxQkFBUyxFLEVBQUksSyxFQUFPOztBQUVuQixNQUFJLFlBQVksTUFBTSxrQkFBdEI7QUFDQSxNQUFJLENBQUMsU0FBRCxJQUFjLGNBQWMsS0FBSyxVQUFqQyxJQUErQyxNQUFNLGNBQU4sQ0FBcUIsUUFBckIsQ0FBOEIsVUFBVSxPQUF4QyxDQUFuRCxFQUFxRztBQUNwRyxTQUFNLGtCQUFOLEdBQTJCLEtBQUssVUFBaEM7QUFDQSxVQUFPLEdBQUcsS0FBSCxDQUFQO0FBQ0E7QUFDRCxFOzs7Ozs7OzsyQkFNRCxlLDhCQUFrQjtBQUNqQixPQUFLLFlBQUwsR0FBb0IsRUFBcEI7QUFDQSxFOzs7OztrQkFHYSxlOzs7QUMvSGY7Ozs7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7OztRQUlDLFM7UUFDQSxpQjtRQUNBLGlCO1FBQ0EsZTs7O0FDWkQ7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7SUFPTSxvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dDQVNMLFkseUJBQWEsSyxFQUFPLFEsRUFBVTtBQUM3QixNQUFJLEtBQUssY0FBTCxDQUFvQixnQkFBeEIsRUFBMEM7QUFDekMsT0FBSSxNQUFNLFVBQU4sQ0FBaUIsV0FBakIsQ0FBSixFQUFtQztBQUNsQyxRQUFJLFFBQVEsTUFBTSxPQUFOLENBQWMsR0FBZCxFQUFtQixDQUFuQixDQUFaO0FBQ0EsUUFBSSxZQUFZLE1BQU0sU0FBTixDQUFnQixDQUFoQixFQUFtQixLQUFuQixDQUFoQjtBQUNBLFFBQUksV0FBVyxNQUFNLFNBQU4sQ0FBZ0IsUUFBUSxDQUF4QixDQUFmO0FBQ0EsV0FBTyxjQUFJLFFBQUosQ0FBYSxLQUFLLGNBQWxCLEVBQWtDLFNBQWxDLEVBQTZDLFFBQTdDLEVBQXVELFFBQXZELENBQVA7QUFDQSxJQUxELE1BS087QUFDTixXQUFPLGNBQUksRUFBSixDQUFPLEtBQUssY0FBWixFQUE0QixLQUE1QixFQUFtQyxRQUFuQyxDQUFQO0FBQ0E7QUFDRCxHQVRELE1BU087QUFDTixVQUFPLDZCQUFNLFlBQU4sWUFBbUIsS0FBbkIsRUFBMEIsUUFBMUIsQ0FBUDtBQUNBO0FBQ0QsRTs7Ozs7Ozs7O2dDQU9ELG9CLGlDQUFxQixLLEVBQU87QUFDM0IsU0FBUSxNQUFNLFVBQU4sQ0FBaUIsV0FBakIsS0FBaUMsTUFBTSxPQUFOLENBQWMsR0FBZCxFQUFtQixDQUFuQixNQUEwQixDQUFDLENBQTdELElBQ04sY0FBSSxhQUFKLENBQWtCLEtBQUssY0FBdkIsRUFBdUMsS0FBdkMsQ0FERDtBQUVBLEU7Ozs7Ozs7Ozs7O2dDQVNELGlCLDhCQUFrQixLLEVBQU87QUFDeEIsU0FBTyw2QkFBTSxpQkFBTixZQUF3QixLQUF4QixNQUNMLENBQUMsS0FBSyxjQUFMLENBQW9CLGdCQUFyQixJQUF5QyxLQUFLLG9CQUFMLENBQTBCLEtBQTFCLENBRHBDLENBQVA7QUFFQSxFOzs7OztrQkFHYSxvQjs7O0FDekRmOzs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7SUFPTSxjOzs7Ozs7Ozs7Ozs7O0FBVUwseUJBQVksT0FBWixFQUFxQixLQUFyQixFQUE0QixRQUE1QixFQUFzQyxXQUF0QyxFQUFtRDtBQUFBOztBQUFBLCtDQUNsRCx3QkFBTSxPQUFOLEVBQWUsS0FBZixFQUFzQixRQUF0QixDQURrRDs7QUFFbEQsUUFBSyxRQUFMLEdBQWdCLFdBQWhCO0FBRmtEO0FBR2xEOzs7Ozs7OzBCQUtELGMsNkJBQWlCO0FBQ2hCLE9BQUssUUFBTCxDQUFjLG1CQUFkLENBQWtDLEtBQUssTUFBdkMsRUFBK0MsS0FBSyxTQUFwRCxFQUErRCxLQUFLLFFBQXBFO0FBQ0EsRTs7Ozs7a0JBR2EsYzs7O0FDaENmOzs7Ozs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7O1FBR1MsRztRQUFLLG9CO1FBQXNCLGM7UUFBZ0IsUTtRQUFVLFU7UUFBWSxnQjs7O0FDWDFFOzs7Ozs7QUFFQTs7QUFDQTs7Ozs7Ozs7SUFFTSxHOzs7Ozs7Ozs7OztLQU1FLFUsdUJBQVcsTyxFQUFTLE8sRUFBUztBQUNuQyxNQUFJLENBQUMsWUFBSyxRQUFMLENBQWMsT0FBZCxDQUFELElBQTJCLENBQUMsWUFBSyxRQUFMLENBQWMsT0FBZCxDQUFoQyxFQUF3RDtBQUN2RDtBQUNBOztBQUVELE1BQUksZUFBZSxPQUFuQixFQUE0QjtBQUMzQixPQUFJLHFCQUFKLENBQTBCLE9BQTFCLEVBQW1DLE9BQW5DO0FBQ0EsR0FGRCxNQUVPO0FBQ04sT0FBSSx3QkFBSixDQUE2QixPQUE3QixFQUFzQyxPQUF0QztBQUNBO0FBQ0QsRTs7Ozs7Ozs7OztLQVFNLHFCLGtDQUFzQixPLEVBQVMsTyxFQUFTO0FBQzlDLFVBQVEsS0FBUixDQUFjLEdBQWQsRUFBbUIsT0FBbkIsQ0FBMkIsVUFBUyxTQUFULEVBQW9CO0FBQzlDLE9BQUksU0FBSixFQUFlO0FBQ2QsWUFBUSxTQUFSLENBQWtCLEdBQWxCLENBQXNCLFNBQXRCO0FBQ0E7QUFDRCxHQUpEO0FBS0EsRTs7Ozs7Ozs7OztLQVFNLHdCLHFDQUF5QixPLEVBQVMsTyxFQUFTO0FBQ2pELE1BQUksbUJBQW1CLE1BQU0sUUFBUSxTQUFkLEdBQTBCLEdBQWpEO0FBQ0EsTUFBSSxrQkFBa0IsRUFBdEI7O0FBRUEsWUFBVSxRQUFRLEtBQVIsQ0FBYyxHQUFkLENBQVY7O0FBRUEsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFFBQVEsTUFBNUIsRUFBb0MsR0FBcEMsRUFBeUM7QUFDeEMsT0FBSSxZQUFZLFFBQVEsQ0FBUixDQUFoQjs7QUFFQSxPQUFJLGlCQUFpQixPQUFqQixDQUF5QixNQUFNLFNBQU4sR0FBa0IsR0FBM0MsTUFBb0QsQ0FBQyxDQUF6RCxFQUE0RDtBQUMzRCx1QkFBbUIsTUFBTSxTQUF6QjtBQUNBO0FBQ0Q7O0FBRUQsTUFBSSxlQUFKLEVBQXFCO0FBQ3BCLFdBQVEsU0FBUixHQUFvQixRQUFRLFNBQVIsR0FBb0IsZUFBeEM7QUFDQTtBQUNELEU7Ozs7Ozs7Ozs7O0tBU00sTyxvQkFBUSxPLEVBQVMsUSxFQUFVO0FBQ2pDLFNBQU8sV0FBVyxDQUFDLElBQUksS0FBSixDQUFVLE9BQVYsRUFBbUIsUUFBbkIsQ0FBbkIsRUFBaUQ7QUFDaEQsYUFBVSxRQUFRLFVBQWxCO0FBQ0E7QUFDRCxTQUFPLE9BQVA7QUFDQSxFOzs7Ozs7Ozs7Ozs7S0FVTSxNLG1CQUFPLE0sRUFBUSxLLEVBQU87QUFDNUIsTUFBSSxZQUFLLFFBQUwsQ0FBYyxLQUFkLENBQUosRUFBMEI7QUFDekIsV0FBUSxJQUFJLGFBQUosQ0FBa0IsS0FBbEIsQ0FBUjtBQUNBO0FBQ0QsTUFBSSxpQkFBaUIsUUFBckIsRUFBK0I7QUFDOUIsT0FBSSxXQUFXLE1BQU0sU0FBTixDQUFnQixLQUFoQixDQUFzQixJQUF0QixDQUEyQixLQUEzQixDQUFmO0FBQ0EsUUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFNBQVMsTUFBN0IsRUFBcUMsR0FBckMsRUFBMEM7QUFDekMsV0FBTyxXQUFQLENBQW1CLFNBQVMsQ0FBVCxDQUFuQjtBQUNBO0FBQ0QsR0FMRCxNQUtPO0FBQ04sVUFBTyxXQUFQLENBQW1CLEtBQW5CO0FBQ0E7QUFDRCxTQUFPLEtBQVA7QUFDQSxFOzs7Ozs7Ozs7S0FPTSxhLDBCQUFjLFUsRUFBWTtBQUNoQyxNQUFJLFVBQVUsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQWQ7QUFDQSxVQUFRLFNBQVIsR0FBb0IsU0FBUyxVQUE3QjtBQUNBLFVBQVEsV0FBUixDQUFvQixRQUFRLFVBQTVCOztBQUVBLE1BQUksV0FBVyxTQUFTLHNCQUFULEVBQWY7QUFDQSxTQUFPLFFBQVEsVUFBZixFQUEyQjtBQUMxQixZQUFTLFdBQVQsQ0FBcUIsUUFBUSxVQUE3QjtBQUNBO0FBQ0QsU0FBTyxRQUFQO0FBQ0EsRTs7Ozs7Ozs7OztLQVFNLFEscUJBQVMsUSxFQUFVLFEsRUFBVTtBQUNuQyxNQUFJLFlBQUssVUFBTCxDQUFnQixRQUFoQixDQUFKLEVBQStCOztBQUU5QixVQUFPLFNBQVMsZUFBVCxDQUF5QixRQUF6QixDQUFrQyxRQUFsQyxDQUFQO0FBQ0EsR0FIRCxNQUdPO0FBQ04sVUFBTyxTQUFTLFFBQVQsQ0FBa0IsUUFBbEIsQ0FBUDtBQUNBO0FBQ0QsRTs7Ozs7Ozs7Ozs7Ozs7OztLQWNNLFEscUJBQVMsTyxFQUFTLFMsRUFBVyxRLEVBQVUsUSxFQUFVO0FBQ3ZELE1BQUksZUFBZSxJQUFJLFlBQUosQ0FBaUIsU0FBakIsQ0FBbkI7QUFDQSxNQUFJLGdCQUFnQixhQUFhLFFBQWpDLEVBQTJDO0FBQzFDLGVBQVksYUFBYSxhQUF6QjtBQUNBLGNBQVcsYUFBYSxPQUFiLENBQXFCLElBQXJCLENBQTBCLFlBQTFCLEVBQXdDLFFBQXhDLENBQVg7QUFDQTtBQUNELFNBQU8sSUFBSSxFQUFKLENBQ04sT0FETSxFQUVOLFNBRk0sRUFHTixJQUFJLG9CQUFKLENBQXlCLElBQXpCLENBQThCLElBQTlCLEVBQW9DLFFBQXBDLEVBQThDLFFBQTlDLENBSE0sQ0FBUDtBQUtBLEU7Ozs7Ozs7O0tBTU0sYSwwQkFBYyxJLEVBQU07QUFDMUIsTUFBSSxNQUFKLENBQVcsU0FBUyxJQUFwQixFQUEwQixJQUExQjtBQUNBLEU7Ozs7Ozs7O0tBTU0sWSx5QkFBYSxJLEVBQU07QUFDekIsTUFBSSxLQUFLLFVBQVQsRUFBcUI7QUFDcEIsUUFBSyxVQUFMLENBQWdCLFdBQWhCLENBQTRCLElBQTVCO0FBQ0E7QUFDRCxFOzs7Ozs7Ozs7Ozs7Ozs7S0FhTSxvQixpQ0FBcUIsUSxFQUFVLFEsRUFBVSxLLEVBQU87QUFDdEQsTUFBSSx1QkFBSixDQUE0QixLQUE1Qjs7QUFFQSxNQUFJLGlCQUFpQixNQUFNLE1BQTNCO0FBQ0EsTUFBSSxjQUFjLElBQWxCOztBQUVBLFNBQU8sa0JBQWtCLENBQUMsTUFBTSxPQUFoQyxFQUF5QztBQUN4QyxPQUFJLFlBQUssUUFBTCxDQUFjLFFBQWQsS0FBMkIsSUFBSSxLQUFKLENBQVUsY0FBVixFQUEwQixRQUExQixDQUEvQixFQUFvRTtBQUNuRSxVQUFNLGNBQU4sR0FBdUIsY0FBdkI7QUFDQSxtQkFBZSxTQUFTLEtBQVQsQ0FBZjtBQUNBO0FBQ0QsT0FBSSxtQkFBbUIsTUFBTSxhQUE3QixFQUE0QztBQUMzQztBQUNBO0FBQ0Qsb0JBQWlCLGVBQWUsVUFBaEM7QUFDQTtBQUNELFFBQU0sY0FBTixHQUF1QixJQUF2Qjs7QUFFQSxTQUFPLFdBQVA7QUFDQSxFOzs7Ozs7Ozs7O0tBUU0sUSxxQkFBUyxPLEVBQVMsUyxFQUFXO0FBQ25DLE1BQUksZUFBZSxPQUFuQixFQUE0QjtBQUMzQixVQUFPLElBQUksbUJBQUosQ0FBd0IsT0FBeEIsRUFBaUMsU0FBakMsQ0FBUDtBQUNBLEdBRkQsTUFFTztBQUNOLFVBQU8sSUFBSSxzQkFBSixDQUEyQixPQUEzQixFQUFvQyxTQUFwQyxDQUFQO0FBQ0E7QUFDRCxFOzs7Ozs7Ozs7OztLQVNNLG1CLGdDQUFvQixPLEVBQVMsUyxFQUFXO0FBQzlDLFNBQU8sUUFBUSxTQUFSLENBQWtCLFFBQWxCLENBQTJCLFNBQTNCLENBQVA7QUFDQSxFOzs7Ozs7Ozs7OztLQVNNLHNCLG1DQUF1QixPLEVBQVMsUyxFQUFXO0FBQ2pELFNBQU8sQ0FBQyxNQUFNLFFBQVEsU0FBZCxHQUEwQixHQUEzQixFQUFnQyxPQUFoQyxDQUF3QyxNQUFNLFNBQU4sR0FBa0IsR0FBMUQsS0FBa0UsQ0FBekU7QUFDQSxFOzs7Ozs7Ozs7S0FPTSxPLG9CQUFRLE8sRUFBUztBQUN2QixTQUFPLFFBQVEsVUFBUixDQUFtQixNQUFuQixLQUE4QixDQUFyQztBQUNBLEU7Ozs7Ozs7Ozs7S0FRTSxLLGtCQUFNLE8sRUFBUyxRLEVBQVU7QUFDL0IsTUFBSSxDQUFDLE9BQUQsSUFBWSxRQUFRLFFBQVIsS0FBcUIsQ0FBckMsRUFBd0M7QUFDdkMsVUFBTyxLQUFQO0FBQ0E7O0FBRUQsTUFBSSxJQUFJLFFBQVEsU0FBaEI7QUFDQSxNQUFJLElBQUksRUFBRSxPQUFGLElBQWEsRUFBRSxxQkFBZixJQUF3QyxFQUFFLGtCQUExQyxJQUFnRSxFQUFFLGlCQUFsRSxJQUF1RixFQUFFLGdCQUFqRztBQUNBLE1BQUksQ0FBSixFQUFPO0FBQ04sVUFBTyxFQUFFLElBQUYsQ0FBTyxPQUFQLEVBQWdCLFFBQWhCLENBQVA7QUFDQTs7QUFFRCxTQUFPLElBQUksY0FBSixDQUFtQixPQUFuQixFQUE0QixRQUE1QixDQUFQO0FBQ0EsRTs7Ozs7Ozs7Ozs7O0tBVU0sYywyQkFBZSxPLEVBQVMsUSxFQUFVO0FBQ3hDLE1BQUksUUFBUSxTQUFTLGdCQUFULENBQTBCLFFBQTFCLEVBQW9DLFFBQVEsVUFBNUMsQ0FBWjtBQUNBLE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFNLE1BQTFCLEVBQWtDLEVBQUUsQ0FBcEMsRUFBdUM7QUFDdEMsT0FBSSxNQUFNLENBQU4sTUFBYSxPQUFqQixFQUEwQjtBQUN6QixXQUFPLElBQVA7QUFDQTtBQUNEO0FBQ0QsU0FBTyxLQUFQO0FBQ0EsRTs7Ozs7Ozs7OztLQVFNLEksaUJBQUssTyxFQUFTLFEsRUFBVTtBQUM5QixLQUFHO0FBQ0YsYUFBVSxRQUFRLFdBQWxCO0FBQ0EsT0FBSSxXQUFXLElBQUksS0FBSixDQUFVLE9BQVYsRUFBbUIsUUFBbkIsQ0FBZixFQUE2QztBQUM1QyxXQUFPLE9BQVA7QUFDQTtBQUNELEdBTEQsUUFLUyxPQUxUO0FBTUEsU0FBTyxJQUFQO0FBQ0EsRTs7Ozs7Ozs7S0FNTSx1QixvQ0FBd0IsSyxFQUFPO0FBQ3JDLFFBQU0sZUFBTixHQUF3QixJQUFJLGdCQUE1QjtBQUNBLFFBQU0sd0JBQU4sR0FBaUMsSUFBSSx5QkFBckM7QUFDQSxFOzs7Ozs7Ozs7Ozs7Ozs7OztLQWVNLEUsZUFBRyxPLEVBQVMsUyxFQUFXLFEsRUFBVSxXLEVBQWE7QUFDcEQsTUFBSSxZQUFLLFFBQUwsQ0FBYyxPQUFkLENBQUosRUFBNEI7QUFDM0IsVUFBTyxJQUFJLFFBQUosQ0FBYSxRQUFiLEVBQXVCLFNBQXZCLEVBQWtDLE9BQWxDLEVBQTJDLFFBQTNDLENBQVA7QUFDQTtBQUNELE1BQUksZUFBZSxJQUFJLFlBQUosQ0FBaUIsU0FBakIsQ0FBbkI7QUFDQSxNQUFJLGdCQUFnQixhQUFhLEtBQWpDLEVBQXdDO0FBQ3ZDLGVBQVksYUFBYSxhQUF6QjtBQUNBLGNBQVcsYUFBYSxPQUFiLENBQXFCLElBQXJCLENBQTBCLFlBQTFCLEVBQXdDLFFBQXhDLENBQVg7QUFDQTtBQUNELFVBQVEsZ0JBQVIsQ0FBeUIsU0FBekIsRUFBb0MsUUFBcEMsRUFBOEMsV0FBOUM7QUFDQSxTQUFPLDZCQUFtQixPQUFuQixFQUE0QixTQUE1QixFQUF1QyxRQUF2QyxFQUFpRCxXQUFqRCxDQUFQO0FBQ0EsRTs7Ozs7Ozs7Ozs7Ozs7S0FZTSxJLGlCQUFLLE8sRUFBUyxTLEVBQVcsUSxFQUFVO0FBQ3pDLE1BQUksaUJBQWlCLEtBQUssRUFBTCxDQUFRLE9BQVIsRUFBaUIsU0FBakIsRUFBNEIsWUFBVztBQUMzRCxrQkFBZSxjQUFmO0FBQ0EsVUFBTyxTQUFTLEtBQVQsQ0FBZSxJQUFmLEVBQXFCLFNBQXJCLENBQVA7QUFDQSxHQUhvQixDQUFyQjtBQUlBLFNBQU8sY0FBUDtBQUNBLEU7Ozs7Ozs7Ozs7O0tBU00sTSxtQkFBTyxPLEVBQVMsUSxFQUFVO0FBQ2hDLFNBQU8sSUFBSSxPQUFKLENBQVksUUFBUSxVQUFwQixFQUFnQyxRQUFoQyxDQUFQO0FBQ0EsRTs7Ozs7Ozs7OztLQVFNLG1CLGdDQUFvQixTLEVBQVcsWSxFQUFjO0FBQ25ELE1BQUksWUFBSixDQUFpQixTQUFqQixJQUE4QixZQUE5QjtBQUNBLEU7Ozs7Ozs7O0tBTU0sYywyQkFBZSxJLEVBQU07QUFDM0IsTUFBSSxLQUFKO0FBQ0EsU0FBUSxRQUFRLEtBQUssVUFBckIsRUFBa0M7QUFDakMsUUFBSyxXQUFMLENBQWlCLEtBQWpCO0FBQ0E7QUFDRCxFOzs7Ozs7Ozs7S0FPTSxhLDBCQUFjLE8sRUFBUyxPLEVBQVM7QUFDdEMsTUFBSSxDQUFDLFlBQUssUUFBTCxDQUFjLE9BQWQsQ0FBRCxJQUEyQixDQUFDLFlBQUssUUFBTCxDQUFjLE9BQWQsQ0FBaEMsRUFBd0Q7QUFDdkQ7QUFDQTs7QUFFRCxNQUFJLGVBQWUsT0FBbkIsRUFBNEI7QUFDM0IsT0FBSSx3QkFBSixDQUE2QixPQUE3QixFQUFzQyxPQUF0QztBQUNBLEdBRkQsTUFFTztBQUNOLE9BQUksMkJBQUosQ0FBZ0MsT0FBaEMsRUFBeUMsT0FBekM7QUFDQTtBQUNELEU7Ozs7Ozs7Ozs7S0FRTSx3QixxQ0FBeUIsTyxFQUFTLE8sRUFBUztBQUNqRCxVQUFRLEtBQVIsQ0FBYyxHQUFkLEVBQW1CLE9BQW5CLENBQTJCLFVBQVMsU0FBVCxFQUFvQjtBQUM5QyxPQUFJLFNBQUosRUFBZTtBQUNkLFlBQVEsU0FBUixDQUFrQixNQUFsQixDQUF5QixTQUF6QjtBQUNBO0FBQ0QsR0FKRDtBQUtBLEU7Ozs7Ozs7Ozs7S0FRTSwyQix3Q0FBNEIsTyxFQUFTLE8sRUFBUztBQUNwRCxNQUFJLG1CQUFtQixNQUFNLFFBQVEsU0FBZCxHQUEwQixHQUFqRDs7QUFFQSxZQUFVLFFBQVEsS0FBUixDQUFjLEdBQWQsQ0FBVjs7QUFFQSxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksUUFBUSxNQUE1QixFQUFvQyxHQUFwQyxFQUF5QztBQUN4QyxzQkFBbUIsaUJBQWlCLE9BQWpCLENBQXlCLE1BQU0sUUFBUSxDQUFSLENBQU4sR0FBbUIsR0FBNUMsRUFBaUQsR0FBakQsQ0FBbkI7QUFDQTs7QUFFRCxVQUFRLFNBQVIsR0FBb0IsaUJBQWlCLElBQWpCLEVBQXBCO0FBQ0EsRTs7Ozs7Ozs7O0tBT00sTyxvQkFBUSxRLEVBQVUsUSxFQUFVO0FBQ2xDLE1BQUksWUFBWSxRQUFaLElBQXdCLGFBQWEsUUFBckMsSUFBaUQsU0FBUyxVQUE5RCxFQUEwRTtBQUN6RSxZQUFTLFVBQVQsQ0FBb0IsWUFBcEIsQ0FBaUMsUUFBakMsRUFBMkMsUUFBM0M7QUFDQSxZQUFTLFVBQVQsQ0FBb0IsV0FBcEIsQ0FBZ0MsUUFBaEM7QUFDQTtBQUNELEU7Ozs7Ozs7O0tBTU0seUIsd0NBQTRCO0FBQ2xDLE9BQUssT0FBTCxHQUFlLElBQWY7QUFDQSxRQUFNLFNBQU4sQ0FBZ0Isd0JBQWhCLENBQXlDLElBQXpDLENBQThDLElBQTlDO0FBQ0EsRTs7Ozs7Ozs7S0FNTSxnQiwrQkFBbUI7QUFDekIsT0FBSyxPQUFMLEdBQWUsSUFBZjtBQUNBLFFBQU0sU0FBTixDQUFnQixlQUFoQixDQUFnQyxJQUFoQyxDQUFxQyxJQUFyQztBQUNBLEU7Ozs7Ozs7Ozs7S0FRTSxhLDBCQUFjLE8sRUFBUyxTLEVBQVc7QUFDeEMsTUFBSSxJQUFJLFlBQUosQ0FBaUIsU0FBakIsQ0FBSixFQUFpQztBQUNoQyxVQUFPLElBQVA7QUFDQTs7QUFFRCxNQUFJLFlBQUssUUFBTCxDQUFjLE9BQWQsQ0FBSixFQUE0QjtBQUMzQixPQUFJLENBQUMsY0FBYyxPQUFkLENBQUwsRUFBNkI7QUFDNUIsa0JBQWMsT0FBZCxJQUF5QixTQUFTLGFBQVQsQ0FBdUIsT0FBdkIsQ0FBekI7QUFDQTtBQUNELGFBQVUsY0FBYyxPQUFkLENBQVY7QUFDQTtBQUNELFNBQU8sT0FBTyxTQUFQLElBQW9CLE9BQTNCO0FBQ0EsRTs7Ozs7Ozs7Ozs7S0FTTSxTLHNCQUFVLGlCLEVBQW1CO0FBQ25DLE1BQUksWUFBSyxTQUFMLENBQWUsaUJBQWYsS0FBcUMsWUFBSyxVQUFMLENBQWdCLGlCQUFoQixDQUF6QyxFQUE2RTtBQUM1RSxVQUFPLGlCQUFQO0FBQ0EsR0FGRCxNQUVPLElBQUksWUFBSyxRQUFMLENBQWMsaUJBQWQsQ0FBSixFQUFzQztBQUM1QyxPQUFJLGtCQUFrQixDQUFsQixNQUF5QixHQUF6QixJQUFnQyxrQkFBa0IsT0FBbEIsQ0FBMEIsR0FBMUIsTUFBbUMsQ0FBQyxDQUF4RSxFQUEyRTtBQUMxRSxXQUFPLFNBQVMsY0FBVCxDQUF3QixrQkFBa0IsTUFBbEIsQ0FBeUIsQ0FBekIsQ0FBeEIsQ0FBUDtBQUNBLElBRkQsTUFFTztBQUNOLFdBQU8sU0FBUyxhQUFULENBQXVCLGlCQUF2QixDQUFQO0FBQ0E7QUFDRCxHQU5NLE1BTUE7QUFDTixVQUFPLElBQVA7QUFDQTtBQUNELEU7Ozs7Ozs7Ozs7S0FRTSxhLDBCQUFjLE8sRUFBUyxPLEVBQVM7QUFDdEMsTUFBSSxDQUFDLFlBQUssUUFBTCxDQUFjLE9BQWQsQ0FBRCxJQUEyQixDQUFDLFlBQUssUUFBTCxDQUFjLE9BQWQsQ0FBaEMsRUFBd0Q7QUFDdkQ7QUFDQTs7QUFFRCxNQUFJLGVBQWUsT0FBbkIsRUFBNEI7QUFDM0IsT0FBSSx3QkFBSixDQUE2QixPQUE3QixFQUFzQyxPQUF0QztBQUNBLEdBRkQsTUFFTztBQUNOLE9BQUksMkJBQUosQ0FBZ0MsT0FBaEMsRUFBeUMsT0FBekM7QUFDQTtBQUNELEU7Ozs7Ozs7Ozs7O0tBU00sd0IscUNBQXlCLE8sRUFBUyxPLEVBQVM7QUFDakQsVUFBUSxLQUFSLENBQWMsR0FBZCxFQUFtQixPQUFuQixDQUEyQixVQUFTLFNBQVQsRUFBb0I7QUFDOUMsV0FBUSxTQUFSLENBQWtCLE1BQWxCLENBQXlCLFNBQXpCO0FBQ0EsR0FGRDtBQUdBLEU7Ozs7Ozs7Ozs7O0tBU00sMkIsd0NBQTRCLE8sRUFBUyxPLEVBQVM7QUFDcEQsTUFBSSxtQkFBbUIsTUFBTSxRQUFRLFNBQWQsR0FBMEIsR0FBakQ7O0FBRUEsWUFBVSxRQUFRLEtBQVIsQ0FBYyxHQUFkLENBQVY7O0FBRUEsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFFBQVEsTUFBNUIsRUFBb0MsR0FBcEMsRUFBeUM7QUFDeEMsT0FBSSxZQUFZLE1BQU0sUUFBUSxDQUFSLENBQU4sR0FBbUIsR0FBbkM7QUFDQSxPQUFJLGFBQWEsaUJBQWlCLE9BQWpCLENBQXlCLFNBQXpCLENBQWpCOztBQUVBLE9BQUksZUFBZSxDQUFDLENBQXBCLEVBQXVCO0FBQ3RCLHVCQUFtQixtQkFBbUIsUUFBUSxDQUFSLENBQW5CLEdBQWdDLEdBQW5EO0FBQ0EsSUFGRCxNQUVPO0FBQ04sdUJBQW1CLGlCQUFpQixTQUFqQixDQUEyQixDQUEzQixFQUE4QixVQUE5QixJQUE0QyxHQUE1QyxHQUNsQixpQkFBaUIsU0FBakIsQ0FBMkIsYUFBYSxVQUFVLE1BQWxELENBREQ7QUFFQTtBQUNEOztBQUVELFVBQVEsU0FBUixHQUFvQixpQkFBaUIsSUFBakIsRUFBcEI7QUFDQSxFOzs7Ozs7Ozs7Ozs7S0FVTSxZLHlCQUFhLE8sRUFBUyxTLEVBQVcsWSxFQUFjO0FBQ3JELE1BQUksV0FBVyxTQUFTLFdBQVQsQ0FBcUIsWUFBckIsQ0FBZjtBQUNBLFdBQVMsU0FBVCxDQUFtQixTQUFuQixFQUE4QixJQUE5QixFQUFvQyxJQUFwQztBQUNBLGdCQUFPLEtBQVAsQ0FBYSxRQUFiLEVBQXVCLFlBQXZCO0FBQ0EsVUFBUSxhQUFSLENBQXNCLFFBQXRCO0FBQ0EsRTs7Ozs7QUFHRixJQUFJLGdCQUFnQixFQUFwQjtBQUNBLElBQUksWUFBSixHQUFtQixFQUFuQjs7a0JBRWUsRzs7O0FDM2tCZjs7QUFFQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFJLGdCQUFnQjtBQUNuQixhQUFZLFdBRE87QUFFbkIsYUFBWSxVQUZPO0FBR25CLGVBQWMsYUFISztBQUluQixlQUFjO0FBSkssQ0FBcEI7QUFNQSxPQUFPLElBQVAsQ0FBWSxhQUFaLEVBQTJCLE9BQTNCLENBQW1DLFVBQVMsU0FBVCxFQUFvQjtBQUN0RCxlQUFJLG1CQUFKLENBQXdCLFNBQXhCLEVBQW1DO0FBQ2xDLFlBQVUsSUFEd0I7QUFFbEMsV0FBUyxpQkFBUyxRQUFULEVBQW1CLEtBQW5CLEVBQTBCO0FBQ2xDLE9BQUksVUFBVSxNQUFNLGFBQXBCO0FBQ0EsT0FBSSxTQUFTLE1BQU0sY0FBbkI7QUFDQSxPQUFJLENBQUMsT0FBRCxJQUFhLFlBQVksTUFBWixJQUFzQixDQUFDLE9BQU8sUUFBUCxDQUFnQixPQUFoQixDQUF4QyxFQUFtRTtBQUNsRSxVQUFNLFVBQU4sR0FBbUIsU0FBbkI7QUFDQSxXQUFPLFNBQVMsS0FBVCxDQUFQO0FBQ0E7QUFDRCxHQVRpQztBQVVsQyxpQkFBZSxjQUFjLFNBQWQ7QUFWbUIsRUFBbkM7QUFZQSxDQWJEOztBQWVBLElBQUksb0JBQW9CO0FBQ3ZCLFlBQVcsY0FEWTtBQUV2QixhQUFZO0FBRlcsQ0FBeEI7QUFJQSxPQUFPLElBQVAsQ0FBWSxpQkFBWixFQUErQixPQUEvQixDQUF1QyxVQUFTLFNBQVQsRUFBb0I7QUFDMUQsS0FBSSxZQUFZLGtCQUFrQixTQUFsQixDQUFoQjtBQUNBLGVBQUksbUJBQUosQ0FBd0IsU0FBeEIsRUFBbUM7QUFDbEMsU0FBTyxJQUQyQjtBQUVsQyxZQUFVLElBRndCO0FBR2xDLFdBQVMsaUJBQVMsUUFBVCxFQUFtQixLQUFuQixFQUEwQjtBQUNsQyxTQUFNLFVBQU4sR0FBbUIsU0FBbkI7QUFDQSxVQUFPLFNBQVMsS0FBVCxDQUFQO0FBQ0EsR0FOaUM7QUFPbEMsaUJBQWUsbUJBQVMsdUJBQVQsR0FBbUMsU0FBbkM7QUFQbUIsRUFBbkM7QUFTQSxDQVhEOzs7QUM5QkE7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7Ozs7Ozs7SUFLTSxROzs7Ozs7Ozs7Ozs7VUFPRSx1QixzQ0FBMEI7QUFDaEMsTUFBSSxTQUFTLG1CQUFULEtBQWlDLFNBQXJDLEVBQWdEO0FBQy9DLFlBQVMsbUJBQVQsR0FBK0I7QUFDOUIsZUFBVyxTQUFTLHdCQUFULENBQWtDLFdBQWxDLENBRG1CO0FBRTlCLGdCQUFZLFNBQVMsd0JBQVQsQ0FBa0MsWUFBbEM7QUFGa0IsSUFBL0I7QUFJQTtBQUNELFNBQU8sU0FBUyxtQkFBaEI7QUFDQSxFOzs7Ozs7Ozs7VUFPTSx3QixxQ0FBeUIsSSxFQUFNO0FBQ3JDLE1BQUksV0FBVyxDQUFDLFFBQUQsRUFBVyxJQUFYLEVBQWlCLEdBQWpCLEVBQXNCLEVBQXRCLENBQWY7QUFDQSxNQUFJLGdCQUFnQixjQUFPLGVBQVAsQ0FBdUIsSUFBdkIsRUFBNkIsQ0FBN0IsRUFBZ0MsQ0FBaEMsRUFBbUMsS0FBSyxTQUFMLENBQWUsQ0FBZixFQUFrQixDQUFsQixFQUFxQixXQUFyQixFQUFuQyxDQUFwQjtBQUNBLE1BQUksV0FBVyxDQUFDLGdCQUFnQixLQUFqQixFQUF3QixnQkFBZ0IsS0FBeEMsRUFBK0MsZ0JBQWdCLEtBQS9ELEVBQXNFLE9BQU8sS0FBN0UsQ0FBZjtBQUNBLE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxTQUFTLE1BQTdCLEVBQXFDLEdBQXJDLEVBQTBDO0FBQ3pDLE9BQUksU0FBUyxpQkFBVCxDQUEyQixLQUEzQixDQUFpQyxTQUFTLENBQVQsSUFBYyxhQUEvQyxNQUFrRSxTQUF0RSxFQUFpRjtBQUNoRixXQUFPLFNBQVMsQ0FBVCxFQUFZLFdBQVosS0FBNEIsU0FBUyxDQUFULENBQW5DO0FBQ0E7QUFDRDtBQUNELFNBQU8sT0FBTyxLQUFkO0FBQ0EsRTs7Ozs7Ozs7OztVQVFNLG9CLG1DQUF1QjtBQUM3QixNQUFJLFNBQVMsZ0JBQVQsS0FBOEIsU0FBbEMsRUFBNkM7QUFDNUMsT0FBSSxrQkFBa0IsMkNBQXRCO0FBQ0EsT0FBSSxVQUFVLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUFkO0FBQ0EsaUJBQUksTUFBSixDQUFXLE9BQVgsRUFBb0IsZUFBcEI7QUFDQSxZQUFTLGdCQUFULEdBQTRCLG9CQUFvQixRQUFRLFNBQXhEO0FBQ0E7QUFDRCxTQUFPLFNBQVMsZ0JBQWhCO0FBQ0EsRTs7Ozs7QUFHRixTQUFTLGlCQUFULEdBQTZCLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUE3QjtBQUNBLFNBQVMsbUJBQVQsR0FBK0IsU0FBL0I7QUFDQSxTQUFTLGdCQUFULEdBQTRCLFNBQTVCOztrQkFFZSxROzs7QUMvRGY7Ozs7OztBQUVBOztBQUNBOzs7Ozs7Ozs7Ozs7SUFLTSxVOzs7Ozs7Ozs7Ozs7O1lBUUUsRyxnQkFBSSxJLEVBQU0sWSxFQUFjO0FBQzlCLE1BQUksU0FBUyxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBYjtBQUNBLFNBQU8sSUFBUCxHQUFjLElBQWQ7QUFDQSxNQUFJLFlBQUosRUFBa0I7QUFDakIsZ0JBQWEsTUFBYjtBQUNBLEdBRkQsTUFFTztBQUNOLFlBQVMsSUFBVCxDQUFjLFdBQWQsQ0FBMEIsTUFBMUI7QUFDQTtBQUNELGdCQUFJLFlBQUosQ0FBaUIsTUFBakI7QUFDQSxTQUFPLE1BQVA7QUFDQSxFOzs7Ozs7Ozs7Ozs7O1lBV00sTyxvQkFBUSxHLEVBQUssWSxFQUFjLFksRUFBYztBQUMvQyxNQUFJLFNBQVMsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBQWI7QUFDQSxTQUFPLEdBQVAsR0FBYSxHQUFiOztBQUVBLE1BQUksV0FBVyxTQUFYLFFBQVcsR0FBVztBQUN6QixpQkFBSSxZQUFKLENBQWlCLE1BQWpCO0FBQ0EsbUJBQWdCLGNBQWhCO0FBQ0EsR0FIRDtBQUlBLGdCQUFJLEVBQUosQ0FBTyxNQUFQLEVBQWUsTUFBZixFQUF1QixRQUF2QjtBQUNBLGdCQUFJLEVBQUosQ0FBTyxNQUFQLEVBQWUsT0FBZixFQUF3QixRQUF4Qjs7QUFFQSxNQUFJLFlBQUosRUFBa0I7QUFDakIsZ0JBQWEsTUFBYjtBQUNBLEdBRkQsTUFFTztBQUNOLFlBQVMsSUFBVCxDQUFjLFdBQWQsQ0FBMEIsTUFBMUI7QUFDQTs7QUFFRCxTQUFPLE1BQVA7QUFDQSxFOzs7Ozs7Ozs7Ozs7O1lBV00sUyxzQkFBVSxNLEVBQVEsWSxFQUFjLFksRUFBYztBQUNwRCxNQUFJLFdBQVcsU0FBWCxRQUFXLEdBQVc7QUFDekIsbUJBQWdCLGNBQWhCO0FBQ0EsR0FGRDtBQUdBLE1BQUksT0FBTyxJQUFQLElBQWUsT0FBTyxJQUFQLEtBQWdCLGlCQUFuQyxFQUFzRDtBQUNyRCxnQkFBTSxRQUFOLENBQWUsUUFBZjtBQUNBO0FBQ0E7QUFDRCxnQkFBSSxZQUFKLENBQWlCLE1BQWpCO0FBQ0EsTUFBSSxPQUFPLEdBQVgsRUFBZ0I7QUFDZixVQUFPLFdBQVcsT0FBWCxDQUFtQixPQUFPLEdBQTFCLEVBQStCLFlBQS9CLEVBQTZDLFlBQTdDLENBQVA7QUFDQSxHQUZELE1BRU87QUFDTixnQkFBTSxRQUFOLENBQWUsUUFBZjtBQUNBLFVBQU8sV0FBVyxHQUFYLENBQWUsT0FBTyxJQUF0QixFQUE0QixZQUE1QixDQUFQO0FBQ0E7QUFDRCxFOzs7Ozs7Ozs7Ozs7WUFVTSxtQixnQ0FBb0IsTyxFQUFTLFksRUFBYyxZLEVBQWM7QUFDL0QsTUFBSSxVQUFVLFFBQVEsZ0JBQVIsQ0FBeUIsUUFBekIsQ0FBZDtBQUNBLE1BQUksUUFBUSxNQUFaLEVBQW9CO0FBQ25CLGNBQVcsaUJBQVgsQ0FBNkIsT0FBN0IsRUFBc0MsQ0FBdEMsRUFBeUMsWUFBekMsRUFBdUQsWUFBdkQ7QUFDQSxHQUZELE1BRU8sSUFBSSxZQUFKLEVBQWtCO0FBQ3hCLGdCQUFNLFFBQU4sQ0FBZSxZQUFmO0FBQ0E7QUFDRCxFOzs7Ozs7Ozs7Ozs7O1lBV00saUIsOEJBQWtCLE8sRUFBUyxLLEVBQU8sWSxFQUFjLFksRUFBYztBQUNwRSxhQUFXLFNBQVgsQ0FBcUIsUUFBUSxJQUFSLENBQWEsS0FBYixDQUFyQixFQUEwQyxZQUFXO0FBQ3BELE9BQUksUUFBUSxRQUFRLE1BQVIsR0FBaUIsQ0FBN0IsRUFBZ0M7QUFDL0IsZUFBVyxpQkFBWCxDQUE2QixPQUE3QixFQUFzQyxRQUFRLENBQTlDLEVBQWlELFlBQWpELEVBQStELFlBQS9EO0FBQ0EsSUFGRCxNQUVPLElBQUksWUFBSixFQUFrQjtBQUN4QixpQkFBTSxRQUFOLENBQWUsWUFBZjtBQUNBO0FBQ0QsR0FORCxFQU1HLFlBTkg7QUFPQSxFOzs7OztrQkFHYSxVOzs7QUN4SGY7Ozs7OztBQUVBOztBQUNBOzs7Ozs7Ozs7Ozs7SUFLTSxnQjs7Ozs7Ozs7Ozs7OztrQkFRRSxHLGdCQUFJLEksRUFBTSxZLEVBQWM7QUFDOUIsTUFBSSxRQUFRLFNBQVMsYUFBVCxDQUF1QixPQUF2QixDQUFaO0FBQ0EsUUFBTSxTQUFOLEdBQWtCLElBQWxCO0FBQ0EsTUFBSSxZQUFKLEVBQWtCO0FBQ2pCLGdCQUFhLEtBQWI7QUFDQSxHQUZELE1BRU87QUFDTixZQUFTLElBQVQsQ0FBYyxXQUFkLENBQTBCLEtBQTFCO0FBQ0E7QUFDRCxTQUFPLEtBQVA7QUFDQSxFOzs7Ozs7Ozs7Ozs7O2tCQVdNLE8sb0JBQVEsSSxFQUFNLFksRUFBYyxZLEVBQWM7QUFDaEQsTUFBSSxPQUFPLFNBQVMsYUFBVCxDQUF1QixNQUF2QixDQUFYO0FBQ0EsT0FBSyxHQUFMLEdBQVcsWUFBWDtBQUNBLE9BQUssSUFBTCxHQUFZLElBQVo7QUFDQSxtQkFBaUIsUUFBakIsQ0FBMEIsSUFBMUIsRUFBZ0MsWUFBaEMsRUFBOEMsWUFBOUM7QUFDQSxTQUFPLElBQVA7QUFDQSxFOzs7Ozs7Ozs7Ozs7O2tCQVdNLFEscUJBQVMsSyxFQUFPLFksRUFBYyxZLEVBQWM7QUFDbEQsTUFBSSxXQUFXLFNBQVgsUUFBVyxHQUFXO0FBQ3pCLG1CQUFnQixjQUFoQjtBQUNBLEdBRkQ7QUFHQSxNQUFJLE1BQU0sR0FBTixJQUFhLE1BQU0sR0FBTixLQUFjLFlBQS9CLEVBQTZDO0FBQzVDLGdCQUFNLFFBQU4sQ0FBZSxRQUFmO0FBQ0E7QUFDQTs7QUFFRCxNQUFJLE1BQU0sT0FBTixLQUFrQixPQUF0QixFQUErQjtBQUM5QixnQkFBTSxRQUFOLENBQWUsUUFBZjtBQUNBLEdBRkQsTUFFTztBQUNOLGlCQUFJLEVBQUosQ0FBTyxLQUFQLEVBQWMsTUFBZCxFQUFzQixRQUF0QjtBQUNBLGlCQUFJLEVBQUosQ0FBTyxLQUFQLEVBQWMsT0FBZCxFQUF1QixRQUF2QjtBQUNBOztBQUVELE1BQUksWUFBSixFQUFrQjtBQUNqQixnQkFBYSxLQUFiO0FBQ0EsR0FGRCxNQUVPO0FBQ04sWUFBUyxJQUFULENBQWMsV0FBZCxDQUEwQixLQUExQjtBQUNBOztBQUVELFNBQU8sS0FBUDtBQUNBLEU7Ozs7Ozs7Ozs7OztrQkFVTSxrQiwrQkFBbUIsTyxFQUFTLFksRUFBYyxZLEVBQWM7QUFDOUQsTUFBSSxTQUFTLFFBQVEsZ0JBQVIsQ0FBeUIsWUFBekIsQ0FBYjtBQUNBLE1BQUksT0FBTyxNQUFQLEtBQWtCLENBQWxCLElBQXVCLFlBQTNCLEVBQXlDO0FBQ3hDLGdCQUFNLFFBQU4sQ0FBZSxZQUFmO0FBQ0E7QUFDQTs7QUFFRCxNQUFJLFlBQVksQ0FBaEI7QUFDQSxNQUFJLFdBQVcsU0FBWCxRQUFXLEdBQVc7QUFDekIsT0FBSSxnQkFBZ0IsRUFBRSxTQUFGLEtBQWdCLE9BQU8sTUFBM0MsRUFBbUQ7QUFDbEQsaUJBQU0sUUFBTixDQUFlLFlBQWY7QUFDQTtBQUNELEdBSkQ7QUFLQSxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBTyxNQUEzQixFQUFtQyxHQUFuQyxFQUF3QztBQUN2QyxvQkFBaUIsUUFBakIsQ0FBMEIsT0FBTyxDQUFQLENBQTFCLEVBQXFDLFFBQXJDLEVBQStDLFlBQS9DO0FBQ0E7QUFDRCxFOzs7OztrQkFHYSxnQjs7O0FDekdmOzs7Ozs7QUFFQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBT00sWTs7O0FBQ0wseUJBQWM7QUFBQTs7Ozs7Ozs7QUFBQSwrQ0FDYixzQkFEYTs7QUFRYixRQUFLLE9BQUwsR0FBZSxFQUFmOzs7Ozs7OztBQVFBLFFBQUssYUFBTCxHQUFxQixFQUFyQjs7Ozs7Ozs7O0FBU0EsUUFBSyxnQkFBTCxHQUF3QixLQUF4QjtBQXpCYTtBQTBCYjs7Ozs7Ozs7Ozs7Ozt3QkFXRCxXLHdCQUFZLE0sRUFBUSxRLEVBQVUsVyxFQUFhO0FBQzFDLE9BQUssaUJBQUwsQ0FBdUIsUUFBdkI7O0FBRUEsV0FBUyxLQUFLLGdCQUFMLENBQXNCLE1BQXRCLENBQVQ7QUFDQSxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBTyxNQUEzQixFQUFtQyxHQUFuQyxFQUF3QztBQUN2QyxRQUFLLGtCQUFMLENBQXdCLE9BQU8sQ0FBUCxDQUF4QixFQUFtQyxRQUFuQyxFQUE2QyxXQUE3QztBQUNBOztBQUVELFNBQU8sMEJBQWdCLElBQWhCLEVBQXNCLE1BQXRCLEVBQThCLFFBQTlCLENBQVA7QUFDQSxFOzs7Ozs7Ozs7Ozs7Ozs7O3dCQWNELGtCLCtCQUFtQixLLEVBQU8sUSxFQUFVLFcsRUFBYSxVLEVBQVk7QUFDNUQsT0FBSyxJQUFMLENBQVUsYUFBVixFQUF5QixLQUF6QixFQUFnQyxRQUFoQzs7QUFFQSxNQUFJLENBQUMsS0FBSyxPQUFMLENBQWEsS0FBYixDQUFMLEVBQTBCO0FBQ3pCLFFBQUssT0FBTCxDQUFhLEtBQWIsSUFBc0IsRUFBdEI7QUFDQTtBQUNELE9BQUssT0FBTCxDQUFhLEtBQWIsRUFBb0IsSUFBcEIsQ0FBeUI7QUFDeEIsWUFBUyxXQURlO0FBRXhCLE9BQUksUUFGb0I7QUFHeEIsV0FBUTtBQUhnQixHQUF6Qjs7QUFNQSxNQUFJLFlBQVksS0FBSyxPQUFMLENBQWEsS0FBYixDQUFoQjtBQUNBLE1BQUksVUFBVSxNQUFWLEdBQW1CLEtBQUssYUFBeEIsSUFBeUMsQ0FBQyxVQUFVLE1BQXhELEVBQWdFO0FBQy9ELFdBQVEsSUFBUixDQUNDLG9FQUNBLGdFQUZELEVBR0MsVUFBVSxNQUhYLEVBSUMsS0FKRDtBQU1BLGFBQVUsTUFBVixHQUFtQixJQUFuQjtBQUNBO0FBQ0QsRTs7Ozs7Ozs7d0JBTUQsZSw4QkFBa0I7QUFDakIsT0FBSyxPQUFMLEdBQWUsRUFBZjtBQUNBLEU7Ozs7Ozs7Ozs7d0JBUUQsSSxpQkFBSyxLLEVBQU87QUFDWCxNQUFJLE9BQU8sYUFBTSxLQUFOLENBQVksU0FBWixFQUF1QixDQUF2QixDQUFYO0FBQ0EsTUFBSSxZQUFZLENBQUMsS0FBSyxPQUFMLENBQWEsS0FBYixLQUF1QixFQUF4QixFQUE0QixNQUE1QixFQUFoQjs7QUFFQSxNQUFJLE1BQUo7QUFDQSxNQUFJLEtBQUssa0JBQUwsRUFBSixFQUErQjtBQUM5QixZQUFTO0FBQ1Isb0JBQWdCLDBCQUFXO0FBQzFCLFlBQU8sZ0JBQVAsR0FBMEIsSUFBMUI7QUFDQSxLQUhPO0FBSVIsWUFBUSxJQUpBO0FBS1IsVUFBTTtBQUxFLElBQVQ7QUFPQSxRQUFLLElBQUwsQ0FBVSxNQUFWO0FBQ0E7O0FBRUQsTUFBSSxtQkFBbUIsRUFBdkI7QUFDQSxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksVUFBVSxNQUE5QixFQUFzQyxHQUF0QyxFQUEyQztBQUMxQyxPQUFJLFVBQVUsQ0FBVixFQUFhLE9BQWpCLEVBQTBCO0FBQ3pCLHFCQUFpQixJQUFqQixDQUFzQixVQUFVLENBQVYsQ0FBdEI7QUFDQSxJQUZELE1BRU87QUFDTixjQUFVLENBQVYsRUFBYSxFQUFiLENBQWdCLEtBQWhCLENBQXNCLElBQXRCLEVBQTRCLElBQTVCO0FBQ0E7QUFDRDtBQUNELE1BQUksQ0FBQyxNQUFELElBQVcsQ0FBQyxPQUFPLGdCQUF2QixFQUF5QztBQUN4QyxRQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksaUJBQWlCLE1BQXJDLEVBQTZDLEdBQTdDLEVBQWtEO0FBQ2pELHFCQUFpQixDQUFqQixFQUFvQixFQUFwQixDQUF1QixLQUF2QixDQUE2QixJQUE3QixFQUFtQyxJQUFuQztBQUNBO0FBQ0Q7O0FBR0QsTUFBSSxVQUFVLEdBQWQsRUFBbUI7QUFDbEIsUUFBSyxJQUFMLENBQVUsS0FBVixDQUFnQixJQUFoQixFQUFzQixDQUFDLEdBQUQsRUFBTSxLQUFOLEVBQWEsTUFBYixDQUFvQixJQUFwQixDQUF0QjtBQUNBOztBQUVELFNBQU8sVUFBVSxNQUFWLEdBQW1CLENBQTFCO0FBQ0EsRTs7Ozs7Ozs7Ozt3QkFRRCxrQixpQ0FBcUI7QUFDcEIsU0FBTyxLQUFLLGdCQUFaO0FBQ0EsRTs7Ozs7Ozs7O3dCQU9ELFMsc0JBQVUsSyxFQUFPO0FBQ2hCLFNBQU8sQ0FBQyxLQUFLLE9BQUwsQ0FBYSxLQUFiLEtBQXVCLEVBQXhCLEVBQTRCLEdBQTVCLENBQWdDO0FBQUEsVUFBWSxTQUFTLEVBQXJCO0FBQUEsR0FBaEMsQ0FBUDtBQUNBLEU7Ozs7Ozs7Ozs7Ozs7O3dCQVlELEksaUJBQUssTSxFQUFRLE0sRUFBUSxRLEVBQVU7QUFDOUIsV0FBUyxLQUFLLGdCQUFMLENBQXNCLE1BQXRCLENBQVQ7QUFDQSxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBTyxNQUEzQixFQUFtQyxHQUFuQyxFQUF3QztBQUN2QyxRQUFLLEtBQUwsQ0FBVyxPQUFPLENBQVAsQ0FBWCxFQUFzQixNQUF0QixFQUE4QixRQUE5QjtBQUNBOztBQUVELFNBQU8sMEJBQWdCLElBQWhCLEVBQXNCLE1BQXRCLEVBQThCLFFBQTlCLENBQVA7QUFDQSxFOzs7Ozs7Ozs7Ozs7Ozt3QkFZRCxLLGtCQUFNLEssRUFBTyxNLEVBQVEsUSxFQUFVO0FBQzlCLE1BQUksT0FBTyxJQUFYOztBQUVBLE1BQUksVUFBVSxDQUFkLEVBQWlCO0FBQ2hCO0FBQ0E7O0FBRUQsV0FBUyxlQUFULEdBQTJCO0FBQzFCLE9BQUksRUFBRSxNQUFGLEtBQWEsQ0FBakIsRUFBb0I7QUFDbkIsU0FBSyxjQUFMLENBQW9CLEtBQXBCLEVBQTJCLGVBQTNCO0FBQ0E7QUFDRCxZQUFTLEtBQVQsQ0FBZSxJQUFmLEVBQXFCLFNBQXJCO0FBQ0E7O0FBRUQsT0FBSyxrQkFBTCxDQUF3QixLQUF4QixFQUErQixlQUEvQixFQUFnRCxLQUFoRCxFQUF1RCxRQUF2RDtBQUNBLEU7Ozs7Ozs7Ozs7Ozt3QkFVRCxnQiw2QkFBaUIsVyxFQUFhLFEsRUFBVTtBQUN2QyxTQUFPLFlBQVksRUFBWixLQUFtQixRQUFuQixJQUNMLFlBQVksTUFBWixJQUFzQixZQUFZLE1BQVosS0FBdUIsUUFEL0M7QUFFQSxFOzs7Ozs7Ozs7O3dCQVFELGdCLDZCQUFpQixNLEVBQVE7QUFDeEIsU0FBTyxZQUFLLFFBQUwsQ0FBYyxNQUFkLElBQXdCLENBQUMsTUFBRCxDQUF4QixHQUFtQyxNQUExQztBQUNBLEU7Ozs7Ozs7Ozs7O3dCQVNELEcsZ0JBQUksTSxFQUFRLFEsRUFBVTtBQUNyQixPQUFLLGlCQUFMLENBQXVCLFFBQXZCOztBQUVBLFdBQVMsS0FBSyxnQkFBTCxDQUFzQixNQUF0QixDQUFUO0FBQ0EsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQU8sTUFBM0IsRUFBbUMsR0FBbkMsRUFBd0M7QUFDdkMsT0FBSSxlQUFlLEtBQUssT0FBTCxDQUFhLE9BQU8sQ0FBUCxDQUFiLEtBQTJCLEVBQTlDO0FBQ0EsUUFBSywyQkFBTCxDQUFpQyxZQUFqQyxFQUErQyxRQUEvQztBQUNBOztBQUVELFNBQU8sSUFBUDtBQUNBLEU7Ozs7Ozs7Ozs7d0JBUUQsRSxpQkFBSztBQUNKLFNBQU8sS0FBSyxXQUFMLENBQWlCLEtBQWpCLENBQXVCLElBQXZCLEVBQTZCLFNBQTdCLENBQVA7QUFDQSxFOzs7Ozs7Ozs7Ozt3QkFTRCxJLGlCQUFLLE0sRUFBUSxRLEVBQVU7QUFDdEIsU0FBTyxLQUFLLElBQUwsQ0FBVSxNQUFWLEVBQWtCLENBQWxCLEVBQXFCLFFBQXJCLENBQVA7QUFDQSxFOzs7Ozs7Ozs7Ozt3QkFTRCxrQiwrQkFBbUIsVSxFQUFZO0FBQzlCLE1BQUksVUFBSixFQUFnQjtBQUNmLE9BQUksU0FBUyxLQUFLLGdCQUFMLENBQXNCLFVBQXRCLENBQWI7QUFDQSxRQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBTyxNQUEzQixFQUFtQyxHQUFuQyxFQUF3QztBQUN2QyxTQUFLLE9BQUwsQ0FBYSxPQUFPLENBQVAsQ0FBYixJQUEwQixJQUExQjtBQUNBO0FBQ0QsR0FMRCxNQUtPO0FBQ04sUUFBSyxPQUFMLEdBQWUsRUFBZjtBQUNBO0FBQ0QsU0FBTyxJQUFQO0FBQ0EsRTs7Ozs7Ozs7Ozs7d0JBU0QsMkIsd0NBQTRCLFksRUFBYyxRLEVBQVU7QUFDbkQsT0FBSyxJQUFJLElBQUksYUFBYSxNQUFiLEdBQXNCLENBQW5DLEVBQXNDLEtBQUssQ0FBM0MsRUFBOEMsR0FBOUMsRUFBbUQ7QUFDbEQsT0FBSSxLQUFLLGdCQUFMLENBQXNCLGFBQWEsQ0FBYixDQUF0QixFQUF1QyxRQUF2QyxDQUFKLEVBQXNEO0FBQ3JELGlCQUFhLE1BQWIsQ0FBb0IsQ0FBcEIsRUFBdUIsQ0FBdkI7QUFDQTtBQUNEO0FBQ0QsRTs7Ozs7Ozs7Ozs7d0JBU0QsYyw2QkFBaUI7QUFDaEIsU0FBTyxLQUFLLEdBQUwsQ0FBUyxLQUFULENBQWUsSUFBZixFQUFxQixTQUFyQixDQUFQO0FBQ0EsRTs7Ozs7Ozs7Ozs7O3dCQVVELGUsNEJBQWdCLEcsRUFBSztBQUNwQixPQUFLLGFBQUwsR0FBcUIsR0FBckI7QUFDQSxTQUFPLElBQVA7QUFDQSxFOzs7Ozs7Ozs7Ozt3QkFTRCxrQiwrQkFBbUIsZSxFQUFpQjtBQUNuQyxPQUFLLGdCQUFMLEdBQXdCLGVBQXhCO0FBQ0EsU0FBTyxJQUFQO0FBQ0EsRTs7Ozs7Ozs7O3dCQU9ELGlCLDhCQUFrQixRLEVBQVU7QUFDM0IsTUFBSSxDQUFDLFlBQUssVUFBTCxDQUFnQixRQUFoQixDQUFMLEVBQWdDO0FBQy9CLFNBQU0sSUFBSSxTQUFKLENBQWMsNkJBQWQsQ0FBTjtBQUNBO0FBQ0QsRTs7Ozs7a0JBR2EsWTs7O0FDcldmOzs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFnQk0saUI7OztBQUNMLDRCQUFZLGFBQVosRUFBMkIsYUFBM0IsRUFBMEMsYUFBMUMsRUFBeUQsYUFBekQsRUFBd0U7QUFBQTs7Ozs7Ozs7QUFBQSwrQ0FDdkUsc0JBRHVFOztBQVF2RSxRQUFLLFVBQUwsR0FBa0IsaUJBQWlCLEVBQW5DOzs7Ozs7OztBQVFBLFFBQUssY0FBTCxHQUFzQixhQUF0Qjs7Ozs7OztBQU9BLFFBQUssY0FBTCxHQUFzQixFQUF0Qjs7Ozs7Ozs7QUFRQSxRQUFLLGNBQUwsR0FBc0IsYUFBdEI7Ozs7Ozs7QUFPQSxRQUFLLFVBQUwsR0FBa0IsYUFBbEI7O0FBRUEsUUFBSyxXQUFMO0FBeEN1RTtBQXlDdkU7Ozs7Ozs7Ozs7OzZCQVNELFkseUJBQWEsSyxFQUFPLFEsRUFBVTtBQUM3QixTQUFPLEtBQUssY0FBTCxDQUFvQixFQUFwQixDQUF1QixLQUF2QixFQUE4QixRQUE5QixDQUFQO0FBQ0EsRTs7Ozs7Ozs7Ozs2QkFRRCxvQixpQ0FBcUIsSyxFQUFPO0FBQzNCLFNBQU8sS0FBSyxZQUFMLENBQWtCLEtBQWxCLEVBQXlCLEtBQUssYUFBTCxDQUFtQixJQUFuQixDQUF3QixJQUF4QixFQUE4QixLQUE5QixDQUF6QixDQUFQO0FBQ0EsRTs7Ozs7Ozs2QkFLRCxlLDhCQUFrQjtBQUNqQixPQUFLLGdCQUFMO0FBQ0EsT0FBSyxjQUFMLEdBQXNCLElBQXRCO0FBQ0EsT0FBSyxjQUFMLEdBQXNCLElBQXRCO0FBQ0EsT0FBSyxjQUFMLEdBQXNCLElBQXRCO0FBQ0EsRTs7Ozs7Ozs7OzZCQU9ELGEsMEJBQWMsUyxFQUFXO0FBQ3hCLE1BQUksT0FBTyxDQUFDLFNBQUQsRUFBWSxNQUFaLENBQW1CLGFBQU0sS0FBTixDQUFZLFNBQVosRUFBdUIsQ0FBdkIsQ0FBbkIsQ0FBWDtBQUNBLE9BQUssY0FBTCxDQUFvQixJQUFwQixDQUF5QixLQUF6QixDQUErQixLQUFLLGNBQXBDLEVBQW9ELElBQXBEO0FBQ0EsRTs7Ozs7Ozs7NkJBTUQsVSx1QkFBVyxLLEVBQU87QUFDakIsTUFBSSxLQUFLLGlCQUFMLENBQXVCLEtBQXZCLENBQUosRUFBbUM7QUFDbEMsUUFBSyxjQUFMLENBQW9CLEtBQXBCLElBQTZCLEtBQUssb0JBQUwsQ0FBMEIsS0FBMUIsQ0FBN0I7QUFDQTtBQUNELEU7Ozs7Ozs7OzZCQU1ELGdCLCtCQUFtQjtBQUNsQixNQUFJLFNBQVMsT0FBTyxJQUFQLENBQVksS0FBSyxjQUFqQixDQUFiO0FBQ0EsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQU8sTUFBM0IsRUFBbUMsR0FBbkMsRUFBd0M7QUFDdkMsUUFBSyxjQUFMLENBQW9CLE9BQU8sQ0FBUCxDQUFwQixFQUErQixjQUEvQjtBQUNBO0FBQ0QsT0FBSyxjQUFMLEdBQXNCLEVBQXRCO0FBQ0EsRTs7Ozs7Ozs7OzZCQU9ELGdCLDZCQUFpQixhLEVBQWU7QUFDL0IsTUFBSSxVQUFVLEtBQUssY0FBbkI7QUFDQSxPQUFLLGdCQUFMO0FBQ0EsT0FBSyxjQUFMLEdBQXNCLGFBQXRCOztBQUVBLE1BQUksU0FBUyxPQUFPLElBQVAsQ0FBWSxPQUFaLENBQWI7QUFDQSxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBTyxNQUEzQixFQUFtQyxHQUFuQyxFQUF3QztBQUN2QyxRQUFLLGNBQUwsQ0FBb0IsT0FBTyxDQUFQLENBQXBCLElBQWlDLEtBQUssb0JBQUwsQ0FBMEIsT0FBTyxDQUFQLENBQTFCLENBQWpDO0FBQ0E7QUFDRCxFOzs7Ozs7Ozs7OzZCQVFELGlCLDhCQUFrQixLLEVBQU87QUFDeEIsTUFBSSxLQUFLLFVBQUwsSUFBbUIsQ0FBQyxLQUFLLFVBQUwsQ0FBZ0IsS0FBaEIsQ0FBeEIsRUFBZ0Q7QUFDL0MsVUFBTyxLQUFQO0FBQ0E7QUFDRCxNQUFJLEtBQUssVUFBTCxDQUFnQixLQUFoQixDQUFKLEVBQTRCO0FBQzNCLFVBQU8sS0FBUDtBQUNBO0FBQ0QsU0FBTyxDQUFDLEtBQUssY0FBTCxDQUFvQixLQUFwQixDQUFSO0FBQ0EsRTs7Ozs7Ozs7NkJBTUQsVywwQkFBYztBQUNiLE9BQUssY0FBTCxDQUFvQixFQUFwQixDQUF1QixhQUF2QixFQUFzQyxLQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FBcUIsSUFBckIsQ0FBdEM7QUFDQSxFOzs7OztrQkFHYSxpQjs7O0FDdEtmOzs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBY00sVzs7O0FBQ0wsc0JBQVksT0FBWixFQUFxQixLQUFyQixFQUE0QixRQUE1QixFQUFzQztBQUFBOzs7Ozs7OztBQUFBLCtDQUNyQyxzQkFEcUM7O0FBUXJDLFFBQUssUUFBTCxHQUFnQixPQUFoQjs7Ozs7OztBQU9BLFFBQUssTUFBTCxHQUFjLEtBQWQ7Ozs7Ozs7QUFPQSxRQUFLLFNBQUwsR0FBaUIsUUFBakI7QUF0QnFDO0FBdUJyQzs7Ozs7Ozs7dUJBTUQsZSw4QkFBa0I7QUFDakIsT0FBSyxjQUFMO0FBQ0EsT0FBSyxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsT0FBSyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsRTs7Ozs7Ozt1QkFLRCxjLDZCQUFpQjtBQUNoQixNQUFJLENBQUMsS0FBSyxRQUFMLENBQWMsVUFBZCxFQUFMLEVBQWlDO0FBQ2hDLFFBQUssUUFBTCxDQUFjLGNBQWQsQ0FBNkIsS0FBSyxNQUFsQyxFQUEwQyxLQUFLLFNBQS9DO0FBQ0E7QUFDRCxFOzs7OztrQkFHYSxXOzs7QUM5RGY7Ozs7OztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7SUFRTSxZOzs7QUFDTCx5QkFBYztBQUFBOzs7Ozs7Ozs7QUFBQSwrQ0FDYixzQkFEYTs7QUFTYixRQUFLLGFBQUwsR0FBcUIsRUFBckI7QUFUYTtBQVViOzs7Ozs7Ozs7d0JBT0QsRyxrQkFBTTtBQUNMLE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxVQUFVLE1BQTlCLEVBQXNDLEdBQXRDLEVBQTJDO0FBQzFDLFFBQUssYUFBTCxDQUFtQixJQUFuQixDQUF3QixVQUFVLENBQVYsQ0FBeEI7QUFDQTtBQUNELEU7Ozs7Ozs7O3dCQU1ELGUsOEJBQWtCO0FBQ2pCLE9BQUssYUFBTCxHQUFxQixJQUFyQjtBQUNBLEU7Ozs7Ozs7d0JBS0Qsa0IsaUNBQXFCO0FBQ3BCLE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLGFBQUwsQ0FBbUIsTUFBdkMsRUFBK0MsR0FBL0MsRUFBb0Q7QUFDbkQsUUFBSyxhQUFMLENBQW1CLENBQW5CLEVBQXNCLGNBQXRCO0FBQ0E7O0FBRUQsT0FBSyxhQUFMLEdBQXFCLEVBQXJCO0FBQ0EsRTs7Ozs7a0JBR2EsWTs7O0FDdERmOzs7Ozs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7UUFHUyxZO1FBQWMsaUI7UUFBbUIsVztRQUFhLFk7OztBQ1J2RDs7Ozs7O0FBRUE7O0FBQ0E7Ozs7Ozs7O0lBS00saUI7Ozs7Ozs7Ozs7bUJBS0UsYyw2QkFBaUI7QUFDdkIsU0FBTyxRQUFRLENBQVIsQ0FBUDtBQUNBLEU7Ozs7Ozs7Ozs7Ozs7Ozs7bUJBY00saUIsOEJBQWtCLEcsRUFBSztBQUM3QixNQUFJLFlBQVksa0JBQWtCLGNBQWxCLEVBQWhCO0FBQ0EsUUFBTSxjQUFPLEdBQVAsQ0FBVyxHQUFYLEVBQWdCLFVBQUMsSUFBRCxFQUFPLEtBQVA7QUFBQSxVQUFpQixNQUFNLElBQU4sQ0FBVyxJQUFYLEVBQWlCLFVBQVUsSUFBVixDQUFqQixDQUFqQjtBQUFBLEdBQWhCLENBQU47QUFDQSxVQUFRLElBQVIsQ0FBYSxjQUFPLEtBQVAsQ0FBYSxFQUFiLEVBQWlCLFNBQWpCLEVBQTRCLEdBQTVCLEVBQWlDO0FBQzdDLFNBQU0sTUFEdUM7QUFFN0MsbUJBQWdCLFNBRjZCO0FBRzdDLHFCQUFrQixXQUgyQjtBQUk3QyxnQkFBYTtBQUpnQyxHQUFqQyxDQUFiO0FBTUEsRTs7Ozs7Ozs7bUJBTU0sZ0IsK0JBQW1CO0FBQ3pCLE1BQUksUUFBUSxNQUFSLEdBQWlCLENBQXJCLEVBQXdCO0FBQ3ZCLFdBQVEsR0FBUjtBQUNBO0FBQ0QsRTs7Ozs7QUFHRixJQUFJLFVBQVUsQ0FBQztBQUNkLE9BQU0sZUFBZSxJQURQO0FBRWQsYUFBWSxlQUFlLFVBQWYsQ0FBMEIsZUFBZSxPQUFmLENBQXVCLE9BQWpELENBRkU7QUFHZCxlQUFjLGVBQWUsWUFIZjtBQUlkLGNBQWEsZUFBZSxXQUpkO0FBS2QsaUJBQWdCLGVBQWUsY0FMakI7QUFNZCxtQkFBa0IsZUFBZSxnQkFObkI7QUFPZCxjQUFhLGVBQWUsV0FQZDtBQVFkLE9BQU0sZUFBZTtBQVJQLENBQUQsQ0FBZDs7QUFXQSxJQUFJLGdCQUFnQixFQUFwQjs7QUFFQSxTQUFTLE1BQVQsQ0FBZ0IsSUFBaEIsRUFBc0IsS0FBdEIsRUFBNkI7QUFDNUIsZUFBYyxJQUFkLENBQW1CLElBQW5CLEVBQXlCLEtBQXpCO0FBQ0E7O0FBRUQsU0FBUyxXQUFULENBQXFCLEdBQXJCLEVBQTBCLEdBQTFCLEVBQStCLE9BQS9CLEVBQXdDO0FBQ3ZDLGlCQUFnQixDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsT0FBWCxDQUFoQjtBQUNBOztBQUVELFNBQVMsU0FBVCxHQUFxQjtBQUNwQixRQUFPLE1BQU0sYUFBTixFQUFxQixLQUFyQixDQUEyQixJQUEzQixFQUFpQyxhQUFqQyxDQUFQO0FBQ0E7O0FBRUQsU0FBUyxNQUFULENBQWdCLEdBQWhCLEVBQXFCO0FBQ3BCLE9BQU0sYUFBTixFQUFxQixLQUFyQixDQUEyQixJQUEzQixFQUFpQyxTQUFqQztBQUNBLFFBQU8sTUFBTSxjQUFOLEVBQXNCLEdBQXRCLENBQVA7QUFDQTs7QUFFRCxTQUFTLEtBQVQsQ0FBZSxJQUFmLEVBQXFCO0FBQ3BCLFFBQU8sUUFBUSxRQUFRLE1BQVIsR0FBaUIsQ0FBekIsRUFBNEIsSUFBNUIsQ0FBUDtBQUNBOztBQUVELFNBQVMsVUFBVCxDQUFvQixJQUFwQixFQUEwQjtBQUN6QixRQUFPLE1BQU0sSUFBTixFQUFZLEtBQVosQ0FBa0IsSUFBbEIsRUFBd0IsYUFBTSxLQUFOLENBQVksU0FBWixFQUF1QixDQUF2QixDQUF4QixDQUFQO0FBQ0E7O0FBRUQsZUFBZSxJQUFmLEdBQXNCLFdBQVcsSUFBWCxDQUFnQixJQUFoQixFQUFzQixNQUF0QixDQUF0QjtBQUNBLGVBQWUsWUFBZixHQUE4QixXQUFXLElBQVgsQ0FBZ0IsSUFBaEIsRUFBc0IsY0FBdEIsQ0FBOUI7QUFDQSxlQUFlLFdBQWYsR0FBNkIsV0FBVyxJQUFYLENBQWdCLElBQWhCLEVBQXNCLGFBQXRCLENBQTdCO0FBQ0EsZUFBZSxjQUFmLEdBQWdDLFdBQVcsSUFBWCxDQUFnQixJQUFoQixFQUFzQixnQkFBdEIsQ0FBaEM7QUFDQSxlQUFlLGdCQUFmLEdBQWtDLFdBQVcsSUFBWCxDQUFnQixJQUFoQixFQUFzQixrQkFBdEIsQ0FBbEM7QUFDQSxlQUFlLFdBQWYsR0FBNkIsV0FBVyxJQUFYLENBQWdCLElBQWhCLEVBQXNCLGFBQXRCLENBQTdCO0FBQ0EsZUFBZSxJQUFmLEdBQXNCLFdBQVcsSUFBWCxDQUFnQixJQUFoQixFQUFzQixNQUF0QixDQUF0Qjs7QUFFQSxlQUFlLFVBQWYsQ0FBMEIsZUFBZSxPQUFmLENBQXVCLE9BQWpELElBQTRELFdBQVcsSUFBWCxDQUMzRCxJQUQyRCxFQUUzRCxZQUYyRCxDQUE1RDs7a0JBS2UsaUI7OztBQ3RHZjs7Ozs7O0FBRUE7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztJQUtNLHNCOzs7Ozs7O0FBSUwsaUNBQVksSUFBWixFQUFrQjtBQUFBOztBQUFBLCtDQUNqQiw4QkFBTSxJQUFOLENBRGlCOztBQUdqQixRQUFLLFFBQUwsR0FBZ0IsRUFBaEI7QUFDQSxRQUFLLGdCQUFMLEdBQXdCLCtCQUFvQixJQUFwQixDQUF4QjtBQUNBLE9BQUssRUFBTCxDQUFRLGlCQUFSLEVBQTJCLE1BQUssc0JBQUwsQ0FBNEIsSUFBNUIsT0FBM0I7QUFDQSxPQUFLLEVBQUwsQ0FBUSxVQUFSLEVBQW9CLE1BQUssZUFBTCxDQUFxQixJQUFyQixPQUFwQjs7OztBQUlBLFFBQUssZ0NBQUwsR0FDQyxNQUFLLGdDQUFMLENBQXNDLElBQXRDLE9BREQ7QUFFQSxRQUFLLDBCQUFMLEdBQ0MsTUFBSywwQkFBTCxDQUFnQyxJQUFoQyxPQUREO0FBRUEsUUFBSyxtQ0FBTCxHQUNDLE1BQUssbUNBQUwsQ0FBeUMsSUFBekMsT0FERDtBQUVBLFFBQUssa0NBQUwsR0FDQyxNQUFLLGtDQUFMLENBQXdDLElBQXhDLE9BREQ7QUFFQSxRQUFLLGtDQUFMLEdBQ0MsTUFBSyxrQ0FBTCxDQUF3QyxJQUF4QyxPQUREO0FBRUEsUUFBSyxrQkFBTCxHQUEwQixNQUFLLGtCQUFMLENBQXdCLElBQXhCLE9BQTFCO0FBcEJpQjtBQXFCakI7Ozs7Ozs7OztrQ0FPRCxtQixnQ0FBb0IsUyxFQUFXO0FBQzlCLE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxVQUFVLE1BQTlCLEVBQXNDLEtBQUssQ0FBM0MsRUFBOEM7QUFDN0MsT0FBSSxPQUFPLFVBQVUsQ0FBVixDQUFYO0FBQ0EsT0FBSSxLQUFLLFVBQVUsSUFBSSxDQUFkLENBQVQ7QUFDQSxPQUFJLEtBQUssVUFBTCxDQUFnQixTQUFoQixLQUE4QixZQUFLLFFBQUwsQ0FBYyxFQUFkLENBQWxDLEVBQXFEO0FBQ3BELFNBQUssa0JBQUwsQ0FBd0IsSUFBeEIsQ0FBNkI7QUFDNUIsZ0JBQVcsS0FBSyxNQUFMLENBQVksQ0FBWixDQURpQjtBQUU1QjtBQUY0QixLQUE3QjtBQUlBO0FBQ0Q7QUFDRCxFOzs7Ozs7Ozs7a0NBT0Qsc0IscUNBQXlCO0FBQ3hCLE9BQUssZ0JBQUwsQ0FBc0IsZUFBdEI7QUFDQSxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxrQkFBTCxDQUF3QixNQUE1QyxFQUFvRCxHQUFwRCxFQUF5RDtBQUN4RCxPQUFJLFdBQVcsS0FBSyxrQkFBTCxDQUF3QixDQUF4QixDQUFmO0FBQ0EsUUFBSyxnQkFBTCxDQUFzQixjQUF0QixDQUFxQyxTQUFTLFNBQTlDLEVBQXlELFNBQVMsRUFBbEU7QUFDQTtBQUNELEU7Ozs7Ozs7Ozs7O2tDQVNELGdCLDZCQUFpQixLLEVBQU87QUFBQTs7QUFDdkIsU0FBTyxZQUFNO0FBQ1osVUFBSyxVQUFMO0FBQ0EsUUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE1BQU0sTUFBMUIsRUFBa0MsR0FBbEMsRUFBdUM7QUFDdEMsbUJBQWUsTUFBTSxDQUFOLEVBQVMsSUFBeEIsRUFBOEIsS0FBOUIsQ0FBb0MsSUFBcEMsRUFBMEMsYUFBTSxLQUFOLENBQVksTUFBTSxDQUFOLEVBQVMsSUFBckIsRUFBMkIsQ0FBM0IsQ0FBMUM7QUFDQTtBQUNELCtCQUFrQixnQkFBbEI7QUFDQSxHQU5EO0FBT0EsRTs7Ozs7Ozs7a0NBTUQsMkIsMENBQThCO0FBQzdCLE1BQUksT0FBTyxPQUFPLElBQVAsQ0FBWSxLQUFLLFVBQUwsQ0FBZ0IsVUFBNUIsQ0FBWDtBQUNBLE1BQUksU0FBUyxFQUFiO0FBQ0EsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssTUFBekIsRUFBaUMsR0FBakMsRUFBc0M7QUFDckMsT0FBSSxDQUFDLEtBQUssbUJBQUwsQ0FBeUIsS0FBSyxDQUFMLENBQXpCLENBQUwsRUFBd0M7QUFDdkMsV0FBTyxJQUFQLENBQVksS0FBSyxDQUFMLENBQVo7QUFDQTtBQUNEO0FBQ0QsT0FBSyxVQUFMLENBQWdCLG9CQUFoQixDQUFxQyxNQUFyQztBQUNBLEU7Ozs7Ozs7Ozs7Ozs7a0NBV0QsZ0IsNkJBQWlCLEcsRUFBSyxTLEVBQVcsTSxFQUFRO0FBQ3hDLE1BQUksT0FBTyxLQUFLLFVBQUwsQ0FBZ0IsZUFBaEIsQ0FBZ0MsR0FBaEMsRUFBcUMsU0FBckMsRUFBZ0QsTUFBaEQsQ0FBWDtBQUNBLE1BQUksS0FBSyxXQUFULEVBQXNCO0FBQ3JCLFFBQUssUUFBTCxDQUFjLE1BQWQ7QUFDQTtBQUNELFNBQU8sSUFBUDtBQUNBLEU7Ozs7Ozs7Ozs7O2tDQVNELGdCLCtCQUFtQjtBQUNsQixNQUFJLFVBQVUsS0FBSyxVQUFMLENBQWdCLE9BQTlCO0FBQ0EsTUFBSSxDQUFDLE9BQUQsSUFBWSxDQUFDLFFBQVEsVUFBekIsRUFBcUM7QUFDcEMsT0FBSSxTQUFTLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUFiO0FBQ0EsT0FBSSxPQUFKLEVBQWE7QUFDWixrQkFBSSxNQUFKLENBQVcsTUFBWCxFQUFtQixPQUFuQjtBQUNBO0FBQ0QsVUFBTyxNQUFQO0FBQ0E7QUFDRCxFOzs7Ozs7OztrQ0FNRCxlLDhCQUFrQjtBQUNqQixPQUFLLGdCQUFMLENBQXNCLGtCQUF0QjtBQUNBLEU7Ozs7Ozs7Ozs7Ozs7a0NBV0QsZ0MsNkNBQWlDLFUsRUFBWSxPLEVBQVMsSSxFQUFNLEssRUFBTztBQUNsRSxNQUFJLEtBQUssVUFBTCxDQUFnQixTQUFoQixDQUFKLEVBQWdDO0FBQy9CLE9BQUksWUFBWSxLQUFLLE1BQUwsQ0FBWSxDQUFaLENBQWhCO0FBQ0EsT0FBSSxZQUFLLFVBQUwsQ0FBZ0IsUUFBUSxJQUFSLENBQWhCLENBQUosRUFBb0M7QUFDbkMsWUFBUSxtQkFBUixDQUE0QixTQUE1QixFQUF1QyxRQUFRLElBQVIsQ0FBdkM7QUFDQTtBQUNELE9BQUksWUFBSyxVQUFMLENBQWdCLEtBQWhCLENBQUosRUFBNEI7QUFDM0Isa0JBQUksRUFBSixDQUFPLE9BQVAsRUFBZ0IsU0FBaEIsRUFBMkIsS0FBM0I7QUFDQTtBQUNELEdBUkQsTUFRTyxJQUFJLFNBQVMsU0FBYixFQUF3Qjs7Ozs7QUFLOUIsV0FBUSxPQUFSLEdBQWtCLFlBQUssZUFBTCxDQUFxQixLQUFyQixLQUErQixVQUFVLEtBQTNEO0FBQ0E7QUFDRCxhQUFXLE9BQVgsRUFBb0IsSUFBcEIsRUFBMEIsS0FBMUI7QUFDQSxFOzs7Ozs7Ozs7OztrQ0FTRCxtQyxnREFBb0MsVSxFQUFZLE8sRUFBUztBQUN4RCxNQUFJLEtBQUssc0JBQUwsQ0FBNEIsT0FBNUIsS0FDRixFQUFFLEtBQUssa0JBQUwsQ0FBd0IsU0FBMUIsS0FBd0MsQ0FEMUMsRUFDNkM7QUFBQSw2QkFFakIsS0FBSyxrQkFGWTtBQUFBLE9BRXZDLEtBRnVDLHVCQUV2QyxLQUZ1QztBQUFBLE9BRWhDLE1BRmdDLHVCQUVoQyxNQUZnQztBQUFBLE9BRXhCLEdBRndCLHVCQUV4QixHQUZ3Qjs7QUFHNUMsVUFBTyxRQUFQLEdBQWtCLEtBQUssZ0JBQUwsQ0FBc0IsS0FBdEIsQ0FBbEI7QUFDQSxRQUFLLGtCQUFMLEdBQTBCLElBQTFCO0FBQ0EsK0JBQWtCLGdCQUFsQjtBQUNBLFVBQU8sS0FBSyxtQkFBTCxDQUF5QixHQUF6QixFQUE4QixNQUE5QixFQUFzQyxPQUE3QztBQUNBO0FBQ0QsT0FBSyxrQkFBTCxDQUF3QixLQUF4QixDQUE4QixJQUE5QixDQUFtQztBQUNsQyxTQUFNLGNBRDRCO0FBRWxDLFNBQU07QUFGNEIsR0FBbkM7QUFJQSxFOzs7Ozs7Ozs7OztrQ0FTRCxrQywrQ0FBbUMsVSxFQUFZLEcsRUFBSztBQUNuRCxNQUFJLEtBQUssc0JBQUwsQ0FBNEIsR0FBNUIsQ0FBSixFQUFzQztBQUNyQyxRQUFLLGtCQUFMLENBQXdCLFNBQXhCO0FBQ0E7QUFDRCxPQUFLLGtCQUFMLENBQXdCLEtBQXhCLENBQThCLElBQTlCLENBQW1DO0FBQ2xDLFNBQU0sYUFENEI7QUFFbEMsU0FBTTtBQUY0QixHQUFuQztBQUlBLEU7Ozs7Ozs7OztrQ0FPRCxrQyxpREFBcUM7QUFDcEMsT0FBSyxrQkFBTCxDQUF3QixLQUF4QixDQUE4QixJQUE5QixDQUFtQztBQUNsQyxTQUFNLE1BRDRCO0FBRWxDLFNBQU07QUFGNEIsR0FBbkM7QUFJQSxFOzs7Ozs7Ozs7OztrQ0FTRCwwQix1Q0FBMkIsVSxFQUFZLEcsRUFBSztBQUMzQyxNQUFJLEtBQUssZUFBTCxDQUFxQixHQUFyQixDQUFKLEVBQStCO0FBQzlCLFVBQU8sS0FBSyx1QkFBTCxDQUE2QixLQUE3QixDQUFtQyxJQUFuQyxFQUF5QyxTQUF6QyxDQUFQO0FBQ0EsR0FGRCxNQUVPO0FBQ04sVUFBTyxLQUFLLGtCQUFMLENBQXdCLEtBQXhCLENBQThCLElBQTlCLEVBQW9DLFNBQXBDLENBQVA7QUFDQTtBQUNELEU7Ozs7Ozs7Ozs7Ozs7O2tDQVlELGtCLCtCQUFtQixVLEVBQVksRyxFQUFLLEcsRUFBSyxPLEVBQVM7QUFDakQsTUFBSSxXQUFXLGFBQU0sS0FBTixDQUFZLFNBQVosRUFBdUIsQ0FBdkIsQ0FBZjtBQUNBLE9BQUssbUJBQUwsQ0FBeUIsQ0FBQyxXQUFXLEVBQVosRUFBZ0IsTUFBaEIsQ0FBdUIsUUFBdkIsQ0FBekI7QUFDQSxNQUFJLE9BQU8sYUFBTSxLQUFOLENBQVksU0FBWixFQUF1QixDQUF2QixDQUFYO0FBQ0EsTUFBSSxDQUFDLEtBQUssbUJBQU4sSUFBNkIsS0FBSyxVQUFMLENBQWdCLE1BQWhCLENBQXVCLEdBQXhELEVBQTZEO0FBQzVELFFBQUssQ0FBTCxJQUFVLEtBQUssVUFBTCxDQUFnQixNQUFoQixDQUF1QixHQUFqQztBQUNBO0FBQ0QsTUFBSSxPQUFPLFdBQVcsS0FBWCxDQUFpQixJQUFqQixFQUF1QixJQUF2QixDQUFYO0FBQ0EsTUFBSSxDQUFDLEtBQUssbUJBQVYsRUFBK0I7QUFDOUIsUUFBSyxtQkFBTCxHQUEyQixJQUEzQjtBQUNBLE9BQUksS0FBSyxVQUFMLENBQWdCLE9BQWhCLEtBQTRCLElBQWhDLEVBQXNDO0FBQ3JDLFNBQUssVUFBTCxDQUFnQixPQUFoQixHQUEwQixJQUExQjtBQUNBO0FBQ0Q7QUFDRCxTQUFPLElBQVA7QUFDQSxFOzs7Ozs7Ozs7OztrQ0FTRCxzQixtQ0FBdUIsSSxFQUFNO0FBQzVCLE1BQUksS0FBSyxHQUFMLEtBQWEsU0FBakIsRUFBNEI7QUFDM0IsUUFBSyxRQUFMLENBQWMsS0FBSyxHQUFuQixJQUEwQixJQUExQjtBQUNBO0FBQ0QsRTs7Ozs7Ozs7Ozs7Ozs7a0NBWUQsdUIsb0NBQXdCLFUsRUFBWSxHLEVBQUssRyxFQUFLLE8sRUFBUztBQUN0RCxNQUFJLFNBQVMsRUFBQyxRQUFELEVBQWI7QUFDQSxNQUFJLFdBQVcsQ0FBQyxXQUFXLEVBQVosRUFBZ0IsTUFBaEIsQ0FBdUIsYUFBTSxLQUFOLENBQVksU0FBWixFQUF1QixDQUF2QixDQUF2QixDQUFmO0FBQ0EsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFNBQVMsTUFBN0IsRUFBcUMsS0FBSyxDQUExQyxFQUE2QztBQUM1QyxVQUFPLFNBQVMsQ0FBVCxDQUFQLElBQXNCLFNBQVMsSUFBSSxDQUFiLENBQXRCO0FBQ0E7O0FBRUQsT0FBSyxrQkFBTCxHQUEwQjtBQUN6QixVQUFPLEVBRGtCO0FBRXpCLGlCQUZ5QjtBQUd6QixXQUh5QjtBQUl6QixjQUFXO0FBSmMsR0FBMUI7QUFNQSw4QkFBa0IsaUJBQWxCLENBQW9DO0FBQ25DLGlCQUFjLEtBQUssbUNBRGdCO0FBRW5DLGdCQUFhLEtBQUssa0NBRmlCO0FBR25DLFNBQU0sS0FBSztBQUh3QixHQUFwQztBQUtBLEU7Ozs7Ozs7O2tDQU1ELFUseUJBQWE7QUFDWiw4QkFBa0IsaUJBQWxCLENBQW9DO0FBQ25DLGVBQVksS0FBSyxnQ0FEa0I7QUFFbkMsZ0JBQWEsS0FBSztBQUZpQixHQUFwQztBQUlBLEU7Ozs7Ozs7OztrQ0FPRCxlLDRCQUFnQixHLEVBQUs7QUFDcEIsU0FBTyxDQUFDLFlBQUssUUFBTCxDQUFjLEdBQWQsQ0FBRCxJQUF1QixJQUFJLENBQUosTUFBVyxJQUFJLENBQUosRUFBTyxXQUFQLEVBQXpDO0FBQ0EsRTs7Ozs7Ozs7OztrQ0FRRCxzQixtQ0FBdUIsRyxFQUFLO0FBQzNCLFNBQU8sS0FBSyxlQUFMLENBQXFCLEdBQXJCLEtBQTZCLEtBQUssa0JBQUwsQ0FBd0IsR0FBeEIsS0FBZ0MsR0FBcEU7QUFDQSxFOzs7Ozs7OztrQ0FNRCxNLHFCQUFTO0FBQ1IsT0FBSyxLQUFMO0FBQ0EsRTs7Ozs7Ozs7O2tDQU9ELFksMkJBQWU7QUFDZCxpQkFBZSxXQUFmLENBQTJCLEtBQTNCO0FBQ0EsRTs7Ozs7Ozs7O2tDQU9ELGtCLGlDQUFxQjs7O0FBR3BCLE9BQUssUUFBTCxHQUFnQixFQUFoQjs7QUFFQSxPQUFLLG1CQUFMLEdBQTJCLEtBQTNCO0FBQ0EsT0FBSyxtQkFBTCxHQUEyQixFQUEzQjtBQUNBLE9BQUssa0JBQUwsR0FBMEIsQ0FBMUI7QUFDQSxPQUFLLGtCQUFMLEdBQTBCLEVBQTFCO0FBQ0EsT0FBSyxVQUFMO0FBQ0EsT0FBSyxZQUFMO0FBQ0EsOEJBQWtCLGdCQUFsQjtBQUNBLE9BQUssc0JBQUw7QUFDQSxFOzs7Ozs7Ozs7OztrQ0FTRCxZLDJCQUFlO0FBQ2QsU0FBTyxJQUFQO0FBQ0EsRTs7Ozs7Ozs7a0NBTUQsSyxvQkFBUTtBQUNQLE1BQUksYUFBYSxLQUFLLGdCQUFMLEVBQWpCO0FBQ0EsTUFBSSxVQUFKLEVBQWdCO0FBQ2Ysa0JBQWUsS0FBZixDQUFxQixVQUFyQixFQUFpQyxLQUFLLGtCQUF0QztBQUNBLGlCQUFJLFlBQUosQ0FBaUIsS0FBSyxVQUFMLENBQWdCLE9BQWpDO0FBQ0EsR0FIRCxNQUdPO0FBQ04sa0JBQWUsVUFBZixDQUEwQixLQUFLLFVBQUwsQ0FBZ0IsT0FBMUMsRUFBbUQsS0FBSyxrQkFBeEQ7QUFDQTtBQUNELEU7Ozs7Ozs7O2tDQU1ELE0scUJBQVM7QUFDUixNQUFJLGNBQWMsT0FBTyxJQUFQLENBQVksS0FBSyxRQUFqQixDQUFsQjtBQUNBLE1BQUksWUFBWSxNQUFaLEdBQXFCLENBQXJCLElBQTBCLEtBQUssWUFBTCxDQUFrQixLQUFLLFFBQXZCLENBQTlCLEVBQWdFO0FBQy9ELFFBQUssS0FBTDtBQUNBLFFBQUssZ0JBQUwsQ0FBc0IscUJBQXRCO0FBQ0EsUUFBSywyQkFBTDtBQUNBO0FBQ0QsRTs7Ozs7Ozs7Ozs7Ozs7a0NBWUQsbUIsZ0NBQW9CLFMsRUFBVyxNLEVBQVE7QUFDdEMsTUFBSSxNQUFNLE9BQU8sR0FBUCxJQUFlLFFBQVEsS0FBSyxrQkFBTCxFQUFqQztBQUNBLE1BQUksT0FBTyxLQUFLLGdCQUFMLENBQXNCLEdBQXRCLEVBQTJCLFNBQTNCLEVBQXNDLE1BQXRDLENBQVg7QUFDQSxNQUFJLFdBQVcsS0FBSyxXQUFMLEVBQWY7QUFDQSxNQUFJLG9CQUFvQixzQkFBeEIsRUFBZ0Q7QUFDL0MsWUFBUyxrQkFBVDtBQUNBLEdBRkQsTUFFTztBQUNOLFdBQVEsSUFBUixDQUNDLHNFQUNBLHVEQUZELEVBR0MsSUFIRDtBQUtBO0FBQ0QsTUFBSSxDQUFDLEtBQUssV0FBVixFQUF1QjtBQUN0QixRQUFLLG9CQUFMO0FBQ0E7QUFDRCxPQUFLLG1CQUFMLENBQXlCLEdBQXpCLElBQWdDLElBQWhDO0FBQ0EsU0FBTyxJQUFQO0FBQ0EsRTs7Ozs7a0JBR2Esc0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMWFkLFdBQVUsTUFBVixFQUFrQixPQUFsQixFQUEyQjtBQUN6QixVQUFTLE9BQU8sY0FBUCxHQUF3QixPQUFPLGNBQVAsSUFBeUIsRUFBMUQsQ0FBRDtBQUNELENBRkEsRUFFQyxNQUZELEVBRVMsVUFBVSxPQUFWLEVBQW1CO0FBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQjdCLE1BQUksaUJBQWlCLE9BQU8sU0FBUCxDQUFpQixjQUF0Qzs7Ozs7QUFLQSxNQUFJLFNBQVMsT0FBTyxNQUFwQjs7Ozs7Ozs7QUFRQSxNQUFJLE1BQU0sU0FBTixHQUFNLENBQVUsR0FBVixFQUFlLFFBQWYsRUFBeUI7QUFDakMsV0FBTyxlQUFlLElBQWYsQ0FBb0IsR0FBcEIsRUFBeUIsUUFBekIsQ0FBUDtBQUNELEdBRkQ7Ozs7OztBQVFBLE1BQUksWUFBWSxTQUFaLFNBQVksR0FBWTtBQUMxQixXQUFPLE9BQU8sSUFBUCxDQUFQO0FBQ0QsR0FGRDs7Ozs7Ozs7QUFVQSxXQUFTLFFBQVQsQ0FBa0IsUUFBbEIsRUFBNEIsR0FBNUIsRUFBaUM7Ozs7O0FBSy9CLFNBQUssS0FBTCxHQUFhLFdBQWI7Ozs7Ozs7O0FBUUEsU0FBSyxRQUFMLEdBQWdCLEVBQWhCOzs7Ozs7QUFNQSxTQUFLLFFBQUwsR0FBZ0IsV0FBaEI7Ozs7Ozs7QUFPQSxTQUFLLEdBQUwsR0FBVyxHQUFYOzs7Ozs7QUFNQSxTQUFLLE1BQUwsR0FBYyxJQUFkOzs7Ozs7QUFNQSxTQUFLLFdBQUwsR0FBbUIsSUFBbkI7Ozs7OztBQU1BLFNBQUssUUFBTCxHQUFnQixRQUFoQjs7Ozs7QUFLQSxTQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0Q7Ozs7Ozs7Ozs7QUFVRCxNQUFJLFdBQVcsU0FBWCxRQUFXLENBQVUsSUFBVixFQUFnQixRQUFoQixFQUEwQixHQUExQixFQUErQjtBQUM1QyxRQUFJLE9BQU8sSUFBSSxRQUFKLENBQWEsUUFBYixFQUF1QixHQUF2QixDQUFYO0FBQ0EsU0FBSyxzQkFBTCxJQUErQixJQUEvQjtBQUNBLFdBQU8sSUFBUDtBQUNELEdBSkQ7Ozs7Ozs7O0FBWUEsTUFBSSxVQUFVLFNBQVYsT0FBVSxDQUFVLElBQVYsRUFBZ0I7QUFDNUIsUUFBSSxPQUFPLEtBQUssc0JBQUwsQ0FBWDs7QUFFQSxRQUFJLENBQUMsSUFBTCxFQUFXO0FBQ1QsVUFBSSxXQUFXLEtBQUssUUFBTCxDQUFjLFdBQWQsRUFBZjtBQUNBLFVBQUksTUFBTSxJQUFWOztBQUVBLFVBQUksZ0JBQWdCLE9BQXBCLEVBQTZCO0FBQzNCLGNBQU0sS0FBSyxZQUFMLENBQWtCLEtBQWxCLENBQU47QUFDRDs7QUFFRCxhQUFPLFNBQVMsSUFBVCxFQUFlLFFBQWYsRUFBeUIsR0FBekIsQ0FBUDtBQUNEOztBQUVELFdBQU8sSUFBUDtBQUNELEdBZkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQ0EsTUFBSSxVQUFVO0FBQ1osYUFBUyxXQURHOztBQUdaLGlCQUFhO0FBSEQsR0FBZDs7Ozs7O0FBVUEsTUFBSSxlQUFlLFNBQWYsWUFBZSxDQUFVLElBQVYsRUFBZ0I7QUFDakMsUUFBSSxLQUFLLFdBQUwsQ0FBaUIsTUFBakIsRUFBeUIsQ0FBekIsTUFBZ0MsQ0FBcEMsRUFBdUM7QUFDckMsYUFBTyxzQ0FBUDtBQUNEOztBQUVELFFBQUksS0FBSyxXQUFMLENBQWlCLFFBQWpCLEVBQTJCLENBQTNCLE1BQWtDLENBQXRDLEVBQXlDO0FBQ3ZDLGFBQU8sOEJBQVA7QUFDRDtBQUNGLEdBUkQ7Ozs7Ozs7Ozs7QUFrQkEsTUFBSSxZQUFZLFNBQVosU0FBWSxDQUFVLEVBQVYsRUFBYyxJQUFkLEVBQW9CLEtBQXBCLEVBQTJCO0FBQ3pDLFFBQUksU0FBUyxJQUFiLEVBQW1CO0FBQ2pCLFNBQUcsZUFBSCxDQUFtQixJQUFuQjtBQUNELEtBRkQsTUFFTztBQUNMLFVBQUksU0FBUyxhQUFhLElBQWIsQ0FBYjtBQUNBLFVBQUksTUFBSixFQUFZO0FBQ1YsV0FBRyxjQUFILENBQWtCLE1BQWxCLEVBQTBCLElBQTFCLEVBQWdDLEtBQWhDO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsV0FBRyxZQUFILENBQWdCLElBQWhCLEVBQXNCLEtBQXRCO0FBQ0Q7QUFDRjtBQUNGLEdBWEQ7Ozs7Ozs7O0FBbUJBLE1BQUksWUFBWSxTQUFaLFNBQVksQ0FBVSxFQUFWLEVBQWMsSUFBZCxFQUFvQixLQUFwQixFQUEyQjtBQUN6QyxPQUFHLElBQUgsSUFBVyxLQUFYO0FBQ0QsR0FGRDs7Ozs7Ozs7OztBQVlBLE1BQUksYUFBYSxTQUFiLFVBQWEsQ0FBVSxFQUFWLEVBQWMsSUFBZCxFQUFvQixLQUFwQixFQUEyQjtBQUMxQyxRQUFJLE9BQU8sS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QixTQUFHLEtBQUgsQ0FBUyxPQUFULEdBQW1CLEtBQW5CO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsU0FBRyxLQUFILENBQVMsT0FBVCxHQUFtQixFQUFuQjtBQUNBLFVBQUksVUFBVSxHQUFHLEtBQWpCO0FBQ0EsVUFBSSxNLHFDQUEyQyxLQUEvQzs7QUFFQSxXQUFLLElBQUksSUFBVCxJQUFpQixHQUFqQixFQUFzQjtBQUNwQixZQUFJLElBQUksR0FBSixFQUFTLElBQVQsQ0FBSixFQUFvQjtBQUNsQixrQkFBUSxJQUFSLElBQWdCLElBQUksSUFBSixDQUFoQjtBQUNEO0FBQ0Y7QUFDRjtBQUNGLEdBZEQ7Ozs7Ozs7Ozs7QUF3QkEsTUFBSSxzQkFBc0IsU0FBdEIsbUJBQXNCLENBQVUsRUFBVixFQUFjLElBQWQsRUFBb0IsS0FBcEIsRUFBMkI7QUFDbkQsUUFBSSxjQUFjLEtBQWQseUNBQWMsS0FBZCxDQUFKOztBQUVBLFFBQUksU0FBUyxRQUFULElBQXFCLFNBQVMsVUFBbEMsRUFBOEM7QUFDNUMsZ0JBQVUsRUFBVixFQUFjLElBQWQsRUFBb0IsS0FBcEI7QUFDRCxLQUZELE1BRU87QUFDTCxnQkFBVSxFQUFWLEVBQWMsSUFBZCxFLHVDQUEyRCxLQUEzRDtBQUNEO0FBQ0YsR0FSRDs7Ozs7Ozs7QUFnQkEsTUFBSSxrQkFBa0IsU0FBbEIsZUFBa0IsQ0FBVSxFQUFWLEVBQWMsSUFBZCxFQUFvQixLQUFwQixFQUEyQjtBQUMvQyxRQUFJLE9BQU8sUUFBUSxFQUFSLENBQVg7QUFDQSxRQUFJLFFBQVEsS0FBSyxLQUFqQjs7QUFFQSxRQUFJLE1BQU0sSUFBTixNQUFnQixLQUFwQixFQUEyQjtBQUN6QjtBQUNEOztBQUVELFFBQUksVUFBVSxXQUFXLElBQVgsS0FBb0IsV0FBVyxRQUFRLE9BQW5CLENBQWxDO0FBQ0EsWUFBUSxFQUFSLEVBQVksSUFBWixFQUFrQixLQUFsQjs7QUFFQSxVQUFNLElBQU4sSUFBYyxLQUFkO0FBQ0QsR0FaRDs7Ozs7O0FBa0JBLE1BQUksYUFBYSxXQUFqQjs7OztBQUlBLGFBQVcsUUFBUSxPQUFuQixJQUE4QixtQkFBOUI7O0FBRUEsYUFBVyxRQUFRLFdBQW5CLElBQWtDLFlBQVksQ0FBRSxDQUFoRDs7QUFFQSxhQUFXLE9BQVgsSUFBc0IsVUFBdEI7Ozs7Ozs7O0FBUUEsTUFBSSxxQkFBcUIsU0FBckIsa0JBQXFCLENBQVUsR0FBVixFQUFlLE1BQWYsRUFBdUI7QUFDOUMsUUFBSSxRQUFRLEtBQVosRUFBbUI7QUFDakIsYUFBTyw0QkFBUDtBQUNEOztBQUVELFFBQUksUUFBUSxNQUFSLEVBQWdCLFFBQWhCLEtBQTZCLGVBQWpDLEVBQWtEO0FBQ2hELGFBQU8sSUFBUDtBQUNEOztBQUVELFdBQU8sT0FBTyxZQUFkO0FBQ0QsR0FWRDs7Ozs7Ozs7Ozs7O0FBc0JBLE1BQUksZ0JBQWdCLFNBQWhCLGFBQWdCLENBQVUsR0FBVixFQUFlLE1BQWYsRUFBdUIsR0FBdkIsRUFBNEIsR0FBNUIsRUFBaUMsT0FBakMsRUFBMEM7QUFDNUQsUUFBSSxZQUFZLG1CQUFtQixHQUFuQixFQUF3QixNQUF4QixDQUFoQjtBQUNBLFFBQUksS0FBSyxTQUFUOztBQUVBLFFBQUksU0FBSixFQUFlO0FBQ2IsV0FBSyxJQUFJLGVBQUosQ0FBb0IsU0FBcEIsRUFBK0IsR0FBL0IsQ0FBTDtBQUNELEtBRkQsTUFFTztBQUNMLFdBQUssSUFBSSxhQUFKLENBQWtCLEdBQWxCLENBQUw7QUFDRDs7QUFFRCxhQUFTLEVBQVQsRUFBYSxHQUFiLEVBQWtCLEdBQWxCOztBQUVBLFFBQUksT0FBSixFQUFhO0FBQ1gsV0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFFBQVEsTUFBNUIsRUFBb0MsS0FBSyxDQUF6QyxFQUE0QztBQUMxQyx3QkFBZ0IsRUFBaEIsRSxxQkFBeUMsUUFBUSxDQUFSLENBQXpDLEVBQXFELFFBQVEsSUFBSSxDQUFaLENBQXJEO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPLEVBQVA7QUFDRCxHQW5CRDs7Ozs7OztBQTBCQSxNQUFJLGFBQWEsU0FBYixVQUFhLENBQVUsR0FBVixFQUFlO0FBQzlCLFFBQUksT0FBTyxJQUFJLGNBQUosQ0FBbUIsRUFBbkIsQ0FBWDtBQUNBLGFBQVMsSUFBVCxFQUFlLE9BQWYsRUFBd0IsSUFBeEI7QUFDQSxXQUFPLElBQVA7QUFDRCxHQUpEOzs7Ozs7OztBQVlBLE1BQUksZUFBZSxTQUFmLFlBQWUsQ0FBVSxFQUFWLEVBQWM7QUFDL0IsUUFBSSxNQUFNLFdBQVY7QUFDQSxRQUFJLFFBQVEsR0FBRyxpQkFBZjs7QUFFQSxXQUFPLEtBQVAsRUFBYztBQUNaLFVBQUksTUFBTSxRQUFRLEtBQVIsRUFBZSxHQUF6Qjs7QUFFQSxVQUFJLEdBQUosRUFBUztBQUNQLFlBQUksR0FBSixJQUFXLEtBQVg7QUFDRDs7QUFFRCxjQUFRLE1BQU0sa0JBQWQ7QUFDRDs7QUFFRCxXQUFPLEdBQVA7QUFDRCxHQWZEOzs7Ozs7OztBQXVCQSxNQUFJLFlBQVksU0FBWixTQUFZLENBQVUsRUFBVixFQUFjO0FBQzVCLFFBQUksT0FBTyxRQUFRLEVBQVIsQ0FBWDs7QUFFQSxRQUFJLENBQUMsS0FBSyxNQUFWLEVBQWtCO0FBQ2hCLFdBQUssTUFBTCxHQUFjLGFBQWEsRUFBYixDQUFkO0FBQ0Q7O0FBRUQsV0FBTyxLQUFLLE1BQVo7QUFDRCxHQVJEOzs7Ozs7OztBQWdCQSxNQUFJLFdBQVcsU0FBWCxRQUFXLENBQVUsTUFBVixFQUFrQixHQUFsQixFQUF1QjtBQUNwQyxXQUFPLE1BQU0sVUFBVSxNQUFWLEVBQWtCLEdBQWxCLENBQU4sR0FBK0IsSUFBdEM7QUFDRCxHQUZEOzs7Ozs7Ozs7O0FBWUEsTUFBSSxnQkFBZ0IsU0FBaEIsYUFBZ0IsQ0FBVSxNQUFWLEVBQWtCLEdBQWxCLEVBQXVCLEtBQXZCLEVBQThCO0FBQ2hELGNBQVUsTUFBVixFQUFrQixHQUFsQixJQUF5QixLQUF6QjtBQUNELEdBRkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkEsTUFBSSxnQkFBZ0I7Ozs7OztBQU1sQixrQkFBYyxJQU5JOzs7Ozs7OztBQWNsQixrQkFBYztBQWRJLEdBQXBCOzs7Ozs7QUFxQkEsV0FBUyxPQUFULEdBQW1COzs7O0FBSWpCLFNBQUssT0FBTCxHQUFlLGNBQWMsWUFBZCxJQUE4QixFQUE3Qzs7Ozs7QUFLQSxTQUFLLE9BQUwsR0FBZSxjQUFjLFlBQWQsSUFBOEIsRUFBN0M7QUFDRDs7Ozs7QUFLRCxVQUFRLFNBQVIsQ0FBa0IsV0FBbEIsR0FBZ0MsVUFBVSxJQUFWLEVBQWdCO0FBQzlDLFFBQUksS0FBSyxPQUFULEVBQWtCO0FBQ2hCLFdBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsSUFBbEI7QUFDRDtBQUNGLEdBSkQ7Ozs7O0FBU0EsVUFBUSxTQUFSLENBQWtCLFdBQWxCLEdBQWdDLFVBQVUsSUFBVixFQUFnQjtBQUM5QyxRQUFJLEtBQUssT0FBVCxFQUFrQjtBQUNoQixXQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLElBQWxCO0FBQ0Q7QUFDRixHQUpEOzs7OztBQVNBLFVBQVEsU0FBUixDQUFrQixhQUFsQixHQUFrQyxZQUFZO0FBQzVDLFFBQUksS0FBSyxPQUFMLElBQWdCLEtBQUssT0FBTCxDQUFhLE1BQWIsR0FBc0IsQ0FBMUMsRUFBNkM7QUFDM0Msb0JBQWMsWUFBZCxDQUEyQixLQUFLLE9BQWhDO0FBQ0Q7O0FBRUQsUUFBSSxLQUFLLE9BQUwsSUFBZ0IsS0FBSyxPQUFMLENBQWEsTUFBYixHQUFzQixDQUExQyxFQUE2QztBQUMzQyxvQkFBYyxZQUFkLENBQTJCLEtBQUssT0FBaEM7QUFDRDtBQUNGLEdBUkQ7Ozs7Ozs7O0FBZ0JBLE1BQUksd0JBQXdCLFNBQXhCLHFCQUF3QixDQUFVLFFBQVYsRUFBb0IsR0FBcEIsRUFBeUIsR0FBekIsRUFBOEI7QUFDeEQsUUFBSSxhQUFhLEdBQWpCLEVBQXNCO0FBQ3BCLFlBQU0sSUFBSSxLQUFKLENBQVUsa0NBQWtDLEdBQWxDLEdBQXdDLFlBQXhDLEdBQXVELEdBQXZELEdBQTZELFVBQTdELEdBQTBFLFFBQTFFLEdBQXFGLEdBQS9GLENBQU47QUFDRDtBQUNGLEdBSkQ7OztBQU9BLE1BQUksVUFBVSxJQUFkOzs7QUFHQSxNQUFJLGNBQWMsSUFBbEI7OztBQUdBLE1BQUksZ0JBQWdCLElBQXBCOzs7QUFHQSxNQUFJLE9BQU8sSUFBWDs7O0FBR0EsTUFBSSxNQUFNLElBQVY7Ozs7Ozs7OztBQVNBLE1BQUksZUFBZSxTQUFmLFlBQWUsQ0FBVSxHQUFWLEVBQWU7Ozs7Ozs7Ozs7QUFVaEMsUUFBSSxJQUFJLFNBQUosQ0FBSSxDQUFVLElBQVYsRUFBZ0IsRUFBaEIsRUFBb0IsSUFBcEIsRUFBMEI7QUFDaEMsVUFBSSxjQUFjLE9BQWxCO0FBQ0EsVUFBSSxXQUFXLElBQWY7QUFDQSxVQUFJLFVBQVUsR0FBZDtBQUNBLFVBQUksa0JBQWtCLFdBQXRCO0FBQ0EsVUFBSSxvQkFBb0IsYUFBeEI7QUFDQSxVQUFJLHVCQUF1QixLQUEzQjtBQUNBLFVBQUksaUJBQWlCLEtBQXJCOztBQUVBLGdCQUFVLElBQUksT0FBSixFQUFWO0FBQ0EsYUFBTyxJQUFQO0FBQ0EsWUFBTSxLQUFLLGFBQVg7QUFDQSxzQkFBZ0IsS0FBSyxVQUFyQjs7QUFFQSxVQUFJLGlCQUFpQixZQUFyQixFQUFtQyxDQUFFOztBQUVyQyxVQUFJLElBQUosRUFBVSxFQUFWLEVBQWMsSUFBZDs7QUFFQSxVQUFJLGlCQUFpQixZQUFyQixFQUFtQyxDQUFFOztBQUVyQyxjQUFRLGFBQVI7O0FBRUEsZ0JBQVUsV0FBVjtBQUNBLGFBQU8sUUFBUDtBQUNBLFlBQU0sT0FBTjtBQUNBLG9CQUFjLGVBQWQ7QUFDQSxzQkFBZ0IsaUJBQWhCO0FBQ0QsS0EzQkQ7QUE0QkEsV0FBTyxDQUFQO0FBQ0QsR0F2Q0Q7Ozs7Ozs7Ozs7OztBQW1EQSxNQUFJLGFBQWEsYUFBYSxVQUFVLElBQVYsRUFBZ0IsRUFBaEIsRUFBb0IsSUFBcEIsRUFBMEI7QUFDdEQsa0JBQWMsSUFBZDs7QUFFQTtBQUNBLE9BQUcsSUFBSDtBQUNBOztBQUVBLFFBQUksaUJBQWlCLFlBQXJCLEVBQW1DLENBQUU7QUFDdEMsR0FSZ0IsQ0FBakI7Ozs7Ozs7Ozs7OztBQW9CQSxNQUFJLGFBQWEsYUFBYSxVQUFVLElBQVYsRUFBZ0IsRUFBaEIsRUFBb0IsSUFBcEIsRUFBMEI7QUFDdEQsa0IsdUJBQXFDLEVBQUUsYUFBYSxJQUFmLEVBQXJDOztBQUVBLE9BQUcsSUFBSDs7QUFFQSxRQUFJLGlCQUFpQixZQUFyQixFQUFtQyxDQUFFO0FBQ3RDLEdBTmdCLENBQWpCOzs7Ozs7Ozs7O0FBZ0JBLE1BQUksVUFBVSxTQUFWLE9BQVUsQ0FBVSxRQUFWLEVBQW9CLEdBQXBCLEVBQXlCO0FBQ3JDLFFBQUksT0FBTyxRQUFRLFdBQVIsQ0FBWDs7Ozs7QUFLQSxXQUFPLGFBQWEsS0FBSyxRQUFsQixJQUE4QixPQUFPLEtBQUssR0FBakQ7QUFDRCxHQVBEOzs7Ozs7Ozs7OztBQWtCQSxNQUFJLGVBQWUsU0FBZixZQUFlLENBQVUsUUFBVixFQUFvQixHQUFwQixFQUF5QixPQUF6QixFQUFrQztBQUNuRCxRQUFJLGVBQWUsUUFBUSxRQUFSLEVBQWtCLEdBQWxCLENBQW5CLEVBQTJDO0FBQ3pDO0FBQ0Q7O0FBRUQsUUFBSSxPQUFPLFNBQVg7OztBQUdBLFFBQUksR0FBSixFQUFTO0FBQ1AsYUFBTyxTQUFTLGFBQVQsRUFBd0IsR0FBeEIsQ0FBUDtBQUNBLFVBQUksUUFBUSxpQkFBaUIsWUFBN0IsRUFBMkM7QUFDekMsOEJBQXNCLFFBQVEsSUFBUixFQUFjLFFBQXBDLEVBQThDLFFBQTlDLEVBQXdELEdBQXhEO0FBQ0Q7QUFDRjs7O0FBR0QsUUFBSSxDQUFDLElBQUwsRUFBVztBQUNULFVBQUksYUFBYSxPQUFqQixFQUEwQjtBQUN4QixlQUFPLFdBQVcsR0FBWCxDQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsZUFBTyxjQUFjLEdBQWQsRUFBbUIsYUFBbkIsRUFBa0MsUUFBbEMsRUFBNEMsR0FBNUMsRUFBaUQsT0FBakQsQ0FBUDtBQUNEOztBQUVELFVBQUksR0FBSixFQUFTO0FBQ1Asc0JBQWMsYUFBZCxFQUE2QixHQUE3QixFQUFrQyxJQUFsQztBQUNEOztBQUVELGNBQVEsV0FBUixDQUFvQixJQUFwQjtBQUNEOzs7Ozs7QUFNRCxRQUFJLGVBQWUsUUFBUSxXQUFSLEVBQXFCLEdBQXhDLEVBQTZDO0FBQzNDLG9CQUFjLFlBQWQsQ0FBMkIsSUFBM0IsRUFBaUMsV0FBakM7QUFDQSxjQUFRLGFBQVIsRUFBdUIsV0FBdkIsR0FBcUMsS0FBckM7QUFDRCxLQUhELE1BR087QUFDTCxvQkFBYyxZQUFkLENBQTJCLElBQTNCLEVBQWlDLFdBQWpDO0FBQ0Q7O0FBRUQsa0JBQWMsSUFBZDtBQUNELEdBMUNEOzs7Ozs7QUFnREEsTUFBSSxvQkFBb0IsU0FBcEIsaUJBQW9CLEdBQVk7QUFDbEMsUUFBSSxPQUFPLGFBQVg7QUFDQSxRQUFJLE9BQU8sUUFBUSxJQUFSLENBQVg7QUFDQSxRQUFJLFNBQVMsS0FBSyxNQUFsQjtBQUNBLFFBQUksY0FBYyxLQUFLLFdBQXZCO0FBQ0EsUUFBSSxRQUFRLEtBQUssU0FBakI7QUFDQSxRQUFJLE1BQU0sU0FBVjs7QUFFQSxRQUFJLFVBQVUsV0FBVixJQUF5QixXQUE3QixFQUEwQztBQUN4QztBQUNEOztBQUVELFFBQUksS0FBSyxLQUFMLENBQVcsUUFBUSxXQUFuQixLQUFtQyxTQUFTLElBQWhELEVBQXNEO0FBQ3BELFVBQUksaUJBQWlCLFlBQXJCLEVBQW1DLENBQUU7QUFDckM7QUFDRDs7QUFFRCxXQUFPLFVBQVUsV0FBakIsRUFBOEI7QUFDNUIsV0FBSyxXQUFMLENBQWlCLEtBQWpCO0FBQ0EsY0FBUSxXQUFSLEMsb0JBQXdDLEtBQXhDOztBQUVBLFlBQU0sUUFBUSxLQUFSLEVBQWUsR0FBckI7QUFDQSxVQUFJLEdBQUosRUFBUztBQUNQLGVBQU8sT0FBTyxHQUFQLENBQVA7QUFDRDtBQUNELGNBQVEsS0FBSyxTQUFiO0FBQ0Q7OztBQUdELFFBQUksQ0FBQyxXQUFMLEVBQWtCO0FBQ2hCLFdBQUssR0FBTCxJQUFZLE1BQVosRUFBb0I7QUFDbEIsZ0JBQVEsT0FBTyxHQUFQLENBQVI7QUFDQSxZQUFJLE1BQU0sVUFBTixLQUFxQixJQUF6QixFQUErQjtBQUM3QixrQkFBUSxXQUFSLENBQW9CLEtBQXBCO0FBQ0EsaUJBQU8sT0FBTyxHQUFQLENBQVA7QUFDRDtBQUNGOztBQUVELFdBQUssV0FBTCxHQUFtQixJQUFuQjtBQUNEO0FBQ0YsR0F4Q0Q7Ozs7O0FBNkNBLE1BQUksWUFBWSxTQUFaLFNBQVksR0FBWTtBQUMxQixvQkFBZ0IsV0FBaEI7QUFDQSxrQkFBYyxJQUFkO0FBQ0QsR0FIRDs7Ozs7QUFRQSxNQUFJLFdBQVcsU0FBWCxRQUFXLEdBQVk7QUFDekIsUUFBSSxXQUFKLEVBQWlCO0FBQ2Ysb0JBQWMsWUFBWSxXQUExQjtBQUNELEtBRkQsTUFFTztBQUNMLG9CQUFjLGNBQWMsVUFBNUI7QUFDRDtBQUNGLEdBTkQ7Ozs7O0FBV0EsTUFBSSxXQUFXLFNBQVgsUUFBVyxHQUFZO0FBQ3pCOztBQUVBLGtCQUFjLGFBQWQ7QUFDQSxvQkFBZ0IsY0FBYyxVQUE5QjtBQUNELEdBTEQ7Ozs7Ozs7Ozs7Ozs7OztBQW9CQSxNQUFJLGtCQUFrQixTQUFsQixlQUFrQixDQUFVLEdBQVYsRUFBZSxHQUFmLEVBQW9CLE9BQXBCLEVBQTZCO0FBQ2pEO0FBQ0EsaUJBQWEsR0FBYixFQUFrQixHQUFsQixFQUF1QixPQUF2QjtBQUNBO0FBQ0EsVyx3QkFBK0I7QUFBL0I7QUFFRCxHQU5EOzs7Ozs7OztBQWNBLE1BQUksbUJBQW1CLFNBQW5CLGdCQUFtQixHQUFZO0FBQ2pDLFFBQUksaUJBQWlCLFlBQXJCLEVBQW1DLENBQUU7O0FBRXJDO0FBQ0EsVyx3QkFBK0I7QUFBL0I7QUFFRCxHQU5EOzs7Ozs7OztBQWNBLE1BQUksV0FBVyxTQUFYLFFBQVcsR0FBWTtBQUN6QjtBQUNBLGlCQUFhLE9BQWIsRUFBc0IsSUFBdEIsRUFBNEIsSUFBNUI7QUFDQSxXLHFCQUE0QjtBQUE1QjtBQUVELEdBTEQ7Ozs7OztBQVdBLE1BQUksaUJBQWlCLFNBQWpCLGNBQWlCLEdBQVk7QUFDL0IsUUFBSSxpQkFBaUIsWUFBckIsRUFBbUMsQ0FBRTtBQUNyQyxXLHdCQUErQjtBQUEvQjtBQUVELEdBSkQ7Ozs7OztBQVVBLE1BQUksT0FBTyxTQUFQLElBQU8sR0FBWTtBQUNyQixRQUFJLGlCQUFpQixZQUFyQixFQUFtQyxDQUFFO0FBQ3JDLGtCQUFjLGNBQWMsU0FBNUI7QUFDRCxHQUhEOzs7Ozs7O0FBVUEsTUFBSSxvQkFBb0IsQ0FBeEI7Ozs7Ozs7QUFPQSxNQUFJLGNBQWMsRUFBbEI7Ozs7Ozs7Ozs7Ozs7O0FBY0EsTUFBSSxjQUFjLFNBQWQsV0FBYyxDQUFVLEdBQVYsRUFBZSxHQUFmLEVBQW9CLE9BQXBCLEVBQTZCLFVBQTdCLEVBQXlDO0FBQ3pELFFBQUksaUJBQWlCLFlBQXJCLEVBQW1DLENBQUU7O0FBRXJDLFFBQUksT0FBTyxnQkFBZ0IsR0FBaEIsRUFBcUIsR0FBckIsRUFBMEIsT0FBMUIsQ0FBWDtBQUNBLFFBQUksT0FBTyxRQUFRLElBQVIsQ0FBWDs7Ozs7Ozs7QUFRQSxRQUFJLFdBQVcsS0FBSyxRQUFwQjtBQUNBLFFBQUksV0FBVyxLQUFLLFFBQXBCO0FBQ0EsUUFBSSxlQUFlLEtBQW5CO0FBQ0EsUUFBSSxJQUFJLGlCQUFSO0FBQ0EsUUFBSSxJQUFJLENBQVI7O0FBRUEsV0FBTyxJQUFJLFVBQVUsTUFBckIsRUFBNkIsS0FBSyxDQUFMLEVBQVEsS0FBSyxDQUExQyxFQUE2QztBQUMzQyxVQUFJLFNBQVMsQ0FBVCxNQUFnQixVQUFVLENBQVYsQ0FBcEIsRUFBa0M7QUFDaEMsdUJBQWUsSUFBZjtBQUNBO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPLElBQUksVUFBVSxNQUFyQixFQUE2QixLQUFLLENBQUwsRUFBUSxLQUFLLENBQTFDLEVBQTZDO0FBQzNDLGVBQVMsQ0FBVCxJQUFjLFVBQVUsQ0FBVixDQUFkO0FBQ0Q7O0FBRUQsUUFBSSxJQUFJLFNBQVMsTUFBakIsRUFBeUI7QUFDdkIscUJBQWUsSUFBZjtBQUNBLGVBQVMsTUFBVCxHQUFrQixDQUFsQjtBQUNEOzs7OztBQUtELFFBQUksWUFBSixFQUFrQjtBQUNoQixXQUFLLElBQUksaUJBQVQsRUFBNEIsSUFBSSxVQUFVLE1BQTFDLEVBQWtELEtBQUssQ0FBdkQsRUFBMEQ7QUFDeEQsaUJBQVMsVUFBVSxDQUFWLENBQVQsSUFBeUIsVUFBVSxJQUFJLENBQWQsQ0FBekI7QUFDRDs7QUFFRCxXQUFLLElBQUksS0FBVCxJQUFrQixRQUFsQixFQUE0QjtBQUMxQix3QkFBZ0IsSUFBaEIsRUFBc0IsS0FBdEIsRUFBNkIsU0FBUyxLQUFULENBQTdCO0FBQ0EsaUJBQVMsS0FBVCxJQUFrQixTQUFsQjtBQUNEO0FBQ0Y7O0FBRUQsV0FBTyxJQUFQO0FBQ0QsR0FqREQ7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpRUEsTUFBSSxtQkFBbUIsU0FBbkIsZ0JBQW1CLENBQVUsR0FBVixFQUFlLEdBQWYsRUFBb0IsT0FBcEIsRUFBNkI7QUFDbEQsUUFBSSxpQkFBaUIsWUFBckIsRUFBbUMsQ0FBRTs7QUFFckMsZ0JBQVksQ0FBWixJQUFpQixHQUFqQjtBQUNBLGdCQUFZLENBQVosSUFBaUIsR0FBakI7QUFDQSxnQkFBWSxDQUFaLElBQWlCLE9BQWpCO0FBQ0QsR0FORDs7Ozs7Ozs7O0FBZUEsTUFBSSxPQUFPLFNBQVAsSUFBTyxDQUFVLElBQVYsRUFBZ0IsS0FBaEIsRUFBdUI7QUFDaEMsUUFBSSxpQkFBaUIsWUFBckIsRUFBbUMsQ0FBRTs7QUFFckMsZ0JBQVksSUFBWixDQUFpQixJQUFqQixFQUF1QixLQUF2QjtBQUNELEdBSkQ7Ozs7OztBQVVBLE1BQUksaUJBQWlCLFNBQWpCLGNBQWlCLEdBQVk7QUFDL0IsUUFBSSxpQkFBaUIsWUFBckIsRUFBbUMsQ0FBRTs7QUFFckMsUUFBSSxPQUFPLFlBQVksS0FBWixDQUFrQixJQUFsQixFQUF3QixXQUF4QixDQUFYO0FBQ0EsZ0JBQVksTUFBWixHQUFxQixDQUFyQjtBQUNBLFdBQU8sSUFBUDtBQUNELEdBTkQ7Ozs7Ozs7O0FBY0EsTUFBSSxlQUFlLFNBQWYsWUFBZSxDQUFVLEdBQVYsRUFBZTtBQUNoQyxRQUFJLGlCQUFpQixZQUFyQixFQUFtQyxDQUFFOztBQUVyQyxRQUFJLE9BQU8sa0JBQVg7O0FBRUEsUUFBSSxpQkFBaUIsWUFBckIsRUFBbUMsQ0FBRTs7QUFFckMsV0FBTyxJQUFQO0FBQ0QsR0FSRDs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQSxNQUFJLGNBQWMsU0FBZCxXQUFjLENBQVUsR0FBVixFQUFlLEdBQWYsRUFBb0IsT0FBcEIsRUFBNkIsVUFBN0IsRUFBeUM7QUFDekQsZ0JBQVksS0FBWixDQUFrQixJQUFsQixFQUF3QixTQUF4QjtBQUNBLFdBQU8sYUFBYSxHQUFiLENBQVA7QUFDRCxHQUhEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBLE1BQUkscUJBQXFCLFNBQXJCLGtCQUFxQixDQUFVLEdBQVYsRUFBZSxHQUFmLEVBQW9CLE9BQXBCLEVBQTZCLFVBQTdCLEVBQXlDO0FBQ2hFLFFBQUksaUJBQWlCLFlBQXJCLEVBQW1DLENBQUU7O0FBRXJDLGdCQUFZLEtBQVosQ0FBa0IsSUFBbEIsRUFBd0IsU0FBeEI7QUFDQTtBQUNBLFdBQU8sYUFBYSxHQUFiLENBQVA7QUFDRCxHQU5EOzs7Ozs7Ozs7OztBQWlCQSxNQUFJLE9BQU8sU0FBUCxJQUFPLENBQVUsS0FBVixFQUFpQixVQUFqQixFQUE2QjtBQUN0QyxRQUFJLGlCQUFpQixZQUFyQixFQUFtQyxDQUFFOztBQUVyQyxRQUFJLE9BQU8sVUFBWDtBQUNBLFFBQUksT0FBTyxRQUFRLElBQVIsQ0FBWDs7QUFFQSxRQUFJLEtBQUssSUFBTCxLQUFjLEtBQWxCLEVBQXlCO0FBQ3ZCLFdBQUssSUFBTCxHLHFCQUFpQyxLQUFqQzs7QUFFQSxVQUFJLFlBQVksS0FBaEI7QUFDQSxXQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksVUFBVSxNQUE5QixFQUFzQyxLQUFLLENBQTNDLEVBQThDOzs7OztBQUs1QyxZQUFJLEtBQUssVUFBVSxDQUFWLENBQVQ7QUFDQSxvQkFBWSxHQUFHLFNBQUgsQ0FBWjtBQUNEOztBQUVELFdBQUssSUFBTCxHQUFZLFNBQVo7QUFDRDs7QUFFRCxXQUFPLElBQVA7QUFDRCxHQXZCRDs7QUF5QkEsVUFBUSxLQUFSLEdBQWdCLFVBQWhCO0FBQ0EsVUFBUSxVQUFSLEdBQXFCLFVBQXJCO0FBQ0EsVUFBUSxVQUFSLEdBQXFCLFVBQXJCO0FBQ0EsVUFBUSxjQUFSLEdBQXlCLGNBQXpCO0FBQ0EsVUFBUSxJQUFSLEdBQWUsSUFBZjtBQUNBLFVBQVEsV0FBUixHQUFzQixXQUF0QjtBQUNBLFVBQVEsZ0JBQVIsR0FBMkIsZ0JBQTNCO0FBQ0EsVUFBUSxjQUFSLEdBQXlCLGNBQXpCO0FBQ0EsVUFBUSxXQUFSLEdBQXNCLFdBQXRCO0FBQ0EsVUFBUSxZQUFSLEdBQXVCLFlBQXZCO0FBQ0EsVUFBUSxrQkFBUixHQUE2QixrQkFBN0I7QUFDQSxVQUFRLElBQVIsR0FBZSxJQUFmO0FBQ0EsVUFBUSxJQUFSLEdBQWUsSUFBZjtBQUNBLFVBQVEsT0FBUixHQUFrQixPQUFsQjtBQUNBLFVBQVEsVUFBUixHQUFxQixVQUFyQjtBQUNBLFVBQVEsU0FBUixHQUFvQixTQUFwQjtBQUNBLFVBQVEsU0FBUixHQUFvQixTQUFwQjtBQUNBLFVBQVEsYUFBUixHQUF3QixhQUF4QjtBQUVELENBM2hDQSxDQUFEOzs7QUNuQkE7Ozs7OztBQUVBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFhTSxHOzs7Ozs7O0FBSUwsY0FBWSxJQUFaLEVBQWtCO0FBQUE7O0FBQUEsK0NBQ2pCLGlDQUFNLElBQU4sQ0FEaUI7O0FBRWpCLFFBQUssR0FBTCxHQUFXLEtBQUssTUFBTCxJQUFlLEtBQUssTUFBTCxDQUFZLElBQVosQ0FBaUIsSUFBakIsQ0FBMUI7QUFGaUI7QUFHakI7Ozs7Ozs7Ozs7OztlQVVELGdCLDZCQUFpQixLLEVBQU87QUFDdkIsTUFBSSxLQUFLLGdDQUFNLGdCQUFOLFlBQXVCLEtBQXZCLENBQVQ7QUFDQSxTQUFPLFlBQVksVUFBWixDQUF1QixFQUF2QixDQUFQO0FBQ0EsRTs7Ozs7Ozs7O2VBT0QsWSwyQkFBZTtBQUNkLE1BQUksS0FBSyxHQUFULEVBQWM7QUFDYixRQUFLLEdBQUw7QUFDQSxHQUZELE1BRU87QUFDTixtQ0FBTSxZQUFOO0FBQ0E7QUFDRCxFOzs7OztrQkFHYSxHOzs7QUNwRGY7Ozs7Ozs7QUFFQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7SUFFTSxZOzs7Ozs7Ozs7Ozs7Ozt3QkFLTCxjLDZCQUFpQjtBQUNoQixTQUFPLGtCQUFRLElBQVIsQ0FBUDtBQUNBLEU7Ozs7O2tCQUdhLFk7UUFDTixHOzs7QUNoQlQ7Ozs7Ozs7Ozs7Ozs7O0FBUUEsT0FBTyxXQUFQLEdBQXFCLE9BQU8sV0FBUCxJQUFzQixFQUEzQzs7QUFFQSxPQUFPLFdBQVAsQ0FBbUIsSUFBbkIsR0FBMEIsVUFBUyxLQUFULEVBQWdCLFFBQWhCLEVBQTBCO0FBQ2xELGlCQUFlLElBQWYsQ0FBb0IsUUFBcEIsRUFBOEIsS0FBOUI7QUFDRCxDQUZEOztBQUlBLE9BQU8sV0FBUCxDQUFtQixNQUFuQixHQUE0QixVQUFTLE1BQVQsRUFBaUIsUUFBakIsRUFBMkI7QUFDckQsTUFBSSxTQUFTLE9BQU8sU0FBUCxDQUFpQixjQUE5QjtBQUNBLE9BQUssSUFBSSxJQUFULElBQWlCLE1BQWpCLEVBQXlCO0FBQ3ZCLFFBQUksT0FBTyxJQUFQLENBQVksTUFBWixFQUFvQixJQUFwQixDQUFKLEVBQStCO0FBQzdCLGVBQVMsT0FBTyxJQUFQLENBQVQsRUFBdUIsSUFBdkI7QUFDRDtBQUNGO0FBQ0YsQ0FQRDs7QUFTQSxPQUFPLFdBQVAsQ0FBbUIsVUFBbkIsR0FBZ0MsVUFBUyxjQUFULEVBQXlCLElBQXpCLEVBQStCO0FBQzdELE1BQUksVUFBVSxPQUFPLFlBQVc7QUFDOUIsV0FBTyxlQUFlLEtBQWYsQ0FBcUIsSUFBckIsRUFBMkIsSUFBM0IsQ0FBUDtBQUNELEdBRmEsR0FFVixjQUZKO0FBR0EsVUFBUSxlQUFSLEdBQTBCLElBQTFCO0FBQ0EsU0FBTyxPQUFQO0FBQ0QsQ0FORDs7QUFRQSxPQUFPLFdBQVAsQ0FBbUIsZUFBbkIsR0FBcUMsVUFBUyxLQUFULEVBQWdCO0FBQ25ELE1BQUksY0FBYyxLQUFkLHlDQUFjLEtBQWQsQ0FBSjtBQUNBLE1BQUksU0FBUyxRQUFULElBQXNCLFNBQVMsUUFBVCxJQUFxQixTQUFTLGlCQUFpQixNQUF6RSxFQUFrRjtBQUNoRixtQkFBZSxJQUFmLENBQW9CLEtBQXBCO0FBQ0QsR0FGRCxNQUVPLElBQUksU0FBUyxVQUFULElBQXVCLE1BQU0sZUFBakMsRUFBa0Q7QUFDdkQ7QUFDRCxHQUZNLE1BRUEsSUFBSSxNQUFNLE9BQU4sQ0FBYyxLQUFkLENBQUosRUFBMEI7QUFDL0IsVUFBTSxPQUFOLENBQWMsT0FBTyxXQUFQLENBQW1CLGVBQWpDO0FBQ0QsR0FGTSxNQUVBLElBQUksT0FBTyxLQUFQLE1BQWtCLGlCQUF0QixFQUF5QztBQUM5QyxXQUFPLFdBQVAsQ0FBbUIsTUFBbkIsQ0FBMEIsS0FBMUIsRUFBaUMsT0FBTyxXQUFQLENBQW1CLGVBQXBEO0FBQ0Q7QUFDRixDQVhEOztrQkFhZSxPQUFPLFc7OztBQzVDdEI7Ozs7OztBQUVBOzs7Ozs7Ozs7OztBQUtBLElBQUksU0FBUyxPQUFPLE1BQXBCOzs7Ozs7OztJQU9NLFE7OztBQUNMLHFCQUFjO0FBQUE7O0FBQUEsK0NBQ2Isc0JBRGE7O0FBRWIsUUFBSyxJQUFMLEdBQVksT0FBTyxJQUFQLENBQVo7QUFDQSxRQUFLLE1BQUwsR0FBYyxPQUFPLElBQVAsQ0FBZDtBQUhhO0FBSWI7Ozs7Ozs7Ozs7b0JBUUQsRyxnQkFBSSxJLEVBQU0sSyxFQUFPO0FBQ2hCLE9BQUssSUFBTCxDQUFVLEtBQUssV0FBTCxFQUFWLElBQWdDLElBQWhDO0FBQ0EsT0FBSyxNQUFMLENBQVksS0FBSyxXQUFMLEVBQVosSUFBa0MsS0FBSyxNQUFMLENBQVksS0FBSyxXQUFMLEVBQVosS0FBbUMsRUFBckU7QUFDQSxPQUFLLE1BQUwsQ0FBWSxLQUFLLFdBQUwsRUFBWixFQUFnQyxJQUFoQyxDQUFxQyxLQUFyQztBQUNBLFNBQU8sSUFBUDtBQUNBLEU7Ozs7Ozs7O29CQU1ELEssb0JBQVE7QUFDUCxPQUFLLElBQUwsR0FBWSxPQUFPLElBQVAsQ0FBWjtBQUNBLE9BQUssTUFBTCxHQUFjLE9BQU8sSUFBUCxDQUFkO0FBQ0EsU0FBTyxJQUFQO0FBQ0EsRTs7Ozs7Ozs7OztvQkFRRCxRLHFCQUFTLEksRUFBTTtBQUNkLFNBQU8sS0FBSyxXQUFMLE1BQXNCLEtBQUssTUFBbEM7QUFDQSxFOzs7Ozs7O29CQUtELGUsOEJBQWtCO0FBQ2pCLE9BQUssTUFBTCxHQUFjLElBQWQ7QUFDQSxFOzs7Ozs7Ozs7O29CQVFELEcsZ0JBQUksSSxFQUFNO0FBQ1QsTUFBSSxTQUFTLEtBQUssTUFBTCxDQUFZLEtBQUssV0FBTCxFQUFaLENBQWI7QUFDQSxNQUFJLE1BQUosRUFBWTtBQUNYLFVBQU8sT0FBTyxDQUFQLENBQVA7QUFDQTtBQUNELEU7Ozs7Ozs7OztvQkFPRCxNLG1CQUFPLEksRUFBTTtBQUNaLFNBQU8sS0FBSyxNQUFMLENBQVksS0FBSyxXQUFMLEVBQVosQ0FBUDtBQUNBLEU7Ozs7Ozs7O29CQU1ELE8sc0JBQVU7QUFDVCxTQUFPLEtBQUssSUFBTCxPQUFnQixDQUF2QjtBQUNBLEU7Ozs7Ozs7O29CQU1ELEssb0JBQVE7QUFBQTs7QUFDUCxTQUFPLE9BQU8sSUFBUCxDQUFZLEtBQUssTUFBakIsRUFBeUIsR0FBekIsQ0FBNkIsVUFBQyxHQUFEO0FBQUEsVUFBUyxPQUFLLElBQUwsQ0FBVSxHQUFWLENBQVQ7QUFBQSxHQUE3QixDQUFQO0FBQ0EsRTs7Ozs7Ozs7O29CQU9ELE0sbUJBQU8sSSxFQUFNO0FBQ1osU0FBTyxLQUFLLElBQUwsQ0FBVSxLQUFLLFdBQUwsRUFBVixDQUFQO0FBQ0EsU0FBTyxLQUFLLE1BQUwsQ0FBWSxLQUFLLFdBQUwsRUFBWixDQUFQO0FBQ0EsU0FBTyxJQUFQO0FBQ0EsRTs7Ozs7Ozs7Ozs7b0JBU0QsRyxnQkFBSSxJLEVBQU0sSyxFQUFPO0FBQ2hCLE9BQUssSUFBTCxDQUFVLEtBQUssV0FBTCxFQUFWLElBQWdDLElBQWhDO0FBQ0EsT0FBSyxNQUFMLENBQVksS0FBSyxXQUFMLEVBQVosSUFBa0MsQ0FBQyxLQUFELENBQWxDO0FBQ0EsU0FBTyxJQUFQO0FBQ0EsRTs7Ozs7Ozs7b0JBTUQsSSxtQkFBTztBQUNOLFNBQU8sS0FBSyxLQUFMLEdBQWEsTUFBcEI7QUFDQSxFOzs7Ozs7OztvQkFNRCxRLHVCQUFXO0FBQ1YsU0FBTyxLQUFLLFNBQUwsQ0FBZSxLQUFLLE1BQXBCLENBQVA7QUFDQSxFOzs7OztrQkFHYSxROzs7Ozs7Ozs7Ozs7O0FDbElmOzs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFXQSxJQUFJLFdBQVcsU0FBWCxRQUFXLEdBQVcsQ0FBRSxDQUE1Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2QkEsU0FBUyxTQUFULENBQW1CLElBQW5CLEdBQTBCLFlBQVcsQ0FBRSxDQUF2Qzs7Ozs7Ozs7OztBQVdBLFNBQVMsbUJBQVQsR0FBK0IsZ0JBQS9COzs7Ozs7Ozs7Ozs7QUFhQSxTQUFTLGlCQUFULEdBQTZCLFVBQVMsSUFBVCxFQUFlO0FBQzFDLE9BQUssU0FBTCxDQUFlLElBQWYsR0FBc0IsS0FBSyxTQUFMLENBQWUsSUFBckM7QUFDQSxPQUFLLFNBQUwsQ0FBZSxjQUFmLEdBQWdDLElBQWhDO0FBQ0QsQ0FIRDs7Ozs7OztBQVdBLFNBQVMsZUFBVCxHQUEyQixVQUFTLE1BQVQsRUFBaUI7QUFDMUMsTUFBSSxDQUFDLE1BQUwsRUFBYTtBQUNYLFdBQU8sS0FBUDtBQUNEO0FBQ0QsTUFBSTtBQUNGLFdBQU8sQ0FBQyxDQUFDLE9BQU8sY0FBaEI7QUFDRCxHQUZELENBRUUsT0FBTyxDQUFQLEVBQVU7O0FBRVYsV0FBTyxLQUFQO0FBQ0Q7QUFDRixDQVZEOzs7Ozs7Ozs7Ozs7Ozs7QUEwQkEsSUFBSSxVQUFVLFNBQVYsT0FBVSxDQUFTLEVBQVQsRUFBYTtBQUN6QixNQUFJLE9BQU8sTUFBTSxTQUFOLENBQWdCLEtBQWhCLENBQXNCLElBQXRCLENBQTJCLFNBQTNCLEVBQXNDLENBQXRDLENBQVg7QUFDQSxTQUFPLFlBQVc7OztBQUdoQixRQUFJLFVBQVUsS0FBSyxLQUFMLEVBQWQ7QUFDQSxZQUFRLElBQVIsQ0FBYSxLQUFiLENBQW1CLE9BQW5CLEVBQTRCLFNBQTVCO0FBQ0EsV0FBTyxHQUFHLEtBQUgsQ0FBUyxJQUFULEVBQWUsT0FBZixDQUFQO0FBQ0QsR0FORDtBQU9ELENBVEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkRBLElBQUkscUJBQXFCLFNBQXJCLGtCQUFxQixDQUFTLFFBQVQsRUFBbUIsV0FBbkIsRUFBZ0M7Ozs7OztBQU12RCxPQUFLLE1BQUwsR0FBYyxtQkFBbUIsTUFBbkIsQ0FBMEIsT0FBeEM7Ozs7Ozs7QUFPQSxPQUFLLE9BQUwsR0FBZSxTQUFmOzs7Ozs7QUFNQSxPQUFLLE9BQUwsR0FBZSxJQUFmOzs7Ozs7O0FBT0EsT0FBSyxnQkFBTCxHQUF3QixJQUF4Qjs7Ozs7O0FBTUEsT0FBSyxVQUFMLEdBQWtCLEtBQWxCOztBQUVBLE1BQUksbUJBQW1CLHlCQUFuQixHQUErQyxDQUFuRCxFQUFzRDs7Ozs7Ozs7Ozs7QUFXcEQsU0FBSyxxQkFBTCxHQUE2QixDQUE3QjtBQUNELEdBWkQsTUFZTyxJQUFJLG1CQUFtQix5QkFBbkIsS0FBaUQsQ0FBckQsRUFBd0Q7Ozs7Ozs7OztBQVM3RCxTQUFLLHNCQUFMLEdBQThCLEtBQTlCO0FBQ0Q7O0FBRUQsTUFBSTtBQUNGLFFBQUksT0FBTyxJQUFYO0FBQ0EsYUFBUyxJQUFULENBQ0UsV0FERixFQUNlLFVBQVMsS0FBVCxFQUFnQjtBQUMzQixXQUFLLFFBQUwsQ0FBYyxtQkFBbUIsTUFBbkIsQ0FBMEIsU0FBeEMsRUFBbUQsS0FBbkQ7QUFDRCxLQUhILEVBR0ssVUFBUyxNQUFULEVBQWlCO0FBQ2xCLFdBQUssUUFBTCxDQUFjLG1CQUFtQixNQUFuQixDQUEwQixRQUF4QyxFQUFrRCxNQUFsRDtBQUNELEtBTEg7QUFNRCxHQVJELENBUUUsT0FBTyxDQUFQLEVBQVU7QUFDVixTQUFLLFFBQUwsQ0FBYyxtQkFBbUIsTUFBbkIsQ0FBMEIsUUFBeEMsRUFBa0QsQ0FBbEQ7QUFDRDtBQUNGLENBckVEOzs7Ozs7Ozs7OztBQWdGQSxtQkFBbUIseUJBQW5CLEdBQStDLENBQS9DOzs7Ozs7OztBQVNBLG1CQUFtQixNQUFuQixHQUE0Qjs7QUFFMUIsV0FBUyxDQUZpQjs7O0FBSzFCLFdBQVMsQ0FMaUI7OztBQVExQixhQUFXLENBUmU7OztBQVcxQixZQUFVO0FBWGdCLENBQTVCOzs7Ozs7Ozs7Ozs7OztBQTJCQSxtQkFBbUIsY0FBbkIsR0FBb0MsSUFBcEM7Ozs7Ozs7O0FBU0EsbUJBQW1CLE9BQW5CLEdBQTZCLFVBQVMsU0FBVCxFQUFvQjtBQUMvQyxTQUFPLElBQUksa0JBQUosQ0FBdUIsVUFBUyxPQUFULEVBQWtCO0FBQzVDLFlBQVEsU0FBUjtBQUNELEdBRkksQ0FBUDtBQUdELENBSkQ7Ozs7Ozs7QUFZQSxtQkFBbUIsTUFBbkIsR0FBNEIsVUFBUyxVQUFULEVBQXFCO0FBQy9DLFNBQU8sSUFBSSxrQkFBSixDQUF1QixVQUFTLE9BQVQsRUFBa0IsTUFBbEIsRUFBMEI7QUFDcEQsV0FBTyxVQUFQO0FBQ0QsR0FGSSxDQUFQO0FBR0QsQ0FKRDs7Ozs7Ozs7QUFhQSxtQkFBbUIsSUFBbkIsR0FBMEIsVUFBUyxRQUFULEVBQW1CO0FBQzNDLFNBQU8sSUFBSSxrQkFBSixDQUF1QixVQUFTLE9BQVQsRUFBa0IsTUFBbEIsRUFBMEI7QUFDcEQsUUFBSSxDQUFDLFNBQVMsTUFBZCxFQUFzQjtBQUNwQixjQUFRLFNBQVI7QUFDRDtBQUNELFNBQUssSUFBSSxJQUFJLENBQVIsRUFBVyxPQUFoQixFQUEwQixVQUFVLFNBQVMsQ0FBVCxDQUFwQyxFQUFrRCxHQUFsRCxFQUF1RDtBQUNyRCxjQUFRLElBQVIsQ0FBYSxPQUFiLEVBQXNCLE1BQXRCO0FBQ0Q7QUFDRixHQVBJLENBQVA7QUFRRCxDQVREOzs7Ozs7Ozs7QUFtQkEsbUJBQW1CLEdBQW5CLEdBQXlCLFVBQVMsUUFBVCxFQUFtQjtBQUMxQyxTQUFPLElBQUksa0JBQUosQ0FBdUIsVUFBUyxPQUFULEVBQWtCLE1BQWxCLEVBQTBCO0FBQ3BELFFBQUksWUFBWSxTQUFTLE1BQXpCO0FBQ0EsUUFBSSxTQUFTLEVBQWI7O0FBRUEsUUFBSSxDQUFDLFNBQUwsRUFBZ0I7QUFDZCxjQUFRLE1BQVI7QUFDQTtBQUNEOztBQUVELFFBQUksWUFBWSxTQUFaLFNBQVksQ0FBUyxLQUFULEVBQWdCLEtBQWhCLEVBQXVCO0FBQ3JDO0FBQ0EsYUFBTyxLQUFQLElBQWdCLEtBQWhCO0FBQ0EsVUFBSSxjQUFjLENBQWxCLEVBQXFCO0FBQ25CLGdCQUFRLE1BQVI7QUFDRDtBQUNGLEtBTkQ7O0FBUUEsUUFBSSxXQUFXLFNBQVgsUUFBVyxDQUFTLE1BQVQsRUFBaUI7QUFDOUIsYUFBTyxNQUFQO0FBQ0QsS0FGRDs7QUFJQSxTQUFLLElBQUksSUFBSSxDQUFSLEVBQVcsT0FBaEIsRUFBMEIsVUFBVSxTQUFTLENBQVQsQ0FBcEMsRUFBa0QsR0FBbEQsRUFBdUQ7QUFDckQsY0FBUSxJQUFSLENBQWEsUUFBUSxTQUFSLEVBQW1CLENBQW5CLENBQWIsRUFBb0MsUUFBcEM7QUFDRDtBQUNGLEdBeEJJLENBQVA7QUF5QkQsQ0ExQkQ7Ozs7Ozs7OztBQW9DQSxtQkFBbUIsY0FBbkIsR0FBb0MsVUFBUyxRQUFULEVBQW1CO0FBQ3JELFNBQU8sSUFBSSxrQkFBSixDQUF1QixVQUFTLE9BQVQsRUFBa0IsTUFBbEIsRUFBMEI7QUFDcEQsUUFBSSxXQUFXLFNBQVMsTUFBeEI7QUFDQSxRQUFJLFVBQVUsRUFBZDs7QUFFQSxRQUFJLENBQUMsUUFBTCxFQUFlO0FBQ2IsY0FBUSxTQUFSO0FBQ0E7QUFDRDs7QUFFRCxRQUFJLFlBQVksU0FBWixTQUFZLENBQVMsS0FBVCxFQUFnQjtBQUM5QixjQUFRLEtBQVI7QUFDRCxLQUZEOztBQUlBLFFBQUksV0FBVyxTQUFYLFFBQVcsQ0FBUyxLQUFULEVBQWdCLE1BQWhCLEVBQXdCO0FBQ3JDO0FBQ0EsY0FBUSxLQUFSLElBQWlCLE1BQWpCO0FBQ0EsVUFBSSxhQUFhLENBQWpCLEVBQW9CO0FBQ2xCLGVBQU8sT0FBUDtBQUNEO0FBQ0YsS0FORDs7QUFRQSxTQUFLLElBQUksSUFBSSxDQUFSLEVBQVcsT0FBaEIsRUFBMEIsVUFBVSxTQUFTLENBQVQsQ0FBcEMsRUFBa0QsR0FBbEQsRUFBdUQ7QUFDckQsY0FBUSxJQUFSLENBQWEsU0FBYixFQUF3QixRQUFRLFFBQVIsRUFBa0IsQ0FBbEIsQ0FBeEI7QUFDRDtBQUNGLEdBeEJJLENBQVA7QUF5QkQsQ0ExQkQ7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNENBLG1CQUFtQixTQUFuQixDQUE2QixJQUE3QixHQUFvQyxVQUFTLGVBQVQsRUFBMEIsY0FBMUIsRUFBMEMsV0FBMUMsRUFBdUQ7QUFDekYsU0FBTyxLQUFLLGdCQUFMLENBQ0wsWUFBSyxVQUFMLENBQWdCLGVBQWhCLElBQW1DLGVBQW5DLEdBQXFELElBRGhELEVBRUwsWUFBSyxVQUFMLENBQWdCLGNBQWhCLElBQWtDLGNBQWxDLEdBQW1ELElBRjlDLEVBR0wsV0FISyxDQUFQO0FBSUQsQ0FMRDtBQU1BLFNBQVMsaUJBQVQsQ0FBMkIsa0JBQTNCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQSxtQkFBbUIsU0FBbkIsQ0FBNkIsVUFBN0IsR0FBMEMsVUFBUyxVQUFULEVBQXFCLFdBQXJCLEVBQWtDO0FBQzFFLE1BQUksV0FBVyxTQUFYLFFBQVcsR0FBVztBQUN4QixRQUFJOztBQUVGLGlCQUFXLElBQVgsQ0FBZ0IsV0FBaEI7QUFDRCxLQUhELENBR0UsT0FBTyxHQUFQLEVBQVk7QUFDWix5QkFBbUIsZ0JBQW5CLENBQW9DLElBQXBDLENBQXlDLElBQXpDLEVBQStDLEdBQS9DO0FBQ0Q7QUFDRixHQVBEOztBQVNBLE9BQUssaUJBQUwsQ0FBdUI7QUFDckIsV0FBTyxJQURjO0FBRXJCLGdCQUFZLFFBRlM7QUFHckIsaUJBQWE7QUFIUSxHQUF2QjtBQUtBLFNBQU8sSUFBUDtBQUNELENBaEJEOzs7Ozs7Ozs7Ozs7Ozs7QUFnQ0EsbUJBQW1CLFNBQW5CLENBQTZCLFNBQTdCLEdBQXlDLFVBQVMsVUFBVCxFQUFxQixXQUFyQixFQUFrQztBQUN6RSxTQUFPLEtBQUssZ0JBQUwsQ0FBc0IsSUFBdEIsRUFBNEIsVUFBNUIsRUFBd0MsV0FBeEMsQ0FBUDtBQUNELENBRkQ7Ozs7O0FBT0EsbUJBQW1CLFNBQW5CLENBQTZCLEtBQTdCLEdBQXFDLG1CQUFtQixTQUFuQixDQUE2QixTQUFsRTs7Ozs7Ozs7Ozs7Ozs7QUFlQSxtQkFBbUIsU0FBbkIsQ0FBNkIsTUFBN0IsR0FBc0MsVUFBUyxXQUFULEVBQXNCO0FBQzFELE1BQUksS0FBSyxNQUFMLEtBQWdCLG1CQUFtQixNQUFuQixDQUEwQixPQUE5QyxFQUF1RDtBQUNyRCxpQkFBTSxHQUFOLENBQVUsWUFBVztBQUNuQixVQUFJLE1BQU0sSUFBSSxtQkFBbUIsaUJBQXZCLENBQXlDLFdBQXpDLENBQVY7QUFDQSxVQUFJLHFCQUFKLEdBQTRCLElBQTVCO0FBQ0EsV0FBSyxlQUFMLENBQXFCLEdBQXJCO0FBQ0QsS0FKRCxFQUlHLElBSkg7QUFLRDtBQUNGLENBUkQ7Ozs7Ozs7O0FBaUJBLG1CQUFtQixTQUFuQixDQUE2QixlQUE3QixHQUErQyxVQUFTLEdBQVQsRUFBYztBQUMzRCxNQUFJLEtBQUssTUFBTCxLQUFnQixtQkFBbUIsTUFBbkIsQ0FBMEIsT0FBOUMsRUFBdUQ7QUFDckQsUUFBSSxLQUFLLE9BQVQsRUFBa0I7O0FBRWhCLFdBQUssT0FBTCxDQUFhLFlBQWIsQ0FBMEIsSUFBMUIsRUFBZ0MsR0FBaEM7QUFDRCxLQUhELE1BR087QUFDTCxXQUFLLFFBQUwsQ0FBYyxtQkFBbUIsTUFBbkIsQ0FBMEIsUUFBeEMsRUFBa0QsR0FBbEQ7QUFDRDtBQUNGO0FBQ0YsQ0FURDs7Ozs7Ozs7Ozs7O0FBc0JBLG1CQUFtQixTQUFuQixDQUE2QixZQUE3QixHQUE0QyxVQUFTLFlBQVQsRUFBdUIsR0FBdkIsRUFBNEI7QUFDdEUsTUFBSSxDQUFDLEtBQUssZ0JBQVYsRUFBNEI7QUFDMUI7QUFDRDtBQUNELE1BQUksYUFBYSxDQUFqQjtBQUNBLE1BQUksYUFBYSxDQUFDLENBQWxCOzs7O0FBSUEsT0FBSyxJQUFJLElBQUksQ0FBUixFQUFXLEtBQWhCLEVBQXdCLFFBQVEsS0FBSyxnQkFBTCxDQUFzQixDQUF0QixDQUFoQyxFQUEyRCxHQUEzRCxFQUFnRTtBQUM5RCxRQUFJLFFBQVEsTUFBTSxLQUFsQjtBQUNBLFFBQUksS0FBSixFQUFXO0FBQ1Q7QUFDQSxVQUFJLFVBQVUsWUFBZCxFQUE0QjtBQUMxQixxQkFBYSxDQUFiO0FBQ0Q7QUFDRCxVQUFJLGNBQWMsQ0FBZCxJQUFtQixhQUFhLENBQXBDLEVBQXVDO0FBQ3JDO0FBQ0Q7QUFDRjtBQUNGOzs7O0FBSUQsTUFBSSxjQUFjLENBQWxCLEVBQXFCO0FBQ25CLFFBQUksS0FBSyxNQUFMLEtBQWdCLG1CQUFtQixNQUFuQixDQUEwQixPQUExQyxJQUFxRCxlQUFlLENBQXhFLEVBQTJFO0FBQ3pFLFdBQUssZUFBTCxDQUFxQixHQUFyQjtBQUNELEtBRkQsTUFFTztBQUNMLFVBQUksZ0JBQWdCLEtBQUssZ0JBQUwsQ0FBc0IsTUFBdEIsQ0FBNkIsVUFBN0IsRUFBeUMsQ0FBekMsRUFBNEMsQ0FBNUMsQ0FBcEI7QUFDQSxXQUFLLGdCQUFMLENBQ0UsYUFERixFQUNpQixtQkFBbUIsTUFBbkIsQ0FBMEIsUUFEM0MsRUFDcUQsR0FEckQ7QUFFRDtBQUNGO0FBQ0YsQ0FqQ0Q7Ozs7Ozs7Ozs7O0FBNkNBLG1CQUFtQixTQUFuQixDQUE2QixpQkFBN0IsR0FBaUQsVUFBUyxhQUFULEVBQXdCO0FBQ3ZFLE1BQUksQ0FBQyxDQUFDLEtBQUssZ0JBQU4sSUFBMEIsQ0FBQyxLQUFLLGdCQUFMLENBQXNCLE1BQWxELE1BQ0QsS0FBSyxNQUFMLEtBQWdCLG1CQUFtQixNQUFuQixDQUEwQixTQUExQyxJQUNELEtBQUssTUFBTCxLQUFnQixtQkFBbUIsTUFBbkIsQ0FBMEIsUUFGeEMsQ0FBSixFQUV1RDtBQUNyRCxTQUFLLGtCQUFMO0FBQ0Q7QUFDRCxNQUFJLENBQUMsS0FBSyxnQkFBVixFQUE0QjtBQUMxQixTQUFLLGdCQUFMLEdBQXdCLEVBQXhCO0FBQ0Q7QUFDRCxPQUFLLGdCQUFMLENBQXNCLElBQXRCLENBQTJCLGFBQTNCO0FBQ0QsQ0FWRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0NBLG1CQUFtQixTQUFuQixDQUE2QixnQkFBN0IsR0FBZ0QsVUFDaEQsV0FEZ0QsRUFDbkMsVUFEbUMsRUFDdkIsV0FEdUIsRUFDVjs7QUFFcEMsTUFBSSxnQkFBZ0I7QUFDbEIsV0FBTyxJQURXO0FBRWxCLGlCQUFhLElBRks7QUFHbEIsZ0JBQVk7QUFITSxHQUFwQjs7QUFNQSxnQkFBYyxLQUFkLEdBQXNCLElBQUksa0JBQUosQ0FBdUIsVUFBUyxPQUFULEVBQWtCLE1BQWxCLEVBQTBCOztBQUVyRSxrQkFBYyxXQUFkLEdBQTRCLGNBQWMsVUFBUyxLQUFULEVBQWdCO0FBQ3hELFVBQUk7QUFDRixZQUFJLFNBQVMsWUFBWSxJQUFaLENBQWlCLFdBQWpCLEVBQThCLEtBQTlCLENBQWI7QUFDQSxnQkFBUSxNQUFSO0FBQ0QsT0FIRCxDQUdFLE9BQU8sR0FBUCxFQUFZO0FBQ1osZUFBTyxHQUFQO0FBQ0Q7QUFDRixLQVAyQixHQU94QixPQVBKOzs7QUFVQSxrQkFBYyxVQUFkLEdBQTJCLGFBQWEsVUFBUyxNQUFULEVBQWlCO0FBQ3ZELFVBQUk7QUFDRixZQUFJLFNBQVMsV0FBVyxJQUFYLENBQWdCLFdBQWhCLEVBQTZCLE1BQTdCLENBQWI7QUFDQSxZQUFJLENBQUMsWUFBSyxLQUFMLENBQVcsTUFBWCxDQUFELElBQXVCLE9BQU8scUJBQWxDLEVBQXlEOztBQUV2RCxpQkFBTyxNQUFQO0FBQ0QsU0FIRCxNQUdPO0FBQ0wsa0JBQVEsTUFBUjtBQUNEO0FBQ0YsT0FSRCxDQVFFLE9BQU8sR0FBUCxFQUFZO0FBQ1osZUFBTyxHQUFQO0FBQ0Q7QUFDRixLQVowQixHQVl2QixNQVpKO0FBYUQsR0F6QnFCLENBQXRCOztBQTJCQSxnQkFBYyxLQUFkLENBQW9CLE9BQXBCLEdBQThCLElBQTlCO0FBQ0EsT0FBSyxpQkFBTDtrREFDb0QsYUFEcEQ7QUFFQSxTQUFPLGNBQWMsS0FBckI7QUFDRCxDQXhDRDs7Ozs7Ozs7QUFpREEsbUJBQW1CLFNBQW5CLENBQTZCLGtCQUE3QixHQUFrRCxVQUFTLEtBQVQsRUFBZ0I7QUFDaEUsTUFBSSxLQUFLLE1BQUwsS0FBZ0IsbUJBQW1CLE1BQW5CLENBQTBCLE9BQTlDLEVBQXVEO0FBQ3JELFVBQU0sSUFBSSxLQUFKLENBQVUsb0NBQVYsQ0FBTjtBQUNEO0FBQ0QsT0FBSyxNQUFMLEdBQWMsbUJBQW1CLE1BQW5CLENBQTBCLE9BQXhDO0FBQ0EsT0FBSyxRQUFMLENBQWMsbUJBQW1CLE1BQW5CLENBQTBCLFNBQXhDLEVBQW1ELEtBQW5EO0FBQ0QsQ0FORDs7Ozs7Ozs7QUFlQSxtQkFBbUIsU0FBbkIsQ0FBNkIsaUJBQTdCLEdBQWlELFVBQVMsTUFBVCxFQUFpQjtBQUNoRSxNQUFJLEtBQUssTUFBTCxLQUFnQixtQkFBbUIsTUFBbkIsQ0FBMEIsT0FBOUMsRUFBdUQ7QUFDckQsVUFBTSxJQUFJLEtBQUosQ0FBVSxvQ0FBVixDQUFOO0FBQ0Q7QUFDRCxPQUFLLE1BQUwsR0FBYyxtQkFBbUIsTUFBbkIsQ0FBMEIsT0FBeEM7QUFDQSxPQUFLLFFBQUwsQ0FBYyxtQkFBbUIsTUFBbkIsQ0FBMEIsUUFBeEMsRUFBa0QsTUFBbEQ7QUFDRCxDQU5EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJBLG1CQUFtQixTQUFuQixDQUE2QixRQUE3QixHQUF3QyxVQUFTLEtBQVQsRUFBZ0IsQ0FBaEIsRUFBbUI7QUFDekQsTUFBSSxLQUFLLE1BQUwsS0FBZ0IsbUJBQW1CLE1BQW5CLENBQTBCLE9BQTlDLEVBQXVEO0FBQ3JEO0FBQ0Q7O0FBRUQsTUFBSSxTQUFTLENBQWIsRUFBZ0I7QUFDZCxZQUFRLG1CQUFtQixNQUFuQixDQUEwQixRQUFsQztBQUNBLFFBQUksSUFBSSxTQUFKLENBQWMsNkNBQWQsQ0FBSjtBQUVELEdBSkQsTUFJTyxJQUFJLFNBQVMsZUFBVCxDQUF5QixDQUF6QixDQUFKLEVBQWlDO0FBQ3RDLFEsd0JBQThCLENBQTlCO0FBQ0EsU0FBSyxNQUFMLEdBQWMsbUJBQW1CLE1BQW5CLENBQTBCLE9BQXhDO0FBQ0EsTUFBRSxJQUFGLENBQU8sS0FBSyxrQkFBWixFQUFnQyxLQUFLLGlCQUFyQyxFQUF3RCxJQUF4RDtBQUNBO0FBRUQsR0FOTSxNQU1BLElBQUksWUFBSyxRQUFMLENBQWMsQ0FBZCxDQUFKLEVBQXNCO0FBQzNCLFFBQUk7QUFDRixVQUFJLE9BQU8sRUFBRSxJQUFiO0FBQ0EsVUFBSSxZQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FBSixFQUEyQjtBQUN6QixhQUFLLFFBQUwsQ0FBYyxDQUFkLEVBQWlCLElBQWpCO0FBQ0E7QUFDRDtBQUNGLEtBTkQsQ0FNRSxPQUFPLENBQVAsRUFBVTtBQUNWLGNBQVEsbUJBQW1CLE1BQW5CLENBQTBCLFFBQWxDO0FBQ0EsVUFBSSxDQUFKO0FBQ0Q7QUFDRjs7QUFFRCxPQUFLLE9BQUwsR0FBZSxDQUFmO0FBQ0EsT0FBSyxNQUFMLEdBQWMsS0FBZDtBQUNBLE9BQUssa0JBQUw7O0FBRUEsTUFBSSxVQUFVLG1CQUFtQixNQUFuQixDQUEwQixRQUFwQyxJQUFnRCxDQUFDLEVBQUUscUJBQXZELEVBQThFO0FBQzVFLHVCQUFtQixzQkFBbkIsQ0FBMEMsSUFBMUMsRUFBZ0QsQ0FBaEQ7QUFDRDtBQUNGLENBbkNEOzs7Ozs7Ozs7Ozs7Ozs7O0FBb0RBLG1CQUFtQixTQUFuQixDQUE2QixRQUE3QixHQUF3QyxVQUFTLFFBQVQsRUFBbUIsSUFBbkIsRUFBeUI7QUFDL0QsT0FBSyxNQUFMLEdBQWMsbUJBQW1CLE1BQW5CLENBQTBCLE9BQXhDO0FBQ0EsTUFBSSxVQUFVLElBQWQ7QUFDQSxNQUFJLFNBQVMsS0FBYjs7QUFFQSxNQUFJLFVBQVUsU0FBVixPQUFVLENBQVMsS0FBVCxFQUFnQjtBQUM1QixRQUFJLENBQUMsTUFBTCxFQUFhO0FBQ1gsZUFBUyxJQUFUO0FBQ0EsY0FBUSxrQkFBUixDQUEyQixLQUEzQjtBQUNEO0FBQ0YsR0FMRDs7QUFPQSxNQUFJLFNBQVMsU0FBVCxNQUFTLENBQVMsTUFBVCxFQUFpQjtBQUM1QixRQUFJLENBQUMsTUFBTCxFQUFhO0FBQ1gsZUFBUyxJQUFUO0FBQ0EsY0FBUSxpQkFBUixDQUEwQixNQUExQjtBQUNEO0FBQ0YsR0FMRDs7QUFPQSxNQUFJO0FBQ0YsU0FBSyxJQUFMLENBQVUsUUFBVixFQUFvQixPQUFwQixFQUE2QixNQUE3QjtBQUNELEdBRkQsQ0FFRSxPQUFPLENBQVAsRUFBVTtBQUNWLFdBQU8sQ0FBUDtBQUNEO0FBQ0YsQ0F4QkQ7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJDQSxtQkFBbUIsU0FBbkIsQ0FBNkIsa0JBQTdCLEdBQWtELFlBQVc7QUFDM0QsTUFBSSxDQUFDLEtBQUssVUFBVixFQUFzQjtBQUNwQixTQUFLLFVBQUwsR0FBa0IsSUFBbEI7QUFDQSxpQkFBTSxHQUFOLENBQVUsS0FBSyxpQkFBZixFQUFrQyxJQUFsQztBQUNEO0FBQ0YsQ0FMRDs7Ozs7OztBQWFBLG1CQUFtQixTQUFuQixDQUE2QixpQkFBN0IsR0FBaUQsWUFBVztBQUMxRCxTQUFPLEtBQUssZ0JBQUwsSUFBeUIsS0FBSyxnQkFBTCxDQUFzQixNQUF0RCxFQUE4RDtBQUM1RCxRQUFJLFVBQVUsS0FBSyxnQkFBbkI7QUFDQSxTQUFLLGdCQUFMLEdBQXdCLEVBQXhCOztBQUVBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxRQUFRLE1BQTVCLEVBQW9DLEdBQXBDLEVBQXlDO0FBQ3ZDLFdBQUssZ0JBQUwsQ0FBc0IsUUFBUSxDQUFSLENBQXRCLEVBQWtDLEtBQUssTUFBdkMsRUFBK0MsS0FBSyxPQUFwRDtBQUNEO0FBQ0Y7QUFDRCxPQUFLLFVBQUwsR0FBa0IsS0FBbEI7QUFDRCxDQVZEOzs7Ozs7Ozs7Ozs7O0FBd0JBLG1CQUFtQixTQUFuQixDQUE2QixnQkFBN0IsR0FBZ0QsVUFDaEQsYUFEZ0QsRUFDakMsS0FEaUMsRUFDMUIsTUFEMEIsRUFDbEI7QUFDNUIsTUFBSSxVQUFVLG1CQUFtQixNQUFuQixDQUEwQixTQUF4QyxFQUFtRDtBQUNqRCxrQkFBYyxXQUFkLENBQTBCLE1BQTFCO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsU0FBSyx5QkFBTDtBQUNBLGtCQUFjLFVBQWQsQ0FBeUIsTUFBekI7QUFDRDtBQUNGLENBUkQ7Ozs7Ozs7OztBQWtCQSxtQkFBbUIsU0FBbkIsQ0FBNkIseUJBQTdCLEdBQXlELFlBQVc7QUFDbEUsTUFBSSxDQUFKO0FBQ0EsTUFBSSxtQkFBbUIseUJBQW5CLEdBQStDLENBQW5ELEVBQXNEO0FBQ3BELFNBQUssSUFBSSxJQUFULEVBQWUsS0FBSyxFQUFFLHFCQUF0QixFQUE2QyxJQUFJLEVBQUUsT0FBbkQsRUFBNEQ7QUFDMUQsbUJBQWEsRUFBRSxxQkFBZjtBQUNBLFFBQUUscUJBQUYsR0FBMEIsQ0FBMUI7QUFDRDtBQUNGLEdBTEQsTUFLTyxJQUFJLG1CQUFtQix5QkFBbkIsS0FBaUQsQ0FBckQsRUFBd0Q7QUFDN0QsU0FBSyxJQUFJLElBQVQsRUFBZSxLQUFLLEVBQUUsc0JBQXRCLEVBQThDLElBQUksRUFBRSxPQUFwRCxFQUE2RDtBQUMzRCxRQUFFLHNCQUFGLEdBQTJCLEtBQTNCO0FBQ0Q7QUFDRjtBQUNGLENBWkQ7Ozs7Ozs7Ozs7Ozs7QUEwQkEsbUJBQW1CLHNCQUFuQixHQUE0QyxVQUFTLE9BQVQsRUFBa0IsTUFBbEIsRUFBMEI7QUFDcEUsTUFBSSxtQkFBbUIseUJBQW5CLEdBQStDLENBQW5ELEVBQXNEO0FBQ3BELFlBQVEscUJBQVIsR0FBZ0MsV0FBVyxZQUFXO0FBQ3BELHlCQUFtQixnQkFBbkIsQ0FBb0MsSUFBcEMsQ0FBeUMsSUFBekMsRUFBK0MsTUFBL0M7QUFDRCxLQUYrQixFQUU3QixtQkFBbUIseUJBRlUsQ0FBaEM7QUFJRCxHQUxELE1BS08sSUFBSSxtQkFBbUIseUJBQW5CLEtBQWlELENBQXJELEVBQXdEO0FBQzdELFlBQVEsc0JBQVIsR0FBaUMsSUFBakM7QUFDQSxpQkFBTSxHQUFOLENBQVUsWUFBVztBQUNuQixVQUFJLFFBQVEsc0JBQVosRUFBb0M7QUFDbEMsMkJBQW1CLGdCQUFuQixDQUFvQyxJQUFwQyxDQUF5QyxJQUF6QyxFQUErQyxNQUEvQztBQUNEO0FBQ0YsS0FKRDtBQUtEO0FBQ0YsQ0FkRDs7Ozs7Ozs7QUF1QkEsbUJBQW1CLGdCQUFuQixHQUFzQyxhQUFNLGNBQTVDOzs7Ozs7Ozs7Ozs7OztBQWVBLG1CQUFtQiw0QkFBbkIsR0FBa0QsVUFBUyxPQUFULEVBQWtCO0FBQ2xFLHFCQUFtQixnQkFBbkIsR0FBc0MsT0FBdEM7QUFDRCxDQUZEOzs7Ozs7Ozs7O0FBY0EsbUJBQW1CLGlCQUFuQjtBQUFBOztBQUNFLGtCQUFZLFdBQVosRUFBeUI7QUFBQTs7QUFBQSxpREFDdEIsa0JBQU0sV0FBTixDQURzQjs7QUFHdEIsUUFBSSxXQUFKLEVBQWlCO0FBQ2YsWUFBSyxPQUFMLEdBQWUsV0FBZjtBQUNEO0FBTHFCO0FBTXZCOztBQVBKO0FBQUEsRUFBcUQsS0FBckQ7OztBQVdBLG1CQUFtQixpQkFBbkIsQ0FBcUMsU0FBckMsQ0FBK0MsSUFBL0MsR0FBc0QsUUFBdEQ7O1FBRVEsa0IsR0FBQSxrQjtrQkFDTyxrQjs7O0FDejdCZjs7Ozs7O0FBRUE7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0lBS00sTTs7Ozs7Ozs7Ozs7Ozs7Ozs7UUFRRSxLLGtCQUFNLEksRUFBTSxTLEVBQVcsWSxFQUFjLGlCLEVBQW1CO0FBQzlELFNBQU8sSUFBSSxNQUFKLENBQVc7QUFDakIsYUFEaUI7QUFFakIsdUJBRmlCO0FBR2pCLDZCQUhpQjtBQUlqQjtBQUppQixHQUFYLEVBS0osS0FMSSxDQUFQO0FBTUEsRTs7Ozs7Ozs7O1FBT00sTSxxQkFBUztBQUNmLE1BQUksQ0FBQyxPQUFPLGNBQVosRUFBNEI7QUFDM0IsVUFBTyxjQUFQLEdBQXdCLG1CQUF4QjtBQUNBO0FBQ0QsU0FBTyxPQUFPLGNBQWQ7QUFDQSxFOzs7Ozs7Ozs7O1FBUU0sOEIsMkNBQStCLE0sRUFBUTtBQUM3QyxTQUFPLE9BQU8sZUFBUCxZQUFrQyxPQUFPLDJCQUFQLEVBQXpDO0FBQ0EsRTs7Ozs7OztrQkFLRCxPLHNCQUFVO0FBQUE7O0FBQ1QsT0FBSyxLQUFMLEdBQWEsb0JBQVUsS0FBSyxJQUFmLEVBQXFCO0FBQUEsVUFBTSxJQUFJLE9BQU8sYUFBWCxRQUFOO0FBQUEsR0FBckIsQ0FBYjtBQUNBLE9BQUssS0FBTCxDQUFXLE1BQVgsR0FBb0IsSUFBcEI7QUFDQSxTQUFPLE1BQVAsR0FBZ0IsU0FBaEIsQ0FBMEIsS0FBSyxLQUEvQjtBQUNBLEU7Ozs7Ozs7a0JBS0QsZSw4QkFBa0I7QUFDakIsU0FBTyxNQUFQLEdBQWdCLFdBQWhCLENBQTRCLEtBQUssS0FBakM7QUFDQSx1QkFBTSxlQUFOO0FBQ0EsRTs7Ozs7Ozs7OztrQkFRRCxlLDRCQUFnQixVLEVBQVksYSxFQUFlO0FBQzFDLFNBQU8sS0FBSyxLQUFLLDJCQUFMLEVBQUwsRUFBeUMsVUFBekMsRUFBcUQsYUFBckQsQ0FBUDtBQUNBLEU7Ozs7Ozs7O2tCQU1ELDJCLDBDQUE4QjtBQUM3QixNQUFJLHVCQUF1QixLQUFLLFNBQWhDO0FBQ0EsTUFBSSxZQUFLLFFBQUwsQ0FBYyxvQkFBZCxDQUFKLEVBQXlDO0FBQ3hDLDBCQUF1Qiw2QkFBa0IsY0FBbEIsQ0FBaUMsb0JBQWpDLENBQXZCO0FBQ0E7QUFDRCxTQUFPLG9CQUFQO0FBQ0EsRTs7Ozs7QUFHRixjQUFJLFFBQUosQ0FBYSxNQUFiOzs7Ozs7O0FBUUEsT0FBTyxLQUFQLEdBQWU7Ozs7OztBQU1kLFlBQVc7QUFDVixhQUFXLFlBQUssU0FETjtBQUVWLFNBQU87QUFGRyxFQU5HOzs7Ozs7QUFlZCxZQUFXLEVBZkc7Ozs7Ozs7QUF1QmQsWUFBVyxFQXZCRzs7Ozs7O0FBOEJkLG9CQUFtQjtBQUNsQixTQUFPO0FBRFcsRUE5Qkw7Ozs7Ozs7QUF1Q2QsZUFBYztBQUNiLFVBQVEsZ0JBQUMsR0FBRDtBQUFBLFVBQVMsTUFBTyxZQUFLLFVBQUwsQ0FBZ0IsR0FBaEIsSUFBdUIsR0FBdkIsR0FBNkI7QUFBQSxXQUFNLEdBQU47QUFBQSxJQUFwQyxHQUFpRCxJQUExRDtBQUFBO0FBREssRUF2Q0E7Ozs7Ozs7O0FBaURkLE9BQU0sRUFqRFE7Ozs7Ozs7O0FBMERkLHVCQUFzQjtBQUNyQixhQUFXLFlBQUssU0FESztBQUVyQixTQUFPO0FBRmM7QUExRFIsQ0FBZjs7Ozs7OztBQXFFQSxPQUFPLGVBQVAsR0FBeUIsSUFBekI7Ozs7Ozs7QUFPQSxPQUFPLFdBQVAsR0FBcUIsSUFBckI7O0lBRU0sZTs7Ozs7OztBQUtMLDBCQUFZLE1BQVosRUFBb0I7QUFBQTs7QUFBQSxnREFDbkIseUJBRG1COztBQUduQixNQUFJLENBQUMsTUFBTCxFQUFhO0FBQ1osU0FBTSxJQUFJLEtBQUosQ0FBVSw0Q0FBVixDQUFOO0FBQ0E7Ozs7OztBQU1ELFNBQUssTUFBTCxHQUFjLE1BQWQ7QUFYbUI7QUFZbkI7Ozs7Ozs7MkJBS0QsZSw4QkFBa0IsQ0FBRSxDOzs7Ozs7OzJCQUtwQixjLDZCQUFpQixDQUFFLEM7Ozs7Ozs7MkJBS25CLEksbUJBQU87QUFDTixNQUFJLFNBQVMsS0FBSyxNQUFsQjtBQUNBLE1BQUksaUJBQWlCLEtBQUssdUJBQUwsRUFBckI7QUFDQSxNQUFJLGNBQUosRUFBb0I7QUFDbkIsWUFBUyxjQUFUO0FBQ0E7O0FBRUQsU0FBTyxXQUFQLEdBQXFCLEtBQUssK0JBQUwsRUFBckI7QUFDQSxNQUFJLE9BQU8saUJBQVgsRUFBOEI7QUFDN0IsVUFBTyxXQUFQLEdBQXFCLGNBQU8sS0FBUCxDQUFhLEVBQWIsRUFBaUIsT0FBTyxXQUF4QixFQUFxQztBQUN6RCxnQkFBWSxPQUFPO0FBRHNDLElBQXJDLENBQXJCO0FBR0E7O0FBRUQsTUFBSSxLQUFLLE1BQUwsQ0FBWSxvQkFBWixJQUFvQyxPQUFPLDhCQUFQLENBQXNDLE1BQXRDLENBQXhDLEVBQXVGO0FBQ3RGLFVBQU8sZUFBUCxDQUF1QixRQUF2QixDQUFnQyxPQUFPLFdBQXZDO0FBQ0EsR0FGRCxNQUVPO0FBQ04sT0FBSSxPQUFPLGVBQVgsRUFBNEI7QUFDM0IsV0FBTyxlQUFQLENBQXVCLE9BQXZCO0FBQ0E7QUFDRCxVQUFPLGVBQVAsR0FBeUIsT0FBTyxlQUFQLENBQXVCLE9BQU8sV0FBOUIsRUFBMkMsT0FBTyxTQUFsRCxDQUF6QjtBQUNBO0FBQ0QsRTs7Ozs7OzsyQkFLRCxJLGlCQUFLLEksRUFBTTtBQUFBOztBQUNWLE9BQUssWUFBTCxDQUFrQixLQUFLLE1BQUwsQ0FBWSxTQUE5QjtBQUNBLE1BQUksV0FBVyxrQkFBbUIsT0FBbkIsRUFBZjtBQUNBLE1BQUksWUFBSyxNQUFMLENBQVksS0FBSyxNQUFMLENBQVksWUFBeEIsQ0FBSixFQUEyQztBQUMxQyxjQUFXLFNBQVMsSUFBVCxDQUFjO0FBQUEsV0FBTSx5QkFBTSxJQUFOLGNBQVcsSUFBWCxDQUFOO0FBQUEsSUFBZCxDQUFYO0FBQ0EsR0FGRCxNQUVPO0FBQ04sY0FBVyxTQUFTLElBQVQsQ0FBYztBQUFBLFdBQU0sT0FBSyxNQUFMLENBQVksWUFBWixDQUF5QixJQUF6QixDQUFOO0FBQUEsSUFBZCxDQUFYO0FBQ0E7QUFDRCxTQUFPLFNBQVMsSUFBVCxDQUFjLFVBQUMsV0FBRCxFQUFpQjtBQUNyQyxVQUFLLE1BQUwsQ0FBWSxRQUFaLEdBQXVCLElBQXZCO0FBQ0EsVUFBSyxNQUFMLENBQVksZUFBWixHQUE4QixXQUE5QjtBQUNBLFVBQU8sV0FBUDtBQUNBLEdBSk0sQ0FBUDtBQUtBLEU7Ozs7Ozs7Ozs7OzJCQVNELHVCLHNDQUEwQjtBQUN6QixNQUFJLGVBQWUsS0FBSyx1QkFBTCxDQUE2QixLQUFLLE1BQUwsQ0FBWSxRQUF6QyxDQUFuQjtBQUNBLE1BQUksaUJBQWlCLEtBQUssTUFBTCxDQUFZLFFBQWpDLEVBQTJDO0FBQzFDLE9BQUksZ0JBQWdCLE9BQU8sTUFBUCxHQUFnQixTQUFoQixDQUEwQixZQUExQixDQUFwQjtBQUNBLE9BQUksYUFBSixFQUFtQjtBQUNsQixXQUFPLGNBQWMsTUFBckI7QUFDQTtBQUNEO0FBQ0QsU0FBTyxJQUFQO0FBQ0EsRTs7Ozs7Ozs7OzJCQU9ELCtCLDhDQUFrQztBQUNqQyxNQUFJLFFBQVEsS0FBSyxNQUFMLENBQVksZUFBeEI7QUFDQSxNQUFJO0FBQ0gsVUFBTyxLQUFLLEtBQUwsQ0FBVyxLQUFYLENBQVA7QUFDQSxHQUZELENBRUUsT0FBTyxHQUFQLEVBQVk7QUFDYixVQUFPLFlBQUssZUFBTCxDQUFxQixLQUFyQixJQUE4QixLQUE5QixHQUFzQyxFQUE3QztBQUNBO0FBQ0QsRTs7Ozs7Ozs7Ozs7QUFRRixPQUFPLGFBQVAsR0FBdUIsZUFBdkI7O2tCQUVlLE07Ozs7Ozs7Ozs7QUNyU2Y7Ozs7QUFDQTs7Ozs7Ozs7Ozs7OztBQUNBLElBQUksU0FBSjtBQUNBLEtBQUssVUFBTCxDQUFnQixVQUFTLE9BQVQsRUFBa0I7Ozs7Ozs7Ozs7QUFVbEMsT0FBSyxNQUFMLENBQVksdUJBQVo7OztBQUdBLE1BQUksTUFBTSxLQUFLLE9BQUwsQ0FBYSxLQUFiLENBQVY7O0FBRUEsTUFBSSxVQUFVLEtBQUssT0FBTCxDQUFhLFNBQWIsQ0FBZDs7QUFFQSxPQUFLLE9BQUwsQ0FBYSxnQkFBYjs7QUFFQSxPQUFLLE9BQUwsQ0FBYSxjQUFiO0FBQ0EsTUFBSSxpQkFBaUIsS0FBSyxPQUFMLENBQWEsZ0JBQWIsQ0FBckI7QUFDQSxNQUFJLFVBQVUsZUFBZSxXQUE3QjtBQUNBLE1BQUksV0FBVyxlQUFlLFlBQTlCO0FBQ0EsTUFBSSxVQUFVLGVBQWUsV0FBN0I7QUFDQSxNQUFJLGdCQUFnQixlQUFlLGdCQUFuQztBQUNBLE1BQUksY0FBYyxlQUFlLGNBQWpDO0FBQ0EsTUFBSSxRQUFRLGVBQWUsSUFBM0I7QUFDQSxNQUFJLFFBQVEsZUFBZSxJQUEzQjs7Ozs7Ozs7O0FBVUEsV0FBUyxPQUFULENBQWlCLFFBQWpCLEVBQTJCLFdBQTNCLEVBQXdDLFVBQXhDLEVBQW9EO0FBQ2xELGVBQVcsWUFBWSxFQUF2QjtBQUNBLFlBQVEsTUFBUixFQUFnQixJQUFoQixFQUFzQixJQUF0QixFQUNJLElBREosRUFDVSxTQUFTLEVBRG5CLEVBRUksS0FGSixFQUVXLGFBRlg7QUFHRDtBQUNELFVBQVEsTUFBUixHQUFpQixPQUFqQjtBQUNBLE1BQUksS0FBSyxLQUFULEVBQWdCO0FBQ2QsWUFBUSxlQUFSLEdBQTBCLGVBQTFCO0FBQ0Q7O0FBRUQsVUFBUSxNQUFSLENBQWUsTUFBZixHQUF3QixDQUFDLElBQUQsQ0FBeEI7QUFDQSxVQUFRLE1BQVIsQ0FBZSxLQUFmLEdBQXVCLEVBQUMsTUFBSyxLQUFOLEVBQXZCO0FBQ0EsVUFRaUIsU0FSakIsZUFBWSxPQUFaO0FBQ0EsU0FBTyxPQUFQO0FBRUMsQ0FyREQ7O0lBdURNLE07Ozs7Ozs7Ozs7OztBQUNOLGNBQUksUUFBSixDQUFhLE1BQWIsRUFBcUIsU0FBckI7a0JBQ2UsUztRQUNOLE0sR0FBQSxNO1FBQVEsUyxHQUFBLFM7Ozs7OE5DOURqQixrRUFFQSxDQUFDLFVBQVcsQ0FDWixLQUFLLGVBQUwsQ0FBdUIsSUFBdkIsQ0FDQSxLQUFLLElBQUwsQ0FBWSxLQUFLLElBQUwsRUFBYSxFQUF6QixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWlDQSxJQUFJLFNBQVcsS0FBZixDOzs7Ozs7R0FVQSxJQUFJLEtBQU8sS0FBSyxJQUFMLEVBQWEsRUFBeEIsQzs7R0FNQSxLQUFLLE1BQUwsQ0FBYyxJQUFkLEM7Ozs7Ozs7Ozs7Ozs7OztHQW1CQSxLQUFLLE1BQUwsQ0FBWSwwQkFBWixDOzs7Ozs7Ozs7Ozs7Ozs7OztHQXFCQSxLQUFLLE1BQUwsQ0FBWSxlQUFaLEM7Ozs7Ozs7R0FXQSxLQUFLLEtBQUwsQ0FBYSxTQUFTLEdBQVQsQ0FBYyxDOztBQUd6QixPQUFPLE1BQVEsS0FBSyxDQUFwQixDQUNELENBSkQsQzs7Ozs7Ozs7OztHQWtCQSxLQUFLLFdBQUwsQ0FBbUIsU0FBUyxJQUFULENBQWUsVUFBZixDQUEyQixvQkFBM0IsQ0FBaUQsQ0FDbEUsSUFBSSxNQUFRLEtBQUssS0FBTCxDQUFXLEdBQVgsQ0FBWixDQUNBLElBQUksSUFBTSxzQkFBd0IsS0FBSyxNQUF2QyxDOzs7QUFLQSxHQUFJLEVBQUUsTUFBTSxDQUFOLEtBQVksR0FBZCxHQUFzQixJQUFJLFVBQTlCLENBQTBDLENBQ3hDLElBQUksVUFBSixDQUFlLE9BQVMsTUFBTSxDQUFOLENBQXhCLEVBQ0QsQzs7Ozs7QUFRRCxJQUFLLElBQUksSUFBVCxDQUFlLE1BQU0sTUFBTixHQUFpQixLQUFPLE1BQU0sS0FBTixFQUF4QixDQUFmLEVBQXdELENBQ3RELEdBQUksQ0FBQyxNQUFNLE1BQVAsRUFBaUIsS0FBSyxLQUFMLENBQVcsVUFBWCxDQUFyQixDQUE2QyxDO0FBRTNDLElBQUksSUFBSixFQUFZLFVBQVosQ0FDRCxDQUhELEtBR08sR0FBSSxJQUFJLElBQUosQ0FBSixDQUFlLENBQ3BCLElBQU0sSUFBSSxJQUFKLENBQU4sQ0FDRCxDQUZNLEtBRUEsQ0FDTCxJQUFNLElBQUksSUFBSixFQUFZLEVBQWxCLENBQ0QsQ0FDRixDQUNGLENBM0JELEM7Ozs7Ozs7OztHQXdDQSxLQUFLLE1BQUwsQ0FBYyxTQUFTLElBQVQsQ0FBZSxZQUFmLENBQTZCLENBQ3pDLElBQUksTUFBUSxZQUFaLENBQ0EsR0FBSSxDQUFDLFFBQUwsQ0FBZSxDQUNiLEdBQUksS0FBSyxNQUFMLENBQVksMEJBQVosRUFDQSxPQUFPLFNBQVAsQ0FBaUIsY0FBakIsQ0FBZ0MsSUFBaEMsQ0FDSSxLQUFLLE1BQUwsQ0FBWSwwQkFEaEIsQ0FDNEMsSUFENUMsQ0FESixDQUV1RCxDQUNyRCxNQUFRLEtBQUssTUFBTCxDQUFZLDBCQUFaLENBQXVDLElBQXZDLENBQVIsQ0FDRCxDQUpELEtBSU8sR0FDSCxLQUFLLE1BQUwsQ0FBWSxlQUFaLEVBQ0EsT0FBTyxTQUFQLENBQWlCLGNBQWpCLENBQWdDLElBQWhDLENBQ0ksS0FBSyxNQUFMLENBQVksZUFEaEIsQ0FDaUMsSUFEakMsQ0FGRyxDQUdxQyxDQUMxQyxNQUFRLEtBQUssTUFBTCxDQUFZLGVBQVosQ0FBNEIsSUFBNUIsQ0FBUixDQUNELENBQ0YsQ0FDRCxLQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBdUIsS0FBdkIsRUFDRCxDQWZELEM7Ozs7Ozs7R0EwQkEsS0FBSyxNQUFMLENBQVksWUFBWixDQUEwQixJQUExQixFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FzQkEsS0FBSyxNQUFMLENBQVksYUFBWixDQUEyQixJQUEzQixFOzs7Ozs7Ozs7OztHQWNBLEtBQUssTUFBTCxDQUFZLG1CQUFaLENBQWlDLElBQWpDLEU7Ozs7Ozs7R0FXQSxLQUFLLE1BQUwsQ0FBWSw2QkFBWixDQUEyQyxLQUEzQyxFOzs7R0FPQSxLQUFLLE1BQUwsQ0FBWSw4QkFBWixDQUE0QyxVQUFZLENBQUMsS0FBSyxLQUE5RCxFOzs7R0FPQSxLQUFLLE1BQUwsQ0FBWSw0Q0FBWixDQUEwRCxLQUExRCxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F5QkEsS0FBSyxPQUFMLENBQWUsU0FBUyxJQUFULENBQWUsQ0FDNUIsR0FBSSxDQUFDLFFBQUwsQ0FBZSxDOztBQUdiLEdBQUksS0FBSyxXQUFMLENBQWlCLElBQWpCLENBQUosQ0FBNEIsQ0FDMUIsTUFBTSxNQUFNLGNBQWdCLElBQWhCLENBQXVCLHFCQUE3QixDQUFOLENBQ0QsQ0FDRixDQUVELEtBQUssbUJBQUwsQ0FBeUIsSUFBekIsRUFDRCxDQVZELEM7Ozs7O0dBbUJBLEtBQUssbUJBQUwsQ0FBMkIsU0FBUyxJQUFULENBQWUsT0FBZixDQUF3QixDQUNqRCxHQUFJLENBQUMsUUFBTCxDQUFlLENBQ2IsT0FBTyxLQUFLLG1CQUFMLENBQXlCLElBQXpCLENBQVAsQ0FFQSxJQUFJLFVBQVksSUFBaEIsQ0FDQSxNQUFRLFVBQVksVUFBVSxTQUFWLENBQW9CLENBQXBCLENBQXVCLFVBQVUsV0FBVixDQUFzQixHQUF0QixDQUF2QixDQUFwQixDQUF5RSxDQUN2RSxHQUFJLEtBQUssZUFBTCxDQUFxQixTQUFyQixDQUFKLENBQXFDLENBQ25DLE1BQ0QsQ0FDRCxLQUFLLG1CQUFMLENBQXlCLFNBQXpCLEVBQXNDLElBQXRDLENBQ0QsQ0FDRixDQUVELEtBQUssV0FBTCxDQUFpQixJQUFqQixDQUF1QixPQUF2QixFQUNELENBZEQsQzs7Ozs7OztHQXlCQSxLQUFLLGdCQUFMLENBQXdCLDZCQUF4QixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWlDQSxLQUFLLE1BQUwsQ0FBYyxTQUFTLElBQVQsQ0FBZSxDQUMzQixHQUFJLENBQUMsS0FBSyxRQUFMLENBQWMsSUFBZCxDQUFELEVBQXdCLENBQUMsSUFBekIsRUFDQSxLQUFLLE1BQUwsQ0FBWSxLQUFLLGdCQUFqQixHQUFzQyxDQUFDLENBRDNDLENBQzhDLENBQzVDLE1BQU0sTUFBTSwyQkFBTixDQUFOLENBQ0QsQ0FDRCxHQUFJLENBQUMsS0FBSyxpQkFBTCxFQUFMLENBQStCLENBQzdCLE1BQU0sTUFBTSxVQUFZLElBQVosQ0FBbUIsK0JBQXpCLENBQU4sQ0FDRCxDQUNELEdBQUksS0FBSyxrQkFBTCxDQUF3QixVQUE1QixDQUF3QyxDQUN0QyxNQUFNLE1BQU0saURBQU4sQ0FBTixDQUNELEM7QUFHRCxLQUFLLGtCQUFMLENBQXdCLFVBQXhCLENBQXFDLElBQXJDLENBQ0EsR0FBSSxDQUFDLFFBQUwsQ0FBZSxDOztBQUdiLEdBQUksS0FBSyxXQUFMLENBQWlCLElBQWpCLENBQUosQ0FBNEIsQ0FDMUIsTUFBTSxNQUFNLGNBQWdCLElBQWhCLENBQXVCLHFCQUE3QixDQUFOLENBQ0QsQ0FDRCxPQUFPLEtBQUssbUJBQUwsQ0FBeUIsSUFBekIsQ0FBUCxDQUNELENBQ0YsQ0F0QkQsQzs7Ozs7Ozs7O0dBbUNBLEtBQUssTUFBTCxDQUFZLEdBQVosQ0FBa0IsU0FBUyxJQUFULENBQWUsQ0FDL0IsT0FBTyxLQUFLLE1BQUwsQ0FBWSxZQUFaLENBQXlCLElBQXpCLENBQVAsQ0FDRCxDQUZELEM7Ozs7R0FVQSxLQUFLLE1BQUwsQ0FBWSxZQUFaLENBQTJCLFNBQVMsSUFBVCxDQUFlLENBQ3hDLEdBQUksQ0FBQyxRQUFMLENBQWUsQ0FDYixHQUFJLEtBQUssV0FBTCxDQUFpQixJQUFqQixDQUFKLENBQTRCLEM7QUFFMUIsT0FBTyxRQUFRLEtBQUssY0FBYixDQUE4QixLQUFLLGNBQUwsQ0FBb0IsSUFBcEIsQ0FBOUIsQ0FDOEIsS0FBSyxlQUFMLENBQXFCLElBQXJCLENBRHJDLENBRUQsQ0FKRCxLQUlPLENBQ0wsT0FBTyxJQUFQLENBQ0QsQ0FDRixDQUNGLENBVkQsQzs7R0FnQkEsS0FBSyxrQkFBTCxDQUEwQixJQUExQixDOzs7R0FPQSxLQUFLLGlCQUFMLENBQXlCLFVBQVcsQ0FDbEMsT0FBTyxLQUFLLGtCQUFMLEVBQTJCLElBQWxDLENBQ0QsQ0FGRCxDOzs7OztHQVdBLEtBQUssTUFBTCxDQUFZLHNCQUFaLENBQXFDLFVBQVcsQ0FDOUMsR0FBSSxDQUFDLFFBQUQsRUFBYSxDQUFDLEtBQUssaUJBQUwsRUFBbEIsQ0FBNEMsQ0FDMUMsTUFBTSxJQUFJLEtBQUosQ0FDRiwwREFDQSxzQkFGRSxDQUFOLENBR0QsQ0FDRCxHQUFJLENBQUMsUUFBRCxFQUFhLENBQUMsS0FBSyxrQkFBTCxDQUF3QixVQUExQyxDQUFzRCxDQUNwRCxNQUFNLE1BQ0YsdUNBQ0EscUNBRkUsQ0FBTixDQUdELENBQ0QsS0FBSyxrQkFBTCxDQUF3QixzQkFBeEIsQ0FBaUQsSUFBakQsQ0FDRCxDQVpELEM7Ozs7Ozs7Ozs7R0EwQkEsS0FBSyxXQUFMLENBQW1CLFNBQVMsV0FBVCxDQUFzQixDQUN2QyxHQUFJLEtBQUssdUJBQVQsQ0FBa0MsQ0FDaEMsWUFBYyxhQUFlLEVBQTdCLENBQ0EsTUFBTSxNQUNGLHVEQUNDLFlBQWMsS0FBTyxXQUFyQixDQUFtQyxHQURwQyxDQURFLENBQU4sQ0FHRCxDQUNGLENBUEQsQ0FTQSxHQUFJLENBQUMsUUFBTCxDQUFlLEM7Ozs7OztLQVFiLEtBQUssV0FBTCxDQUFtQixTQUFTLElBQVQsQ0FBZSxDQUNoQyxPQUFRLFFBQVEsS0FBSyxjQUFkLEVBQ0YsQ0FBQyxLQUFLLG1CQUFMLENBQXlCLElBQXpCLENBQUQsRUFDQSxLQUFLLGVBQUwsQ0FBcUIsS0FBSyxlQUFMLENBQXFCLElBQXJCLENBQXJCLENBRkwsQ0FHRCxDQUpELEM7Ozs7Ozs7S0FjQSxLQUFLLG1CQUFMLENBQTJCLENBQUMsY0FBZSxJQUFoQixDQUEzQixDOzs7O0FBTUQsQzs7Ozs7Ozs7OztHQWNELEtBQUssZUFBTCxDQUF1QixTQUFTLElBQVQsQ0FBZSxPQUFmLENBQXdCLENBQzdDLElBQUksTUFBUSxLQUFLLEtBQUwsQ0FBVyxHQUFYLENBQVosQ0FDQSxJQUFJLElBQU0sU0FBVyxLQUFLLE1BQTFCLENBQ0EsSUFBSyxJQUFJLElBQVQsQ0FBZSxLQUFPLE1BQU0sS0FBTixFQUF0QixFQUFzQyxDQUNwQyxHQUFJLEtBQUssZUFBTCxDQUFxQixJQUFJLElBQUosQ0FBckIsQ0FBSixDQUFxQyxDQUNuQyxJQUFNLElBQUksSUFBSixDQUFOLENBQ0QsQ0FGRCxLQUVPLENBQ0wsT0FBTyxJQUFQLENBQ0QsQ0FDRixDQUNELE9BQU8sR0FBUCxDQUNELENBWEQsQzs7Ozs7OztHQXNCQSxLQUFLLFNBQUwsQ0FBaUIsU0FBUyxHQUFULENBQWMsVUFBZCxDQUEwQixDQUN6QyxJQUFJLE9BQVMsWUFBYyxLQUFLLE1BQWhDLENBQ0EsSUFBSyxJQUFJLENBQVQsSUFBYyxHQUFkLENBQW1CLENBQ2pCLE9BQU8sQ0FBUCxFQUFZLElBQUksQ0FBSixDQUFaLENBQ0QsQ0FDRixDQUxELEM7Ozs7Ozs7Ozs7O0dBb0JBLEtBQUssYUFBTCxDQUFxQixTQUFTLE9BQVQsQ0FBa0IsUUFBbEIsQ0FBNEIsUUFBNUIsQ0FBc0MsYUFBdEMsQ0FBcUQsQ0FDeEUsR0FBSSxLQUFLLG9CQUFULENBQStCLENBQzdCLElBQUksT0FBSixDQUFhLE9BQWIsQ0FDQSxJQUFJLEtBQU8sUUFBUSxPQUFSLENBQWdCLEtBQWhCLENBQXVCLEdBQXZCLENBQVgsQ0FDQSxJQUFJLEtBQU8sS0FBSyxhQUFoQixDQUNBLEdBQUksQ0FBQyxhQUFELEVBQWtCLE9BQU8sYUFBUCxHQUF5QixTQUEvQyxDQUEwRCxDQUN4RCxjQUFnQixjQUFnQixDQUFDLFNBQVUsTUFBWCxDQUFoQixDQUFxQyxFQUFyRCxDQUNELENBQ0QsSUFBSyxJQUFJLEVBQUksQ0FBYixDQUFnQixRQUFVLFNBQVMsQ0FBVCxDQUExQixDQUF1QyxHQUF2QyxDQUE0QyxDQUMxQyxLQUFLLFVBQUwsQ0FBZ0IsT0FBaEIsRUFBMkIsSUFBM0IsQ0FDQSxLQUFLLFlBQUwsQ0FBa0IsSUFBbEIsRUFBMEIsY0FBYyxRQUFkLEdBQTJCLE1BQXJELENBQ0QsQ0FDRCxJQUFLLElBQUksRUFBSSxDQUFiLENBQWdCLFFBQVUsU0FBUyxDQUFULENBQTFCLENBQXVDLEdBQXZDLENBQTRDLENBQzFDLEdBQUksRUFBRSxRQUFRLEtBQUssUUFBZixDQUFKLENBQThCLENBQzVCLEtBQUssUUFBTCxDQUFjLElBQWQsRUFBc0IsRUFBdEIsQ0FDRCxDQUNELEtBQUssUUFBTCxDQUFjLElBQWQsRUFBb0IsT0FBcEIsRUFBK0IsSUFBL0IsQ0FDRCxDQUNGLENBQ0YsQ0FuQkQsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FxREEsS0FBSyxNQUFMLENBQVksMEJBQVosQ0FBd0MsSUFBeEMsRTs7O0dBT0EsS0FBSyxhQUFMLENBQXFCLFNBQVMsR0FBVCxDQUFjLENBQ2pDLEdBQUksS0FBSyxNQUFMLENBQVksT0FBaEIsQ0FBeUIsQ0FDdkIsS0FBSyxNQUFMLENBQVksT0FBWixDQUFvQixPQUFwQixFQUE2QixHQUE3QixFQUNELENBQ0YsQ0FKRCxDOzs7Ozs7Ozs7O0dBa0JBLEtBQUssT0FBTCxDQUFlLFNBQVMsSUFBVCxDQUFlLEM7QUFFNUIsR0FBSSxDQUFDLFFBQUwsQ0FBZSxDQUNiLEdBQUksS0FBSyxtQkFBTCxFQUE0QixLQUFLLFVBQXJDLENBQWlELENBQy9DLEtBQUssd0JBQUwsQ0FBOEIsSUFBOUIsRUFDRCxDQUVELEdBQUksS0FBSyxXQUFMLENBQWlCLElBQWpCLENBQUosQ0FBNEIsQ0FDMUIsR0FBSSxLQUFLLGlCQUFMLEVBQUosQ0FBOEIsQ0FDNUIsT0FBTyxLQUFLLE1BQUwsQ0FBWSxZQUFaLENBQXlCLElBQXpCLENBQVAsQ0FDRCxDQUZELEtBRU8sQ0FDTCxPQUFPLElBQVAsQ0FDRCxDQUNGLENBRUQsR0FBSSxLQUFLLG1CQUFULENBQThCLENBQzVCLElBQUksS0FBTyxLQUFLLGdCQUFMLENBQXNCLElBQXRCLENBQVgsQ0FDQSxHQUFJLElBQUosQ0FBVSxDQUNSLEtBQUssYUFBTCxDQUFtQixJQUFuQixFQUNBLE9BQU8sSUFBUCxDQUNELENBQ0YsQ0FFRCxJQUFJLGFBQWUsZ0NBQWtDLElBQXJELENBQ0EsS0FBSyxhQUFMLENBQW1CLFlBQW5CLEVBRUEsTUFBTSxNQUFNLFlBQU4sQ0FBTixDQUNELENBQ0YsQ0E1QkQsQzs7O0dBbUNBLEtBQUssUUFBTCxDQUFnQixFQUFoQixDOzs7R0FPQSxLQUFLLE1BQUwsQ0FBWSxpQkFBWixDOzs7R0FPQSxLQUFLLE1BQUwsQ0FBWSxlQUFaLEM7Ozs7Ozs7OztHQWFBLEtBQUssTUFBTCxDQUFZLHFCQUFaLEM7OztHQU9BLEtBQUssWUFBTCxDQUFvQixVQUFXLENBQUUsQ0FBakMsQzs7Ozs7Ozs7Ozs7O0dBZ0JBLEtBQUssY0FBTCxDQUFzQixVQUFXLENBQy9CLE1BQU0sTUFBTSwrQkFBTixDQUFOLENBQ0QsQ0FGRCxDOzs7OztHQVdBLEtBQUssa0JBQUwsQ0FBMEIsU0FBUyxJQUFULENBQWUsQ0FDdkMsS0FBSyxXQUFMLENBQW1CLFVBQVcsQ0FDNUIsR0FBSSxLQUFLLFNBQVQsQ0FBb0IsQ0FDbEIsT0FBTyxLQUFLLFNBQVosQ0FDRCxDQUNELEdBQUksS0FBSyxLQUFULENBQWdCLEM7QUFFZCxLQUFLLHVCQUFMLENBQTZCLEtBQUssdUJBQUwsQ0FBNkIsTUFBMUQsRUFBb0UsSUFBcEUsQ0FDRCxDQUNELE9BQU8sS0FBSyxTQUFMLENBQWlCLElBQUksSUFBSixFQUF4QixDQUNELENBVEQsQ0FVRCxDQVhELEM7Ozs7OztHQXFCQSxLQUFLLHVCQUFMLENBQStCLEVBQS9CLEM7Ozs7OztHQVVBLEtBQUssTUFBTCxDQUFZLDZCQUFaLENBQTJDLElBQTNDLEU7OztHQU9BLEtBQUssTUFBTCxDQUFZLDBCQUFaLENBQXdDLEtBQUssS0FBN0MsRTs7OztHQVFBLEtBQUssY0FBTCxDQUFzQixFQUF0QixDOzs7R0FPQSxLQUFLLG9CQUFMLENBQTRCLENBQUMsUUFBRCxFQUFhLEtBQUssbUJBQTlDLENBR0EsR0FBSSxLQUFLLG9CQUFULENBQStCLEM7Ozs7Ozs7Ozs7OztLQWM3QixLQUFLLGFBQUwsQ0FBcUIsQ0FDbkIsYUFBYyxFQURLLEM7QUFHbkIsV0FBWSxFQUhPLEM7QUFLbkIsU0FBVSxFQUxTLEM7O0FBUW5CLFFBQVMsRUFSVSxDQVVuQixRQUFTLEVBVlUsQztBQVluQixTQUFVLEU7QUFaUyxDQUFyQixDOzs7O0tBcUJBLEtBQUssZUFBTCxDQUF1QixVQUFXLEMsd0JBRWhDLElBQUksSUFBTSxLQUFLLE1BQUwsQ0FBWSxRQUF0QixDQUNBLE9BQU8sS0FBTyxJQUFQLEVBQWUsV0FBVyxHQUFqQyxDO0FBQ0QsQ0FKRCxDOzs7S0FXQSxLQUFLLGFBQUwsQ0FBcUIsVUFBVyxDQUM5QixHQUFJLEtBQUssS0FBTCxDQUFXLEtBQUssTUFBTCxDQUFZLGlCQUF2QixDQUFKLENBQStDLENBQzdDLEtBQUssUUFBTCxDQUFnQixLQUFLLE1BQUwsQ0FBWSxpQkFBNUIsQ0FDQSxPQUNELENBSEQsS0FHTyxHQUFJLENBQUMsS0FBSyxlQUFMLEVBQUwsQ0FBNkIsQ0FDbEMsT0FDRCxDLHdCQUVELElBQUksSUFBTSxLQUFLLE1BQUwsQ0FBWSxRQUF0QixDQUNBLElBQUksUUFBVSxJQUFJLG9CQUFKLENBQXlCLFFBQXpCLENBQWQsQzs7QUFHQSxJQUFLLElBQUksRUFBSSxRQUFRLE1BQVIsQ0FBaUIsQ0FBOUIsQ0FBaUMsR0FBSyxDQUF0QyxDQUF5QyxFQUFFLENBQTNDLENBQThDLENBQzVDLElBQUksTyxrQ0FBNEMsUUFBUSxDQUFSLENBQWhELENBQ0EsSUFBSSxJQUFNLE9BQU8sR0FBakIsQ0FDQSxJQUFJLE1BQVEsSUFBSSxXQUFKLENBQWdCLEdBQWhCLENBQVosQ0FDQSxJQUFJLEVBQUksT0FBUyxDQUFDLENBQVYsQ0FBYyxJQUFJLE1BQWxCLENBQTJCLEtBQW5DLENBQ0EsR0FBSSxJQUFJLE1BQUosQ0FBVyxFQUFJLENBQWYsQ0FBa0IsQ0FBbEIsR0FBd0IsU0FBNUIsQ0FBdUMsQ0FDckMsS0FBSyxRQUFMLENBQWdCLElBQUksTUFBSixDQUFXLENBQVgsQ0FBYyxFQUFJLENBQWxCLENBQWhCLENBQ0EsT0FDRCxDQUNGLENBQ0YsQ0F0QkQsQzs7Ozs7O0tBZ0NBLEtBQUssYUFBTCxDQUFxQixTQUFTLEdBQVQsQ0FBYyxjQUFkLENBQThCLENBQ2pELElBQUksYUFDQSxLQUFLLE1BQUwsQ0FBWSxxQkFBWixFQUFxQyxLQUFLLGVBRDlDLENBRUEsR0FBSSxhQUFhLEdBQWIsQ0FBa0IsY0FBbEIsQ0FBSixDQUF1QyxDQUNyQyxLQUFLLGFBQUwsQ0FBbUIsT0FBbkIsQ0FBMkIsR0FBM0IsRUFBa0MsSUFBbEMsQ0FDRCxDQUNGLENBTkQsQyxpQ0FVQSxLQUFLLFVBQUwsQ0FDSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLE1BQUwsQ0FBWSxJQUFiLEVBQXFCLEtBQUssTUFBTCxDQUFZLFFBQWpDLEVBQTZDLEtBQUssTUFBTCxDQUFZLFFBQVosQ0FBcUIsR0FBcEUsQ0FETCxDOzs7O0tBU0EsS0FBSyxhQUFMLENBQXFCLFNBQVMsR0FBVCxDQUFjLEM7O0FBR2pDLElBQUksVUFBWSxnQ0FBa0MsR0FBbEMsQ0FBd0MsS0FBeEQsQ0FFQSxHQUFJLEtBQUssYUFBTCxDQUFtQixFQUFuQixDQUF1QixTQUF2QixDQUFKLENBQXVDLENBQ3JDLEtBQUssYUFBTCxDQUFtQixPQUFuQixDQUEyQixHQUEzQixFQUFrQyxJQUFsQyxDQUNELENBQ0YsQ0FSRCxDLGlDQVlBLEtBQUssY0FBTCxDQUFzQixFQUF0QixDOzs7Ozs7O0tBV0EsS0FBSyxXQUFMLENBQW1CLFNBQVMsTUFBVCxDQUFpQixVQUFqQixDQUE2QixDQUM5QyxHQUFJLENBQUMsS0FBSyxzQkFBTixFQUFnQyxDQUFDLEtBQUssS0FBTCxDQUFXLEtBQUssTUFBTCxDQUFZLElBQXZCLENBQXJDLENBQW1FLENBQ2pFLE9BQU8sR0FDSCxxQ0FERyxDQUVILGVBRkcsQ0FFZSxVQUZmLENBR0gsSUFIRyxDO0FBSUgsaUJBSkcsQ0FLSCxLQUxHLENBTUgsa0JBTkcsQ0FNa0IsTUFObEIsQ0FNMkIsSUFObEMsQ0FPRCxDQVJELEtBUU8sQ0FDTCxPQUFPLEdBQ0gsa0JBREcsQ0FFSCxLQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLFNBQWpCLENBQ0ksV0FBYSxrQkFBYixDQUFrQyxNQUFsQyxDQUEyQyxJQUQvQyxDQUZHLENBSUgsSUFKSixDQUtELENBQ0YsQ0FoQkQsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBNENBLEtBQUssa0JBQUwsQ0FBMEIsVUFBVyxDQUNuQyxJQUFJLE1BQVEsS0FBSyxjQUFMLENBQW9CLE1BQWhDLENBQ0EsR0FBSSxNQUFRLENBQVosQ0FBZSxDQUNiLElBQUksTUFBUSxLQUFLLGNBQWpCLENBQ0EsS0FBSyxjQUFMLENBQXNCLEVBQXRCLENBQ0EsSUFBSyxJQUFJLEVBQUksQ0FBYixDQUFnQixFQUFJLEtBQXBCLENBQTJCLEdBQTNCLENBQWdDLENBQzlCLElBQUksS0FBTyxNQUFNLENBQU4sQ0FBWCxDQUNBLEtBQUsseUJBQUwsQ0FBK0IsSUFBL0IsRUFDRCxDQUNGLENBQ0YsQ0FWRCxDOzs7OztLQW1CQSxLQUFLLHdCQUFMLENBQWdDLFNBQVMsSUFBVCxDQUFlLENBQzdDLEdBQUksS0FBSyxpQkFBTCxDQUF1QixJQUF2QixHQUFnQyxLQUFLLG9CQUFMLENBQTBCLElBQTFCLENBQXBDLENBQXFFLENBQ25FLElBQUksS0FBTyxLQUFLLGdCQUFMLENBQXNCLElBQXRCLENBQVgsQ0FDQSxLQUFLLHlCQUFMLENBQStCLEtBQUssUUFBTCxDQUFnQixJQUEvQyxFQUNELENBQ0YsQ0FMRCxDOzs7OztLQWFBLEtBQUssaUJBQUwsQ0FBeUIsU0FBUyxJQUFULENBQWUsQ0FDdEMsSUFBSSxLQUFPLEtBQUssZ0JBQUwsQ0FBc0IsSUFBdEIsQ0FBWCxDQUNBLEdBQUksTUFBUSxLQUFLLGFBQUwsQ0FBbUIsWUFBbkIsQ0FBZ0MsSUFBaEMsQ0FBWixDQUFtRCxDQUNqRCxJQUFJLFFBQVUsS0FBSyxRQUFMLENBQWdCLElBQTlCLENBQ0EsT0FBUSxPQUFELElBQWEsS0FBSyxhQUFMLENBQW1CLFFBQXZDLENBQ0QsQ0FDRCxPQUFPLEtBQVAsQ0FDRCxDQVBELEM7Ozs7OztLQWdCQSxLQUFLLG9CQUFMLENBQTRCLFNBQVMsSUFBVCxDQUFlLENBQ3pDLElBQUksS0FBTyxLQUFLLGdCQUFMLENBQXNCLElBQXRCLENBQVgsQ0FDQSxHQUFJLE1BQVMsUUFBUSxLQUFLLGFBQUwsQ0FBbUIsUUFBeEMsQ0FBbUQsQ0FDakQsSUFBSyxJQUFJLFdBQVQsSUFBd0IsS0FBSyxhQUFMLENBQW1CLFFBQW5CLENBQTRCLElBQTVCLENBQXhCLENBQTJELENBQ3pELEdBQUksQ0FBQyxLQUFLLFdBQUwsQ0FBaUIsV0FBakIsQ0FBRCxFQUNBLENBQUMsS0FBSyxpQkFBTCxDQUF1QixXQUF2QixDQURMLENBQzBDLENBQ3hDLE9BQU8sS0FBUCxDQUNELENBQ0YsQ0FDRixDQUNELE9BQU8sSUFBUCxDQUNELENBWEQsQzs7O0tBa0JBLEtBQUsseUJBQUwsQ0FBaUMsU0FBUyxPQUFULENBQWtCLENBQ2pELEdBQUksV0FBVyxLQUFLLGFBQUwsQ0FBbUIsUUFBbEMsQ0FBNEMsQ0FDMUMsSUFBSSxJQUFNLEtBQUssYUFBTCxDQUFtQixRQUFuQixDQUE0QixPQUE1QixDQUFWLENBQ0EsT0FBTyxLQUFLLGFBQUwsQ0FBbUIsUUFBbkIsQ0FBNEIsT0FBNUIsQ0FBUCxDQUNBLEtBQUssVUFBTCxDQUFnQixHQUFoQixFQUNELENBQ0YsQ0FORCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7S0E0QkEsS0FBSyxpQkFBTCxDQUF5QixTQUFTLEdBQVQsQ0FBYyxDOzs7QUFJckMsS0FBSyxzQkFBTCxDQUE0QixHQUE1QixFQUNELENBTEQsQzs7S0FXQSxLQUFLLFVBQUwsQ0FBa0IsU0FBUyxTQUFULENBQW9CLEM7Ozs7O0FBTXBDLElBQUksY0FBZ0IsS0FBSyxrQkFBekIsQ0FDQSxHQUFJLENBQ0YsS0FBSyxrQkFBTCxDQUEwQixDQUN4QixXQUFZLFNBRFksQ0FFeEIsdUJBQXdCLEtBRkEsQ0FBMUIsQ0FJQSxJQUFJLE9BQUosQ0FDQSxHQUFJLEtBQUssVUFBTCxDQUFnQixTQUFoQixDQUFKLENBQWdDLENBQzlCLFFBQVUsVUFBVSxJQUFWLENBQWUsS0FBSyxNQUFwQixDQUE0QixFQUE1QixDQUFWLENBQ0QsQ0FGRCxLQUVPLEdBQUksS0FBSyxRQUFMLENBQWMsU0FBZCxDQUFKLENBQThCLENBQ25DLFFBQVUsS0FBSyxxQkFBTCxDQUEyQixJQUEzQixDQUFnQyxLQUFLLE1BQXJDLENBQTZDLFNBQTdDLENBQVYsQ0FDRCxDQUZNLEtBRUEsQ0FDTCxNQUFNLE1BQU0sMkJBQU4sQ0FBTixDQUNELENBRUQsSUFBSSxXQUFhLEtBQUssa0JBQUwsQ0FBd0IsVUFBekMsQ0FDQSxHQUFJLENBQUMsS0FBSyxRQUFMLENBQWMsVUFBZCxDQUFELEVBQThCLENBQUMsVUFBbkMsQ0FBK0MsQ0FDN0MsTUFBTSxNQUFNLHlCQUEyQixVQUEzQixDQUF3QyxJQUE5QyxDQUFOLENBQ0QsQzs7QUFJRCxHQUFJLEtBQUssa0JBQUwsQ0FBd0Isc0JBQTVCLENBQW9ELENBQ2xELEtBQUssbUJBQUwsQ0FBeUIsVUFBekIsQ0FBcUMsT0FBckMsRUFDRCxDQUZELEtBRU8sR0FBSSxLQUFLLG1CQUFMLEVBQTRCLE9BQU8sSUFBdkMsQ0FBNkMsQ0FDbEQsT0FBTyxJQUFQLENBQVksT0FBWixFQUNELENBRUQsS0FBSyxjQUFMLENBQW9CLFVBQXBCLEVBQWtDLE9BQWxDLENBQ0QsQ0E1QkQsUUE0QlUsQ0FDUixLQUFLLGtCQUFMLENBQTBCLGFBQTFCLENBQ0QsQ0FDRixDQXRDRCxDOzs7Ozs7O0tBaURBLEtBQUsscUJBQUwsQ0FBNkIsVUFBVyxDOztBQUd0QyxhQUNBLElBQUksUUFBVSxFQUFkLENBQ0EsS0FBSyxVQUFVLENBQVYsQ0FBTCxFQUNBLE9BQU8sT0FBUCxDQUNELENBUEQsQzs7Ozs7Ozs7S0FtQkEsS0FBSyxtQkFBTCxDQUEyQixTQUFTLEdBQVQsQ0FBYyxDQUN2QyxLQUFLLE1BQUwsQ0FBWSxRQUFaLENBQXFCLEtBQXJCLENBQ0ksdUNBQXlDLEdBQXpDLENBQStDLE1BQS9DLENBQ0EsU0FGSixFQUdELENBSkQsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7S0F5QkEsS0FBSyxvQkFBTCxDQUE0QixTQUFTLEdBQVQsQ0FBYyxDLHdCQUV4QyxJQUFJLElBQU0sS0FBSyxNQUFMLENBQVksUUFBdEIsQ0FDQSxJQUFJLFMsaUNBQ2tDLElBQUksYUFBSixDQUFrQixRQUFsQixDQUR0QyxDQUVBLFNBQVMsSUFBVCxDQUFnQixpQkFBaEIsQ0FDQSxTQUFTLEdBQVQsQ0FBZSxHQUFmLENBQ0EsU0FBUyxLQUFULENBQWlCLEtBQWpCLENBQ0EsU0FBUyxLQUFULENBQWlCLEtBQWpCLENBQ0EsSUFBSSxJQUFKLENBQVMsV0FBVCxDQUFxQixRQUFyQixFQUNELENBVkQsQzs7Ozs7Ozs7S0FzQkEsS0FBSyxlQUFMLENBQXVCLFNBQVMsR0FBVCxDQUFjLGNBQWQsQ0FBOEIsQ0FDbkQsR0FBSSxLQUFLLGVBQUwsRUFBSixDQUE0QixDLDZCQUUxQixJQUFJLElBQU0sS0FBSyxNQUFMLENBQVksUUFBdEIsQzs7OztBQU1BLEdBQUksQ0FBQyxLQUFLLHFDQUFOLEVBQ0EsSUFBSSxVQUFKLEVBQWtCLFVBRHRCLENBQ2tDLEM7Ozs7QUFLaEMsSUFBSSxPQUFTLGFBQWEsSUFBYixDQUFrQixHQUFsQixDQUFiLENBQ0EsR0FBSSxNQUFKLENBQVksQ0FDVixPQUFPLEtBQVAsQ0FDRCxDQUZELEtBRU8sQ0FDTCxNQUFNLE1BQU0saUJBQW1CLEdBQW5CLENBQXlCLHVCQUEvQixDQUFOLENBQ0QsQ0FDRixDQUVELElBQUksUUFBVSxLQUFLLFVBQW5CLENBRUEsR0FBSSxpQkFBbUIsU0FBdkIsQ0FBa0MsQ0FDaEMsR0FBSSxDQUFDLE9BQUwsQ0FBYyxDQUNaLEdBQUksS0FBSyxxQ0FBVCxDQUFnRCxDQUM5QyxLQUFLLG9CQUFMLENBQTBCLEdBQTFCLEVBQ0QsQ0FGRCxLQUVPLENBQ0wsS0FBSyxtQkFBTCxDQUF5QixHQUF6QixFQUNELENBQ0YsQ0FORCxLQU1PLENBQ0wsSUFBSSxNQUFRLGtEQUNSLEVBQUUsS0FBSyx5QkFEQyxDQUMyQixLQUR2QyxDQUVBLElBQUksS0FBSixDQUNJLHVDQUF5QyxHQUF6QyxDQUErQyxHQUEvQyxDQUFxRCxLQUFyRCxDQUNBLEtBREEsQ0FFQSxTQUhKLEVBSUQsQ0FDRixDQWZELEtBZU8sQ0FDTCxJQUFJLEtBQUosQ0FDSSxrQ0FBb0MsY0FBcEMsQ0FBcUQsSUFBckQsQ0FDQSxTQUZKLEVBR0QsQ0FDRCxPQUFPLElBQVAsQ0FDRCxDQTdDRCxLQTZDTyxDQUNMLE9BQU8sS0FBUCxDQUNELENBQ0YsQ0FqREQsQyx5QkFxREEsS0FBSyx5QkFBTCxDQUFpQyxDQUFqQyxDOzs7Ozs7S0FVQSxLQUFLLGFBQUwsQ0FBcUIsU0FBUyxNQUFULENBQWlCLFdBQWpCLENBQThCLEM7O0FBR2pELEdBQUksT0FBTyxVQUFQLEVBQXFCLFVBQXJCLEVBQ0EsS0FBSyx5QkFBTCxFQUFrQyxXQUR0QyxDQUNtRCxDQUNqRCxLQUFLLGtCQUFMLEdBQ0QsQ0FDRCxPQUFPLElBQVAsQ0FDRCxDQVJELEM7Ozs7OztLQWlCQSxLQUFLLGFBQUwsQ0FBcUIsU0FBUyxVQUFULENBQXFCLEMsc0VBRXhDLElBQUksUUFBVSxFQUFkLENBQ0EsSUFBSSxXQUFhLEVBQWpCLENBQ0EsSUFBSSxLQUFPLEtBQUssYUFBaEIsQyw0QkFHQSxTQUFTLFNBQVQsQ0FBbUIsSUFBbkIsQ0FBeUIsQ0FDdkIsR0FBSSxRQUFRLEtBQUssT0FBakIsQ0FBMEIsQ0FDeEIsT0FDRCxDOztBQUlELEdBQUksUUFBUSxLQUFLLE9BQWpCLENBQTBCLENBQ3hCLE9BQ0QsQ0FFRCxLQUFLLE9BQUwsQ0FBYSxJQUFiLEVBQXFCLElBQXJCLENBRUEsR0FBSSxRQUFRLEtBQUssUUFBakIsQ0FBMkIsQ0FDekIsSUFBSyxJQUFJLFdBQVQsSUFBd0IsS0FBSyxRQUFMLENBQWMsSUFBZCxDQUF4QixDQUE2QyxDOztBQUczQyxHQUFJLENBQUMsS0FBSyxXQUFMLENBQWlCLFdBQWpCLENBQUwsQ0FBb0MsQ0FDbEMsR0FBSSxlQUFlLEtBQUssVUFBeEIsQ0FBb0MsQ0FDbEMsVUFBVSxLQUFLLFVBQUwsQ0FBZ0IsV0FBaEIsQ0FBVixFQUNELENBRkQsS0FFTyxDQUNMLE1BQU0sTUFBTSw0QkFBOEIsV0FBcEMsQ0FBTixDQUNELENBQ0YsQ0FDRixDQUNGLENBRUQsR0FBSSxFQUFFLFFBQVEsVUFBVixDQUFKLENBQTJCLENBQ3pCLFdBQVcsSUFBWCxFQUFtQixJQUFuQixDQUNBLFFBQVEsSUFBUixDQUFhLElBQWIsRUFDRCxDQUNGLENBRUQsVUFBVSxVQUFWLEU7QUFHQSxJQUFLLElBQUksRUFBSSxDQUFiLENBQWdCLEVBQUksUUFBUSxNQUE1QixDQUFvQyxHQUFwQyxDQUF5QyxDQUN2QyxJQUFJLEtBQU8sUUFBUSxDQUFSLENBQVgsQ0FDQSxLQUFLLGFBQUwsQ0FBbUIsT0FBbkIsQ0FBMkIsSUFBM0IsRUFBbUMsSUFBbkMsQ0FDRCxDOzs7QUFLRCxJQUFJLFlBQWMsS0FBSyxrQkFBdkIsQ0FDQSxLQUFLLGtCQUFMLENBQTBCLElBQTFCLENBRUEsSUFBSyxJQUFJLEVBQUksQ0FBYixDQUFnQixFQUFJLFFBQVEsTUFBNUIsQ0FBb0MsR0FBcEMsQ0FBeUMsQ0FDdkMsSUFBSSxLQUFPLFFBQVEsQ0FBUixDQUFYLENBQ0EsR0FBSSxJQUFKLENBQVUsQ0FDUixHQUFJLENBQUMsS0FBSyxZQUFMLENBQWtCLElBQWxCLENBQUwsQ0FBOEIsQ0FDNUIsS0FBSyxhQUFMLENBQW1CLEtBQUssUUFBTCxDQUFnQixJQUFuQyxFQUNELENBRkQsS0FFTyxDQUNMLEtBQUssYUFBTCxDQUFtQixLQUFLLFFBQUwsQ0FBZ0IsSUFBbkMsRUFDRCxDQUNGLENBTkQsS0FNTyxDQUNMLEtBQUssa0JBQUwsQ0FBMEIsV0FBMUIsQ0FDQSxNQUFNLE1BQU0sd0JBQU4sQ0FBTixDQUNELENBQ0YsQztBQUdELEtBQUssa0JBQUwsQ0FBMEIsV0FBMUIsQ0FDRCxDQXRFRCxDOzs7Ozs7S0FnRkEsS0FBSyxnQkFBTCxDQUF3QixTQUFTLElBQVQsQ0FBZSxDQUNyQyxHQUFJLFFBQVEsS0FBSyxhQUFMLENBQW1CLFVBQS9CLENBQTJDLENBQ3pDLE9BQU8sS0FBSyxhQUFMLENBQW1CLFVBQW5CLENBQThCLElBQTlCLENBQVAsQ0FDRCxDQUZELEtBRU8sQ0FDTCxPQUFPLElBQVAsQ0FDRCxDQUNGLENBTkQsQ0FRQSxLQUFLLGFBQUwsRztBQUdBLEdBQUksQ0FBQyxLQUFLLE1BQUwsQ0FBWSxlQUFqQixDQUFrQyxDQUNoQyxLQUFLLGFBQUwsQ0FBbUIsS0FBSyxRQUFMLENBQWdCLFNBQW5DLEVBQ0QsQ0FDRixDOzs7Ozs7R0FVRCxLQUFLLGNBQUwsQ0FBc0IsU0FBUyxJQUFULENBQWUsQ0FDbkMsSUFBSSxXQUFhLEtBQUssS0FBTCxDQUFXLEdBQVgsQ0FBakIsQ0FDQSxJQUFJLEVBQUksQ0FBUixDQUNBLE1BQU8sRUFBSSxXQUFXLE1BQXRCLENBQThCLENBQzVCLEdBQUksV0FBVyxDQUFYLEdBQWlCLEdBQXJCLENBQTBCLENBQ3hCLFdBQVcsTUFBWCxDQUFrQixDQUFsQixDQUFxQixDQUFyQixFQUNELENBRkQsS0FFTyxHQUNILEdBQUssV0FBVyxDQUFYLEdBQWlCLElBQXRCLEVBQThCLFdBQVcsRUFBSSxDQUFmLENBQTlCLEVBQ0EsV0FBVyxFQUFJLENBQWYsR0FBcUIsSUFGbEIsQ0FFd0IsQ0FDN0IsV0FBVyxNQUFYLENBQWtCLEVBQUUsQ0FBcEIsQ0FBdUIsQ0FBdkIsRUFDRCxDQUpNLEtBSUEsQ0FDTCxJQUNELENBQ0YsQ0FDRCxPQUFPLFdBQVcsSUFBWCxDQUFnQixHQUFoQixDQUFQLENBQ0QsQ0FmRCxDOzs7OztHQXdCQSxLQUFLLGFBQUwsQ0FBcUIsU0FBUyxHQUFULENBQWMsQ0FDakMsR0FBSSxLQUFLLE1BQUwsQ0FBWSxzQkFBaEIsQ0FBd0MsQ0FDdEMsT0FBTyxLQUFLLE1BQUwsQ0FBWSxzQkFBWixDQUFtQyxHQUFuQyxDQUFQLENBQ0QsQ0FGRCxLQUVPLEMsOEJBRUwsSUFBSSxJQUFNLElBQUksS0FBSyxNQUFMLENBQVksZ0JBQVosQ0FBSixFQUFWLENBQ0EsSUFBSSxJQUFKLENBQVMsS0FBVCxDQUFnQixHQUFoQixDQUFxQixLQUFyQixFQUNBLElBQUksSUFBSixHQUNBLE9BQU8sSUFBSSxZQUFYLENBQ0QsQ0FDRixDQVZELEM7Ozs7R0FrQkEsS0FBSyxzQkFBTCxDQUE4QixTQUFTLEdBQVQsQ0FBYyxDQUMxQyxHQUFJLENBQUMsUUFBTCxDQUFlLEM7QUFFYixJQUFJLGFBQWUsR0FBbkIsQzs7QUFHQSxJQUFNLEtBQUssY0FBTCxDQUFvQixHQUFwQixDQUFOLENBRUEsSUFBSSxhQUNBLEtBQUssTUFBTCxDQUFZLHFCQUFaLEVBQXFDLEtBQUssZUFEOUMsQ0FHQSxJQUFJLFdBQWEsS0FBSyxhQUFMLENBQW1CLEdBQW5CLENBQWpCLENBRUEsR0FBSSxZQUFjLElBQWxCLENBQXdCLENBQ3RCLElBQUksaUJBQW1CLEtBQUssV0FBTCxDQUFpQixHQUFqQixDQUFzQixVQUF0QixDQUF2QixDQUNBLElBQUksUUFBVSxLQUFLLFVBQW5CLENBQ0EsR0FBSSxPQUFKLENBQWEsQ0FDWCxLQUFLLGFBQUwsQ0FBbUIsUUFBbkIsQ0FBNEIsWUFBNUIsRUFBNEMsZ0JBQTVDLENBQ0EsS0FBSyxjQUFMLENBQW9CLElBQXBCLENBQXlCLFlBQXpCLEVBQ0QsQ0FIRCxLQUdPLENBQ0wsYUFBYSxHQUFiLENBQWtCLGdCQUFsQixFQUNELENBQ0YsQ0FURCxLQVNPLENBQ0wsTUFBTSxJQUFJLEtBQUosQ0FBVSxXQUFhLEdBQWIsQ0FBbUIsUUFBN0IsQ0FBTixDQUNELENBQ0YsQ0FDRixDQTFCRCxDOzs7Ozs7OztHQXdDQSxLQUFLLE1BQUwsQ0FBYyxTQUFTLEtBQVQsQ0FBZ0IsQ0FDNUIsSUFBSSxTQUFXLEtBQVgsbUNBQVcsS0FBWCxDQUFKLENBQ0EsR0FBSSxHQUFLLFFBQVQsQ0FBbUIsQ0FDakIsR0FBSSxLQUFKLENBQVcsQzs7Ozs7QUFNVCxHQUFJLGlCQUFpQixLQUFyQixDQUE0QixDQUMxQixPQUFPLE9BQVAsQ0FDRCxDQUZELEtBRU8sR0FBSSxpQkFBaUIsTUFBckIsQ0FBNkIsQ0FDbEMsT0FBTyxDQUFQLENBQ0QsQzs7O0FBS0QsSUFBSSxVQUFZLE9BQU8sU0FBUCxDQUFpQixRQUFqQixDQUEwQixJQUExQixDLHVCQUNZLEtBRFosQ0FBaEIsQzs7O0FBS0EsR0FBSSxXQUFhLGlCQUFqQixDQUFvQyxDQUNsQyxPQUFPLFFBQVAsQ0FDRCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkQsR0FBSyxXQUFhLGdCQUFiLEU7OztBQUlBLE9BQU8sTUFBTSxNQUFiLEVBQXVCLFFBQXZCLEVBQ0ksT0FBTyxNQUFNLE1BQWIsRUFBdUIsV0FEM0IsRUFFSSxPQUFPLE1BQU0sb0JBQWIsRUFBcUMsV0FGekMsRUFHSSxDQUFDLE1BQU0sb0JBQU4sQ0FBMkIsUUFBM0IsQ0FQVixDQVNZLENBQ1YsT0FBTyxPQUFQLENBQ0QsQzs7Ozs7Ozs7Ozs7OztBQWVELEdBQUssV0FBYSxtQkFBYixFQUNBLE9BQU8sTUFBTSxJQUFiLEVBQXFCLFdBQXJCLEVBQ0ksT0FBTyxNQUFNLG9CQUFiLEVBQXFDLFdBRHpDLEVBRUksQ0FBQyxNQUFNLG9CQUFOLENBQTJCLE1BQTNCLENBSFYsQ0FHK0MsQ0FDN0MsT0FBTyxVQUFQLENBQ0QsQ0FFRixDQTNFRCxLQTJFTyxDQUNMLE9BQU8sTUFBUCxDQUNELENBRUYsQ0FoRkQsS0FnRk8sR0FBSSxHQUFLLFVBQUwsRUFBbUIsT0FBTyxNQUFNLElBQWIsRUFBcUIsV0FBNUMsQ0FBeUQsQzs7OztBQUs5RCxPQUFPLFFBQVAsQ0FDRCxDQUNELE9BQU8sQ0FBUCxDQUNELENBMUZELEM7Ozs7R0FrR0EsS0FBSyxNQUFMLENBQWMsU0FBUyxHQUFULENBQWMsQ0FDMUIsT0FBTyxNQUFRLElBQWYsQ0FDRCxDQUZELEM7Ozs7R0FVQSxLQUFLLGVBQUwsQ0FBdUIsU0FBUyxHQUFULENBQWMsQztBQUVuQyxPQUFPLEtBQU8sSUFBZCxDQUNELENBSEQsQzs7OztHQVdBLEtBQUssT0FBTCxDQUFlLFNBQVMsR0FBVCxDQUFjLENBQzNCLE9BQU8sS0FBSyxNQUFMLENBQVksR0FBWixHQUFvQixPQUEzQixDQUNELENBRkQsQzs7Ozs7OztHQWFBLEtBQUssV0FBTCxDQUFtQixTQUFTLEdBQVQsQ0FBYyxDQUMvQixJQUFJLEtBQU8sS0FBSyxNQUFMLENBQVksR0FBWixDQUFYLEM7QUFFQSxPQUFPLE1BQVEsT0FBUixFQUFtQixNQUFRLFFBQVIsRUFBb0IsT0FBTyxJQUFJLE1BQVgsRUFBcUIsUUFBbkUsQ0FDRCxDQUpELEM7Ozs7O0dBYUEsS0FBSyxVQUFMLENBQWtCLFNBQVMsR0FBVCxDQUFjLENBQzlCLE9BQU8sS0FBSyxRQUFMLENBQWMsR0FBZCxHQUFzQixPQUFPLElBQUksV0FBWCxFQUEwQixVQUF2RCxDQUNELENBRkQsQzs7OztHQVVBLEtBQUssUUFBTCxDQUFnQixTQUFTLEdBQVQsQ0FBYyxDQUM1QixPQUFPLE9BQU8sR0FBUCxFQUFjLFFBQXJCLENBQ0QsQ0FGRCxDOzs7O0dBVUEsS0FBSyxTQUFMLENBQWlCLFNBQVMsR0FBVCxDQUFjLENBQzdCLE9BQU8sT0FBTyxHQUFQLEVBQWMsU0FBckIsQ0FDRCxDQUZELEM7Ozs7R0FVQSxLQUFLLFFBQUwsQ0FBZ0IsU0FBUyxHQUFULENBQWMsQ0FDNUIsT0FBTyxPQUFPLEdBQVAsRUFBYyxRQUFyQixDQUNELENBRkQsQzs7OztHQVVBLEtBQUssVUFBTCxDQUFrQixTQUFTLEdBQVQsQ0FBYyxDQUM5QixPQUFPLEtBQUssTUFBTCxDQUFZLEdBQVosR0FBb0IsVUFBM0IsQ0FDRCxDQUZELEM7Ozs7O0dBV0EsS0FBSyxRQUFMLENBQWdCLFNBQVMsR0FBVCxDQUFjLENBQzVCLElBQUksWUFBYyxHQUFkLG1DQUFjLEdBQWQsQ0FBSixDQUNBLE9BQU8sTUFBUSxRQUFSLEVBQW9CLEtBQU8sSUFBM0IsRUFBbUMsTUFBUSxVQUFsRCxDOztBQUdELENBTEQsQzs7Ozs7Ozs7OztHQW1CQSxLQUFLLE1BQUwsQ0FBYyxTQUFTLEdBQVQsQ0FBYyxDOzs7O0FBTTFCLE9BQU8sSUFBSSxLQUFLLGFBQVQsSUFDRixJQUFJLEtBQUssYUFBVCxFQUEwQixFQUFFLEtBQUssV0FEL0IsQ0FBUCxDQUVELENBUkQsQzs7Ozs7OztHQW1CQSxLQUFLLE1BQUwsQ0FBYyxTQUFTLEdBQVQsQ0FBYyxDQUMxQixPQUFPLENBQUMsQ0FBQyxJQUFJLEtBQUssYUFBVCxDQUFULENBQ0QsQ0FGRCxDOzs7OztHQVdBLEtBQUssU0FBTCxDQUFpQixTQUFTLEdBQVQsQ0FBYyxDOzs7QUFLN0IsR0FBSSxNQUFRLElBQVIsRUFBZ0IscUJBQXFCLEdBQXpDLENBQThDLENBQzVDLElBQUksZUFBSixDQUFvQixLQUFLLGFBQXpCLEVBQ0QsQyxvQkFFRCxHQUFJLENBQ0YsT0FBTyxJQUFJLEtBQUssYUFBVCxDQUFQLENBQ0QsQ0FBQyxNQUFPLEVBQVAsQ0FBVyxDQUNaLENBQ0YsQ0FiRCxDOzs7OztHQXNCQSxLQUFLLGFBQUwsQ0FBcUIsZ0JBQW1CLEtBQUssTUFBTCxHQUFnQixHQUFqQixHQUEwQixDQUE1QyxDQUFyQixDOzs7O0dBUUEsS0FBSyxXQUFMLENBQW1CLENBQW5CLEM7Ozs7OztHQVVBLEtBQUssV0FBTCxDQUFtQixLQUFLLE1BQXhCLEM7Ozs7R0FRQSxLQUFLLGNBQUwsQ0FBc0IsS0FBSyxTQUEzQixDOzs7Ozs7Ozs7Ozs7OztHQWtCQSxLQUFLLFdBQUwsQ0FBbUIsU0FBUyxHQUFULENBQWMsQ0FDL0IsSUFBSSxLQUFPLEtBQUssTUFBTCxDQUFZLEdBQVosQ0FBWCxDQUNBLEdBQUksTUFBUSxRQUFSLEVBQW9CLE1BQVEsT0FBaEMsQ0FBeUMsQ0FDdkMsR0FBSSxJQUFJLEtBQVIsQ0FBZSxDQUNiLE9BQU8sSUFBSSxLQUFKLEVBQVAsQ0FDRCxDQUNELElBQUksTUFBUSxNQUFRLE9BQVIsQ0FBa0IsRUFBbEIsQ0FBdUIsRUFBbkMsQ0FDQSxJQUFLLElBQUksR0FBVCxJQUFnQixHQUFoQixDQUFxQixDQUNuQixNQUFNLEdBQU4sRUFBYSxLQUFLLFdBQUwsQ0FBaUIsSUFBSSxHQUFKLENBQWpCLENBQWIsQ0FDRCxDQUNELE9BQU8sS0FBUCxDQUNELENBRUQsT0FBTyxHQUFQLENBQ0QsQ0FkRCxDOzs7Ozs7Ozs7Ozs7O0dBK0JBLEtBQUssV0FBTCxDQUFtQixTQUFTLEVBQVQsQ0FBYSxPQUFiLENBQXNCLFFBQXRCLENBQWdDLENBQ2pELE8sMEJBQWlDLEdBQUcsSUFBSCxDQUFRLEtBQVIsQ0FBYyxHQUFHLElBQWpCLENBQXVCLFNBQXZCLENBQWpDLEVBQ0QsQ0FGRCxDOzs7Ozs7Ozs7O0dBZ0JBLEtBQUssT0FBTCxDQUFlLFNBQVMsRUFBVCxDQUFhLE9BQWIsQ0FBc0IsUUFBdEIsQ0FBZ0MsQ0FDN0MsR0FBSSxDQUFDLEVBQUwsQ0FBUyxDQUNQLE1BQU0sSUFBSSxLQUFKLEVBQU4sQ0FDRCxDQUVELEdBQUksVUFBVSxNQUFWLENBQW1CLENBQXZCLENBQTBCLENBQ3hCLElBQUksVUFBWSxNQUFNLFNBQU4sQ0FBZ0IsS0FBaEIsQ0FBc0IsSUFBdEIsQ0FBMkIsU0FBM0IsQ0FBc0MsQ0FBdEMsQ0FBaEIsQ0FDQSxPQUFPLFVBQVcsQztBQUVoQixJQUFJLFFBQVUsTUFBTSxTQUFOLENBQWdCLEtBQWhCLENBQXNCLElBQXRCLENBQTJCLFNBQTNCLENBQWQsQ0FDQSxNQUFNLFNBQU4sQ0FBZ0IsT0FBaEIsQ0FBd0IsS0FBeEIsQ0FBOEIsT0FBOUIsQ0FBdUMsU0FBdkMsRUFDQSxPQUFPLEdBQUcsS0FBSCxDQUFTLE9BQVQsQ0FBa0IsT0FBbEIsQ0FBUCxDQUNELENBTEQsQ0FPRCxDQVRELEtBU08sQ0FDTCxPQUFPLFVBQVcsQ0FBRSxPQUFPLEdBQUcsS0FBSCxDQUFTLE9BQVQsQ0FBa0IsU0FBbEIsQ0FBUCxDQUFzQyxDQUExRCxDQUNELENBQ0YsQ0FqQkQsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E0Q0EsS0FBSyxJQUFMLENBQVksU0FBUyxFQUFULENBQWEsT0FBYixDQUFzQixRQUF0QixDQUFnQyxDO0FBRTFDLEdBQUksU0FBUyxTQUFULENBQW1CLElBQW5CLEU7Ozs7OztBQU9BLFNBQVMsU0FBVCxDQUFtQixJQUFuQixDQUF3QixRQUF4QixHQUFtQyxPQUFuQyxDQUEyQyxhQUEzQyxHQUE2RCxDQUFDLENBUGxFLENBT3FFLENBQ25FLEtBQUssSUFBTCxDQUFZLEtBQUssV0FBakIsQ0FDRCxDQVRELEtBU08sQ0FDTCxLQUFLLElBQUwsQ0FBWSxLQUFLLE9BQWpCLENBQ0QsQ0FDRCxPQUFPLEtBQUssSUFBTCxDQUFVLEtBQVYsQ0FBZ0IsSUFBaEIsQ0FBc0IsU0FBdEIsQ0FBUCxDQUNELENBZkQsQzs7Ozs7Ozs7Ozs7O0dBK0JBLEtBQUssT0FBTCxDQUFlLFNBQVMsRUFBVCxDQUFhLFFBQWIsQ0FBdUIsQ0FDcEMsSUFBSSxLQUFPLE1BQU0sU0FBTixDQUFnQixLQUFoQixDQUFzQixJQUF0QixDQUEyQixTQUEzQixDQUFzQyxDQUF0QyxDQUFYLENBQ0EsT0FBTyxVQUFXLEM7O0FBR2hCLElBQUksUUFBVSxLQUFLLEtBQUwsRUFBZCxDQUNBLFFBQVEsSUFBUixDQUFhLEtBQWIsQ0FBbUIsT0FBbkIsQ0FBNEIsU0FBNUIsRUFDQSxPQUFPLEdBQUcsS0FBSCxDQUFTLElBQVQsQ0FBZSxPQUFmLENBQVAsQ0FDRCxDQU5ELENBT0QsQ0FURCxDOzs7Ozs7R0FtQkEsS0FBSyxLQUFMLENBQWEsU0FBUyxNQUFULENBQWlCLE1BQWpCLENBQXlCLENBQ3BDLElBQUssSUFBSSxDQUFULElBQWMsTUFBZCxDQUFzQixDQUNwQixPQUFPLENBQVAsRUFBWSxPQUFPLENBQVAsQ0FBWixDQUNELEM7Ozs7O0FBT0YsQ0FWRCxDOzs7R0FpQkEsS0FBSyxHQUFMLENBQVksS0FBSyxZQUFMLEVBQXFCLEtBQUssR0FBM0IsRUFBb0MsVUFBVyxDOzs7QUFJN0MsT0FBTyxDQUFDLElBQUksSUFBSixFQUFSLENBQ0QsQ0FMWixDOzs7Ozs7R0FlQSxLQUFLLFVBQUwsQ0FBa0IsU0FBUyxNQUFULENBQWlCLENBQ2pDLEdBQUksS0FBSyxNQUFMLENBQVksVUFBaEIsQ0FBNEIsQ0FDMUIsS0FBSyxNQUFMLENBQVksVUFBWixDQUF1QixNQUF2QixDQUErQixZQUEvQixFQUNELENBRkQsS0FFTyxHQUFJLEtBQUssTUFBTCxDQUFZLElBQWhCLENBQXNCLEM7QUFFM0IsR0FBSSxLQUFLLG9CQUFMLEVBQTZCLElBQWpDLENBQXVDLENBQ3JDLEtBQUssTUFBTCxDQUFZLElBQVosQ0FBaUIscUJBQWpCLEVBQ0EsR0FBSSxPQUFPLEtBQUssTUFBTCxDQUFZLFlBQVosQ0FBUCxFQUFvQyxXQUF4QyxDQUFxRCxDQUNuRCxHQUFJLENBQ0YsT0FBTyxLQUFLLE1BQUwsQ0FBWSxZQUFaLENBQVAsQ0FDRCxDQUFDLE1BQU8sTUFBUCxDQUFlLEM7QUFFaEIsQ0FDRCxLQUFLLG9CQUFMLENBQTRCLElBQTVCLENBQ0QsQ0FQRCxLQU9PLENBQ0wsS0FBSyxvQkFBTCxDQUE0QixLQUE1QixDQUNELENBQ0YsQ0FFRCxHQUFJLEtBQUssb0JBQVQsQ0FBK0IsQ0FDN0IsS0FBSyxNQUFMLENBQVksSUFBWixDQUFpQixNQUFqQixFQUNELENBRkQsS0FFTyxDLHdCQUVMLElBQUksSUFBTSxLQUFLLE1BQUwsQ0FBWSxRQUF0QixDQUNBLElBQUksVSxrQ0FDbUMsSUFBSSxhQUFKLENBQWtCLFFBQWxCLENBRHZDLENBRUEsVUFBVSxJQUFWLENBQWlCLGlCQUFqQixDQUNBLFVBQVUsS0FBVixDQUFrQixLQUFsQixDOztBQUdBLFVBQVUsV0FBVixDQUFzQixJQUFJLGNBQUosQ0FBbUIsTUFBbkIsQ0FBdEIsRUFDQSxJQUFJLElBQUosQ0FBUyxXQUFULENBQXFCLFNBQXJCLEVBQ0EsSUFBSSxJQUFKLENBQVMsV0FBVCxDQUFxQixTQUFyQixFQUNELENBQ0YsQ0EvQk0sS0ErQkEsQ0FDTCxNQUFNLE1BQU0sK0JBQU4sQ0FBTixDQUNELENBQ0YsQ0FyQ0QsQzs7Ozs7O0dBK0NBLEtBQUssb0JBQUwsQ0FBNEIsSUFBNUIsQzs7Ozs7R0FTQSxLQUFLLGVBQUwsQzs7Ozs7O0dBVUEsS0FBSyxvQkFBTCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FrQ0EsS0FBSyxVQUFMLENBQWtCLFNBQVMsU0FBVCxDQUFvQixZQUFwQixDQUFrQyxDQUNsRCxJQUFJLFdBQWEsU0FBYixVQUFhLENBQVMsT0FBVCxDQUFrQixDQUNqQyxPQUFPLEtBQUssZUFBTCxDQUFxQixPQUFyQixHQUFpQyxPQUF4QyxDQUNELENBRkQsQ0FJQSxJQUFJLGNBQWdCLFNBQWhCLGFBQWdCLENBQVMsT0FBVCxDQUFrQixDO0FBRXBDLElBQUksTUFBUSxRQUFRLEtBQVIsQ0FBYyxHQUFkLENBQVosQ0FDQSxJQUFJLE9BQVMsRUFBYixDQUNBLElBQUssSUFBSSxFQUFJLENBQWIsQ0FBZ0IsRUFBSSxNQUFNLE1BQTFCLENBQWtDLEdBQWxDLENBQXVDLENBQ3JDLE9BQU8sSUFBUCxDQUFZLFdBQVcsTUFBTSxDQUFOLENBQVgsQ0FBWixFQUNELENBQ0QsT0FBTyxPQUFPLElBQVAsQ0FBWSxHQUFaLENBQVAsQ0FDRCxDQVJELENBVUEsSUFBSSxNQUFKLENBQ0EsR0FBSSxLQUFLLGVBQVQsQ0FBMEIsQ0FDeEIsT0FDSSxLQUFLLG9CQUFMLEVBQTZCLFVBQTdCLENBQTBDLFVBQTFDLENBQXVELGFBRDNELENBRUQsQ0FIRCxLQUdPLENBQ0wsT0FBUyxnQkFBUyxDQUFULENBQVksQ0FBRSxPQUFPLENBQVAsQ0FBVyxDQUFsQyxDQUNELENBRUQsR0FBSSxZQUFKLENBQWtCLENBQ2hCLE9BQU8sVUFBWSxHQUFaLENBQWtCLE9BQU8sWUFBUCxDQUF6QixDQUNELENBRkQsS0FFTyxDQUNMLE9BQU8sT0FBTyxTQUFQLENBQVAsQ0FDRCxDQUNGLENBNUJELEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FzREEsS0FBSyxpQkFBTCxDQUF5QixTQUFTLE9BQVQsQ0FBa0IsU0FBbEIsQ0FBNkIsQ0FDcEQsS0FBSyxlQUFMLENBQXVCLE9BQXZCLENBQ0EsS0FBSyxvQkFBTCxDQUE0QixTQUE1QixDQUNELENBSEQsQzs7Ozs7Ozs7Ozs7R0FrQkEsS0FBSyxNQUFMLENBQVksd0JBQVosQ0FHQSxHQUFJLENBQUMsUUFBRCxFQUFhLEtBQUssTUFBTCxDQUFZLHdCQUE3QixDQUF1RCxDOztBQUdyRCxLQUFLLGVBQUwsQ0FBdUIsS0FBSyxNQUFMLENBQVksd0JBQW5DLENBQ0QsQzs7Ozs7Ozs7Ozs7Ozs7O0dBbUJELEtBQUssTUFBTCxDQUFjLFNBQVMsR0FBVCxDQUFjLFVBQWQsQ0FBMEIsQ0FDdEMsR0FBSSxVQUFKLENBQWdCLENBQ2QsSUFBTSxJQUFJLE9BQUosQ0FBWSxlQUFaLENBQTZCLFNBQVMsS0FBVCxDQUFnQixHQUFoQixDQUFxQixDQUN0RCxPQUFRLFlBQWMsSUFBZCxFQUFzQixPQUFPLFVBQTlCLENBQTRDLFdBQVcsR0FBWCxDQUE1QyxDQUM0QyxLQURuRCxDQUVELENBSEssQ0FBTixDQUlELENBQ0QsT0FBTyxHQUFQLENBQ0QsQ0FSRCxDOzs7Ozs7Ozs7Ozs7OztHQTBCQSxLQUFLLGtCQUFMLENBQTBCLFNBQVMsQ0FBVCxDQUFZLENBQVosQ0FBZSxDQUN2QyxPQUFPLENBQVAsQ0FDRCxDQUZELEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMEJBLEtBQUssWUFBTCxDQUFvQixTQUFTLFVBQVQsQ0FBcUIsTUFBckIsQ0FBNkIsb0JBQTdCLENBQW1ELENBQ3JFLEtBQUssV0FBTCxDQUFpQixVQUFqQixDQUE2QixNQUE3QixDQUFxQyxvQkFBckMsRUFDRCxDQUZELEM7Ozs7Ozs7R0FhQSxLQUFLLGNBQUwsQ0FBc0IsU0FBUyxNQUFULENBQWlCLFVBQWpCLENBQTZCLE1BQTdCLENBQXFDLENBQ3pELE9BQU8sVUFBUCxFQUFxQixNQUFyQixDQUNELENBRkQsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXlCQSxLQUFLLFFBQUwsQ0FBZ0IsU0FBUyxTQUFULENBQW9CLFVBQXBCLENBQWdDLEMsb0JBRTlDLFNBQVMsUUFBVCxFQUFvQixDQUFFLENBQ3RCLFNBQVMsU0FBVCxDQUFxQixXQUFXLFNBQWhDLENBQ0EsVUFBVSxXQUFWLENBQXdCLFdBQVcsU0FBbkMsQ0FDQSxVQUFVLFNBQVYsQ0FBc0IsSUFBSSxRQUFKLEVBQXRCLEMsaUJBRUEsVUFBVSxTQUFWLENBQW9CLFdBQXBCLENBQWtDLFNBQWxDLEM7Ozs7Ozs7Ozs7Ozs7Ozs7S0FtQkEsVUFBVSxJQUFWLENBQWlCLFNBQVMsRUFBVCxDQUFhLFVBQWIsQ0FBeUIsUUFBekIsQ0FBbUMsQzs7QUFHbEQsSUFBSSxLQUFPLElBQUksS0FBSixDQUFVLFVBQVUsTUFBVixDQUFtQixDQUE3QixDQUFYLENBQ0EsSUFBSyxJQUFJLEVBQUksQ0FBYixDQUFnQixFQUFJLFVBQVUsTUFBOUIsQ0FBc0MsR0FBdEMsQ0FBMkMsQ0FDekMsS0FBSyxFQUFJLENBQVQsRUFBYyxVQUFVLENBQVYsQ0FBZCxDQUNELENBQ0QsT0FBTyxXQUFXLFNBQVgsQ0FBcUIsVUFBckIsRUFBaUMsS0FBakMsQ0FBdUMsRUFBdkMsQ0FBMkMsSUFBM0MsQ0FBUCxDQUNELENBUkQsQ0FTRCxDQW5DRCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0ErREEsS0FBSyxJQUFMLENBQVksU0FBUyxFQUFULENBQWEsY0FBYixDQUE2QixRQUE3QixDQUF1QyxDQUNqRCxJQUFJLE9BQVMsVUFBVSxNQUFWLENBQWlCLE1BQTlCLENBRUEsR0FBSSxLQUFLLHNCQUFMLEVBQWdDLEtBQUssS0FBTCxFQUFjLENBQUMsTUFBbkQsQ0FBNEQsQ0FDMUQsTUFBTSxNQUNGLDZEQUNBLDZCQURBLENBRUEsdURBSEUsQ0FBTixDQUlELENBRUQsR0FBSSxPQUFPLFdBQVgsQ0FBd0IsQzs7QUFHdEIsSUFBSSxTQUFXLElBQUksS0FBSixDQUFVLFVBQVUsTUFBVixDQUFtQixDQUE3QixDQUFmLENBQ0EsSUFBSyxJQUFJLEVBQUksQ0FBYixDQUFnQixFQUFJLFVBQVUsTUFBOUIsQ0FBc0MsR0FBdEMsQ0FBMkMsQ0FDekMsU0FBUyxFQUFJLENBQWIsRUFBa0IsVUFBVSxDQUFWLENBQWxCLENBQ0QsQztBQUVELE9BQU8sT0FBTyxXQUFQLENBQW1CLFdBQW5CLENBQStCLEtBQS9CLENBQXFDLEVBQXJDLENBQXlDLFFBQXpDLENBQVAsQ0FDRCxDOztBQUlELElBQUksS0FBTyxJQUFJLEtBQUosQ0FBVSxVQUFVLE1BQVYsQ0FBbUIsQ0FBN0IsQ0FBWCxDQUNBLElBQUssSUFBSSxFQUFJLENBQWIsQ0FBZ0IsRUFBSSxVQUFVLE1BQTlCLENBQXNDLEdBQXRDLENBQTJDLENBQ3pDLEtBQUssRUFBSSxDQUFULEVBQWMsVUFBVSxDQUFWLENBQWQsQ0FDRCxDQUNELElBQUksWUFBYyxLQUFsQixDQUNBLElBQUssSUFBSSxLQUFPLEdBQUcsV0FBbkIsQ0FBZ0MsSUFBaEMsQ0FDSyxLQUFPLEtBQUssV0FBTCxFQUFvQixLQUFLLFdBQUwsQ0FBaUIsV0FEakQsQ0FDOEQsQ0FDNUQsR0FBSSxLQUFLLFNBQUwsQ0FBZSxjQUFmLElBQW1DLE1BQXZDLENBQStDLENBQzdDLFlBQWMsSUFBZCxDQUNELENBRkQsS0FFTyxHQUFJLFdBQUosQ0FBaUIsQ0FDdEIsT0FBTyxLQUFLLFNBQUwsQ0FBZSxjQUFmLEVBQStCLEtBQS9CLENBQXFDLEVBQXJDLENBQXlDLElBQXpDLENBQVAsQ0FDRCxDQUNGLEM7Ozs7QUFNRCxHQUFJLEdBQUcsY0FBSCxJQUF1QixNQUEzQixDQUFtQyxDQUNqQyxPQUFPLEdBQUcsV0FBSCxDQUFlLFNBQWYsQ0FBeUIsY0FBekIsRUFBeUMsS0FBekMsQ0FBK0MsRUFBL0MsQ0FBbUQsSUFBbkQsQ0FBUCxDQUNELENBRkQsS0FFTyxDQUNMLE1BQU0sTUFDRiw4Q0FDQSxpQ0FGRSxDQUFOLENBR0QsQ0FDRixDQWhERCxDOzs7Ozs7Ozs7O0dBOERBLEtBQUssS0FBTCxDQUFhLFNBQVMsRUFBVCxDQUFhLENBQ3hCLEdBQUcsSUFBSCxDQUFRLEtBQUssTUFBYixFQUNELENBRkQsQzs7Ozs7Ozs7O0dBZUEsR0FBSSxDQUFDLFFBQUwsQ0FBZSxDQUNiLEtBQUssTUFBTCxDQUFZLFVBQVosRUFBMEIsUUFBMUIsQ0FDRCxDQUVELEtBQUssTUFBTCxDQUFjLEVBQWQsQzs7Ozs7OztHQVdBLEtBQUssTUFBTCxDQUFZLElBQVosQ0FBbUIsU0FBUyxHQUFULENBQWMsUUFBZCxDQUF3QixDQUN6QyxJQUFJLFdBQWEsSUFBSSxLQUFKLENBQVUsSUFBVixDQUFqQixDQUNBLElBQUksYUFBZSxFQUFuQixDQUVBLElBQUksY0FBZ0IsTUFBTSxTQUFOLENBQWdCLEtBQWhCLENBQXNCLElBQXRCLENBQTJCLFNBQTNCLENBQXNDLENBQXRDLENBQXBCLENBQ0EsTUFBTyxjQUFjLE1BQWQsRTs7QUFHQSxXQUFXLE1BQVgsQ0FBb0IsQ0FIM0IsQ0FHOEIsQ0FDNUIsY0FBZ0IsV0FBVyxLQUFYLEdBQXFCLGNBQWMsS0FBZCxFQUFyQyxDQUNELENBRUQsT0FBTyxhQUFlLFdBQVcsSUFBWCxDQUFnQixJQUFoQixDQUF0QixDO0FBQ0QsQ0FiRCxDOzs7O0dBb0JBLEtBQUssTUFBTCxDQUFZLE9BQVosQ0FBc0IsSUFBdEIsQzs7OztHQVFBLEtBQUssTUFBTCxDQUFZLE1BQVosQ0FBcUIsSUFBckIsQzs7OztHQVFBLEtBQUssTUFBTCxDQUFZLE1BQVosQ0FBcUIsSUFBckIsQzs7OztHQVFBLEtBQUssTUFBTCxDQUFZLFFBQVosQ0FBdUIsSUFBdkIsQzs7OztHQVFBLEtBQUssTUFBTCxDQUFZLGdCQUFaLENBQStCLElBQS9CLEM7Ozs7R0FRQSxLQUFLLE1BQUwsQ0FBWSxRQUFaLENBQXVCLE9BQXZCLEM7Ozs7R0FRQSxLQUFLLE1BQUwsQ0FBWSxLQUFaLENBQW9CLElBQXBCLEM7Ozs7R0FRQSxLQUFLLE1BQUwsQ0FBWSxPQUFaLENBQ0ssS0FBSyxNQUFMLENBQVksc0JBQVosQ0FBcUMsY0FBckMsQ0FBc0QsYUFEM0QsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQStDQSxLQUFLLE1BQUwsQ0FBWSxVQUFaLENBQXlCLFNBQVMsR0FBVCxDQUFjLDhCQUFkLENBQThDLENBRXJFLEdBQUksOEJBQUosQ0FBb0MsQ0FDbEMsSUFBTSxJQUFJLE9BQUosQ0FBWSxLQUFLLE1BQUwsQ0FBWSxPQUF4QixDQUFpQyxPQUFqQyxFQUNLLE9BREwsQ0FDYSxLQUFLLE1BQUwsQ0FBWSxNQUR6QixDQUNpQyxNQURqQyxFQUVLLE9BRkwsQ0FFYSxLQUFLLE1BQUwsQ0FBWSxNQUZ6QixDQUVpQyxNQUZqQyxFQUdLLE9BSEwsQ0FHYSxLQUFLLE1BQUwsQ0FBWSxRQUh6QixDQUdtQyxRQUhuQyxFQUlLLE9BSkwsQ0FJYSxLQUFLLE1BQUwsQ0FBWSxnQkFKekIsQ0FJMkMsT0FKM0MsRUFLSyxPQUxMLENBS2EsS0FBSyxNQUFMLENBQVksUUFMekIsQ0FLbUMsTUFMbkMsQ0FBTixDQU1BLEdBQUksS0FBSyxNQUFMLENBQVksc0JBQWhCLENBQXdDLENBQ3RDLElBQU0sSUFBSSxPQUFKLENBQVksS0FBSyxNQUFMLENBQVksS0FBeEIsQ0FBK0IsUUFBL0IsQ0FBTixDQUNELENBQ0QsT0FBTyxHQUFQLENBRUQsQ0FaRCxLQVlPLEM7O0FBR0wsR0FBSSxDQUFDLEtBQUssTUFBTCxDQUFZLE9BQVosQ0FBb0IsSUFBcEIsQ0FBeUIsR0FBekIsQ0FBTCxDQUFvQyxPQUFPLEdBQVAsQztBQUdwQyxHQUFJLElBQUksT0FBSixDQUFZLEdBQVosR0FBb0IsQ0FBQyxDQUF6QixDQUE0QixDQUMxQixJQUFNLElBQUksT0FBSixDQUFZLEtBQUssTUFBTCxDQUFZLE9BQXhCLENBQWlDLE9BQWpDLENBQU4sQ0FDRCxDQUNELEdBQUksSUFBSSxPQUFKLENBQVksR0FBWixHQUFvQixDQUFDLENBQXpCLENBQTRCLENBQzFCLElBQU0sSUFBSSxPQUFKLENBQVksS0FBSyxNQUFMLENBQVksTUFBeEIsQ0FBZ0MsTUFBaEMsQ0FBTixDQUNELENBQ0QsR0FBSSxJQUFJLE9BQUosQ0FBWSxHQUFaLEdBQW9CLENBQUMsQ0FBekIsQ0FBNEIsQ0FDMUIsSUFBTSxJQUFJLE9BQUosQ0FBWSxLQUFLLE1BQUwsQ0FBWSxNQUF4QixDQUFnQyxNQUFoQyxDQUFOLENBQ0QsQ0FDRCxHQUFJLElBQUksT0FBSixDQUFZLEdBQVosR0FBb0IsQ0FBQyxDQUF6QixDQUE0QixDQUMxQixJQUFNLElBQUksT0FBSixDQUFZLEtBQUssTUFBTCxDQUFZLFFBQXhCLENBQWtDLFFBQWxDLENBQU4sQ0FDRCxDQUNELEdBQUksSUFBSSxPQUFKLENBQVksSUFBWixHQUFxQixDQUFDLENBQTFCLENBQTZCLENBQzNCLElBQU0sSUFBSSxPQUFKLENBQVksS0FBSyxNQUFMLENBQVksZ0JBQXhCLENBQTBDLE9BQTFDLENBQU4sQ0FDRCxDQUNELEdBQUksSUFBSSxPQUFKLENBQVksTUFBWixHQUF1QixDQUFDLENBQTVCLENBQStCLENBQzdCLElBQU0sSUFBSSxPQUFKLENBQVksS0FBSyxNQUFMLENBQVksUUFBeEIsQ0FBa0MsTUFBbEMsQ0FBTixDQUNELENBQ0QsR0FBSSxLQUFLLE1BQUwsQ0FBWSxzQkFBWixFQUFzQyxJQUFJLE9BQUosQ0FBWSxHQUFaLEdBQW9CLENBQUMsQ0FBL0QsQ0FBa0UsQ0FDaEUsSUFBTSxJQUFJLE9BQUosQ0FBWSxLQUFLLE1BQUwsQ0FBWSxLQUF4QixDQUErQixRQUEvQixDQUFOLENBQ0QsQ0FDRCxPQUFPLEdBQVAsQ0FDRCxDQUNGLENBM0NELENBOENBLEtBQUssS0FBTCxDQUFhLEVBQWIsQzs7Ozs7Ozs7R0FXQSxLQUFLLEtBQUwsQ0FBVyxXQUFYLENBQXlCLFNBQVMsS0FBVCxDQUFnQixDQUN2QyxHQUFJLGlCQUFpQixRQUFyQixDQUErQixDQUM3QixPQUFPLE1BQU0sV0FBTixFQUFxQixNQUFNLElBQTNCLEVBQW1DLG1CQUExQyxDQUNELENBRkQsS0FFTyxHQUFJLGlCQUFpQixNQUFyQixDQUE2QixDQUNsQyxPQUFPLE1BQU0sV0FBTixDQUFrQixXQUFsQixFQUFpQyxNQUFNLFdBQU4sQ0FBa0IsSUFBbkQsRUFDSCxPQUFPLFNBQVAsQ0FBaUIsUUFBakIsQ0FBMEIsSUFBMUIsQ0FBK0IsS0FBL0IsQ0FESixDQUVELENBSE0sS0FHQSxDQUNMLE9BQU8sUUFBVSxJQUFWLENBQWlCLE1BQWpCLFFBQWlDLEtBQWpDLG1DQUFpQyxLQUFqQyxDQUFQLENBQ0QsQ0FDRixDQVRELEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F5Q0EsS0FBSyxLQUFMLENBQVcsS0FBWCxDQUFtQixTQUFTLE9BQVQsQ0FBa0IsQztBQUduQyxHQUFJLE1BQU0saUJBQVYsQ0FBNkIsQ0FDM0IsTUFBTSxpQkFBTixDQUF3QixJQUF4QixDQUE4QixLQUFLLEtBQUwsQ0FBVyxLQUF6QyxFQUNELENBRkQsS0FFTyxDQUNMLElBQUksTUFBUSxJQUFJLEtBQUosR0FBWSxLQUF4QixDQUNBLEdBQUksS0FBSixDQUFXLENBQ1QsS0FBSyxLQUFMLENBQWEsS0FBYixDQUNELENBQ0YsQ0FFRCxHQUFJLE9BQUosQ0FBYSxDQUNYLEtBQUssT0FBTCxDQUFlLE9BQU8sT0FBUCxDQUFmLENBQ0QsQzs7Ozs7O0tBU0QsS0FBSyxtQkFBTCxDQUEyQixJQUEzQixDQUNELENBeEJELENBeUJBLEtBQUssUUFBTCxDQUFjLEtBQUssS0FBTCxDQUFXLEtBQXpCLENBQWdDLEtBQWhDLEUsaUJBSUEsS0FBSyxLQUFMLENBQVcsS0FBWCxDQUFpQixTQUFqQixDQUEyQixJQUEzQixDQUFrQyxhQUFsQyxDOztHQU9BLEtBQUssR0FBTCxDQUFXLEVBQVgsQzs7Ozs7Ozs7Ozs7O0dBZUEsS0FBSyxHQUFMLENBQVMsUUFBVCxDQUFvQixDQUNsQixRQUFTLENBRFMsQ0FFbEIsVUFBVyxDQUZPLENBR2xCLEtBQU0sQ0FIWSxDQUlsQixjQUFlLENBSkcsQ0FLbEIsaUJBQWtCLENBTEEsQ0FNbEIsT0FBUSxDQU5VLENBT2xCLHVCQUF3QixDQVBOLENBUWxCLFFBQVMsQ0FSUyxDQVNsQixTQUFVLENBVFEsQ0FVbEIsY0FBZSxFQVZHLENBV2xCLGtCQUFtQixFQVhELENBWWxCLFNBQVUsRUFaUSxDQUFwQixDOzs7Ozs7Ozs7Ozs7Ozs7OztHQXFDQSxLQUFLLE9BQUwsQ0FBYSxnQkFBYixFQUNBLEtBQUssT0FBTCxDQUFhLG9CQUFiLEVBQ0EsS0FBSyxPQUFMLENBQWEsa0NBQWIsRUFDQSxLQUFLLE9BQUwsQ0FBYSx1QkFBYixFOzs7Ozs7O0dBV0EsS0FBSyxNQUFMLENBQVksMEJBQVosQ0FBd0MsS0FBeEMsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBeUJBLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxNQUFmLENBQXdCLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxTQUFmLEVBQ25CLENBQUMsS0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixDQUF0QixDQUF5QixDQUF6QixFQUE0QixXQUE1QixJQUE2QyxJQUE3QyxFQUNBLEtBQUssTUFBTCxDQUFZLFNBQVosQ0FBc0IsQ0FBdEIsQ0FBeUIsQ0FBekIsRUFBNEIsV0FBNUIsSUFBNkMsSUFEN0MsRUFFQSxLQUFLLE1BQUwsQ0FBWSxTQUFaLENBQXNCLENBQXRCLENBQXlCLENBQXpCLEVBQTRCLFdBQTVCLElBQTZDLElBRjdDLEVBR0EsS0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixDQUF0QixDQUF5QixDQUF6QixFQUE0QixXQUE1QixJQUE2QyxJQUg3QyxFQUlBLEtBQUssTUFBTCxDQUFZLFNBQVosQ0FBc0IsQ0FBdEIsQ0FBeUIsQ0FBekIsRUFBNEIsV0FBNUIsSUFBNkMsSUFKN0MsRUFLQSxLQUFLLE1BQUwsQ0FBWSxTQUFaLENBQXNCLENBQXRCLENBQXlCLENBQXpCLEVBQTRCLFdBQTVCLElBQTZDLElBTDdDLEVBTUEsS0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixDQUF0QixDQUF5QixDQUF6QixFQUE0QixXQUE1QixJQUE2QyxJQU43QyxFQU9BLEtBQUssTUFBTCxDQUFZLFNBQVosQ0FBc0IsQ0FBdEIsQ0FBeUIsQ0FBekIsRUFBNEIsV0FBNUIsSUFBNkMsSUFQN0MsRUFRQSxLQUFLLE1BQUwsQ0FBWSxTQUFaLENBQXNCLENBQXRCLENBQXlCLENBQXpCLEVBQTRCLFdBQTVCLElBQTZDLElBUjlDLElBU0MsS0FBSyxNQUFMLENBQVksTUFBWixFQUFzQixDQUF0QixFQUEyQixLQUFLLE1BQUwsQ0FBWSxTQUFaLENBQXNCLENBQXRCLENBQXlCLENBQXpCLEdBQStCLEdBQTFELEVBQ0EsS0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixDQUF0QixDQUF5QixDQUF6QixHQUErQixHQVZoQyxDQURtQixFQVluQixLQUFLLE1BQUwsQ0FBWSxNQUFaLEVBQXNCLENBQXRCLEVBQ0EsS0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixDQUF0QixDQUF5QixDQUF6QixFQUE0QixXQUE1QixJQUE2QyxLQUQ3QyxHQUVDLEtBQUssTUFBTCxDQUFZLE1BQVosRUFBc0IsQ0FBdEIsRUFBMkIsS0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixDQUF0QixDQUF5QixDQUF6QixHQUErQixHQUExRCxFQUNBLEtBQUssTUFBTCxDQUFZLFNBQVosQ0FBc0IsQ0FBdEIsQ0FBeUIsQ0FBekIsR0FBK0IsR0FIaEMsQ0FaTCxDOzs7R0FzQkEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLE1BQWYsQ0FBd0IsQywwREFFdEIsSUFBSyxHQUZpQixDLDBEQUl0QixJQUFLLEdBSmlCLEMsNkRBTXRCLElBQUssR0FOaUIsQyxxREFRdEIsSUFBSyxHQVJpQixDLHFEQVV0QixJQUFLLEdBVmlCLENBQXhCLEM7OztHQWtCQSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsR0FBZixDQUFxQixDOztLQUluQixJQUFLLENBSmMsQzs7S0FTbkIsSUFBSyxDQUFDLENBVGEsQzs7S0FjbkIsUUFBUyxDQWRVLENBQXJCLEM7OztHQXNCQSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsS0FBZixDQUF1QixPQUF2QixDOzs7R0FPQSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsSUFBZixDQUFzQixNQUF0QixDOzs7R0FPQSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsVUFBZixDQUNJLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxNQUFmLENBQXdCLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxJQUF2QyxDQUE4QyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsS0FEakUsQzs7O0dBUUEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLFNBQWYsQ0FDSSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsTUFBZixDQUF3QixLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsS0FBdkMsQ0FBK0MsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLElBRGxFLEM7Ozs7Ozs7Ozs7Ozs7Ozs7R0FxQkEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLEtBQWYsQ0FBdUIsU0FBUyxRQUFULENBQW1CLGFBQW5CLENBQWtDLENBQ3ZELEdBQUksT0FBTyxRQUFQLEVBQW1CLFFBQXZCLENBQWlDLEM7QUFFL0IsT0FBTyxTQUFXLENBQVgsQ0FBZSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsR0FBZixDQUFtQixHQUFsQyxDQUF3QyxTQUFXLENBQVgsQ0FDekIsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLEdBQWYsQ0FBbUIsR0FETSxDQUV6QixjQUFnQixJQUFoQixDQUF1QixLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsR0FBZixDQUFtQixPQUZoRSxDQUdELENBTEQsS0FLTyxHQUFJLFVBQVksSUFBaEIsQ0FBc0IsQ0FDM0IsT0FBTyxJQUFQLENBQ0QsQ0FGTSxLQUVBLEM7QUFFTCxPQUFPLFNBQVcsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLEdBQWYsQ0FBbUIsR0FBOUIsQ0FBb0MsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLEdBQWYsQ0FBbUIsR0FBOUQsQ0FDRCxDQUNGLENBWkQsQzs7Ozs7O0dBc0JBLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxTQUFmLENBQ0ksd0JBQ0EsWUFGSixDOzs7Ozs7R0FZQSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsU0FBZixDQUNJLGVBREosQzs7Ozs7O0dBV0EsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLFlBQWYsQ0FBOEIsa0JBQTlCLEM7Ozs7Ozs7Ozs7OztHQWdCQSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsa0JBQWYsQ0FBb0MsU0FBUyxHQUFULENBQWMsaUJBQWQsQ0FBaUMsQ0FDbkUsT0FBTyxrQkFBb0IsSUFBSSxPQUFKLENBQVksS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLFlBQTNCLENBQXlDLEVBQXpDLENBQXBCLENBQW1FLEdBQTFFLENBQ0QsQ0FGRCxDOzs7O0dBVUEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLFdBQWYsQ0FBNkIsSUFBSSxNQUFKLENBQVcsSUFBTSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsU0FBckIsQ0FBaUMsR0FBNUMsQ0FBN0IsQzs7OztHQVFBLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxXQUFmLENBQTZCLElBQUksTUFBSixDQUFXLElBQU0sS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLFNBQXJCLENBQWlDLEdBQTVDLENBQTdCLEM7Ozs7OztHQVVBLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxTQUFmLENBQTJCLFNBQVMsR0FBVCxDQUFjLFVBQWQsQ0FBMEIsQ0FDbkQsT0FBTyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsV0FBZixDQUEyQixJQUEzQixDQUNILEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxrQkFBZixDQUFrQyxHQUFsQyxDQUF1QyxVQUF2QyxDQURHLENBQVAsQ0FFRCxDQUhELEM7Ozs7O0dBWUEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLFVBQWYsQ0FBNEIsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLFNBQTNDLEM7Ozs7OztHQVVBLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxTQUFmLENBQTJCLFNBQVMsR0FBVCxDQUFjLFVBQWQsQ0FBMEIsQ0FDbkQsT0FBTyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsV0FBZixDQUEyQixJQUEzQixDQUNILEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxrQkFBZixDQUFrQyxHQUFsQyxDQUF1QyxVQUF2QyxDQURHLENBQVAsQ0FFRCxDQUhELEM7Ozs7O0dBWUEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLE1BQWYsQ0FBd0IsSUFBSSxNQUFKLENBQVcsS0FBTyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsU0FBdEIsQ0FBa0MsR0FBN0MsQ0FBeEIsQzs7Ozs7R0FTQSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsTUFBZixDQUF3QixJQUFJLE1BQUosQ0FBVyxLQUFPLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxTQUF0QixDQUFrQyxHQUE3QyxDQUF4QixDOzs7O0dBUUEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLFNBQWYsQ0FBMkIsU0FBUyxHQUFULENBQWMsQ0FDdkMsT0FBTyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsTUFBZixDQUFzQixJQUF0QixDQUEyQixHQUEzQixDQUFQLENBQ0QsQ0FGRCxDOzs7O0dBVUEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLFNBQWYsQ0FBMkIsU0FBUyxHQUFULENBQWMsQ0FDdkMsT0FBTyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsTUFBZixDQUFzQixJQUF0QixDQUEyQixHQUEzQixDQUFQLENBQ0QsQ0FGRCxDOzs7O0dBVUEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGFBQWYsQ0FBK0IsU0FBUyxHQUFULENBQWMsQ0FDM0MsT0FBTyxDQUFDLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxTQUFmLENBQXlCLEdBQXpCLENBQUQsRUFBa0MsQ0FBQyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsU0FBZixDQUF5QixHQUF6QixDQUExQyxDQUNELENBRkQsQzs7Ozs7R0FXQSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsY0FBZixDQUFnQyxJQUFJLE1BQUosQ0FDNUIsTUFBUSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsU0FBdkIsQ0FBbUMsS0FBbkMsQ0FBMkMsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLFNBQTFELENBQXNFLEdBRDFDLENBQWhDLEM7Ozs7O0dBVUEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGNBQWYsQ0FBZ0MsSUFBSSxNQUFKLENBQzVCLE1BQVEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLFNBQXZCLENBQW1DLEtBQW5DLENBQTJDLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxTQUExRCxDQUFzRSxHQUQxQyxDQUFoQyxDOzs7Ozs7O0dBWUEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGFBQWYsQ0FBK0IsU0FBUyxHQUFULENBQWMsVUFBZCxDQUEwQixDQUN2RCxPQUFPLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxjQUFmLENBQThCLElBQTlCLENBQ0gsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGtCQUFmLENBQWtDLEdBQWxDLENBQXVDLFVBQXZDLENBREcsQ0FBUCxDQUVELENBSEQsQzs7Ozs7Ozs7R0FlQSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsU0FBZixDQUEyQixLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsYUFBMUMsQzs7Ozs7OztHQVdBLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxhQUFmLENBQStCLFNBQVMsR0FBVCxDQUFjLFVBQWQsQ0FBMEIsQ0FDdkQsT0FBTyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsY0FBZixDQUE4QixJQUE5QixDQUNILEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxrQkFBZixDQUFrQyxHQUFsQyxDQUF1QyxVQUF2QyxDQURHLENBQVAsQ0FFRCxDQUhELEM7Ozs7Ozs7O0dBZUEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLFNBQWYsQ0FBMkIsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGFBQTFDLEM7Ozs7Ozs7R0FXQSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsZ0JBQWYsQ0FBa0MsY0FBbEMsQzs7Ozs7OztHQVdBLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxhQUFmLENBQStCLFNBQVMsR0FBVCxDQUFjLFVBQWQsQ0FBMEIsQ0FDdkQsSUFBTSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsa0JBQWYsQ0FBa0MsR0FBbEMsQ0FBdUMsVUFBdkMsQ0FBTixDQUNBLE9BQU8sS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGdCQUFmLENBQWdDLElBQWhDLENBQXFDLEdBQXJDLEdBQ0gsQ0FBQyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsU0FBZixDQUF5QixHQUF6QixDQUFELEVBQWtDLENBQUMsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLFNBQWYsQ0FBeUIsR0FBekIsQ0FEdkMsQ0FFRCxDQUpELEM7Ozs7O0dBYUEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGtCQUFmLENBQW9DLElBQUksTUFBSixDQUNoQyxJQUFNLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxTQUFyQixDQUFpQyxLQUFqQyxDQUF5QyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsU0FBeEQsQ0FBb0UsS0FEcEMsQ0FBcEMsQzs7Ozs7R0FVQSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsa0JBQWYsQ0FBb0MsSUFBSSxNQUFKLENBQ2hDLElBQU0sS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLFNBQXJCLENBQWlDLEtBQWpDLENBQXlDLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxTQUF4RCxDQUFvRSxLQURwQyxDQUFwQyxDOzs7Ozs7O0dBWUEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLFdBQWYsQ0FBNkIsU0FBUyxHQUFULENBQWMsVUFBZCxDQUEwQixDQUNyRCxPQUFPLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxrQkFBZixDQUFrQyxJQUFsQyxDQUNILEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxrQkFBZixDQUFrQyxHQUFsQyxDQUF1QyxVQUF2QyxDQURHLENBQVAsQ0FFRCxDQUhELEM7Ozs7Ozs7O0dBZUEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGFBQWYsQ0FBK0IsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLFdBQTlDLEM7Ozs7Ozs7R0FXQSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsV0FBZixDQUE2QixTQUFTLEdBQVQsQ0FBYyxVQUFkLENBQTBCLENBQ3JELE9BQU8sS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGtCQUFmLENBQWtDLElBQWxDLENBQ0gsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGtCQUFmLENBQWtDLEdBQWxDLENBQXVDLFVBQXZDLENBREcsQ0FBUCxDQUVELENBSEQsQzs7Ozs7Ozs7R0FlQSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsYUFBZixDQUErQixLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsV0FBOUMsQzs7Ozs7R0FTQSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsYUFBZixDQUErQixJQUFJLE1BQUosQ0FDM0IsMkNBQ0ksbUNBREosQ0FFSSxxQ0FIdUIsQ0FJM0IsR0FKMkIsQ0FBL0IsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNkJBLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxhQUFmLENBQStCLFNBQVMsSUFBVCxDQUFlLENBQzVDLE9BQU8sS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGFBQWYsQ0FBNkIsSUFBN0IsQ0FBa0MsSUFBbEMsQ0FBUCxDQUNELENBRkQsQzs7OztHQVVBLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxtQkFBZixDQUNJLDRDQURKLEM7Ozs7Ozs7Ozs7R0FlQSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsa0JBQWYsQ0FBb0MsU0FBUyxDQUFULENBQVksZ0JBQVosQ0FBOEIsQ0FDaEUsSUFBSSxPQUFTLG1CQUFxQixTQUFyQixDQUFpQyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsU0FBZixDQUF5QixDQUF6QixDQUFqQyxDQUNpQyxnQkFEOUMsQ0FFQSxJQUFJLEtBQU8sT0FBUyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsTUFBZixDQUFzQixHQUEvQixDQUFxQyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsTUFBZixDQUFzQixHQUF0RSxDQUNBLE9BQU8sRUFBRSxPQUFGLENBQVUsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLG1CQUF6QixDQUE4QyxLQUFPLElBQVAsQ0FBYyxJQUE1RCxDQUFQLENBQ0QsQ0FMRCxDOzs7Ozs7Ozs7R0FrQkEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGdCQUFmLENBQWtDLFNBQVMsSUFBVCxDQUFlLENBQy9DLEdBQUksS0FBSyxNQUFMLENBQVksQ0FBWixHQUFrQixHQUF0QixDQUEyQixDQUN6QixPQUFPLEtBQUssT0FBTCxDQUFhLE1BQWIsQ0FBcUIsWUFBckIsQ0FBUCxDQUNELEM7QUFFRCxPQUFPLG1CQUFxQixJQUFyQixDQUE0QixTQUFuQyxDQUNELENBTkQsQzs7Ozs7R0FlQSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsZ0JBQWYsQ0FBa0MsU0FBUyxJQUFULENBQWUsQ0FDL0MsT0FBTyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsTUFBZixDQUFzQixHQUF0QixDQUE0QixJQUE1QixDQUFtQyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsTUFBZixDQUFzQixHQUFoRSxDQUNELENBRkQsQzs7Ozs7Ozs7O0dBZUEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGdCQUFmLENBQWtDLFNBQVMsSUFBVCxDQUFlLENBQy9DLEdBQUksS0FBSyxNQUFMLENBQVksQ0FBWixHQUFrQixHQUF0QixDQUEyQixDQUN6QixPQUFPLEtBQUssT0FBTCxDQUFhLE1BQWIsQ0FBcUIsWUFBckIsQ0FBUCxDQUNELEM7QUFFRCxPQUFPLG1CQUFxQixJQUFyQixDQUE0QixTQUFuQyxDQUNELENBTkQsQzs7Ozs7R0FlQSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsZ0JBQWYsQ0FBa0MsU0FBUyxJQUFULENBQWUsQ0FDL0MsT0FBTyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsTUFBZixDQUFzQixHQUF0QixDQUE0QixJQUE1QixDQUFtQyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsTUFBZixDQUFzQixHQUFoRSxDQUNELENBRkQsQzs7OztHQVVBLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxhQUFmLENBQ0ksb0VBREosQzs7OztHQVNBLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxPQUFmLENBQXlCLFFBQXpCLEM7Ozs7R0FRQSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsUUFBZixDQUEwQixTQUExQixDOzs7O0dBUUEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLE9BQWYsQ0FBeUIsT0FBekIsQzs7Ozs7OztHQVdBLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxTQUFmLENBQTJCLFNBQVMsTUFBVCxDQUFpQixDQUMxQyxPQUFPLE87QUFHSCxPQUhHLENBR0ssS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGFBSHBCLENBR21DLGNBSG5DLEVBSUYsT0FKRSxDQUlNLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxPQUpyQixDQUk4QixNQUo5QixFO0FBTUgsT0FORyxDQU1LLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxRQU5wQixDQU04QixLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsSUFON0MsRUFPRixPQVBFLENBT00sS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLE9BUHJCLENBTzhCLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxLQVA3QyxDQUFQLENBUUQsQ0FURCxDOzs7OztHQWtCQSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsd0JBQWYsQ0FBMEMscUJBQTFDLEM7Ozs7O0dBU0EsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLHdCQUFmLENBQTBDLHFCQUExQyxDOzs7OztHQVNBLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxvQkFBZixDQUFzQyxTQUFTLEdBQVQsQ0FBYyxDQUNsRCxPQUFPLElBQUksT0FBSixDQUFZLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSx3QkFBM0IsQ0FBcUQsS0FBckQsRUFDRixPQURFLENBQ00sS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLHdCQURyQixDQUMrQyxLQUQvQyxDQUFQLENBRUQsQ0FIRCxDOzs7OztHQVlBLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxnQkFBZixDQUFrQyxLQUFsQyxDOzs7Ozs7Ozs7Ozs7Ozs7O0dBb0JBLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxjQUFmLENBQWdDLG1CQUFoQyxDOzs7O0dBUUEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLHNCQUFmLENBQXdDLElBQXhDLEM7Ozs7Ozs7Ozs7O0dBZUEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGlCQUFmLENBQW1DLFNBQVMsR0FBVCxDQUFjLFVBQWQsQ0FBMEIsQ0FDM0QsSUFBSSxTQUFXLENBQWYsQ0FDQSxJQUFJLFdBQWEsQ0FBakIsQ0FDQSxJQUFJLGFBQWUsS0FBbkIsQ0FDQSxJQUFJLE9BQVMsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGtCQUFmLENBQWtDLEdBQWxDLENBQXVDLFVBQXZDLEVBQ0ssS0FETCxDQUNXLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxnQkFEMUIsQ0FBYixDQUVBLElBQUssSUFBSSxFQUFJLENBQWIsQ0FBZ0IsRUFBSSxPQUFPLE1BQTNCLENBQW1DLEdBQW5DLENBQXdDLENBQ3RDLElBQUksTUFBUSxPQUFPLENBQVAsQ0FBWixDQUNBLEdBQUksS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGFBQWYsQ0FBNkIsS0FBN0IsQ0FBSixDQUF5QyxDQUN2QyxXQUNBLGFBQ0QsQ0FIRCxLQUdPLEdBQUksS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGdCQUFmLENBQWdDLElBQWhDLENBQXFDLEtBQXJDLENBQUosQ0FBaUQsQ0FDdEQsYUFBZSxJQUFmLENBQ0QsQ0FGTSxLQUVBLEdBQUksS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLFNBQWYsQ0FBeUIsS0FBekIsQ0FBSixDQUFxQyxDQUMxQyxhQUNELENBRk0sS0FFQSxHQUFJLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxjQUFmLENBQThCLElBQTlCLENBQW1DLEtBQW5DLENBQUosQ0FBK0MsQ0FDcEQsYUFBZSxJQUFmLENBQ0QsQ0FDRixDQUVELE9BQU8sWUFBYyxDQUFkLENBQ0YsYUFBZSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsR0FBZixDQUFtQixHQUFsQyxDQUF3QyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsR0FBZixDQUFtQixPQUR6RCxDQUVGLFNBQVcsVUFBWCxDQUF3QixLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsc0JBQXZDLENBQ0ksS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLEdBQWYsQ0FBbUIsR0FEdkIsQ0FFSSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsR0FBZixDQUFtQixHQUo1QixDQUtELENBekJELEM7Ozs7Ozs7R0FvQ0EsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLHVCQUFmLENBQXlDLFNBQVMsR0FBVCxDQUFjLFVBQWQsQ0FBMEIsQ0FDakUsT0FBTyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsaUJBQWYsQ0FBaUMsR0FBakMsQ0FBc0MsVUFBdEMsR0FDSCxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsR0FBZixDQUFtQixHQUR2QixDQUVELENBSEQsQzs7Ozs7Ozs7Ozs7R0FrQkEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLHFCQUFmLENBQXVDLFNBQVMsT0FBVCxDQUFrQixHQUFsQixDQUF1QixDQUM1RCxHQUFJLE9BQUosQ0FBYSxDQUNYLElBQU0sS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLEtBQWYsQ0FBcUIsR0FBckIsQ0FBTixDQUNBLEdBQUksR0FBSixDQUFTLENBQ1AsUUFBUSxLQUFSLENBQWMsU0FBZCxDQUEwQixLQUFPLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxHQUFmLENBQW1CLEdBQTFCLENBQ3RCLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxLQURPLENBRXRCLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxJQUZuQixDQUdBLFFBQVEsR0FBUixDQUFjLEtBQU8sS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLEdBQWYsQ0FBbUIsR0FBMUIsQ0FBZ0MsS0FBaEMsQ0FBd0MsS0FBdEQsQ0FDRCxDQUNGLENBQ0YsQ0FWRCxDOzs7O0dBa0JBLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxpQ0FBZixDQUFtRCxTQUFTLE9BQVQsQ0FBa0IsSUFBbEIsQ0FBd0IsQ0FDekUsT0FBUSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsaUJBQWYsQ0FBaUMsSUFBakMsQ0FBUixFQUNFLEtBQU0sS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLEdBQWYsQ0FBbUIsR0FBekIsQ0FDRSxRQUFRLEdBQVIsQ0FBYyxLQUFkLENBQ0EsTUFDRixLQUFNLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxHQUFmLENBQW1CLEdBQXpCLENBQ0UsUUFBUSxHQUFSLENBQWMsS0FBZCxDQUNBLE1BQ0YsUTtBQUVFLFFBQVEsZUFBUixDQUF3QixLQUF4QixFQVRKLENBV0QsQ0FaRCxDOzs7Ozs7R0F1QkEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGlCQUFmLENBQW1DLFVBQVcsQ0FBRSxDQUFoRCxDOzs7Ozs7O0dBV0EsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGlCQUFmLENBQWlDLFNBQWpDLENBQ0ssdUNBREwsQzs7O0dBUUEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGlCQUFmLENBQWlDLFNBQWpDLENBQTJDLFlBQTNDLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTBDQSxLQUFLLE9BQUwsQ0FBYSxjQUFiLEU7O0dBS0EsS0FBSyxNQUFMLENBQVksNkJBQVosQ0FBMkMsS0FBSyxLQUFoRCxFOzs7Ozs7O0dBWUEsS0FBSyxPQUFMLENBQWEsY0FBYixDQUE4QixTQUFTLGNBQVQsQ0FBeUIsV0FBekIsQ0FBc0MsQ0FDbEUsWUFBWSxPQUFaLENBQW9CLGNBQXBCLEVBQ0EsS0FBSyxLQUFMLENBQVcsS0FBWCxDQUFpQixJQUFqQixDQUFzQixJQUF0QixDQUE0QixLQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLEtBQWpCLENBQXVCLElBQXZCLENBQTZCLFdBQTdCLENBQTVCLEU7O0FBR0EsWUFBWSxLQUFaLEc7Ozs7S0FPQSxLQUFLLGNBQUwsQ0FBc0IsY0FBdEIsQ0FDRCxDQWJELENBY0EsS0FBSyxRQUFMLENBQWMsS0FBSyxPQUFMLENBQWEsY0FBM0IsQ0FBMkMsS0FBSyxLQUFMLENBQVcsS0FBdEQsRSxpQkFJQSxLQUFLLE9BQUwsQ0FBYSxjQUFiLENBQTRCLFNBQTVCLENBQXNDLElBQXRDLENBQTZDLGdCQUE3QyxDOzs7R0FPQSxLQUFLLE9BQUwsQ0FBYSxxQkFBYixDQUFxQyxTQUFTLENBQVQsQ0FBWSxDQUMvQyxNQUFNLENBQU4sQ0FDRCxDQUZELEM7OztHQVNBLEtBQUssT0FBTCxDQUFhLGFBQWIsQ0FBNkIsS0FBSyxPQUFMLENBQWEscUJBQTFDLEM7Ozs7Ozs7OztHQWFBLEtBQUssT0FBTCxDQUFhLGdCQUFiLENBQWdDLFNBQzVCLGNBRDRCLENBQ1osV0FEWSxDQUNDLFlBREQsQ0FDZSxTQURmLENBQzBCLENBQ3hELElBQUksUUFBVSxrQkFBZCxDQUNBLEdBQUksWUFBSixDQUFrQixDQUNoQixTQUFXLEtBQU8sWUFBbEIsQ0FDQSxJQUFJLEtBQU8sU0FBWCxDQUNELENBSEQsS0FHTyxHQUFJLGNBQUosQ0FBb0IsQ0FDekIsU0FBVyxLQUFPLGNBQWxCLENBQ0EsS0FBTyxXQUFQLENBQ0QsQzs7OztBQUtELElBQUksRUFBSSxJQUFJLEtBQUssT0FBTCxDQUFhLGNBQWpCLENBQWdDLEdBQUssT0FBckMsQ0FBOEMsTUFBUSxFQUF0RCxDQUFSLENBQ0EsS0FBSyxPQUFMLENBQWEsYUFBYixDQUEyQixDQUEzQixFQUNELENBaEJELEM7Ozs7O0dBeUJBLEtBQUssT0FBTCxDQUFhLGVBQWIsQ0FBK0IsU0FBUyxZQUFULENBQXVCLENBQ3BELEdBQUksS0FBSyxPQUFMLENBQWEsY0FBakIsQ0FBaUMsQ0FDL0IsS0FBSyxPQUFMLENBQWEsYUFBYixDQUE2QixZQUE3QixDQUNELENBQ0YsQ0FKRCxDOzs7Ozs7Ozs7R0FpQkEsS0FBSyxPQUFMLENBQWEsTUFBYixDQUFzQixTQUFTLFNBQVQsQ0FBb0IsV0FBcEIsQ0FBaUMsUUFBakMsQ0FBMkMsQ0FDL0QsR0FBSSxLQUFLLE9BQUwsQ0FBYSxjQUFiLEVBQStCLENBQUMsU0FBcEMsQ0FBK0MsQ0FDN0MsS0FBSyxPQUFMLENBQWEsZ0JBQWIsQ0FDSSxFQURKLENBQ1EsSUFEUixDQUNjLFdBRGQsQ0FDMkIsTUFBTSxTQUFOLENBQWdCLEtBQWhCLENBQXNCLElBQXRCLENBQTJCLFNBQTNCLENBQXNDLENBQXRDLENBRDNCLEVBRUQsQ0FDRCxPQUFPLFNBQVAsQ0FDRCxDQU5ELEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMkJBLEtBQUssT0FBTCxDQUFhLElBQWIsQ0FBb0IsU0FBUyxXQUFULENBQXNCLFFBQXRCLENBQWdDLENBQ2xELEdBQUksS0FBSyxPQUFMLENBQWEsY0FBakIsQ0FBaUMsQ0FDL0IsS0FBSyxPQUFMLENBQWEsYUFBYixDQUNJLElBQUksS0FBSyxPQUFMLENBQWEsY0FBakIsQ0FDSSxXQUFhLFlBQWMsS0FBTyxXQUFyQixDQUFtQyxFQUFoRCxDQURKLENBRUksTUFBTSxTQUFOLENBQWdCLEtBQWhCLENBQXNCLElBQXRCLENBQTJCLFNBQTNCLENBQXNDLENBQXRDLENBRkosQ0FESixFQUlELENBQ0YsQ0FQRCxDOzs7Ozs7O0dBa0JBLEtBQUssT0FBTCxDQUFhLFlBQWIsQ0FBNEIsU0FBUyxLQUFULENBQWdCLFdBQWhCLENBQTZCLFFBQTdCLENBQXVDLENBQ2pFLEdBQUksS0FBSyxPQUFMLENBQWEsY0FBYixFQUErQixDQUFDLEtBQUssUUFBTCxDQUFjLEtBQWQsQ0FBcEMsQ0FBMEQsQ0FDeEQsS0FBSyxPQUFMLENBQWEsZ0JBQWIsQ0FDSSxpQ0FESixDQUN1QyxDQUFDLEtBQUssTUFBTCxDQUFZLEtBQVosQ0FBRCxDQUFxQixLQUFyQixDQUR2QyxDQUVJLFdBRkosQ0FFaUIsTUFBTSxTQUFOLENBQWdCLEtBQWhCLENBQXNCLElBQXRCLENBQTJCLFNBQTNCLENBQXNDLENBQXRDLENBRmpCLEVBR0QsQ0FDRCxPLHVCQUE4QixLQUE5QixFQUNELENBUEQsQzs7Ozs7OztHQWtCQSxLQUFLLE9BQUwsQ0FBYSxZQUFiLENBQTRCLFNBQVMsS0FBVCxDQUFnQixXQUFoQixDQUE2QixRQUE3QixDQUF1QyxDQUNqRSxHQUFJLEtBQUssT0FBTCxDQUFhLGNBQWIsRUFBK0IsQ0FBQyxLQUFLLFFBQUwsQ0FBYyxLQUFkLENBQXBDLENBQTBELENBQ3hELEtBQUssT0FBTCxDQUFhLGdCQUFiLENBQ0ksaUNBREosQ0FDdUMsQ0FBQyxLQUFLLE1BQUwsQ0FBWSxLQUFaLENBQUQsQ0FBcUIsS0FBckIsQ0FEdkMsQ0FFSSxXQUZKLENBRWlCLE1BQU0sU0FBTixDQUFnQixLQUFoQixDQUFzQixJQUF0QixDQUEyQixTQUEzQixDQUFzQyxDQUF0QyxDQUZqQixFQUdELENBQ0QsTyx1QkFBOEIsS0FBOUIsRUFDRCxDQVBELEM7Ozs7Ozs7O0dBbUJBLEtBQUssT0FBTCxDQUFhLGNBQWIsQ0FBOEIsU0FBUyxLQUFULENBQWdCLFdBQWhCLENBQTZCLFFBQTdCLENBQXVDLENBQ25FLEdBQUksS0FBSyxPQUFMLENBQWEsY0FBYixFQUErQixDQUFDLEtBQUssVUFBTCxDQUFnQixLQUFoQixDQUFwQyxDQUE0RCxDQUMxRCxLQUFLLE9BQUwsQ0FBYSxnQkFBYixDQUNJLG1DQURKLENBQ3lDLENBQUMsS0FBSyxNQUFMLENBQVksS0FBWixDQUFELENBQXFCLEtBQXJCLENBRHpDLENBRUksV0FGSixDQUVpQixNQUFNLFNBQU4sQ0FBZ0IsS0FBaEIsQ0FBc0IsSUFBdEIsQ0FBMkIsU0FBM0IsQ0FBc0MsQ0FBdEMsQ0FGakIsRUFHRCxDQUNELE8sMEJBQWlDLEtBQWpDLEVBQ0QsQ0FQRCxDOzs7Ozs7O0dBa0JBLEtBQUssT0FBTCxDQUFhLFlBQWIsQ0FBNEIsU0FBUyxLQUFULENBQWdCLFdBQWhCLENBQTZCLFFBQTdCLENBQXVDLENBQ2pFLEdBQUksS0FBSyxPQUFMLENBQWEsY0FBYixFQUErQixDQUFDLEtBQUssUUFBTCxDQUFjLEtBQWQsQ0FBcEMsQ0FBMEQsQ0FDeEQsS0FBSyxPQUFMLENBQWEsZ0JBQWIsQ0FDSSxpQ0FESixDQUN1QyxDQUFDLEtBQUssTUFBTCxDQUFZLEtBQVosQ0FBRCxDQUFxQixLQUFyQixDQUR2QyxDQUVJLFdBRkosQ0FFaUIsTUFBTSxTQUFOLENBQWdCLEtBQWhCLENBQXNCLElBQXRCLENBQTJCLFNBQTNCLENBQXNDLENBQXRDLENBRmpCLEVBR0QsQ0FDRCxPLHdCQUErQixLQUEvQixFQUNELENBUEQsQzs7Ozs7OztHQWtCQSxLQUFLLE9BQUwsQ0FBYSxXQUFiLENBQTJCLFNBQVMsS0FBVCxDQUFnQixXQUFoQixDQUE2QixRQUE3QixDQUF1QyxDQUNoRSxHQUFJLEtBQUssT0FBTCxDQUFhLGNBQWIsRUFBK0IsQ0FBQyxLQUFLLE9BQUwsQ0FBYSxLQUFiLENBQXBDLENBQXlELENBQ3ZELEtBQUssT0FBTCxDQUFhLGdCQUFiLENBQ0ksZ0NBREosQ0FDc0MsQ0FBQyxLQUFLLE1BQUwsQ0FBWSxLQUFaLENBQUQsQ0FBcUIsS0FBckIsQ0FEdEMsQ0FFSSxXQUZKLENBRWlCLE1BQU0sU0FBTixDQUFnQixLQUFoQixDQUFzQixJQUF0QixDQUEyQixTQUEzQixDQUFzQyxDQUF0QyxDQUZqQixFQUdELENBQ0QsTywwQkFBaUMsS0FBakMsRUFDRCxDQVBELEM7Ozs7Ozs7O0dBbUJBLEtBQUssT0FBTCxDQUFhLGFBQWIsQ0FBNkIsU0FBUyxLQUFULENBQWdCLFdBQWhCLENBQTZCLFFBQTdCLENBQXVDLENBQ2xFLEdBQUksS0FBSyxPQUFMLENBQWEsY0FBYixFQUErQixDQUFDLEtBQUssU0FBTCxDQUFlLEtBQWYsQ0FBcEMsQ0FBMkQsQ0FDekQsS0FBSyxPQUFMLENBQWEsZ0JBQWIsQ0FDSSxrQ0FESixDQUN3QyxDQUFDLEtBQUssTUFBTCxDQUFZLEtBQVosQ0FBRCxDQUFxQixLQUFyQixDQUR4QyxDQUVJLFdBRkosQ0FFaUIsTUFBTSxTQUFOLENBQWdCLEtBQWhCLENBQXNCLElBQXRCLENBQTJCLFNBQTNCLENBQXNDLENBQXRDLENBRmpCLEVBR0QsQ0FDRCxPLHdCQUErQixLQUEvQixFQUNELENBUEQsQzs7Ozs7Ozs7R0FtQkEsS0FBSyxPQUFMLENBQWEsYUFBYixDQUE2QixTQUFTLEtBQVQsQ0FBZ0IsV0FBaEIsQ0FBNkIsUUFBN0IsQ0FBdUMsQ0FDbEUsR0FBSSxLQUFLLE9BQUwsQ0FBYSxjQUFiLEdBQ0MsQ0FBQyxLQUFLLFFBQUwsQ0FBYyxLQUFkLENBQUQsRUFBeUIsTUFBTSxRQUFOLEVBQWtCLEtBQUssR0FBTCxDQUFTLFFBQVQsQ0FBa0IsT0FEOUQsQ0FBSixDQUM0RSxDQUMxRSxLQUFLLE9BQUwsQ0FBYSxnQkFBYixDQUNJLGtDQURKLENBQ3dDLENBQUMsS0FBSyxNQUFMLENBQVksS0FBWixDQUFELENBQXFCLEtBQXJCLENBRHhDLENBRUksV0FGSixDQUVpQixNQUFNLFNBQU4sQ0FBZ0IsS0FBaEIsQ0FBc0IsSUFBdEIsQ0FBMkIsU0FBM0IsQ0FBc0MsQ0FBdEMsQ0FGakIsRUFHRCxDQUNELE8seUJBQWdDLEtBQWhDLEVBQ0QsQ0FSRCxDOzs7Ozs7Ozs7Ozs7OztHQTBCQSxLQUFLLE9BQUwsQ0FBYSxnQkFBYixDQUFnQyxTQUFTLEtBQVQsQ0FBZ0IsSUFBaEIsQ0FBc0IsV0FBdEIsQ0FBbUMsUUFBbkMsQ0FBNkMsQ0FDM0UsR0FBSSxLQUFLLE9BQUwsQ0FBYSxjQUFiLEVBQStCLEVBQUUsaUJBQWlCLElBQW5CLENBQW5DLENBQTZELENBQzNELEtBQUssT0FBTCxDQUFhLGdCQUFiLENBQ0ksb0NBREosQ0FFSSxDQUFDLEtBQUssT0FBTCxDQUFhLFFBQWIsQ0FBc0IsSUFBdEIsQ0FBRCxDQUE4QixLQUFLLE9BQUwsQ0FBYSxRQUFiLENBQXNCLEtBQXRCLENBQTlCLENBRkosQ0FHSSxXQUhKLENBR2lCLE1BQU0sU0FBTixDQUFnQixLQUFoQixDQUFzQixJQUF0QixDQUEyQixTQUEzQixDQUFzQyxDQUF0QyxDQUhqQixFQUlELENBQ0QsT0FBTyxLQUFQLENBQ0QsQ0FSRCxDOzs7R0FlQSxLQUFLLE9BQUwsQ0FBYSw2QkFBYixDQUE2QyxVQUFXLENBQ3RELElBQUssSUFBSSxHQUFULElBQWdCLE9BQU8sU0FBdkIsQ0FBa0MsQ0FDaEMsS0FBSyxPQUFMLENBQWEsSUFBYixDQUFrQixJQUFNLGdEQUF4QixFQUNELENBQ0YsQ0FKRCxDOzs7Ozs7R0FjQSxLQUFLLE9BQUwsQ0FBYSxRQUFiLENBQXdCLFNBQVMsS0FBVCxDQUFnQixDQUN0QyxHQUFJLGlCQUFpQixRQUFyQixDQUErQixDQUM3QixPQUFPLE1BQU0sV0FBTixFQUFxQixNQUFNLElBQTNCLEVBQW1DLG1CQUExQyxDQUNELENBRkQsS0FFTyxHQUFJLGlCQUFpQixNQUFyQixDQUE2QixDQUNsQyxPQUFPLE1BQU0sV0FBTixDQUFrQixXQUFsQixFQUFpQyxNQUFNLFdBQU4sQ0FBa0IsSUFBbkQsRUFDSCxPQUFPLFNBQVAsQ0FBaUIsUUFBakIsQ0FBMEIsSUFBMUIsQ0FBK0IsS0FBL0IsQ0FESixDQUVELENBSE0sS0FHQSxDQUNMLE9BQU8sUUFBVSxJQUFWLENBQWlCLE1BQWpCLFFBQWlDLEtBQWpDLG1DQUFpQyxLQUFqQyxDQUFQLENBQ0QsQ0FDRixDQVRELEM7Ozs7Ozs7OztHQTRCQSxLQUFLLE1BQUwsQ0FBWSxZQUFaLENBQTJCLFNBQVMsTUFBVCxDQUFpQixRQUFqQixDQUEyQixDQUNwRCxHQUFJLFFBQVUsSUFBZCxDQUFvQixDQUNsQixLQUFLLE1BQUwsQ0FBWSxLQUFaLENBQWtCLElBQWxCLENBQXdCLFNBQXhCLEVBQ0QsQ0FDRixDQUpELEM7Ozs7R0FZQSxLQUFLLE1BQUwsQ0FBWSxZQUFaLENBQXlCLFNBQXpCLENBQW1DLE9BQW5DLENBQTZDLEVBQTdDLEM7Ozs7O0dBU0EsS0FBSyxNQUFMLENBQVksWUFBWixDQUF5QixTQUF6QixDQUFtQyxHQUFuQyxDQUF5QyxTQUFTLENBQVQsQ0FBWSxDQUNuRCxLQUFLLE9BQUwsQ0FBZSxHQUFLLENBQXBCLENBQ0QsQ0FGRCxDOzs7Ozs7Ozs7OztHQWlCQSxLQUFLLE1BQUwsQ0FBWSxZQUFaLENBQXlCLFNBQXpCLENBQW1DLE1BQW5DLENBQTRDLFNBQVMsRUFBVCxDQUFhLE1BQWIsQ0FBcUIsUUFBckIsQ0FBK0IsQztBQUV6RSxLQUFLLE9BQUwsRUFBZ0IsT0FBTyxFQUFQLENBQWhCLENBQ0EsR0FBSSxRQUFVLElBQWQsQ0FBb0IsQztBQUNsQixJQUFLLElBQUksRUFBSSxDQUFiLENBQWdCLEVBQUksVUFBVSxNQUE5QixDQUFzQyxHQUF0QyxDQUEyQyxDQUN6QyxLQUFLLE9BQUwsRUFBZ0IsVUFBVSxDQUFWLENBQWhCLENBQ0QsQ0FDRixDQUNELE9BQU8sSUFBUCxDQUNELENBVEQsQzs7R0FlQSxLQUFLLE1BQUwsQ0FBWSxZQUFaLENBQXlCLFNBQXpCLENBQW1DLEtBQW5DLENBQTJDLFVBQVcsQ0FDcEQsS0FBSyxPQUFMLENBQWUsRUFBZixDQUNELENBRkQsQzs7R0FRQSxLQUFLLE1BQUwsQ0FBWSxZQUFaLENBQXlCLFNBQXpCLENBQW1DLFNBQW5DLENBQStDLFVBQVcsQ0FDeEQsT0FBTyxLQUFLLE9BQUwsQ0FBYSxNQUFwQixDQUNELENBRkQsQzs7O0dBU0EsS0FBSyxNQUFMLENBQVksWUFBWixDQUF5QixTQUF6QixDQUFtQyxRQUFuQyxDQUE4QyxVQUFXLENBQ3ZELE9BQU8sS0FBSyxPQUFaLENBQ0QsQ0FGRCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQThCQSxLQUFLLEdBQUwsQ0FBVyxFQUFYLENBQ0EsS0FBSyxHQUFMLENBQVMsSUFBVCxDQUFnQixFQUFoQixDOzs7Ozs7R0FVQSxLQUFLLEdBQUwsQ0FBUyxJQUFULENBQWMsb0JBQWQsQ0FBcUMsQzs7OztLQU9uQyxLQUFNLEtBQUssS0FBTCxDQUFhLENBQUMseUJBQTBCLElBQTNCLENBQWIsQ0FBZ0QsRUFQbkIsQzs7Ozs7O0tBZ0JuQyxHQUFJLEtBQUssS0FBTCxDQUFhLENBQUMsd0JBQXlCLElBQTFCLENBQWIsQ0FBK0MsRUFoQmhCLEMsNENBbUJuQyxJQUFLLEtBQUssS0FBTCxDQUFhLENBQUMsb0JBQXFCLElBQXRCLENBQWIsQ0FBMkMsRUFuQmIsQyxrREFzQm5DLHFCQUNJLEtBQUssS0FBTCxDQUFhLENBQUMsbUNBQW9DLElBQXJDLENBQWIsQ0FBMEQsRUF2QjNCLEM7OztLQTZCbkMsV0FBWSxLQUFLLEtBQUwsQ0FBYSxDQUFDLDhCQUErQixJQUFoQyxDQUFiLENBQXFELEVBN0I5QixDOzs7Ozs7S0FzQ25DLElBQUssS0FBSyxLQUFMLENBQWEsQ0FBQyxvQkFBcUIsSUFBdEIsQ0FBYixDQUEyQyxFQXRDYixDOzs7Ozs7O0tBZ0RuQyxLQUFNLEtBQUssS0FBTCxDQUFhLENBQUMseUJBQTBCLElBQTNCLENBQWIsQ0FBZ0QsRUFoRG5CLENBQXJDLEM7Ozs7Ozs7Ozs7R0FnRUEsS0FBSyxHQUFMLENBQVMsSUFBVCxDQUFjLGdCQUFkLENBQWlDLFVBQVcsQ0FDMUMsTUFBTSxNQUFNLDZCQUFOLENBQU4sQ0FDRCxDQUZELEM7OztHQVNBLEtBQUssR0FBTCxDQUFTLElBQVQsQ0FBYyxnQkFBZCxDQUErQixTQUEvQixDQUF5QyxXQUF6QyxDOzs7O0dBUUEsS0FBSyxHQUFMLENBQVMsSUFBVCxDQUFjLGdCQUFkLENBQStCLFNBQS9CLENBQXlDLFVBQXpDLENBQXNELElBQXRELEM7OztHQU9BLEtBQUssR0FBTCxDQUFTLElBQVQsQ0FBYyxnQkFBZCxDQUErQixTQUEvQixDQUF5QyxPQUF6QyxDOzs7R0FPQSxLQUFLLEdBQUwsQ0FBUyxJQUFULENBQWMsZ0JBQWQsQ0FBK0IsU0FBL0IsQ0FBeUMsVUFBekMsQ0FBc0QsVUFBVyxDQUMvRCxPQUFPLEtBQUssT0FBWixDQUNELENBRkQsQyxpQkFNQSxLQUFLLEdBQUwsQ0FBUyxJQUFULENBQWMsZ0JBQWQsQ0FBK0IsU0FBL0IsQ0FBeUMsUUFBekMsQ0FBb0QsVUFBVyxDQUM3RCxPQUFPLEtBQUssT0FBWixDQUNELENBRkQsQzs7Ozs7R0FVQSxLQUFLLEdBQUwsQ0FBUyxJQUFULENBQWMsZUFBZCxDQUFnQyxVQUFXLEM7QUFFekMsS0FBSyxHQUFMLENBQVMsSUFBVCxDQUFjLGVBQWQsQ0FBOEIsSUFBOUIsQ0FBbUMsSUFBbkMsQ0FBeUMsYUFBekMsRUFDRCxDQUhELENBSUEsS0FBSyxRQUFMLENBQWMsS0FBSyxHQUFMLENBQVMsSUFBVCxDQUFjLGVBQTVCLENBQTZDLEtBQUssR0FBTCxDQUFTLElBQVQsQ0FBYyxnQkFBM0QsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0NBLENBQUMsVUFBVyxDQUNWLElBQUksSUFBTSxFQUFWLENBQ0EsSUFBSSxPQUFKLENBQWMsRUFBZCxDQUNBLElBQUksR0FBSixDQUFVLEVBQVYsQ0FDQSxJQUFJLFFBQVUsRUFBZCxDOzs7Ozs7OztLQVdBLElBQUksYUFBSixDQUFvQixLQUFLLE1BQUwsQ0FBWSxZQUFoQyxDOzs7Ozs7Ozs7O0tBZUEsUUFBUSxvQkFBUixDQUErQixLQUFLLEdBQUwsQ0FBUyxJQUFULENBQWMsb0JBQTdDLEM7Ozs7Ozs7O0tBWUEsUUFBUSxhQUFSLENBQXdCLFNBQVMsS0FBVCxDQUFnQixXQUFoQixDQUE2QixDOzs7OztBQU1uRCxPQUFPLE9BQVMsSUFBVCxFQUFpQixNQUFNLFdBQU4sR0FBc0IsV0FBOUMsQ0FDRCxDQVBELEM7Ozs7Ozs7O0tBa0JBLFFBQVEsWUFBUixDQUF1QixVQUFXLENBQ2hDLEtBQUssR0FBTCxDQUFTLElBQVQsQ0FBYyxnQkFBZCxDQUErQixJQUEvQixDQUFvQyxJQUFwQyxFO0FBQ0QsQ0FGRCxDQUdBLEtBQUssUUFBTCxDQUFjLFFBQVEsWUFBdEIsQ0FBb0MsS0FBSyxHQUFMLENBQVMsSUFBVCxDQUFjLGdCQUFsRCxFLGlCQUdBLFFBQVEsWUFBUixDQUFxQixTQUFyQixDQUErQixXQUEvQixDQUE2QyxRQUFRLG9CQUFSLENBQTZCLEdBQTFFLEMsaUJBR0EsUUFBUSxZQUFSLENBQXFCLFNBQXJCLENBQStCLFVBQS9CLENBQTRDLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxHQUFmLENBQW1CLEdBQS9ELEM7Ozs7Ozs7Ozs7OztLQWVBLFFBQVEsZUFBUixDQUEwQixTQUFTLE9BQVQsQ0FBa0IsY0FBbEIsQ0FBa0MsQyxpQkFFMUQsS0FBSyxPQUFMLENBQWUsT0FBTyxPQUFQLENBQWYsQ0FDQSxLQUFLLFVBQUwsQ0FBa0IsZ0JBQWtCLElBQWxCLENBQXlCLGNBQXpCLENBQTBDLElBQTVELENBQ0QsQ0FKRCxDQUtBLEtBQUssUUFBTCxDQUFjLFFBQVEsZUFBdEIsQ0FBdUMsS0FBSyxHQUFMLENBQVMsSUFBVCxDQUFjLGVBQXJELEUsaUJBR0EsUUFBUSxlQUFSLENBQXdCLFNBQXhCLENBQWtDLFdBQWxDLENBQ0ksUUFBUSxvQkFBUixDQUE2QixJQURqQyxDOzs7O0tBU0EsUUFBUSxlQUFSLENBQTBCLENBQ3hCLE1BQU8sRUFEaUIsQ0FBMUIsQzs7Ozs7Ozs7Ozs7Ozs7O0tBcUJBLFFBQVEsOEJBQVIsQ0FBeUMsU0FBUyxJQUFULENBQWUsQzs7OztPQU10RCxTQUFTLGdCQUFULENBQTBCLE9BQTFCLENBQW1DLEMsaUJBRWpDLEtBQUssT0FBTCxDQUFlLE9BQWYsQ0FDRCxDQUNELGlCQUFpQixTQUFqQixDQUE2QixLQUFLLFNBQWxDLEM7Ozs7Ozs7OztPQVdBLFNBQVMsdUJBQVQsQ0FBaUMsT0FBakMsQ0FBMEMsY0FBMUMsQ0FBMEQsQ0FDeEQsSUFBSSxPQUFTLElBQUksZ0JBQUosQ0FBcUIsT0FBTyxPQUFQLENBQXJCLENBQWIsQ0FDQSxHQUFJLGlCQUFtQixTQUF2QixDQUFrQyxDQUNoQyxPQUFPLFVBQVAsQ0FBb0IsY0FBcEIsQ0FDRCxDQUNELE9BQU8sTUFBUCxDQUNELENBQ0QsT0FBTyx1QkFBUCxDQUNELENBN0JELEM7Ozs7Ozs7Ozs7Ozs7OztLQWdEQSxRQUFRLGdEQUFSLENBQTJELFNBQVMsSUFBVCxDQUFlLEM7Ozs7T0FNeEUsU0FBUyxnQkFBVCxDQUEwQixPQUExQixDQUFtQyxDLGlCQUVqQyxLQUFLLE9BQUwsQ0FBZSxPQUFmLENBQ0QsQ0FDRCxpQkFBaUIsU0FBakIsQ0FBNkIsS0FBSyxTQUFsQyxDOzs7Ozs7O09BU0EsU0FBUyx1QkFBVCxDQUFpQyxPQUFqQyxDQUEwQyxDQUN4QyxJQUFJLE9BQVMsSUFBSSxnQkFBSixDQUFxQixPQUFPLE9BQVAsQ0FBckIsQ0FBYixDQUNBLE9BQU8sTUFBUCxDQUNELENBQ0QsT0FBTyx1QkFBUCxDQUNELENBeEJELEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBK0NBLFFBQVEsbUJBQVIsQ0FBOEIsU0FBUyxPQUFULENBQWtCLGNBQWxCLENBQWtDLENBQzlELE9BQU8sSUFBSSxRQUFRLGVBQVosQ0FBNEIsT0FBNUIsQ0FBcUMsY0FBckMsQ0FBUCxDQUNELENBRkQsQ0FJQSxRQUFRLFdBQVIsQ0FBc0IsRUFBdEIsQzs7Ozs7Ozs7Ozs7OztJQWlCQSxRQUFRLFdBQVIsQ0FBb0Isa0JBQXBCLENBQ0ksUUFBUSxnREFBUixDQUNJLFFBQVEsWUFEWixDQURKLEM7Ozs7Ozs7Ozs7OztLQWtCQSxJQUFJLFlBQUosQ0FBbUIsU0FBUyxPQUFULENBQWtCLGFBQWxCLENBQWlDLEM7bUJBSWxELFNBQVMsUUFBVCxFQUFvQixDQUFFLENBQ3RCLFNBQVMsU0FBVCxDQUFxQixPQUFyQixDQUNBLElBQUksYUFBZSxJQUFJLFFBQUosRUFBbkIsQztBQUdBLElBQUssSUFBSSxHQUFULElBQWdCLGFBQWhCLENBQStCLENBQzdCLGFBQWEsR0FBYixFQUFvQixjQUFjLEdBQWQsQ0FBcEIsQ0FDRCxDQUVELE9BQU8sWUFBUCxDQUNELENBZEQsQzs7OztLQXNCQSxJQUFJLGFBQUosQ0FBb0IsU0FBUyxHQUFULENBQWMsQztBQUVoQyxHQUFLLE9BQU8sR0FBUixFQUFnQixRQUFwQixDQUE4QixDQUM1QixNQUFNLE1BQ0Ysd0RBQ0Esc0JBREEsU0FDaUMsR0FEakMsbUNBQ2lDLEdBRGpDLEdBQ3dDLEtBRnRDLENBQU4sQ0FHRCxDQUNELE9BQU8sR0FBUCxDQUNELENBUkQsQzs7OztLQWdCQSxJQUFJLFlBQUosQ0FBbUIsU0FBUyxHQUFULENBQWMsQ0FDL0IsSUFBSSxRQUFVLEVBQWQsQ0FDQSxJQUFLLElBQUksR0FBVCxJQUFnQixHQUFoQixDQUFxQixDQUNuQixRQUFRLElBQVIsQ0FBYSxHQUFiLEVBQ0QsQ0FDRCxPQUFPLE9BQVAsQ0FDRCxDQU5ELEM7Ozs7OztLQWdCQSxJQUFJLGNBQUosQ0FBcUIsU0FBUyxHQUFULENBQWMsQ0FDakMsR0FBSSxLQUFPLElBQVgsQ0FBaUIsQ0FDZixNQUFNLE1BQU0sdUJBQU4sQ0FBTixDQUNELENBQ0QsT0FBTyxHQUFQLENBQ0QsQ0FMRCxDOzs7Ozs7Ozs7Ozs7Ozs7OztLQTBCQSxJQUFJLGtCQUFKLENBQXlCLFNBQVMsZUFBVCxDQUEwQixDQUNqRCxPQUFPLGVBQVAsQ0FDRCxDQUZELEM7Ozs7O0tBV0EsSUFBSSwrQkFBSixDQUFzQyxFQUF0QyxDOzs7O0tBT0EsSUFBSSw4QkFBSixDQUFxQyxFQUFyQyxDOzs7Ozs7Ozs7OztLQWVBLElBQUksb0JBQUosQ0FBMkIsU0FDdkIsYUFEdUIsQ0FDUixrQkFEUSxDQUNZLFdBRFosQ0FDeUIsS0FEekIsQ0FDZ0MsQ0FFekQsSUFBSSxPQUFTLE9BQVMsYUFBVCxDQUF5QixHQUF6QixDQUErQixrQkFBNUMsQ0FDQSxJQUFJLGFBQWUsSUFBSSwrQkFBSixDQUFvQyxNQUFwQyxDQUFuQixDQUNBLEdBQUksZUFBaUIsU0FBakIsRUFBOEIsWUFBYyxZQUFoRCxDQUE4RCxDO0FBRTVELElBQUksK0JBQUosQ0FBb0MsTUFBcEMsRUFBOEMsV0FBOUMsQ0FDQSxJQUFJLDhCQUFKLENBQW1DLE1BQW5DLEVBQTZDLEtBQTdDLENBQ0QsQ0FKRCxLQUlPLEdBQUksYUFBZSxZQUFuQixDQUFpQyxDO0FBRXRDLE1BQU0sTUFDRiw2REFDSSxhQURKLENBQ29CLEdBRHBCLENBQzBCLGtCQUQxQixDQUMrQyxLQUY3QyxDQUFOLENBR0QsQ0FMTSxLQUtBLEM7QUFFTixDQUNGLENBakJELEM7Ozs7Ozs7Ozs7Ozs7O0tBbUNBLElBQUksZUFBSixDQUFzQixTQUNsQixhQURrQixDQUNILGtCQURHLENBQ2lCLGtCQURqQixDQUNxQyxDQUV6RCxJQUFJLE1BQVEsSUFBSSw4QkFBSixDQUNSLE9BQVMsYUFBVCxDQUF5QixHQUF6QixDQUErQixrQkFEdkIsQ0FBWixDQUVBLEdBQUksQ0FBRSxLQUFGLEVBQVcsb0JBQXNCLEVBQXJDLENBQXlDLEM7QUFFdkMsTUFBUSxJQUFJLDhCQUFKLENBQW1DLE9BQVMsYUFBVCxDQUF5QixHQUE1RCxDQUFSLENBQ0QsQ0FFRCxHQUFJLEtBQUosQ0FBVyxDQUNULE9BQU8sS0FBUCxDQUNELENBRkQsS0FFTyxHQUFJLGtCQUFKLENBQXdCLENBQzdCLE9BQU8sSUFBSSxvQkFBWCxDQUNELENBRk0sS0FFQSxDQUNMLE1BQU0sTUFDRiw4Q0FBZ0QsYUFBaEQsQ0FBZ0UsR0FBaEUsQ0FDSSxrQkFESixDQUN5Qix1Q0FGdkIsQ0FBTixDQUdELENBQ0YsQ0FuQkQsQzs7Ozs7Ozs7O0tBZ0NBLElBQUksb0JBQUosQ0FBMkIsU0FBUyxRQUFULENBQW1CLE1BQW5CLENBQTJCLFVBQTNCLENBQXVDLENBQ2hFLE9BQU8sRUFBUCxDQUNELENBRkQsQzs7Ozs7Ozs7Ozs7OztLQW9CQSxJQUFJLFVBQUosQ0FBaUIsU0FBUyxHQUFULENBQWMsTUFBZCxDQUFzQixhQUF0QixDQUFxQyxDQUVwRCxJQUFNLE9BQU8sR0FBUCxDQUFOLENBQ0EsR0FBSSxJQUFJLE1BQUosRUFBYyxNQUFsQixDQUEwQixDQUN4QixPQUFPLEdBQVAsQztBQUNELEM7O0FBSUQsR0FBSSxhQUFKLENBQW1CLENBQ2pCLEdBQUksT0FBUyxDQUFiLENBQWdCLENBQ2QsUUFBVSxDQUFWLENBQ0QsQ0FGRCxLQUVPLENBQ0wsY0FBZ0IsS0FBaEIsQ0FDRCxDQUNGLEM7QUFHRCxHQUFJLElBQUksa0JBQUosQ0FBdUIsSUFBSSxNQUFKLENBQVcsT0FBUyxDQUFwQixDQUF2QixHQUNBLElBQUksaUJBQUosQ0FBc0IsSUFBSSxNQUFKLENBQVcsTUFBWCxDQUF0QixDQURKLENBQytDLENBQzdDLFFBQVUsQ0FBVixDQUNELEM7QUFHRCxJQUFNLElBQUksU0FBSixDQUFjLENBQWQsQ0FBaUIsTUFBakIsQ0FBTixDO0FBR0EsR0FBSSxhQUFKLENBQW1CLENBQ2pCLEtBQU8sS0FBUCxDQUNELENBRUQsT0FBTyxHQUFQLENBQ0QsQ0FoQ0QsQzs7Ozs7S0F3Q0EsSUFBSSxrQkFBSixDQUF5QixTQUFTLEVBQVQsQ0FBYSxDQUNwQyxPQUFPLFFBQVUsRUFBVixFQUFnQixJQUFNLE1BQTdCLENBQ0QsQ0FGRCxDOzs7OztLQVVBLElBQUksaUJBQUosQ0FBd0IsU0FBUyxFQUFULENBQWEsQ0FDbkMsT0FBTyxRQUFVLEVBQVYsRUFBZ0IsSUFBTSxNQUE3QixDQUNELENBRkQsQzs7Ozs7Ozs7Ozs7Ozs7S0FvQkEsSUFBSSxPQUFKLENBQVksVUFBWixDQUF5QixTQUFTLFNBQVQsQ0FBb0IsU0FBcEIsQ0FDckIsS0FEcUIsQ0FDZCxZQURjLENBQ0EsUUFEQSxDQUNVLENBQ2pDLElBQUksSUFBTSxrQkFBb0IsU0FBcEIsQ0FBZ0MsV0FBaEMsQ0FBOEMsWUFBOUMsRUFDTCxLQUFLLEtBQUwsQ0FBYyxhQUFlLEtBQUssS0FBTCxDQUFXLFdBQVgsQ0FBdUIsS0FBdkIsQ0FBN0IsQ0FBOEQsRUFEekQsRUFFTixHQUZKLENBR0EsT0FBTyxLQUFLLE9BQUwsQ0FBYSxNQUFiLENBQW9CLFNBQXBCLENBQStCLEdBQS9CLENBQW9DLFFBQXBDLENBQVAsQ0FDRCxDQU5ELEM7Ozs7O0tBa0JBLElBQUksR0FBSixDQUFRLGtCQUFSLENBQTZCLFNBQVMsQ0FBVCxDQUFZLENBQ3ZDLE9BQU8sS0FBSyxNQUFMLENBQVksVUFBWixDQUF1QixPQUFPLENBQVAsQ0FBdkIsQ0FBUCxDQUNELENBRkQsQzs7Ozs7O0tBV0EsSUFBSSxvQkFBSixDQUEyQixTQUFTLEtBQVQsQ0FBZ0IsQztBQUV6QyxPQUFPLFFBQVEsV0FBUixDQUFvQixrQkFBcEIsQ0FDSCxJQUFJLEdBQUosQ0FBUSwwQkFBUixDQUFtQyxLQUFuQyxDQURHLENBQVAsQ0FFRCxDQUpELEM7OztLQVVBLElBQUksR0FBSixDQUFRLG1DQUFSLENBQThDLHNFQUE5QyxDOzs7O0tBT0EsSUFBSSxHQUFKLENBQVEsMEJBQVIsQ0FBcUMsU0FBUyxLQUFULENBQWdCLENBQ25ELElBQUksSUFBTSxPQUFPLEtBQVAsQ0FBVixDQUNBLEdBQUksQ0FBQyxJQUFJLEdBQUosQ0FBUSxtQ0FBUixDQUE0QyxJQUE1QyxDQUFpRCxHQUFqRCxDQUFMLENBQTRELENBQzFELEtBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0Isd0NBQWxCLENBQTRELENBQUMsR0FBRCxDQUE1RCxFQUNBLE9BQU8sNkJBQVAsQ0FDRCxDQUNELE9BQU8sR0FBUCxDQUNELENBUEQsQztBQVdBLEtBQUssVUFBTCxDQUFnQixVQUFXLENBQ3pCLEtBQUssTUFBTCxDQUFZLEtBQVosRUFDQSxPQUFPLEdBQVAsQ0FDRCxDQUhELEVBS0EsS0FBSyxVQUFMLENBQWdCLFVBQVcsQ0FDekIsS0FBSyxNQUFMLENBQVksU0FBWixFQUNBLE9BQU8sT0FBUCxDQUNELENBSEQsRUFLQSxLQUFLLFVBQUwsQ0FBZ0IsVUFBVyxDQUN6QixLQUFLLE1BQUwsQ0FBWSxhQUFaLEVBQ0EsT0FBTyxHQUFQLENBQ0QsQ0FIRCxFQUlELENBcmxCRCxJLHdCQTBsQkEsS0FBSyxVQUFMLENBQWdCLFVBQVcsQ0FDekIsS0FBSyxNQUFMLENBQVksZ0JBQVosRUFDQSxPQUFPLGNBQVAsQ0FDRCxDQUhELEVBSUMsQ0FycUpELEVBcXFKRyxJQXJxSkgsQ0FxcUpRLE1BcnFKUjs7O0FDRkE7Ozs7Ozs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFHQSxJQUFJLFNBQVMsRUFBYjs7SUFFTSxHOzs7Ozs7O0FBSUwsY0FBWSxJQUFaLEVBQWtCO0FBQUE7O0FBQUEsK0NBQ2pCLGlDQUFNLElBQU4sQ0FEaUI7O0FBRWpCLFFBQUssb0JBQUw7QUFGaUI7QUFHakI7Ozs7Ozs7ZUFLRCxvQixtQ0FBdUI7QUFDdEIsTUFBSSxrQkFBa0IsS0FBSyxVQUFMLENBQWdCLFdBQWhCLENBQTRCLFFBQWxEO0FBQ0EsTUFBSSxDQUFDLFlBQUssVUFBTCxDQUFnQixlQUFoQixDQUFMLEVBQXVDO0FBQ3RDO0FBQ0E7O0FBRUQsb0JBQWtCLGlCQUFPLGFBQVAsQ0FBcUIsZUFBckIsQ0FBbEI7QUFDQSxPQUFLLGNBQUwsR0FBc0IsZ0JBQWdCLEtBQWhCLElBQXlCLEVBQS9DOztBQUVBLE1BQUksT0FBTyxnQkFBZ0IsTUFBaEIsSUFBMEIsRUFBckM7QUFDQSxNQUFJLFlBQVksS0FBSyxVQUFyQjtBQUNBLE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE1BQXpCLEVBQWlDLEdBQWpDLEVBQXNDO0FBQ3JDLE9BQUksQ0FBQyxVQUFVLGlCQUFWLENBQTRCLEtBQUssQ0FBTCxDQUE1QixDQUFELElBQXlDLENBQUMsVUFBVSxLQUFLLENBQUwsQ0FBVixDQUE5QyxFQUFrRTtBQUNqRSxjQUFVLFVBQVYsQ0FBcUIsS0FBSyxDQUFMLENBQXJCLEVBQThCLEVBQTlCLEVBQWtDLFVBQVUsZ0JBQVYsR0FBNkIsS0FBSyxDQUFMLENBQTdCLENBQWxDO0FBQ0E7QUFDRDtBQUNELEU7Ozs7Ozs7Ozs7Ozs7ZUFXRCxrQiwrQkFBbUIsTSxFQUFRO0FBQUE7O0FBQzFCLE1BQUksWUFBWSxLQUFLLFVBQXJCO0FBQ0EsTUFBSSxPQUFPLGNBQU8sS0FBUCxDQUFhLEVBQWIsRUFBaUIsVUFBVSxNQUEzQixDQUFYO0FBQ0EsWUFBVSxZQUFWLEdBQXlCLE9BQXpCLENBQWlDLGVBQU87OztBQUd2QyxPQUFJLFFBQVEsU0FBWixFQUF1QjtBQUN0QjtBQUNBOztBQUVELE9BQUksUUFBUSxVQUFVLEdBQVYsQ0FBWjtBQUNBLE9BQUksT0FBSyxZQUFMLENBQWtCLEdBQWxCLENBQUosRUFBNEI7QUFDM0IsWUFBUSxJQUFJLFFBQUosQ0FBYSxLQUFiLENBQVI7QUFDQTtBQUNELFFBQUssR0FBTCxJQUFZLEtBQVo7QUFDQSxHQVpEO0FBYUEsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQU8sTUFBM0IsRUFBbUMsR0FBbkMsRUFBd0M7QUFDdkMsT0FBSSxDQUFDLEtBQUssT0FBTyxDQUFQLENBQUwsQ0FBRCxJQUFvQixZQUFLLFVBQUwsQ0FBZ0IsVUFBVSxPQUFPLENBQVAsQ0FBVixDQUFoQixDQUF4QixFQUErRDtBQUM5RCxTQUFLLE9BQU8sQ0FBUCxDQUFMLElBQWtCLFVBQVUsT0FBTyxDQUFQLENBQVYsRUFBcUIsSUFBckIsQ0FBMEIsU0FBMUIsQ0FBbEI7QUFDQTtBQUNEO0FBQ0QsU0FBTyxJQUFQO0FBQ0EsRTs7Ozs7Ozs7Ozs7O0tBVU0sVyx3QkFBWSxTLEVBQVcsWSxFQUFjO0FBQzNDLFNBQU8sVUFBUyxRQUFULEVBQW1CLFdBQW5CLEVBQWdDLFVBQWhDLEVBQTRDO0FBQ2xELE9BQUksQ0FBQyxLQUFLLGNBQUwsQ0FBb0IsU0FBcEIsQ0FBTCxFQUFxQztBQUNwQyxVQUFNLElBQUksS0FBSixDQUNMLGlDQUFpQyxTQUFqQyxHQUE2Qyx3QkFEeEMsQ0FBTjtBQUdBO0FBQ0QsVUFBTyxLQUFLLGNBQUwsQ0FBb0IsU0FBcEIsRUFBK0IsWUFBL0IsRUFBNkMsUUFBN0MsRUFBdUQsV0FBdkQsRUFBb0UsVUFBcEUsQ0FBUDtBQUNBLEdBUEQ7QUFRQSxFOzs7Ozs7Ozs7Ozs7O0tBV00sc0IsbUNBQXVCLFUsRUFBWSxRLEVBQVU7QUFDbkQsTUFBSSxPQUFPLENBQUMsV0FBVyxhQUFaLEVBQTJCLElBQTNCLEVBQWlDLEVBQWpDLENBQVg7QUFDQSxNQUFJLFFBQVEsT0FBTyxJQUFQLENBQVksWUFBWSxFQUF4QixDQUFaO0FBQ0EsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE1BQU0sTUFBMUIsRUFBa0MsR0FBbEMsRUFBdUM7QUFDdEMsUUFBSyxJQUFMLENBQVUsTUFBTSxDQUFOLENBQVYsRUFBb0IsU0FBUyxNQUFNLENBQU4sQ0FBVCxDQUFwQjtBQUNBO0FBQ0QsaUJBQWUsV0FBZixDQUEyQixLQUEzQixDQUFpQyxJQUFqQyxFQUF1QyxJQUF2QztBQUNBLEU7Ozs7Ozs7OztlQU9ELFkseUJBQWEsSSxFQUFNO0FBQ2xCLE1BQUksS0FBSyxVQUFMLENBQWdCLGlCQUFoQixDQUFrQyxJQUFsQyxFQUF3QyxNQUE1QyxFQUFvRDtBQUNuRCxVQUFPLElBQVA7QUFDQTtBQUNELE1BQUksT0FBTyxLQUFLLGNBQUwsQ0FBb0IsSUFBcEIsS0FBNkIsRUFBeEM7QUFDQSxTQUFPLEtBQUssS0FBTCxDQUFXLEdBQVgsRUFBZ0IsT0FBaEIsQ0FBd0IsTUFBeEIsTUFBb0MsQ0FBQyxDQUE1QztBQUNBLEU7Ozs7Ozs7Ozs7Ozs7S0FXTSxRLHFCQUFTLGEsRUFBZSxTLEVBQW9DO0FBQUEsTUFBekIsWUFBeUIseURBQVYsUUFBVTs7QUFDbEUsZ0JBQWMsUUFBZCxHQUF5QixHQUF6QjtBQUNBLGdCQUFjLFFBQWQsR0FBeUIsaUJBQU8sYUFBUCxDQUFxQixVQUFVLFlBQVYsQ0FBckIsQ0FBekI7QUFDQSxnQkFBYyxRQUFkLENBQXVCLGFBQXZCLEdBQXVDLGFBQXZDO0FBQ0EsbUJBQU8sdUJBQVAsQ0FBK0IsU0FBL0IsRUFBMEMsWUFBMUM7QUFDQSwrQkFBa0IsUUFBbEIsQ0FBMkIsYUFBM0I7QUFDQSxFOzs7Ozs7Ozs7O2VBUUQsWSwyQkFBZTtBQUNkLE1BQUksa0JBQWtCLEtBQUssVUFBTCxDQUFnQixXQUFoQixDQUE0QixRQUFsRDtBQUNBLE1BQUksWUFBSyxVQUFMLENBQWdCLGVBQWhCLENBQUosRUFBc0M7QUFDckMscUJBQWtCLGlCQUFPLGFBQVAsQ0FBcUIsZUFBckIsQ0FBbEI7QUFDQSxvQkFBTyxpQkFBUCxDQUF5QixJQUFJLHNCQUE3QjtBQUNBLG1CQUFnQixLQUFLLGtCQUFMLENBQXdCLGdCQUFnQixNQUFoQixJQUEwQixFQUFsRCxDQUFoQixFQUF1RSxJQUF2RSxFQUE2RSxNQUE3RTtBQUNBLG9CQUFPLGdCQUFQO0FBQ0EsR0FMRCxNQUtPO0FBQ04sbUNBQU0sWUFBTjtBQUNBO0FBQ0QsRTs7Ozs7Ozs7S0FNTSxlLDRCQUFnQixJLEVBQU07QUFDNUIsV0FBUyxRQUFRLEVBQWpCO0FBQ0EsRTs7Ozs7Ozs7OztlQVFELFkseUJBQWEsTyxFQUFTO0FBQ3JCLE1BQUksS0FBSyxLQUFLLFVBQUwsQ0FBZ0IsV0FBaEIsQ0FBNEIsUUFBckM7QUFDQSxNQUFJLFNBQVMsS0FBSyxpQkFBTyxhQUFQLENBQXFCLEVBQXJCLEVBQXlCLE1BQTlCLEdBQXVDLEVBQXBEO0FBQ0EsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQU8sTUFBM0IsRUFBbUMsR0FBbkMsRUFBd0M7QUFDdkMsT0FBSSxRQUFRLE9BQU8sQ0FBUCxDQUFSLENBQUosRUFBd0I7QUFDdkIsV0FBTyxJQUFQO0FBQ0E7QUFDRDtBQUNELFNBQU8sS0FBUDtBQUNBLEU7Ozs7Ozs7OztLQU9NLFkseUJBQWEsUSxFQUFVO0FBQzdCLE1BQUksVUFBVSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBZDtBQUNBLGlCQUFlLEtBQWYsQ0FBcUIsT0FBckIsRUFBOEIsUUFBOUI7QUFDQSxTQUFPLFFBQVEsU0FBZjtBQUNBLEU7Ozs7Ozs7OztLQU9NLFEscUJBQVMsSyxFQUFPO0FBQ3RCLE1BQUksWUFBSyxRQUFMLENBQWMsS0FBZCxLQUF3QixZQUFLLFFBQUwsQ0FBYyxNQUFNLE9BQXBCLENBQXhCLElBQXlELE1BQU0sV0FBTixLQUFzQixNQUFuRixFQUE0RjtBQUMzRixXQUFRLE1BQU0sT0FBZDtBQUNBO0FBQ0QsTUFBSSxZQUFLLFFBQUwsQ0FBYyxLQUFkLENBQUosRUFBMEI7QUFDekIsV0FBUSxxQkFBWSxPQUFaLENBQW9CLEtBQXBCLENBQVI7QUFDQTtBQUNELFNBQU8sS0FBUDtBQUNBLEU7Ozs7O2tCQUdhLEc7UUFDTixHLEdBQUEsRztRQUFLLE07OztBQ3JOZDs7Ozs7QUFFQSxJQUFJLFNBQVM7Ozs7Ozs7O0FBUVosZ0JBQWUsRUFSSDs7Ozs7Ozs7QUFnQlosZ0JBQWUsdUJBQVMsRUFBVCxFQUFhO0FBQzNCLFNBQU8sR0FBRyxVQUFILEdBQWdCLEdBQUcsVUFBbkIsR0FBZ0MsRUFBdkM7QUFDQSxFQWxCVzs7Ozs7Ozs7Ozs7OztBQStCWixzQkFBcUIsNkJBQVMsVUFBVCxFQUFxQixRQUFyQixFQUErQixXQUEvQixFQUE0QyxVQUE1QyxFQUF3RDtBQUM1RSxNQUFJLGNBQWMsT0FBTyxhQUFQLENBQXFCLE9BQU8sYUFBUCxDQUFxQixNQUFyQixHQUE4QixDQUFuRCxDQUFsQjtBQUNBLE1BQUksV0FBSixFQUFpQjtBQUNoQixVQUFPLFlBQVksSUFBWixDQUFpQixJQUFqQixFQUF1QixVQUF2QixFQUFtQyxRQUFuQyxFQUE2QyxXQUE3QyxFQUEwRCxVQUExRCxDQUFQO0FBQ0EsR0FGRCxNQUVPO0FBQ04sVUFBTyxXQUFXLElBQVgsQ0FBZ0IsSUFBaEIsRUFBc0IsUUFBdEIsRUFBZ0MsV0FBaEMsRUFBNkMsVUFBN0MsQ0FBUDtBQUNBO0FBQ0QsRUF0Q1c7Ozs7Ozs7O0FBOENaLDBCQUF5QixpQ0FBUyxTQUFULEVBQW9CLElBQXBCLEVBQTBCO0FBQ2xELE1BQUksYUFBYSxVQUFVLElBQVYsQ0FBakI7QUFDQSxNQUFJLENBQUMsV0FBVyxVQUFoQixFQUE0QjtBQUMzQixhQUFVLElBQVYsSUFBa0IsT0FBTyxtQkFBUCxDQUEyQixJQUEzQixDQUFnQyxJQUFoQyxFQUFzQyxVQUF0QyxDQUFsQjtBQUNBLGFBQVUsSUFBVixFQUFnQixVQUFoQixHQUE2QixVQUE3QjtBQUNBO0FBQ0QsRUFwRFc7Ozs7Ozs7QUEyRFosb0JBQW1CLDJCQUFTLEVBQVQsRUFBYTtBQUMvQixTQUFPLGFBQVAsQ0FBcUIsSUFBckIsQ0FBMEIsRUFBMUI7QUFDQSxFQTdEVzs7Ozs7QUFrRVosdUJBQXNCLGdDQUFXO0FBQ2hDLFNBQU8sYUFBUCxHQUF1QixFQUF2QjtBQUNBLEVBcEVXOzs7OztBQXlFWixtQkFBa0IsNEJBQVc7QUFDNUIsU0FBTyxhQUFQLENBQXFCLEdBQXJCO0FBQ0E7QUEzRVcsQ0FBYjs7a0JBOEVlLE07OztBQ2hGZjs7Ozs7O0FBRUE7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBVU0sSzs7O0FBQ0wsZ0JBQVksVUFBWixFQUF3QjtBQUFBOzs7Ozs7Ozs7QUFBQSwrQ0FDdkIsd0JBRHVCOztBQVN2QixRQUFLLG1CQUFMLEdBQTJCLElBQTNCOzs7Ozs7O0FBT0EsUUFBSyxVQUFMLEdBQWtCLEVBQWxCOzs7Ozs7O0FBT0EsUUFBSyxNQUFMLEdBQWMsY0FBTyxLQUFQLENBQWEsRUFBYixFQUFpQixjQUFjLEVBQS9CLENBQWQ7O0FBRUEsUUFBSyxrQkFBTCxDQUF3QixJQUF4QjtBQUNBLFFBQUssaUJBQUw7QUFDQSxRQUFLLHlCQUFMLENBQStCLFVBQS9CO0FBM0J1QjtBQTRCdkI7Ozs7Ozs7Ozs7O2lCQVNELGEsMEJBQWMsSSxFQUFNLE0sRUFBUSxZLEVBQWM7QUFDekMsT0FBSyxhQUFMLENBQW1CLElBQW5CLEVBQXlCLE1BQXpCLEVBQWlDLFlBQWpDO0FBQ0EsU0FBTyxjQUFQLENBQXNCLElBQXRCLEVBQTRCLElBQTVCLEVBQWtDLEtBQUssb0JBQUwsQ0FBMEIsSUFBMUIsQ0FBbEM7QUFDQSxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lCQW1DRCxVLHVCQUFXLGEsRUFBZSx5QixFQUEyQix5QixFQUEyQjtBQUMvRSxNQUFJLFlBQUssUUFBTCxDQUFjLGFBQWQsQ0FBSixFQUFrQztBQUNqQyxVQUFPLEtBQUssYUFBTCxDQUNOLGFBRE0sRUFFTix5QkFGTSxFQUdOLHlCQUhNLENBQVA7QUFLQTs7QUFFRCxNQUFJLGdCQUFnQiw2QkFBNkIsRUFBakQ7QUFDQSxNQUFJLFFBQVEsT0FBTyxJQUFQLENBQVksYUFBWixDQUFaOztBQUVBLE1BQUksUUFBUSxFQUFaO0FBQ0EsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE1BQU0sTUFBMUIsRUFBa0MsR0FBbEMsRUFBdUM7QUFDdEMsT0FBSSxPQUFPLE1BQU0sQ0FBTixDQUFYO0FBQ0EsUUFBSyxhQUFMLENBQW1CLElBQW5CLEVBQXlCLGNBQWMsSUFBZCxDQUF6QixFQUE4QyxjQUFjLElBQWQsQ0FBOUM7QUFDQSxTQUFNLElBQU4sSUFBYyxLQUFLLG9CQUFMLENBQTBCLElBQTFCLENBQWQ7QUFDQTs7QUFFRCxNQUFJLDhCQUE4QixLQUFsQyxFQUF5QztBQUN4QyxVQUFPLGdCQUFQLENBQXdCLDZCQUE2QixJQUFyRCxFQUEyRCxLQUEzRDtBQUNBO0FBQ0QsRTs7Ozs7Ozs7OztpQkFRRCx5QixzQ0FBMEIsVSxFQUFZO0FBQ3JDLE1BQUksT0FBTyxLQUFLLFdBQWhCO0FBQ0EsTUFBSSxnQkFBZ0IsS0FBcEI7QUFDQSxNQUFJLE1BQU0sZ0JBQU4sQ0FBdUIsSUFBdkIsQ0FBSixFQUFrQztBQUNqQyxtQkFBZ0IsS0FBSyxTQUFyQjtBQUNBO0FBQ0QsT0FBSyxVQUFMLENBQWdCLEtBQUssWUFBckIsRUFBbUMsVUFBbkMsRUFBK0MsYUFBL0M7QUFDQSxFOzs7Ozs7Ozs7OztpQkFTRCx3QixxQ0FBeUIsSSxFQUFNO0FBQzlCLE1BQUksS0FBSyxXQUFMLENBQWlCLG1CQUFqQixDQUFxQyxJQUFyQyxDQUFKLEVBQWdEO0FBQy9DLFNBQU0sSUFBSSxLQUFKLENBQVUsNERBQTRELElBQTVELEdBQW1FLElBQTdFLENBQU47QUFDQTtBQUNELEU7Ozs7Ozs7Ozs7O2lCQVNELGEsMEJBQWMsSSxFQUFNLE0sRUFBUSxZLEVBQWM7QUFDekMsT0FBSyx3QkFBTCxDQUE4QixJQUE5Qjs7QUFFQSxPQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsSUFBd0I7QUFDdkIsV0FBUSxVQUFVLEVBREs7QUFFdkIsaUJBQWMsWUFGUztBQUd2QixVQUFPLE1BQU0sU0FBTixDQUFnQjtBQUhBLEdBQXhCO0FBS0EsRTs7Ozs7Ozs7OztpQkFRRCxvQixpQ0FBcUIsSSxFQUFNO0FBQzFCLFNBQU87QUFDTixpQkFBYyxJQURSO0FBRU4sZUFBWSxJQUZOO0FBR04sUUFBSyxlQUFXO0FBQ2YsV0FBTyxLQUFLLGlCQUFMLENBQXVCLElBQXZCLENBQVA7QUFDQSxJQUxLO0FBTU4sUUFBSyxhQUFTLEdBQVQsRUFBYztBQUNsQixTQUFLLGlCQUFMLENBQXVCLElBQXZCLEVBQTZCLEdBQTdCO0FBQ0E7QUFSSyxHQUFQO0FBVUEsRTs7Ozs7Ozs7Ozs7OztpQkFXRCxhLDBCQUFjLEUsRUFBSSxJLEVBQU07QUFDdkIsTUFBSSxZQUFLLFFBQUwsQ0FBYyxFQUFkLENBQUosRUFBdUI7QUFDdEIsVUFBTyxLQUFLLEVBQUwsRUFBUyxLQUFULENBQWUsSUFBZixFQUFxQixJQUFyQixDQUFQO0FBQ0EsR0FGRCxNQUVPLElBQUksWUFBSyxVQUFMLENBQWdCLEVBQWhCLENBQUosRUFBeUI7QUFDL0IsVUFBTyxHQUFHLEtBQUgsQ0FBUyxJQUFULEVBQWUsSUFBZixDQUFQO0FBQ0E7QUFDRCxFOzs7Ozs7Ozs7Ozs7aUJBVUQsVyx3QkFBWSxJLEVBQU0sSyxFQUFPLFksRUFBYztBQUN0QyxNQUFJLE9BQU8sS0FBSyxVQUFMLENBQWdCLElBQWhCLENBQVg7QUFDQSxNQUFJLFNBQVMsS0FBSyxNQUFsQjtBQUNBLE1BQUksT0FBTyxNQUFYLEVBQW1CO0FBQ2xCLFdBQVEsS0FBSyxhQUFMLENBQW1CLE9BQU8sTUFBMUIsRUFBa0MsQ0FBQyxLQUFELEVBQVEsWUFBUixDQUFsQyxDQUFSO0FBQ0E7QUFDRCxTQUFPLEtBQVA7QUFDQSxFOzs7Ozs7Ozs7OztpQkFTRCxjLDJCQUFlLEksRUFBTSxLLEVBQU87QUFDM0IsTUFBSSxPQUFPLEtBQUssVUFBTCxDQUFnQixJQUFoQixDQUFYO0FBQ0EsTUFBSSxTQUFTLEtBQUssTUFBbEI7QUFDQSxNQUFJLE9BQU8sU0FBWCxFQUFzQjtBQUNyQixVQUFPLEtBQUssYUFBTCxDQUFtQixPQUFPLFNBQTFCLEVBQXFDLENBQUMsS0FBRCxDQUFyQyxDQUFQO0FBQ0E7QUFDRCxTQUFPLElBQVA7QUFDQSxFOzs7Ozs7Ozs7aUJBT0QsVyx3QkFBWSxJLEVBQU07QUFDakIsTUFBSSxPQUFPLEtBQUssVUFBTCxDQUFnQixJQUFoQixDQUFYO0FBQ0EsU0FBTyxDQUFDLEtBQUssTUFBTCxDQUFZLFNBQWIsSUFBMEIsQ0FBQyxLQUFLLE9BQXZDO0FBQ0EsRTs7Ozs7OztpQkFLRCxlLDhCQUFrQjtBQUNqQiwwQkFBTSxlQUFOO0FBQ0EsT0FBSyxVQUFMLEdBQWtCLElBQWxCO0FBQ0EsT0FBSyxtQkFBTCxHQUEyQixJQUEzQjtBQUNBLEU7Ozs7Ozs7O2lCQU1ELGUsOEJBQWtCO0FBQ2pCLE1BQUksQ0FBQyxLQUFLLFVBQUwsRUFBTCxFQUF3QjtBQUN2QixPQUFJLE9BQU8sS0FBSyxtQkFBaEI7QUFDQSxRQUFLLG1CQUFMLEdBQTJCLElBQTNCO0FBQ0EsUUFBSyxJQUFMLENBQVUsY0FBVixFQUEwQixJQUExQjtBQUNBO0FBQ0QsRTs7Ozs7Ozs7Ozs7O2lCQVVELEcsZ0JBQUksSSxFQUFNO0FBQ1QsU0FBTyxLQUFLLElBQUwsQ0FBUDtBQUNBLEU7Ozs7Ozs7Ozs7aUJBUUQsUSxxQkFBUyxTLEVBQVc7QUFDbkIsTUFBSSxRQUFRLEVBQVo7QUFDQSxNQUFJLFFBQVEsYUFBYSxLQUFLLFlBQUwsRUFBekI7O0FBRUEsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE1BQU0sTUFBMUIsRUFBa0MsR0FBbEMsRUFBdUM7QUFDdEMsU0FBTSxNQUFNLENBQU4sQ0FBTixJQUFrQixLQUFLLE1BQU0sQ0FBTixDQUFMLENBQWxCO0FBQ0E7O0FBRUQsU0FBTyxLQUFQO0FBQ0EsRTs7Ozs7Ozs7OztpQkFRRCxpQiw4QkFBa0IsSSxFQUFNO0FBQ3ZCLFNBQU8sQ0FBQyxLQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsS0FBeUIsRUFBMUIsRUFBOEIsTUFBckM7QUFDQSxFOzs7Ozs7OztpQkFNRCxZLDJCQUFlO0FBQ2QsU0FBTyxPQUFPLElBQVAsQ0FBWSxLQUFLLFVBQWpCLENBQVA7QUFDQSxFOzs7Ozs7Ozs7OztpQkFTRCxpQiw4QkFBa0IsSSxFQUFNO0FBQ3ZCLE9BQUssYUFBTCxDQUFtQixJQUFuQjtBQUNBLFNBQU8sS0FBSyxVQUFMLENBQWdCLElBQWhCLEVBQXNCLEtBQTdCO0FBQ0EsRTs7Ozs7Ozs7OztpQkFRRCxVLHVCQUFXLEksRUFBTTtBQUNoQixNQUFJLE9BQU8sS0FBSyxVQUFMLENBQWdCLElBQWhCLENBQVg7QUFDQSxTQUFPLEtBQUssS0FBTCxLQUFlLE1BQU0sU0FBTixDQUFnQixXQUEvQixJQUE4QyxLQUFLLFlBQTFEO0FBQ0EsRTs7Ozs7Ozs7Ozs7aUJBU0QsYSwwQkFBYyxJLEVBQU0sTyxFQUFTO0FBQzVCLE1BQUksS0FBSyxtQkFBTCxDQUF5QixJQUF6QixFQUErQixPQUEvQixDQUFKLEVBQTZDO0FBQzVDLE9BQUksT0FBTztBQUNWLFNBQUssSUFESztBQUVWLFlBQVEsS0FBSyxJQUFMLENBRkU7QUFHVixhQUFTO0FBSEMsSUFBWDtBQUtBLFFBQUssSUFBTCxDQUFVLE9BQU8sU0FBakIsRUFBNEIsSUFBNUI7QUFDQSxRQUFLLElBQUwsQ0FBVSxpQkFBVixFQUE2QixJQUE3QjtBQUNBLFFBQUssbUJBQUwsQ0FBeUIsSUFBekI7QUFDQTtBQUNELEU7Ozs7Ozs7OztpQkFPRCxhLDBCQUFjLEksRUFBTTtBQUNuQixNQUFJLE9BQU8sS0FBSyxVQUFMLENBQWdCLElBQWhCLENBQVg7QUFDQSxNQUFJLEtBQUssS0FBTCxLQUFlLE1BQU0sU0FBTixDQUFnQixhQUFuQyxFQUFrRDtBQUNqRDtBQUNBOztBQUVELE9BQUssS0FBTCxHQUFhLE1BQU0sU0FBTixDQUFnQixZQUE3QjtBQUNBLE9BQUssZ0JBQUwsQ0FBc0IsSUFBdEI7QUFDQSxNQUFJLENBQUMsS0FBSyxPQUFWLEVBQW1CO0FBQ2xCLFFBQUssS0FBTCxHQUFhLE1BQU0sU0FBTixDQUFnQixvQkFBN0I7QUFDQSxRQUFLLGdCQUFMLENBQXNCLElBQXRCO0FBQ0E7QUFDRCxPQUFLLEtBQUwsR0FBYSxNQUFNLFNBQU4sQ0FBZ0IsV0FBN0I7QUFDQSxFOzs7Ozs7Ozs7OztPQVNNLFcsd0JBQVksTSxFQUFRO0FBQzFCLFNBQU8sY0FBTyxLQUFQLENBQWEsS0FBYixDQUFtQixJQUFuQixFQUF5QixDQUFDLEVBQUQsRUFBSyxNQUFMLENBQVksT0FBTyxPQUFQLEVBQVosQ0FBekIsQ0FBUDtBQUNBLEU7Ozs7Ozs7Ozs7T0FRTSxnQiw2QkFBaUIsSSxFQUFNO0FBQzdCLFNBQU8sWUFBSyx5QkFBTCxDQUErQixJQUEvQixFQUFxQyxPQUFyQyxFQUE4QyxNQUFNLFdBQXBELENBQVA7QUFDQSxFOzs7Ozs7Ozs7aUJBT0QsaUIsZ0NBQW9CO0FBQ25CLGNBQUsseUJBQUwsQ0FBK0IsS0FBSyxXQUFwQyxFQUFpRCxjQUFqRCxFQUFpRSxVQUFTLE1BQVQsRUFBaUI7QUFDakYsVUFBTyxhQUFNLE9BQU4sQ0FBYyxNQUFkLEVBQXNCLE1BQXRCLENBQTZCLFVBQVMsTUFBVCxFQUFpQixHQUFqQixFQUFzQjtBQUN6RCxRQUFJLEdBQUosRUFBUztBQUNSLFlBQU8sR0FBUCxJQUFjLElBQWQ7QUFDQTtBQUNELFdBQU8sTUFBUDtBQUNBLElBTE0sRUFLSixFQUxJLENBQVA7QUFNQSxHQVBEO0FBUUEsRTs7Ozs7Ozs7aUJBTUQsYywyQkFBZSxJLEVBQU07QUFDcEIsT0FBSyxVQUFMLENBQWdCLElBQWhCLElBQXdCLElBQXhCO0FBQ0EsU0FBTyxLQUFLLElBQUwsQ0FBUDtBQUNBLEU7Ozs7Ozs7OztpQkFPRCxtQixnQ0FBb0IsVSxFQUFZO0FBQy9CLE1BQUksQ0FBQyxLQUFLLG1CQUFWLEVBQStCO0FBQzlCLGdCQUFNLFFBQU4sQ0FBZSxLQUFLLGVBQXBCLEVBQXFDLElBQXJDO0FBQ0EsUUFBSyxtQkFBTCxHQUEyQjtBQUMxQixhQUFTO0FBRGlCLElBQTNCO0FBR0E7O0FBRUQsTUFBSSxPQUFPLFdBQVcsR0FBdEI7QUFDQSxNQUFJLFVBQVUsS0FBSyxtQkFBTCxDQUF5QixPQUF2QztBQUNBLE1BQUksUUFBUSxJQUFSLENBQUosRUFBbUI7QUFDbEIsV0FBUSxJQUFSLEVBQWMsTUFBZCxHQUF1QixXQUFXLE1BQWxDO0FBQ0EsR0FGRCxNQUVPO0FBQ04sV0FBUSxJQUFSLElBQWdCLFVBQWhCO0FBQ0E7QUFDRCxFOzs7Ozs7Ozs7Ozs7O2lCQVdELEcsZ0JBQUksSSxFQUFNLEssRUFBTztBQUNoQixPQUFLLElBQUwsSUFBYSxLQUFiO0FBQ0EsRTs7Ozs7Ozs7OztpQkFRRCxnQiw2QkFBaUIsSSxFQUFNO0FBQ3RCLE1BQUksU0FBUyxLQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsRUFBc0IsTUFBbkM7O0FBRUEsTUFBSSxPQUFPLEtBQVAsS0FBaUIsU0FBckIsRUFBZ0M7QUFDL0IsUUFBSyxJQUFMLElBQWEsT0FBTyxLQUFwQjtBQUNBLEdBRkQsTUFFTztBQUNOLFFBQUssSUFBTCxJQUFhLEtBQUssYUFBTCxDQUFtQixPQUFPLE9BQTFCLENBQWI7QUFDQTtBQUNELEU7Ozs7Ozs7Ozs7aUJBUUQsZ0IsNkJBQWlCLEksRUFBTTtBQUN0QixNQUFJLE9BQU8sS0FBSyxVQUFMLENBQWdCLElBQWhCLENBQVg7QUFDQSxNQUFJLEtBQUssWUFBTCxLQUFzQixTQUExQixFQUFxQztBQUNwQyxRQUFLLElBQUwsSUFBYSxLQUFLLFlBQWxCO0FBQ0EsUUFBSyxZQUFMLEdBQW9CLFNBQXBCO0FBQ0E7QUFDRCxFOzs7Ozs7Ozs7aUJBT0QsUSxxQkFBUyxNLEVBQVE7QUFDaEIsZ0JBQU8sS0FBUCxDQUFhLEtBQUssTUFBbEIsRUFBMEIsTUFBMUI7O0FBRUEsTUFBSSxRQUFRLE9BQU8sSUFBUCxDQUFZLE1BQVosQ0FBWjtBQUNBLE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFNLE1BQTFCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ3RDLFFBQUssTUFBTSxDQUFOLENBQUwsSUFBaUIsT0FBTyxNQUFNLENBQU4sQ0FBUCxDQUFqQjtBQUNBO0FBQ0QsRTs7Ozs7Ozs7Ozs7O2lCQVVELGlCLDhCQUFrQixJLEVBQU0sSyxFQUFPO0FBQzlCLE1BQUksQ0FBQyxLQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBRCxJQUEyQixDQUFDLEtBQUssaUJBQUwsQ0FBdUIsSUFBdkIsRUFBNkIsS0FBN0IsQ0FBaEMsRUFBcUU7QUFDcEU7QUFDQTs7QUFFRCxNQUFJLE9BQU8sS0FBSyxVQUFMLENBQWdCLElBQWhCLENBQVg7QUFDQSxNQUFJLEtBQUssWUFBTCxLQUFzQixTQUF0QixJQUFtQyxLQUFLLEtBQUwsS0FBZSxNQUFNLFNBQU4sQ0FBZ0IsYUFBdEUsRUFBcUY7QUFDcEYsUUFBSyxLQUFMLEdBQWEsTUFBTSxTQUFOLENBQWdCLFdBQTdCO0FBQ0E7O0FBRUQsTUFBSSxVQUFVLEtBQUssSUFBTCxDQUFkO0FBQ0EsT0FBSyxLQUFMLEdBQWEsS0FBSyxXQUFMLENBQWlCLElBQWpCLEVBQXVCLEtBQXZCLEVBQThCLE9BQTlCLENBQWI7QUFDQSxPQUFLLE9BQUwsR0FBZSxJQUFmO0FBQ0EsT0FBSyxhQUFMLENBQW1CLElBQW5CLEVBQXlCLE9BQXpCO0FBQ0EsRTs7Ozs7Ozs7Ozs7Ozs7OztpQkFjRCxtQixnQ0FBb0IsSSxFQUFNLE8sRUFBUztBQUNsQyxNQUFJLE9BQU8sS0FBSyxVQUFMLENBQWdCLElBQWhCLENBQVg7QUFDQSxTQUFRLEtBQUssS0FBTCxLQUFlLE1BQU0sU0FBTixDQUFnQixXQUFoQyxLQUNMLFlBQUssUUFBTCxDQUFjLE9BQWQsS0FBMEIsWUFBWSxLQUFLLElBQUwsQ0FEakMsQ0FBUDtBQUVBLEU7Ozs7Ozs7Ozs7OztpQkFVRCxpQiw4QkFBa0IsSSxFQUFNLEssRUFBTztBQUM5QixNQUFJLE9BQU8sS0FBSyxVQUFMLENBQWdCLElBQWhCLENBQVg7O0FBRUEsU0FBTyxLQUFLLEtBQUwsS0FBZSxNQUFNLFNBQU4sQ0FBZ0Isb0JBQS9CLElBQ04sS0FBSyxjQUFMLENBQW9CLElBQXBCLEVBQTBCLEtBQTFCLENBREQ7QUFFQSxFOzs7Ozs7Ozs7Ozs7O0FBU0YsTUFBTSxZQUFOLEdBQXFCLENBQUMsUUFBRCxFQUFXLE9BQVgsRUFBb0IsVUFBcEIsQ0FBckI7Ozs7OztBQU1BLE1BQU0sU0FBTixHQUFrQjtBQUNqQixnQkFBZSxDQURFO0FBRWpCLGVBQWMsQ0FGRztBQUdqQix1QkFBc0IsQ0FITDtBQUlqQixjQUFhO0FBSkksQ0FBbEI7O2tCQU9lLEs7OztBQzFqQmY7Ozs7Ozs7O0FBRUE7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7QUFFQSxJQUFJLDBCQUFKOztJQUVNLEc7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCTCxnQkFBMEI7QUFBQSxNQUFkLE9BQWMseURBQUosRUFBSTs7QUFBQTs7QUFDekIsT0FBSyxHQUFMLEdBQVcsSUFBSSxLQUFKLENBQVUsS0FBSyw0QkFBTCxDQUFrQyxPQUFsQyxDQUFWLENBQVg7QUFDQTs7Ozs7Ozs7Ozs7ZUFTRCx5QixzQ0FBMEIsUSxFQUFVO0FBQUE7O0FBQ25DLFdBQVMsS0FBVCxHQUFpQixPQUFqQixDQUF5QixVQUFDLElBQUQsRUFBVTtBQUNsQyxZQUFTLE1BQVQsQ0FBZ0IsSUFBaEIsRUFBc0IsT0FBdEIsQ0FBOEIsVUFBQyxLQUFELEVBQVc7QUFDeEMsVUFBSyxpQkFBTCxDQUF1QixJQUF2QixFQUE2QixLQUE3QjtBQUNBLElBRkQ7QUFHQSxHQUpEO0FBS0EsU0FBTyxJQUFQO0FBQ0EsRTs7Ozs7Ozs7OztlQVFELGlCLDhCQUFrQixJLEVBQU0sSyxFQUFPO0FBQzlCLE9BQUssdUJBQUw7QUFDQSxNQUFJLFlBQUssS0FBTCxDQUFXLEtBQVgsQ0FBSixFQUF1QjtBQUN0QixXQUFRLE9BQU8sS0FBUCxDQUFSO0FBQ0E7QUFDRCxPQUFLLEtBQUwsQ0FBVyxHQUFYLENBQWUsSUFBZixFQUFxQixLQUFyQjtBQUNBLFNBQU8sSUFBUDtBQUNBLEU7Ozs7Ozs7Ozs7ZUFRRCxrQiwrQkFBbUIsSSxFQUFNLE0sRUFBUTtBQUFBOztBQUNoQyxTQUFPLE9BQVAsQ0FBZSxVQUFDLEtBQUQ7QUFBQSxVQUFXLE9BQUssaUJBQUwsQ0FBdUIsSUFBdkIsRUFBNkIsS0FBN0IsQ0FBWDtBQUFBLEdBQWY7QUFDQSxTQUFPLElBQVA7QUFDQSxFOzs7Ozs7Ozs7ZUFPRCx1QixzQ0FBMEI7QUFBQTs7QUFDekIsTUFBSSxLQUFLLEtBQVQsRUFBZ0I7QUFDZjtBQUNBO0FBQ0QsT0FBSyxLQUFMLEdBQWEsd0JBQWI7QUFDQSxNQUFJLFNBQVMsS0FBSyxHQUFMLENBQVMsTUFBdEI7QUFDQSxNQUFJLE1BQUosRUFBWTtBQUNYLFVBQU8sU0FBUCxDQUFpQixDQUFqQixFQUFvQixLQUFwQixDQUEwQixHQUExQixFQUErQixPQUEvQixDQUF1QyxVQUFDLEtBQUQsRUFBVztBQUFBLHVCQUM5QixNQUFNLEtBQU4sQ0FBWSxHQUFaLENBRDhCOztBQUFBOztBQUFBLFFBQzVDLEdBRDRDO0FBQUEsUUFDdkMsS0FEdUM7O0FBRWpELFFBQUksWUFBSyxLQUFMLENBQVcsS0FBWCxDQUFKLEVBQXVCO0FBQ3RCLGFBQVEsSUFBSSxTQUFKLENBQWMsS0FBZCxDQUFSO0FBQ0E7QUFDRCxXQUFLLGlCQUFMLENBQXVCLEdBQXZCLEVBQTRCLEtBQTVCO0FBQ0EsSUFORDtBQU9BO0FBQ0QsRTs7Ozs7Ozs7ZUFNRCxPLHNCQUFVO0FBQ1QsU0FBTyxLQUFLLEdBQUwsQ0FBUyxJQUFULElBQWlCLEVBQXhCO0FBQ0EsRTs7Ozs7Ozs7ZUFNRCxPLHNCQUFVO0FBQ1QsTUFBSSxPQUFPLEtBQUssV0FBTCxFQUFYO0FBQ0EsTUFBSSxJQUFKLEVBQVU7QUFDVCxPQUFJLE9BQU8sS0FBSyxPQUFMLEVBQVg7QUFDQSxPQUFJLFFBQVEsU0FBUyxJQUFyQixFQUEyQjtBQUMxQixZQUFRLE1BQU0sSUFBZDtBQUNBO0FBQ0Q7QUFDRCxTQUFPLElBQVA7QUFDQSxFOzs7Ozs7OztlQU1ELFcsMEJBQWM7QUFDYixNQUFJLFdBQVcsS0FBSyxHQUFMLENBQVMsUUFBeEI7QUFDQSxNQUFJLGFBQWEsSUFBSSxvQkFBckIsRUFBMkM7QUFDMUMsVUFBTyxFQUFQO0FBQ0E7QUFDRCxTQUFPLFFBQVA7QUFDQSxFOzs7Ozs7OztlQU1ELFMsd0JBQVk7QUFDWCxNQUFJLE9BQU8sS0FBSyxPQUFMLEVBQVg7QUFDQSxNQUFJLElBQUosRUFBVTtBQUNULFVBQU8sS0FBSyxXQUFMLEtBQXFCLElBQXJCLEdBQTRCLElBQW5DO0FBQ0E7QUFDRCxTQUFPLEVBQVA7QUFDQSxFOzs7Ozs7Ozs7Ozs7ZUFVRCxpQiw4QkFBa0IsSSxFQUFNO0FBQ3ZCLE9BQUssdUJBQUw7QUFDQSxTQUFPLEtBQUssS0FBTCxDQUFXLEdBQVgsQ0FBZSxJQUFmLENBQVA7QUFDQSxFOzs7Ozs7Ozs7OztlQVNELGtCLCtCQUFtQixJLEVBQU07QUFDeEIsT0FBSyx1QkFBTDtBQUNBLFNBQU8sS0FBSyxLQUFMLENBQVcsTUFBWCxDQUFrQixJQUFsQixDQUFQO0FBQ0EsRTs7Ozs7Ozs7O2VBT0QsaUIsZ0NBQW9CO0FBQ25CLE9BQUssdUJBQUw7QUFDQSxTQUFPLEtBQUssS0FBTCxDQUFXLEtBQVgsRUFBUDtBQUNBLEU7Ozs7Ozs7O0tBTU0sVSx5QkFBYTtBQUNuQixTQUFPLFFBQVA7QUFDQSxFOzs7Ozs7OztlQU1ELFcsMEJBQWM7QUFDYixTQUFPLEtBQUssR0FBTCxDQUFTLFFBQWhCO0FBQ0EsRTs7Ozs7Ozs7ZUFNRCxPLHNCQUFVO0FBQ1QsU0FBTyxLQUFLLEdBQUwsQ0FBUyxJQUFoQjtBQUNBLEU7Ozs7Ozs7O2VBTUQsVywwQkFBYztBQUNiLFNBQU8sS0FBSyxHQUFMLENBQVMsUUFBaEI7QUFDQSxFOzs7Ozs7Ozs7ZUFPRCxTLHdCQUFZO0FBQUE7O0FBQ1gsTUFBSSxTQUFTLEVBQWI7QUFDQSxNQUFJLGNBQWMsRUFBbEI7QUFDQSxPQUFLLGlCQUFMLEdBQXlCLE9BQXpCLENBQWlDLFVBQUMsSUFBRCxFQUFVO0FBQzFDLFVBQUssa0JBQUwsQ0FBd0IsSUFBeEIsRUFBOEIsT0FBOUIsQ0FBc0MsVUFBQyxLQUFELEVBQVc7QUFDaEQsbUJBQWUsSUFBZjtBQUNBLFFBQUksWUFBSyxLQUFMLENBQVcsS0FBWCxDQUFKLEVBQXVCO0FBQ3RCLG9CQUFlLE1BQU0sbUJBQW1CLEtBQW5CLENBQXJCO0FBQ0E7QUFDRCxtQkFBZSxHQUFmO0FBQ0EsSUFORDtBQU9BLEdBUkQ7QUFTQSxnQkFBYyxZQUFZLEtBQVosQ0FBa0IsQ0FBbEIsRUFBcUIsQ0FBQyxDQUF0QixDQUFkO0FBQ0EsTUFBSSxXQUFKLEVBQWlCO0FBQ2hCLGFBQVUsTUFBTSxXQUFoQjtBQUNBO0FBQ0QsU0FBTyxNQUFQO0FBQ0EsRTs7Ozs7Ozs7O2VBT0QsWSx5QkFBYSxJLEVBQU07QUFDbEIsT0FBSyx1QkFBTDtBQUNBLFNBQU8sS0FBSyxLQUFMLENBQVcsUUFBWCxDQUFvQixJQUFwQixDQUFQO0FBQ0EsRTs7Ozs7Ozs7ZUFNRCxVLHlCQUFhO0FBQ1osT0FBSyxpQkFBTCxDQUF1QixJQUFJLFlBQTNCLEVBQXlDLGNBQU8sZUFBUCxFQUF6QztBQUNBLFNBQU8sSUFBUDtBQUNBLEU7Ozs7Ozs7Ozs7ZUFRRCw0Qix5Q0FBNkIsTyxFQUFTO0FBQ3JDLE1BQUksTUFBTSxPQUFWO0FBQ0EsTUFBSSxRQUFRLE9BQVIsQ0FBZ0IsS0FBaEIsTUFBMkIsQ0FBQyxDQUE1QixJQUNILFFBQVEsT0FBUixDQUFnQixhQUFoQixNQUFtQyxDQURwQyxFQUN1Qzs7O0FBRXRDLFNBQU0sSUFBSSxnQkFBVjtBQUNBLE9BQUksUUFBUSxDQUFSLE1BQWUsR0FBZixJQUFzQixRQUFRLENBQVIsTUFBZSxHQUF6QyxFQUE4QztBQUM3QyxXQUFPLElBQVA7QUFDQTs7QUFFRCxXQUFRLFFBQVEsTUFBUixDQUFlLENBQWYsQ0FBUjtBQUNDLFNBQUssR0FBTDtBQUNBLFNBQUssR0FBTDtBQUNBLFNBQUssR0FBTDtBQUNDLFlBQU8sSUFBSSxvQkFBWDtBQUNBLFlBQU8sR0FBUDtBQUNBLFlBQU8sT0FBUDtBQUNBO0FBQ0QsU0FBSyxFQUFMO0FBQ0EsU0FBSyxHQUFMO0FBQ0MsU0FBSSxRQUFRLENBQVIsTUFBZSxHQUFuQixFQUF3QjtBQUN2QixhQUFPLElBQUksb0JBQVg7QUFDQTtBQUNELFlBQU8sT0FBUDtBQUNBO0FBQ0Q7QUFDQyxZQUFPLE9BQVA7QUFoQkY7QUFrQkE7QUFDRCxTQUFPLEdBQVA7QUFDQSxFOzs7Ozs7OztLQU1NLGUsNEJBQWdCLE0sRUFBUTtBQUM5QixNQUFJLFNBQVMsT0FBTyxRQUFQLEdBQWtCLE9BQU8sUUFBUCxDQUFnQixNQUFsQyxHQUEyQyxDQUF4RDtBQUNBLE1BQUksU0FBUyxDQUFULElBQWMsT0FBTyxRQUFQLENBQWdCLFNBQVMsQ0FBekIsTUFBZ0MsR0FBbEQsRUFBdUQ7QUFDdEQsVUFBTyxRQUFQLEdBQWtCLE9BQU8sUUFBUCxDQUFnQixNQUFoQixDQUF1QixDQUF2QixFQUEwQixTQUFTLENBQW5DLENBQWxCO0FBQ0E7QUFDRCxTQUFPLE1BQVA7QUFDQSxFOzs7Ozs7OztLQU1NLEssa0JBQU0sTyxFQUFTO0FBQ3JCLFNBQU8sSUFBSSxlQUFKLENBQW9CLFNBQVMsT0FBVCxDQUFwQixDQUFQO0FBQ0EsRTs7Ozs7Ozs7O2VBT0QsZSw0QkFBZ0IsSSxFQUFNO0FBQ3JCLE9BQUssdUJBQUw7QUFDQSxPQUFLLEtBQUwsQ0FBVyxNQUFYLENBQWtCLElBQWxCO0FBQ0EsU0FBTyxJQUFQO0FBQ0EsRTs7Ozs7Ozs7ZUFNRCxZLDJCQUFlO0FBQ2QsT0FBSyxlQUFMLENBQXFCLElBQUksWUFBekI7QUFDQSxTQUFPLElBQVA7QUFDQSxFOzs7Ozs7Ozs7ZUFPRCxPLG9CQUFRLEksRUFBTTtBQUNiLE9BQUssR0FBTCxDQUFTLElBQVQsR0FBZ0IsSUFBaEI7QUFDQSxTQUFPLElBQVA7QUFDQSxFOzs7Ozs7Ozs7ZUFPRCxXLHdCQUFZLFEsRUFBVTtBQUNyQixPQUFLLEdBQUwsQ0FBUyxRQUFULEdBQW9CLFFBQXBCO0FBQ0EsU0FBTyxJQUFQO0FBQ0EsRTs7Ozs7Ozs7Ozs7ZUFTRCxpQiw4QkFBa0IsSSxFQUFNLEssRUFBTztBQUM5QixPQUFLLGVBQUwsQ0FBcUIsSUFBckI7QUFDQSxPQUFLLGlCQUFMLENBQXVCLElBQXZCLEVBQTZCLEtBQTdCO0FBQ0EsU0FBTyxJQUFQO0FBQ0EsRTs7Ozs7Ozs7Ozs7ZUFTRCxrQiwrQkFBbUIsSSxFQUFNLE0sRUFBUTtBQUFBOztBQUNoQyxPQUFLLGVBQUwsQ0FBcUIsSUFBckI7QUFDQSxTQUFPLE9BQVAsQ0FBZSxVQUFDLEtBQUQ7QUFBQSxVQUFXLE9BQUssaUJBQUwsQ0FBdUIsSUFBdkIsRUFBNkIsS0FBN0IsQ0FBWDtBQUFBLEdBQWY7QUFDQSxTQUFPLElBQVA7QUFDQSxFOzs7Ozs7Ozs7ZUFPRCxXLHdCQUFZLFEsRUFBVTtBQUNyQixPQUFLLEdBQUwsQ0FBUyxRQUFULEdBQW9CLFFBQXBCO0FBQ0EsU0FBTyxJQUFQO0FBQ0EsRTs7Ozs7Ozs7O2VBT0QsTyxvQkFBUSxJLEVBQU07QUFDYixPQUFLLEdBQUwsQ0FBUyxJQUFULEdBQWdCLElBQWhCO0FBQ0EsU0FBTyxJQUFQO0FBQ0EsRTs7Ozs7Ozs7O0tBT00sVSx1QkFBVyxPLEVBQVM7QUFDMUIsYUFBVyxPQUFYO0FBQ0EsRTs7Ozs7Ozs7O2VBT0QsVyx3QkFBWSxRLEVBQVU7QUFDckIsT0FBSyxHQUFMLENBQVMsUUFBVCxHQUFvQixRQUFwQjtBQUNBLE1BQUksS0FBSyxHQUFMLENBQVMsUUFBVCxDQUFrQixLQUFLLEdBQUwsQ0FBUyxRQUFULENBQWtCLE1BQWxCLEdBQTJCLENBQTdDLE1BQW9ELEdBQXhELEVBQTZEO0FBQzVELFFBQUssR0FBTCxDQUFTLFFBQVQsSUFBcUIsR0FBckI7QUFDQTtBQUNELFNBQU8sSUFBUDtBQUNBLEU7Ozs7Ozs7O2VBTUQsUSx1QkFBVztBQUNWLE1BQUksT0FBTyxFQUFYO0FBQ0EsTUFBSSxPQUFPLEtBQUssT0FBTCxFQUFYO0FBQ0EsTUFBSSxJQUFKLEVBQVU7QUFDVCxXQUFRLEtBQUssV0FBTCxLQUFxQixJQUE3QjtBQUNBO0FBQ0QsVUFBUSxPQUFPLEtBQUssV0FBTCxFQUFQLEdBQTRCLEtBQUssU0FBTCxFQUE1QixHQUErQyxLQUFLLE9BQUwsRUFBdkQ7QUFDQSxTQUFPLElBQVA7QUFDQSxFOzs7Ozs7Ozs7O0tBUU0sUyxzQkFBVSxRLEVBQW9CO0FBQUEsb0NBQVAsS0FBTztBQUFQLFFBQU87QUFBQTs7QUFDcEMsTUFBSSxTQUFTLE1BQVQsQ0FBZ0IsU0FBUyxNQUFULEdBQWtCLENBQWxDLE1BQXlDLEdBQTdDLEVBQWtEO0FBQ2pELGNBQVcsU0FBUyxTQUFULENBQW1CLENBQW5CLEVBQXNCLFNBQVMsTUFBVCxHQUFrQixDQUF4QyxDQUFYO0FBQ0E7QUFDRCxVQUFRLE1BQU0sR0FBTixDQUFVO0FBQUEsVUFBUSxLQUFLLE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQW5CLEdBQXlCLEtBQUssU0FBTCxDQUFlLENBQWYsQ0FBekIsR0FBNkMsSUFBckQ7QUFBQSxHQUFWLENBQVI7QUFDQSxTQUFPLENBQUMsUUFBRCxFQUFXLE1BQVgsQ0FBa0IsS0FBbEIsRUFBeUIsSUFBekIsQ0FBOEIsR0FBOUIsRUFBbUMsT0FBbkMsQ0FBMkMsS0FBM0MsRUFBa0QsRUFBbEQsQ0FBUDtBQUNBLEU7Ozs7Ozs7Ozs7S0FRTSxTLHNCQUFVLEcsRUFBSztBQUNyQixTQUFPLG1CQUFtQixJQUFJLE9BQUosQ0FBWSxLQUFaLEVBQW1CLEdBQW5CLENBQW5CLENBQVA7QUFDQSxFOzs7Ozs7Ozs7Ozs7O0FBVUYsSUFBSSxnQkFBSixHQUF1QixPQUF2Qjs7Ozs7OztBQU9BLElBQUksb0JBQUosR0FBMkIsYUFBYSxLQUFLLEdBQUwsRUFBeEM7Ozs7Ozs7QUFPQSxJQUFJLFlBQUosR0FBbUIsSUFBbkI7O2tCQUVlLEc7OztBQzlkZjs7Ozs7O0FBRUE7O0FBQ0E7Ozs7Ozs7Ozs7O0FBT0EsU0FBUyxLQUFULENBQWUsT0FBZixFQUF3QjtBQUN2QixLQUFJLFlBQUssVUFBTCxDQUFnQixHQUFoQixLQUF3QixJQUFJLE1BQWhDLEVBQXdDO0FBQ3ZDLFNBQU8sSUFBSSxHQUFKLENBQVEsT0FBUixDQUFQO0FBQ0EsRUFGRCxNQUVPO0FBQ04sU0FBTywrQkFBZ0IsT0FBaEIsQ0FBUDtBQUNBO0FBQ0Q7O2tCQUVjLEs7OztBQ2xCZjs7Ozs7Ozs7OztBQU1BLFNBQVMsZUFBVCxDQUF5QixPQUF6QixFQUFrQztBQUNqQyxLQUFJLE9BQU8sU0FBUyxhQUFULENBQXVCLEdBQXZCLENBQVg7QUFDQSxNQUFLLElBQUwsR0FBWSxPQUFaO0FBQ0EsUUFBTztBQUNOLFFBQU0sS0FBSyxJQURMO0FBRU4sWUFBVSxLQUFLLFFBRlQ7QUFHTixZQUFVLEtBQUssUUFIVDtBQUlOLFlBQVUsS0FBSyxRQUFMLENBQWMsQ0FBZCxNQUFxQixHQUFyQixHQUEyQixLQUFLLFFBQWhDLEdBQTJDLE1BQU0sS0FBSyxRQUoxRDtBQUtOLFFBQU0sS0FBSyxJQUxMO0FBTU4sWUFBVSxLQUFLLFFBTlQ7QUFPTixVQUFRLEtBQUssTUFQUDtBQVFOLFlBQVUsS0FBSztBQVJULEVBQVA7QUFVQTs7a0JBRWMsZTs7O0FDckJmOzs7Ozs7Ozs7Ozs7Ozs7O0lBU00sRTs7Ozs7Ozs7Ozs7Ozs7SUFTRSxrQixpQ0FBcUI7QUFDM0IsTUFBSSxZQUFZLEdBQUcsT0FBSCxDQUFXLE1BQVgsQ0FBa0IsU0FBbEM7QUFDQSxNQUFJLFNBQUosRUFBZTtBQUNkLE9BQUksWUFBWSxVQUFVLFNBQTFCO0FBQ0EsT0FBSSxTQUFKLEVBQWU7QUFDZCxXQUFPLFNBQVA7QUFDQTtBQUNEO0FBQ0QsU0FBTyxFQUFQO0FBQ0EsRTs7Ozs7Ozs7Ozs7SUFTTSxjLDJCQUFlLEcsRUFBSztBQUMxQixTQUFPLEdBQUcsU0FBSCxDQUFhLE9BQWIsQ0FBcUIsR0FBckIsTUFBOEIsQ0FBQyxDQUF0QztBQUNBLEU7Ozs7Ozs7OztJQU9NLGEsMEJBQWMsUyxFQUFXOzs7Ozs7QUFNL0IsS0FBRyxTQUFILEdBQWUsU0FBZjs7Ozs7OztBQU9BLEtBQUcsT0FBSCxHQUFhLEdBQUcsY0FBSCxDQUFrQixPQUFsQixLQUE4QixHQUFHLGNBQUgsQ0FBa0IsS0FBbEIsQ0FBM0M7Ozs7Ozs7QUFPQSxLQUFHLElBQUgsR0FBVSxHQUFHLGNBQUgsQ0FBa0IsU0FBbEIsS0FBZ0MsR0FBRyxjQUFILENBQWtCLE1BQWxCLENBQTFDOzs7Ozs7O0FBT0EsS0FBRyxNQUFILEdBQVksR0FBRyxjQUFILENBQWtCLE1BQWxCLENBQVo7Ozs7Ozs7QUFPQSxLQUFHLFVBQUgsR0FBZ0IsR0FBRyxJQUFILElBQVcsR0FBRyxNQUE5Qjs7Ozs7OztBQU9BLEtBQUcsUUFBSCxHQUFjLENBQUMsR0FBRyxjQUFILENBQWtCLFFBQWxCLEtBQStCLEdBQUcsY0FBSCxDQUFrQixPQUFsQixDQUFoQyxLQUErRCxDQUFDLEdBQUcsT0FBbkUsSUFBOEUsQ0FBQyxHQUFHLE1BQWhHOzs7Ozs7O0FBT0EsS0FBRyxRQUFILEdBQWMsR0FBRyxjQUFILENBQWtCLFFBQWxCLEtBQStCLEVBQUUsR0FBRyxRQUFILElBQWUsR0FBRyxPQUFsQixJQUE2QixHQUFHLE1BQWxDLENBQTdDOzs7Ozs7O0FBT0EsS0FBRyxTQUFILEdBQWUsR0FBRyxjQUFILENBQWtCLFNBQWxCLENBQWY7QUFDQSxFOzs7Ozs7Ozs7Ozs7QUFRRixHQUFHLE9BQUgsR0FBYTtBQUNaLFNBQVE7QUFESSxDQUFiOztBQUlBLEdBQUcsYUFBSCxDQUFpQixHQUFHLGtCQUFILEVBQWpCOztrQkFFZSxFOzs7QUNuSGY7Ozs7OztBQUVBOzs7Ozs7OztJQUVNLEs7Ozs7Ozs7Ozs7OztPQU9FLEssa0JBQU0sSSxFQUFNLEksRUFBTTtBQUN4QixNQUFJLEtBQUssTUFBTCxLQUFnQixLQUFLLE1BQXpCLEVBQWlDO0FBQ2hDLFVBQU8sS0FBUDtBQUNBO0FBQ0QsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssTUFBekIsRUFBaUMsR0FBakMsRUFBc0M7QUFDckMsT0FBSSxLQUFLLENBQUwsTUFBWSxLQUFLLENBQUwsQ0FBaEIsRUFBeUI7QUFDeEIsV0FBTyxLQUFQO0FBQ0E7QUFDRDtBQUNELFNBQU8sSUFBUDtBQUNBLEU7Ozs7Ozs7OztPQU9NLGlCLDhCQUFrQixHLEVBQUs7QUFDN0IsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLElBQUksTUFBeEIsRUFBZ0MsR0FBaEMsRUFBcUM7QUFDcEMsT0FBSSxJQUFJLENBQUosTUFBVyxTQUFmLEVBQTBCO0FBQ3pCLFdBQU8sSUFBSSxDQUFKLENBQVA7QUFDQTtBQUNEO0FBQ0QsRTs7Ozs7Ozs7OztPQVFNLE8sb0JBQVEsRyxFQUFLLFUsRUFBWTtBQUMvQixNQUFJLFNBQVMsY0FBYyxFQUEzQjtBQUNBLE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxJQUFJLE1BQXhCLEVBQWdDLEdBQWhDLEVBQXFDO0FBQ3BDLE9BQUksTUFBTSxPQUFOLENBQWMsSUFBSSxDQUFKLENBQWQsQ0FBSixFQUEyQjtBQUMxQixVQUFNLE9BQU4sQ0FBYyxJQUFJLENBQUosQ0FBZCxFQUFzQixNQUF0QjtBQUNBLElBRkQsTUFFTztBQUNOLFdBQU8sSUFBUCxDQUFZLElBQUksQ0FBSixDQUFaO0FBQ0E7QUFDRDtBQUNELFNBQU8sTUFBUDtBQUNBLEU7Ozs7Ozs7Ozs7O09BU00sTSxtQkFBTyxHLEVBQUssRyxFQUFLO0FBQ3ZCLE1BQUksSUFBSSxJQUFJLE9BQUosQ0FBWSxHQUFaLENBQVI7QUFDQSxNQUFJLEVBQUo7QUFDQSxNQUFNLEtBQUssS0FBSyxDQUFoQixFQUFxQjtBQUNwQixTQUFNLFFBQU4sQ0FBZSxHQUFmLEVBQW9CLENBQXBCO0FBQ0E7QUFDRCxTQUFPLEVBQVA7QUFDQSxFOzs7Ozs7Ozs7O09BUU0sUSxxQkFBUyxHLEVBQUssQyxFQUFHO0FBQ3ZCLFNBQU8sTUFBTSxTQUFOLENBQWdCLE1BQWhCLENBQXVCLElBQXZCLENBQTRCLEdBQTVCLEVBQWlDLENBQWpDLEVBQW9DLENBQXBDLEVBQXVDLE1BQXZDLEtBQWtELENBQXpEO0FBQ0EsRTs7Ozs7Ozs7Ozs7Ozs7T0FZTSxLLGtCQUFNLEcsRUFBSyxLLEVBQU8sTyxFQUFTO0FBQ2pDLE1BQUksU0FBUyxFQUFiO0FBQ0EsTUFBSSxNQUFNLGVBQUssS0FBTCxDQUFXLE9BQVgsSUFBc0IsT0FBdEIsR0FBZ0MsSUFBSSxNQUE5QztBQUNBLE9BQUssSUFBSSxJQUFJLEtBQWIsRUFBb0IsSUFBSSxHQUF4QixFQUE2QixHQUE3QixFQUFrQztBQUNqQyxVQUFPLElBQVAsQ0FBWSxJQUFJLENBQUosQ0FBWjtBQUNBO0FBQ0QsU0FBTyxNQUFQO0FBQ0EsRTs7Ozs7a0JBR2EsSzs7Ozs7Ozs7QUMvRmY7Ozs7O0FBRUEsSUFBSSxRQUFRLEVBQVo7Ozs7Ozs7OztBQVVBLE1BQU0sY0FBTixHQUF1QixVQUFTLFNBQVQsRUFBb0I7O0FBRTFDLE9BQU0sUUFBTixDQUFlLFlBQVc7QUFDekIsUUFBTSxTQUFOO0FBQ0EsRUFGRDtBQUdBLENBTEQ7Ozs7Ozs7Ozs7QUFnQkEsTUFBTSxHQUFOLEdBQVksVUFBUyxRQUFULEVBQW1CLFdBQW5CLEVBQWdDO0FBQzNDLEtBQUksQ0FBQyxNQUFNLEdBQU4sQ0FBVSxtQkFBZixFQUFvQzs7QUFFbkMsUUFBTSxRQUFOLENBQWUsTUFBTSxHQUFOLENBQVUsZ0JBQXpCO0FBQ0EsUUFBTSxHQUFOLENBQVUsbUJBQVYsR0FBZ0MsSUFBaEM7QUFDQTs7QUFFRCxPQUFNLEdBQU4sQ0FBVSxVQUFWLENBQXFCLElBQXJCLENBQ0MsSUFBSSxNQUFNLEdBQU4sQ0FBVSxTQUFkLENBQXdCLFFBQXhCLEVBQWtDLFdBQWxDLENBREQ7QUFFQSxDQVREOzs7QUFhQSxNQUFNLEdBQU4sQ0FBVSxtQkFBVixHQUFnQyxLQUFoQzs7O0FBSUEsTUFBTSxHQUFOLENBQVUsVUFBVixHQUF1QixFQUF2Qjs7Ozs7OztBQU9BLE1BQU0sR0FBTixDQUFVLGdCQUFWLEdBQTZCLFlBQVc7O0FBRXZDLFFBQU8sTUFBTSxHQUFOLENBQVUsVUFBVixDQUFxQixNQUE1QixFQUFvQzs7QUFFbkMsTUFBSSxZQUFZLE1BQU0sR0FBTixDQUFVLFVBQTFCO0FBQ0EsUUFBTSxHQUFOLENBQVUsVUFBVixHQUF1QixFQUF2QjtBQUNBLE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxVQUFVLE1BQTlCLEVBQXNDLEdBQXRDLEVBQTJDO0FBQzFDLE9BQUksV0FBVyxVQUFVLENBQVYsQ0FBZjtBQUNBLE9BQUk7QUFDSCxhQUFTLEVBQVQsQ0FBWSxJQUFaLENBQWlCLFNBQVMsS0FBMUI7QUFDQSxJQUZELENBRUUsT0FBTyxDQUFQLEVBQVU7QUFDWCxVQUFNLGNBQU4sQ0FBcUIsQ0FBckI7QUFDQTtBQUNEO0FBQ0Q7OztBQUdELE9BQU0sR0FBTixDQUFVLG1CQUFWLEdBQWdDLEtBQWhDO0FBQ0EsQ0FsQkQ7Ozs7Ozs7Ozs7O0FBOEJBLE1BQU0sR0FBTixDQUFVLFNBQVYsR0FBc0IsVUFBUyxFQUFULEVBQWEsS0FBYixFQUFvQjs7QUFFekMsTUFBSyxFQUFMLEdBQVUsRUFBVjs7QUFFQSxNQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0EsQ0FMRDs7Ozs7Ozs7Ozs7QUFpQkEsTUFBTSxRQUFOLEdBQWlCLFVBQVMsUUFBVCxFQUFtQixXQUFuQixFQUFnQztBQUNoRCxLQUFJLEtBQUssUUFBVDtBQUNBLEtBQUksV0FBSixFQUFpQjtBQUNoQixPQUFLLFNBQVMsSUFBVCxDQUFjLFdBQWQsQ0FBTDtBQUNBO0FBQ0QsTUFBSyxNQUFNLFFBQU4sQ0FBZSxhQUFmLENBQTZCLEVBQTdCLENBQUw7Ozs7OztBQU1BLEtBQUksT0FBTyxZQUFQLEtBQXdCLFVBQTVCLEVBQXdDO0FBQ3ZDLGVBQWEsRUFBYjtBQUNBO0FBQ0E7O0FBRUQsS0FBSSxDQUFDLE1BQU0sUUFBTixDQUFlLGFBQXBCLEVBQW1DO0FBQ2xDLFFBQU0sUUFBTixDQUFlLGFBQWYsR0FBK0IsTUFBTSxRQUFOLENBQWUsd0JBQWYsRUFBL0I7QUFDQTtBQUNELE9BQU0sUUFBTixDQUFlLGFBQWYsQ0FBNkIsRUFBN0I7QUFDQSxDQXBCRDs7Ozs7OztBQTRCQSxNQUFNLFFBQU4sQ0FBZSxhQUFmLEdBQStCLElBQS9COzs7Ozs7OztBQVNBLE1BQU0sUUFBTixDQUFlLHdCQUFmLEdBQTBDLFlBQVc7OztBQUdwRCxLQUFJLE9BQUo7Ozs7OztBQU1BLEtBQUksT0FBTyxjQUFQLEtBQTBCLFVBQTlCLEVBQTBDO0FBQ3pDLFlBQVUsY0FBVjtBQUNBOzs7Ozs7QUFNRCxLQUFJLE9BQU8sT0FBUCxLQUFtQixXQUFuQixJQUFrQyxPQUFPLE1BQVAsS0FBa0IsV0FBcEQsSUFDSCxPQUFPLFdBREosSUFDbUIsT0FBTyxnQkFEOUIsRUFDZ0Q7O0FBRS9DLFlBQVUsbUJBQVc7O0FBRXBCLE9BQUksU0FBUyxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBYjtBQUNBLFVBQU8sS0FBUCxDQUFhLE9BQWIsR0FBdUIsTUFBdkI7QUFDQSxVQUFPLEdBQVAsR0FBYSxFQUFiO0FBQ0EsWUFBUyxlQUFULENBQXlCLFdBQXpCLENBQXFDLE1BQXJDO0FBQ0EsT0FBSSxNQUFNLE9BQU8sYUFBakI7QUFDQSxPQUFJLE1BQU0sSUFBSSxRQUFkO0FBQ0EsT0FBSSxJQUFKO0FBQ0EsT0FBSSxLQUFKLENBQVUsRUFBVjtBQUNBLE9BQUksS0FBSjtBQUNBLE9BQUksVUFBVSxrQkFBa0IsS0FBSyxNQUFMLEVBQWhDO0FBQ0EsT0FBSSxTQUFTLElBQUksUUFBSixDQUFhLFFBQWIsR0FBd0IsSUFBeEIsR0FBK0IsSUFBSSxRQUFKLENBQWEsSUFBekQ7QUFDQSxPQUFJLFlBQVksVUFBUyxDQUFULEVBQVk7OztBQUczQixRQUFJLEVBQUUsTUFBRixLQUFhLE1BQWIsSUFBdUIsRUFBRSxJQUFGLEtBQVcsT0FBdEMsRUFBK0M7QUFDOUM7QUFDQTtBQUNELFNBQUssS0FBTCxDQUFXLFNBQVg7QUFDQSxJQVBlLENBT2QsSUFQYyxDQU9ULElBUFMsQ0FBaEI7QUFRQSxPQUFJLGdCQUFKLENBQXFCLFNBQXJCLEVBQWdDLFNBQWhDLEVBQTJDLEtBQTNDO0FBQ0EsUUFBSyxLQUFMLEdBQWEsRUFBYjtBQUNBLFFBQUssS0FBTCxHQUFhO0FBQ1osaUJBQWEsdUJBQVc7QUFDdkIsU0FBSSxXQUFKLENBQWdCLE9BQWhCLEVBQXlCLE1BQXpCO0FBQ0E7QUFIVyxJQUFiO0FBS0EsR0E1QkQ7QUE2QkE7QUFDRCxLQUFJLE9BQU8sT0FBUCxLQUFtQixXQUF2QixFQUFvQztBQUNuQyxNQUFJLFVBQVUsSUFBSSxPQUFKLEVBQWQ7O0FBRUEsTUFBSSxPQUFPLEVBQVg7QUFDQSxNQUFJLE9BQU8sSUFBWDtBQUNBLFVBQVEsS0FBUixDQUFjLFNBQWQsR0FBMEIsWUFBVztBQUNwQyxVQUFPLEtBQUssSUFBWjtBQUNBLE9BQUksS0FBSyxLQUFLLEVBQWQ7QUFDQSxRQUFLLEVBQUwsR0FBVSxJQUFWO0FBQ0E7QUFDQSxHQUxEO0FBTUEsU0FBTyxVQUFTLEVBQVQsRUFBYTtBQUNuQixRQUFLLElBQUwsR0FBWTtBQUNYLFFBQUk7QUFETyxJQUFaO0FBR0EsVUFBTyxLQUFLLElBQVo7QUFDQSxXQUFRLEtBQVIsQ0FBYyxXQUFkLENBQTBCLENBQTFCO0FBQ0EsR0FORDtBQU9BOzs7QUFHRCxLQUFJLE9BQU8sUUFBUCxLQUFvQixXQUFwQixJQUFtQyx3QkFDdEMsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBREQsRUFDbUM7QUFDbEMsU0FBTyxVQUFTLEVBQVQsRUFBYTtBQUNuQixPQUFJLFNBQVMsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBQWI7QUFDQSxVQUFPLGtCQUFQLEdBQTRCLFlBQVc7O0FBRXRDLFdBQU8sa0JBQVAsR0FBNEIsSUFBNUI7QUFDQSxXQUFPLFVBQVAsQ0FBa0IsV0FBbEIsQ0FBOEIsTUFBOUI7QUFDQSxhQUFTLElBQVQ7QUFDQTtBQUNBLFNBQUssSUFBTDtBQUNBLElBUEQ7QUFRQSxZQUFTLGVBQVQsQ0FBeUIsV0FBekIsQ0FBcUMsTUFBckM7QUFDQSxHQVhEO0FBWUE7OztBQUdELFFBQU8sVUFBUyxFQUFULEVBQWE7QUFDbkIsYUFBVyxFQUFYLEVBQWUsQ0FBZjtBQUNBLEVBRkQ7QUFHQSxDQTNGRDs7Ozs7Ozs7O0FBcUdBLE1BQU0sUUFBTixDQUFlLGFBQWYsR0FBK0IsVUFBUyxlQUFULEVBQTBCO0FBQ3hELFFBQU8sZUFBUDtBQUNBLENBRkQ7O2tCQUllLEs7OztBQ3RQZjs7Ozs7Ozs7Ozs7Ozs7O0lBTU0sSTs7Ozs7Ozs7Ozs7Ozs7OztNQVdFLGMsNkJBQWlCO0FBQ3ZCLFFBQU0sTUFBTSwrQkFBTixDQUFOO0FBQ0EsRTs7Ozs7Ozs7Ozs7OztNQVdNLDJCLHdDQUE0QixXLEVBQWEsWSxFQUFjO0FBQzdELE1BQUksaUJBQWlCLENBQUMsWUFBWSxZQUFaLENBQUQsQ0FBckI7QUFDQSxTQUFPLFlBQVksU0FBWixJQUF5QixDQUFDLFlBQVksU0FBWixDQUFzQixhQUF0QixDQUFvQyxRQUFwQyxDQUFqQyxFQUFnRjtBQUMvRSxpQkFBYyxZQUFZLFNBQTFCO0FBQ0Esa0JBQWUsSUFBZixDQUFvQixZQUFZLFlBQVosQ0FBcEI7QUFDQTtBQUNELFNBQU8sY0FBUDtBQUNBLEU7Ozs7Ozs7Ozs7O01BU00sZSw0QkFBZ0IsRSxFQUFJO0FBQzFCLE1BQUksQ0FBQyxHQUFHLElBQVIsRUFBYztBQUNiLE9BQUksTUFBTSxHQUFHLFFBQUgsRUFBVjtBQUNBLE1BQUcsSUFBSCxHQUFVLElBQUksU0FBSixDQUFjLENBQWQsRUFBaUIsSUFBSSxPQUFKLENBQVksR0FBWixDQUFqQixDQUFWO0FBQ0E7QUFDRCxTQUFPLEdBQUcsSUFBVjtBQUNBLEU7Ozs7Ozs7Ozs7Ozs7TUFXTSxNLG1CQUFPLFUsRUFBWTtBQUN6QixNQUFJLFVBQUosRUFBZ0I7QUFDZixVQUFPLFdBQVcsS0FBSyxZQUFoQixNQUNMLFdBQVcsS0FBSyxZQUFoQixJQUFnQyxLQUFLLGdCQUFMLEVBRDNCLENBQVA7QUFFQTtBQUNELFNBQU8sS0FBSyxnQkFBTCxFQUFQO0FBQ0EsRTs7Ozs7Ozs7O01BT00sZ0IsNkJBQWlCLGUsRUFBaUI7QUFDeEMsU0FBTyxlQUFQO0FBQ0EsRTs7Ozs7Ozs7O01BT00sUyxzQkFBVSxHLEVBQUs7QUFDckIsU0FBTyxPQUFPLEdBQVAsS0FBZSxTQUF0QjtBQUNBLEU7Ozs7Ozs7OztNQU9NLEssa0JBQU0sRyxFQUFLO0FBQ2pCLFNBQU8sUUFBUSxTQUFmO0FBQ0EsRTs7Ozs7Ozs7O01BT00sZSw0QkFBZ0IsRyxFQUFLO0FBQzNCLFNBQU8sS0FBSyxLQUFMLENBQVcsR0FBWCxLQUFtQixDQUFDLEtBQUssTUFBTCxDQUFZLEdBQVosQ0FBM0I7QUFDQSxFOzs7Ozs7Ozs7TUFPTSxVLHVCQUFXLEcsRUFBSztBQUN0QixTQUFPLE9BQU8sUUFBTyxHQUFQLHlDQUFPLEdBQVAsT0FBZSxRQUF0QixJQUFrQyxJQUFJLFFBQUosS0FBaUIsQ0FBMUQ7QUFDQSxFOzs7Ozs7Ozs7TUFPTSxTLHNCQUFVLEcsRUFBSztBQUNyQixTQUFPLE9BQU8sUUFBTyxHQUFQLHlDQUFPLEdBQVAsT0FBZSxRQUF0QixJQUFrQyxJQUFJLFFBQUosS0FBaUIsQ0FBMUQ7QUFDQSxFOzs7Ozs7Ozs7TUFPTSxVLHVCQUFXLEcsRUFBSztBQUN0QixTQUFPLE9BQU8sR0FBUCxLQUFlLFVBQXRCO0FBQ0EsRTs7Ozs7Ozs7O01BT00sTSxtQkFBTyxHLEVBQUs7QUFDbEIsU0FBTyxRQUFRLElBQWY7QUFDQSxFOzs7Ozs7Ozs7TUFPTSxRLHFCQUFTLEcsRUFBSztBQUNwQixTQUFPLE9BQU8sR0FBUCxLQUFlLFFBQXRCO0FBQ0EsRTs7Ozs7Ozs7O01BT00sUSxxQkFBUyxHLEVBQUs7QUFDcEIsU0FBTyxRQUFRLElBQVIsSUFBZ0IsUUFBUSxJQUFJLE1BQW5DO0FBQ0EsRTs7Ozs7Ozs7OztNQVFNLFEscUJBQVMsRyxFQUFLO0FBQ3BCLE1BQUksY0FBYyxHQUFkLHlDQUFjLEdBQWQsQ0FBSjtBQUNBLFNBQU8sU0FBUyxRQUFULElBQXFCLFFBQVEsSUFBN0IsSUFBcUMsU0FBUyxVQUFyRDtBQUNBLEU7Ozs7Ozs7OztNQU9NLFMsc0JBQVUsRyxFQUFLO0FBQ3JCLFNBQU8sT0FBTyxRQUFPLEdBQVAseUNBQU8sR0FBUCxPQUFlLFFBQXRCLElBQWtDLE9BQU8sSUFBSSxJQUFYLEtBQW9CLFVBQTdEO0FBQ0EsRTs7Ozs7Ozs7O01BT00sUSxxQkFBUyxHLEVBQUs7QUFDcEIsU0FBTyxPQUFPLEdBQVAsS0FBZSxRQUF0QjtBQUNBLEU7Ozs7Ozs7Ozs7Ozs7Ozs7TUFjTSx5QixzQ0FBMEIsVyxFQUFhLFksRUFBYyxXLEVBQWE7QUFDeEUsTUFBSSxhQUFhLGVBQWUsU0FBaEM7QUFDQSxNQUFJLFlBQVksY0FBWixDQUEyQixVQUEzQixDQUFKLEVBQTRDO0FBQzNDLFVBQU8sS0FBUDtBQUNBOztBQUVELE1BQUksU0FBUyxLQUFLLDJCQUFMLENBQWlDLFdBQWpDLEVBQThDLFlBQTlDLENBQWI7QUFDQSxNQUFJLFdBQUosRUFBaUI7QUFDaEIsWUFBUyxZQUFZLE1BQVosQ0FBVDtBQUNBO0FBQ0QsY0FBWSxVQUFaLElBQTBCLE1BQTFCO0FBQ0EsU0FBTyxJQUFQO0FBQ0EsRTs7Ozs7Ozs7TUFNTSxZLDJCQUFlLENBQUUsQzs7Ozs7Ozs7Ozs7O0FBUXpCLEtBQUssWUFBTCxHQUFvQixXQUFZLEtBQUssTUFBTCxLQUFnQixHQUFqQixLQUEwQixDQUFyQyxDQUFwQjs7Ozs7OztBQU9BLEtBQUssZ0JBQUwsR0FBd0IsQ0FBeEI7O2tCQUVlLEk7OztBQzdPZjs7Ozs7Ozs7Ozs7Ozs7OztJQVNNLFU7QUFDTCx1QkFBYztBQUFBOzs7Ozs7O0FBTWIsT0FBSyxTQUFMLEdBQWlCLEtBQWpCO0FBQ0E7Ozs7Ozs7c0JBS0QsTyxzQkFBVTtBQUNULE1BQUksQ0FBQyxLQUFLLFNBQVYsRUFBcUI7QUFDcEIsUUFBSyxlQUFMO0FBQ0EsUUFBSyxTQUFMLEdBQWlCLElBQWpCO0FBQ0E7QUFDRCxFOzs7Ozs7Ozs7c0JBT0QsZSw4QkFBa0IsQ0FBRSxDOzs7Ozs7OztzQkFNcEIsVSx5QkFBYTtBQUNaLFNBQU8sS0FBSyxTQUFaO0FBQ0EsRTs7Ozs7a0JBR2EsVTs7O0FDN0NmOzs7Ozs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7O1FBR1MsSTtRQUFNLEs7UUFBTyxLO1FBQU8sVTtRQUFZLE07UUFBUSxNOzs7QUNWakQ7Ozs7Ozs7O0lBRU0sTTs7Ozs7Ozs7Ozs7O1FBT0UsSyxrQkFBTSxNLEVBQVE7QUFDcEIsTUFBSSxHQUFKLEVBQVMsTUFBVDtBQUNBLE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxVQUFVLE1BQTlCLEVBQXNDLEdBQXRDLEVBQTJDO0FBQzFDLFlBQVMsVUFBVSxDQUFWLENBQVQ7QUFDQSxRQUFLLEdBQUwsSUFBWSxNQUFaLEVBQW9CO0FBQ25CLFdBQU8sR0FBUCxJQUFjLE9BQU8sR0FBUCxDQUFkO0FBQ0E7QUFDRDtBQUNELFNBQU8sTUFBUDtBQUNBLEU7Ozs7Ozs7Ozs7O1FBU00sZSw0QkFBZ0IsSSxFQUFNLE8sRUFBUztBQUNyQyxNQUFJLFFBQVEsV0FBVyxNQUF2QjtBQUNBLE1BQUksUUFBUSxLQUFLLEtBQUwsQ0FBVyxHQUFYLENBQVo7QUFDQSxTQUFPLE1BQU0sTUFBTixDQUFhLFVBQUMsSUFBRCxFQUFPLEdBQVA7QUFBQSxVQUFlLEtBQUssR0FBTCxDQUFmO0FBQUEsR0FBYixFQUF1QyxLQUF2QyxDQUFQO0FBQ0EsRTs7Ozs7Ozs7Ozs7UUFTTSxHLGdCQUFJLEcsRUFBSyxFLEVBQUk7QUFDbkIsTUFBSSxZQUFZLEVBQWhCO0FBQ0EsTUFBSSxPQUFPLE9BQU8sSUFBUCxDQUFZLEdBQVosQ0FBWDtBQUNBLE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE1BQXpCLEVBQWlDLEdBQWpDLEVBQXNDO0FBQ3JDLGFBQVUsS0FBSyxDQUFMLENBQVYsSUFBcUIsR0FBRyxLQUFLLENBQUwsQ0FBSCxFQUFZLElBQUksS0FBSyxDQUFMLENBQUosQ0FBWixDQUFyQjtBQUNBO0FBQ0QsU0FBTyxTQUFQO0FBQ0EsRTs7Ozs7a0JBR2EsTTs7O0FDbERmOzs7Ozs7OztJQUVNLE07Ozs7Ozs7Ozs7Ozs7UUFRRSxzQixtQ0FBdUIsRyxFQUFLO0FBQ2xDLFNBQU8sSUFBSSxPQUFKLENBQVksYUFBWixFQUEyQixHQUEzQixFQUFnQyxPQUFoQyxDQUF3QywwQkFBeEMsRUFBb0UsRUFBcEUsQ0FBUDtBQUNBLEU7Ozs7Ozs7O1FBTU0sZSw4QkFBa0I7QUFDeEIsTUFBSSxJQUFJLFVBQVI7QUFDQSxTQUFPLEtBQUssS0FBTCxDQUFXLEtBQUssTUFBTCxLQUFnQixDQUEzQixFQUE4QixRQUE5QixDQUF1QyxFQUF2QyxJQUNOLEtBQUssR0FBTCxDQUFTLEtBQUssS0FBTCxDQUFXLEtBQUssTUFBTCxLQUFnQixDQUEzQixJQUFnQyxLQUFLLEdBQUwsRUFBekMsRUFBcUQsUUFBckQsQ0FBOEQsRUFBOUQsQ0FERDtBQUVBLEU7Ozs7Ozs7Ozs7Ozs7UUFXTSxRLHFCQUFTLEcsRUFBSztBQUNwQixNQUFJLE9BQU8sQ0FBWDtBQUNBLE9BQUssSUFBSSxJQUFJLENBQVIsRUFBVyxNQUFNLElBQUksTUFBMUIsRUFBa0MsSUFBSSxHQUF0QyxFQUEyQyxHQUEzQyxFQUFnRDtBQUMvQyxVQUFPLEtBQUssSUFBTCxHQUFZLElBQUksVUFBSixDQUFlLENBQWYsQ0FBbkI7QUFDQSxXQUFRLFdBQVI7QUFDQTtBQUNELFNBQU8sSUFBUDtBQUNBLEU7Ozs7Ozs7Ozs7Ozs7UUFXTSxlLDRCQUFnQixHLEVBQUssSyxFQUFPLEcsRUFBSyxLLEVBQU87QUFDOUMsU0FBTyxJQUFJLFNBQUosQ0FBYyxDQUFkLEVBQWlCLEtBQWpCLElBQTBCLEtBQTFCLEdBQWtDLElBQUksU0FBSixDQUFjLEdBQWQsQ0FBekM7QUFDQSxFOzs7OztrQkFHYSxNOzs7QUN4RGY7Ozs7OztBQUVBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztJQUVNLEc7Ozs7Ozs7OztBQU9MLGdCQUFjO0FBQUE7Ozs7Ozs7O0FBQUEsK0NBQ2Isd0JBRGE7O0FBUWIsUUFBSyxZQUFMLEdBQW9CLElBQXBCOzs7Ozs7O0FBT0EsUUFBSyxVQUFMLEdBQWtCLElBQWxCOzs7Ozs7OztBQVFBLFFBQUssb0JBQUwsR0FBNEIsSUFBNUI7Ozs7Ozs7O0FBUUEsUUFBSyxRQUFMLEdBQWdCLEVBQWhCOzs7Ozs7OztBQVFBLFFBQUssb0NBQUwsR0FBNEMsSUFBNUM7Ozs7Ozs7O0FBUUEsUUFBSyxZQUFMLEdBQW9CLGtCQUFRLFFBQVIsQ0FBaUIsS0FBckM7Ozs7Ozs7O0FBUUEsUUFBSyxZQUFMLEdBQW9CLDJEQUFwQjs7Ozs7Ozs7QUFRQSxRQUFLLFlBQUwsR0FBb0IseUJBQXBCOzs7Ozs7OztBQVFBLFFBQUssZUFBTCxHQUF1QixlQUF2Qjs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsUUFBSyxnQ0FBTCxHQUF5Qyx1QkFBdUIsa0JBQVEsTUFBUixDQUFlLE9BQS9FOzs7Ozs7OztBQVFBLFFBQUssZUFBTCxHQUF1QixJQUF2Qjs7Ozs7Ozs7O0FBU0EsUUFBSyxrQkFBTCxHQUEwQixDQUExQjs7Ozs7Ozs7O0FBU0EsUUFBSyxpQkFBTCxHQUF5QixDQUF6Qjs7Ozs7OztBQU9BLFFBQUssWUFBTCxHQUFvQixJQUFwQjs7Ozs7Ozs7QUFRQSxRQUFLLE1BQUwsR0FBYyxFQUFkOzs7Ozs7OztBQVFBLFFBQUssT0FBTCxHQUFlLEVBQWY7Ozs7Ozs7Ozs7QUFVQSxRQUFLLGdCQUFMLEdBQXdCLEtBQXhCOzs7Ozs7OztBQVFBLFFBQUssUUFBTCxHQUFnQixFQUFoQjs7Ozs7Ozs7OztBQVVBLFFBQUssb0JBQUwsR0FBNEIsSUFBNUI7O0FBRUEsUUFBSyxpQkFBTCxHQUF5QiwwQkFBekI7O0FBRUEsUUFBSyxpQkFBTCxDQUF1QixHQUF2QixDQUNDLGNBQUksRUFBSixDQUFPLGtCQUFRLE1BQWYsRUFBdUIsUUFBdkIsRUFBaUMsTUFBSyxTQUFMLENBQWUsSUFBZixPQUFqQyxDQURELEVBRUMsY0FBSSxFQUFKLENBQU8sa0JBQVEsTUFBZixFQUF1QixNQUF2QixFQUErQixNQUFLLE9BQUwsQ0FBYSxJQUFiLE9BQS9CLENBRkQsRUFHQyxjQUFJLEVBQUosQ0FBTyxrQkFBUSxNQUFmLEVBQXVCLFVBQXZCLEVBQW1DLE1BQUssV0FBTCxDQUFpQixJQUFqQixPQUFuQyxDQUhEOztBQU1BLFFBQUssRUFBTCxDQUFRLGVBQVIsRUFBeUIsTUFBSyxnQkFBOUI7QUFDQSxRQUFLLEVBQUwsQ0FBUSxnQkFBUixFQUEwQixNQUFLLGlCQUEvQjtBQUNBLFFBQUssRUFBTCxDQUFRLGdCQUFSLEVBQTBCLE1BQUssd0JBQS9CLEVBQXlELElBQXpEOztBQUVBLFFBQUssZUFBTCxDQUFxQixNQUFLLFlBQTFCO0FBQ0EsUUFBSyxlQUFMLENBQXFCLE1BQUssWUFBMUI7QUFsTGE7QUFtTGI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBcUJELFMsc0JBQVUsTSxFQUFRO0FBQUE7O0FBQ2pCLE1BQUksQ0FBQyxNQUFNLE9BQU4sQ0FBYyxNQUFkLENBQUwsRUFBNEI7QUFDM0IsWUFBUyxDQUFDLE1BQUQsQ0FBVDtBQUNBO0FBQ0QsU0FBTyxPQUFQLENBQWUsVUFBQyxLQUFELEVBQVc7QUFDekIsT0FBSSxFQUFFLGdDQUFGLENBQUosRUFBK0I7QUFDOUIsWUFBUSxvQkFBVSxNQUFNLElBQWhCLEVBQXNCLE1BQU0sT0FBNUIsQ0FBUjtBQUNBO0FBQ0QsVUFBSyxNQUFMLENBQVksSUFBWixDQUFpQixLQUFqQjtBQUNBLEdBTEQ7QUFNQSxTQUFPLElBQVA7QUFDQSxFOzs7Ozs7Ozs7Ozs7ZUFVRCxXLHdCQUFZLFEsRUFBVTtBQUFBOztBQUNyQixNQUFJLENBQUMsTUFBTSxPQUFOLENBQWMsUUFBZCxDQUFMLEVBQThCO0FBQzdCLGNBQVcsQ0FBQyxRQUFELENBQVg7QUFDQTtBQUNELFdBQVMsT0FBVCxDQUFpQixVQUFDLE9BQUQsRUFBYTtBQUM3QixPQUFJLFlBQUssUUFBTCxDQUFjLE9BQWQsQ0FBSixFQUE0QjtBQUMzQixjQUFVLHNCQUFZLE9BQVosQ0FBVjtBQUNBO0FBQ0QsVUFBSyxRQUFMLENBQWMsUUFBUSxLQUFSLEVBQWQsSUFBaUMsT0FBakM7QUFDQSxHQUxEO0FBTUEsU0FBTyxJQUFQO0FBQ0EsRTs7Ozs7Ozs7O2VBT0QsVyx3QkFBWSxHLEVBQUs7QUFDaEIsTUFBSSxPQUFPLGdCQUFNLFVBQU4sQ0FBaUIsR0FBakIsQ0FBWDtBQUNBLE1BQUksTUFBTSxrQkFBUSxHQUFSLENBQVY7O0FBRUEsTUFBSSxDQUFDLEtBQUssaUJBQUwsQ0FBdUIsSUFBSSxXQUFKLEVBQXZCLENBQUwsRUFBZ0Q7QUFDL0MsV0FBUSxHQUFSLENBQVksc0JBQVo7QUFDQSxVQUFPLEtBQVA7QUFDQTtBQUNELE1BQUksQ0FBQyxLQUFLLGVBQUwsQ0FBcUIsSUFBckIsQ0FBTCxFQUFpQztBQUNoQyxXQUFRLEdBQVIsQ0FBWSx1Q0FBWjtBQUNBLFVBQU8sS0FBUDtBQUNBO0FBQ0QsTUFBSSxDQUFDLEtBQUssU0FBTCxDQUFlLElBQWYsQ0FBTCxFQUEyQjtBQUMxQixXQUFRLEdBQVIsQ0FBWSxrQkFBa0IsSUFBOUI7QUFDQSxVQUFPLEtBQVA7QUFDQTs7QUFFRCxTQUFPLElBQVA7QUFDQSxFOzs7Ozs7OztlQU1ELGlCLGdDQUFvQjtBQUFBOztBQUNuQixTQUFPLElBQVAsQ0FBWSxLQUFLLE9BQWpCLEVBQTBCLE9BQTFCLENBQWtDLFVBQUMsSUFBRCxFQUFVO0FBQzNDLE9BQUksU0FBUyxPQUFLLFVBQWxCLEVBQThCO0FBQzdCLFdBQUssWUFBTCxDQUFrQixVQUFsQjtBQUNBLElBRkQsTUFFTztBQUNOLFdBQUssWUFBTCxDQUFrQixJQUFsQjtBQUNBO0FBQ0QsR0FORDtBQU9BLEU7Ozs7Ozs7OztlQU9ELG9CLGlDQUFxQixJLEVBQU0sSyxFQUFPO0FBQ2pDLE1BQUksQ0FBQyxLQUFLLGVBQU4sSUFBeUIsU0FBUyxLQUFLLFVBQTNDLEVBQXVEO0FBQ3RELFdBQVEsR0FBUixDQUFZLDRDQUFaO0FBQ0EsVUFBTyxLQUFLLFlBQVo7QUFDQTs7QUFFRCxNQUFJLFNBQVMsS0FBSyxPQUFMLENBQWEsSUFBYixDQUFiO0FBQ0EsTUFBSSxDQUFDLE1BQUwsRUFBYTtBQUNaLE9BQUksVUFBVSxNQUFNLFVBQU4sRUFBZDtBQUNBLE9BQUksZ0NBQXNCLGlCQUFPLGVBQVAsQ0FBdUIsUUFBUSxTQUEvQixDQUExQixFQUFxRTtBQUNwRSxhQUFTLElBQUksT0FBSixFQUFUO0FBQ0EsSUFGRCxNQUVPO0FBQ04sYUFBUyxRQUFRLEtBQVIsS0FBa0Isc0JBQTNCO0FBQ0E7QUFDRCxXQUFRLEdBQVIsQ0FBWSx3QkFBd0IsSUFBeEIsR0FBK0IsS0FBL0IsR0FBdUMsTUFBdkMsR0FBZ0QsR0FBNUQ7QUFDQTtBQUNELFNBQU8sTUFBUDtBQUNBLEU7Ozs7Ozs7ZUFLRCxlLDhCQUFrQjtBQUNqQixNQUFJLEtBQUssWUFBVCxFQUF1QjtBQUN0QixRQUFLLFlBQUwsQ0FBa0IsS0FBSyxVQUF2QjtBQUNBO0FBQ0QsT0FBSyxpQkFBTDtBQUNBLE9BQUssaUJBQUwsQ0FBdUIsY0FBdkI7QUFDQSxPQUFLLGlCQUFMLENBQXVCLGNBQXZCO0FBQ0EsT0FBSyxpQkFBTCxDQUF1QixrQkFBdkI7QUFDQSwwQkFBTSxlQUFOO0FBQ0EsRTs7Ozs7Ozs7O2VBT0QsUSx1QkFBVztBQUNWLFNBQU8sS0FBSyxRQUFMLENBQWMsZ0JBQU0scUJBQU4sRUFBZCxFQUE2QyxJQUE3QyxDQUFQO0FBQ0EsRTs7Ozs7Ozs7OztlQVFELFcsd0JBQVksSSxFQUFNLGtCLEVBQW9CO0FBQUE7O0FBQ3JDLE1BQUksS0FBSyxZQUFMLElBQXFCLEtBQUssWUFBTCxDQUFrQixnQkFBbEIsRUFBekIsRUFBK0Q7QUFDOUQsUUFBSyxlQUFMLEdBQXVCLGtCQUFtQixNQUFuQixDQUEwQixJQUFJLGtCQUFtQixpQkFBdkIsQ0FBeUMsNEJBQXpDLENBQTFCLENBQXZCO0FBQ0EsVUFBTyxLQUFLLGVBQVo7QUFDQTs7QUFFRCxNQUFJLFFBQVEsS0FBSyxTQUFMLENBQWUsSUFBZixDQUFaO0FBQ0EsTUFBSSxDQUFDLEtBQUwsRUFBWTtBQUNYLFFBQUssZUFBTCxHQUF1QixrQkFBbUIsTUFBbkIsQ0FBMEIsSUFBSSxrQkFBbUIsaUJBQXZCLENBQXlDLGtCQUFrQixJQUEzRCxDQUExQixDQUF2QjtBQUNBLFVBQU8sS0FBSyxlQUFaO0FBQ0E7O0FBRUQsVUFBUSxHQUFSLENBQVksa0JBQWtCLElBQWxCLEdBQXlCLEdBQXJDOztBQUVBLE9BQUssb0JBQUw7O0FBRUEsTUFBSSxhQUFhLEtBQUssb0JBQUwsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBaEMsQ0FBakI7O0FBRUEsU0FBTyxXQUFXLElBQVgsQ0FBZ0IsSUFBaEIsRUFDTCxJQURLLENBQ0EsWUFBTTtBQUNYLE9BQUksT0FBSyxZQUFULEVBQXVCO0FBQ3RCLFdBQUssWUFBTCxDQUFrQixVQUFsQjtBQUNBO0FBQ0QsVUFBSyx1QkFBTCxDQUE2QixJQUE3QixFQUFtQyxVQUFuQyxFQUErQyxrQkFBL0M7QUFDQSxVQUFLLHdCQUFMLENBQThCLFVBQTlCLEVBQTBDLE9BQUssUUFBL0M7QUFDQSxHQVBLLEVBUUwsSUFSSyxDQVFBO0FBQUEsVUFBTSxXQUFXLGNBQVgsQ0FBMEIsT0FBSyxRQUEvQixDQUFOO0FBQUEsR0FSQSxFQVNMLElBVEssQ0FTQTtBQUFBLFVBQU0sV0FBVyxJQUFYLENBQWdCLE9BQUssUUFBckIsQ0FBTjtBQUFBLEdBVEEsRUFVTCxJQVZLLENBVUE7QUFBQSxVQUFNLFdBQVcsZUFBWCxDQUEyQixPQUFLLFFBQWhDLENBQU47QUFBQSxHQVZBLEVBV0wsSUFYSyxDQVdBO0FBQUEsVUFBTSxPQUFLLGdDQUFMLEVBQU47QUFBQSxHQVhBLEVBWUwsSUFaSyxDQVlBO0FBQUEsVUFBTSxPQUFLLGlCQUFMLENBQXVCLElBQXZCLEVBQTZCLFVBQTdCLENBQU47QUFBQSxHQVpBLEVBYUwsS0FiSyxDQWFDLFVBQUMsTUFBRCxFQUFZO0FBQ2xCLFVBQUssb0JBQUwsQ0FBMEIsSUFBMUIsRUFBZ0MsVUFBaEMsRUFBNEMsTUFBNUM7QUFDQSxTQUFNLE1BQU47QUFDQSxHQWhCSyxDQUFQO0FBaUJBLEU7Ozs7Ozs7Ozs7ZUFRRCxpQiw4QkFBa0IsSSxFQUFNLFUsRUFBWTtBQUNuQyxhQUFXLFFBQVg7O0FBRUEsTUFBSSxLQUFLLFlBQUwsSUFBcUIsQ0FBQyxLQUFLLFlBQUwsQ0FBa0IsV0FBbEIsRUFBMUIsRUFBMkQ7QUFDMUQsT0FBSSxLQUFLLFlBQUwsS0FBc0IsVUFBMUIsRUFBc0M7QUFDckMsU0FBSyxZQUFMLENBQWtCLEtBQUssVUFBdkI7QUFDQTtBQUNEOztBQUVELE9BQUssVUFBTCxHQUFrQixJQUFsQjtBQUNBLE9BQUssWUFBTCxHQUFvQixVQUFwQjtBQUNBLE9BQUssT0FBTCxDQUFhLElBQWIsSUFBcUIsVUFBckI7QUFDQSxPQUFLLGVBQUwsR0FBdUIsSUFBdkI7QUFDQSxvQkFBUSxtQkFBUixHQUE4QixJQUE5QjtBQUNBLFVBQVEsR0FBUixDQUFZLGlCQUFaO0FBQ0EsRTs7Ozs7Ozs7Ozs7ZUFTRCxTLHNCQUFVLEksRUFBTTs7QUFFZixNQUFLLEtBQUssV0FBTCxDQUFpQixHQUFqQixJQUF3QixDQUFDLENBQTFCLElBQWdDLGdCQUFNLG9CQUFOLENBQTJCLElBQTNCLENBQXBDLEVBQXNFO0FBQ3JFLFVBQU8sSUFBUDtBQUNBOztBQUVELFNBQU8sZ0JBQU0scUJBQU4sQ0FBNEIsSUFBNUIsQ0FBUDs7OztBQUlBLFNBQU8sZ0JBQU0scUJBQU4sQ0FBNEIsS0FBSyxNQUFMLENBQVksS0FBSyxRQUFMLENBQWMsTUFBMUIsQ0FBNUIsQ0FBUDs7QUFFQSxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxNQUFMLENBQVksTUFBaEMsRUFBd0MsR0FBeEMsRUFBNkM7QUFDNUMsT0FBSSxRQUFRLEtBQUssTUFBTCxDQUFZLENBQVosQ0FBWjtBQUNBLE9BQUksTUFBTSxXQUFOLENBQWtCLElBQWxCLENBQUosRUFBNkI7QUFDNUIsV0FBTyxLQUFQO0FBQ0E7QUFDRDs7QUFFRCxTQUFPLElBQVA7QUFDQSxFOzs7Ozs7OztlQU1ELHVCLHNDQUEwQjtBQUN6QixTQUFPLEtBQUssb0JBQVo7QUFDQSxFOzs7Ozs7OztlQU1ELFcsMEJBQWM7QUFDYixTQUFPLEtBQUssUUFBWjtBQUNBLEU7Ozs7Ozs7O2VBTUQsZSw4QkFBa0I7QUFDakIsU0FBTyxLQUFLLFlBQVo7QUFDQSxFOzs7Ozs7OztlQU1ELGUsOEJBQWtCO0FBQ2pCLFNBQU8sS0FBSyxZQUFaO0FBQ0EsRTs7Ozs7Ozs7ZUFNRCxlLDhCQUFrQjtBQUNqQixTQUFPLEtBQUssWUFBWjtBQUNBLEU7Ozs7Ozs7O2VBTUQsa0IsaUNBQXFCO0FBQ3BCLFNBQU8sS0FBSyxlQUFaO0FBQ0EsRTs7Ozs7Ozs7ZUFNRCx1QixzQ0FBMEI7QUFDekIsU0FBTyxLQUFLLG9CQUFaO0FBQ0EsRTs7Ozs7Ozs7Ozs7ZUFTRCxvQixpQ0FBcUIsSSxFQUFNLFUsRUFBWSxHLEVBQUs7QUFDM0MsVUFBUSxHQUFSLENBQVksMkJBQTJCLFVBQTNCLEdBQXdDLEtBQXhDLEdBQWdELEdBQWhELEdBQXNELEdBQWxFO0FBQ0EsTUFBSSxDQUFDLGdCQUFNLG9CQUFOLENBQTJCLElBQTNCLENBQUwsRUFBdUM7QUFDdEMsUUFBSyxZQUFMLENBQWtCLElBQWxCO0FBQ0E7QUFDRCxFOzs7Ozs7OztlQU1ELFMsd0JBQVk7QUFDWCxTQUFPLEtBQUssTUFBTCxDQUFZLE1BQVosR0FBcUIsQ0FBNUI7QUFDQSxFOzs7Ozs7Ozs7OztlQVNELGlCLDhCQUFrQixRLEVBQVU7QUFDM0IsU0FBTyxhQUFhLGtCQUFRLE1BQVIsQ0FBZSxRQUFmLENBQXdCLFFBQTVDO0FBQ0EsRTs7Ozs7Ozs7OztlQVFELGUsNEJBQWdCLEksRUFBTTtBQUNyQixTQUFPLEtBQUssT0FBTCxDQUFhLEtBQUssUUFBbEIsTUFBZ0MsQ0FBdkM7QUFDQSxFOzs7Ozs7Ozs7O2VBUUQsMEIseUNBQTZCO0FBQzVCLE1BQUksUUFBUSxrQkFBUSxNQUFSLENBQWUsT0FBZixDQUF1QixLQUFuQztBQUNBLE1BQUksQ0FBQyxLQUFMLEVBQVk7QUFDWDtBQUNBOzs7Ozs7Ozs7QUFTRCxNQUFJLFNBQVMsS0FBYjtBQUNBLE1BQUksMkJBQTJCLFNBQTNCLHdCQUEyQixHQUFXO0FBQ3pDLHFCQUFRLFFBQVIsQ0FBaUIsbUJBQWpCLENBQXFDLFFBQXJDLEVBQStDLHdCQUEvQyxFQUF5RSxLQUF6RTtBQUNBLE9BQUksQ0FBQyxNQUFMLEVBQWE7QUFDWixzQkFBUSxNQUFSLENBQWUsUUFBZixDQUF3QixNQUFNLFVBQTlCLEVBQTBDLE1BQU0sU0FBaEQ7QUFDQSxhQUFTLElBQVQ7QUFDQTtBQUNELEdBTkQ7QUFPQSxlQUFNLFFBQU4sQ0FBZSx3QkFBZjtBQUNBLG9CQUFRLFFBQVIsQ0FBaUIsZ0JBQWpCLENBQWtDLFFBQWxDLEVBQTRDLHdCQUE1QyxFQUFzRSxLQUF0RTtBQUNBLEU7Ozs7Ozs7O2VBTUQsbUMsa0RBQXNDO0FBQ3JDLE1BQUksS0FBSyxnQ0FBVCxFQUEyQztBQUMxQyxRQUFLLHdCQUFMLEdBQWdDLGtCQUFRLE1BQVIsQ0FBZSxPQUFmLENBQXVCLGlCQUF2RDtBQUNBLHFCQUFRLE1BQVIsQ0FBZSxPQUFmLENBQXVCLGlCQUF2QixHQUEyQyxRQUEzQztBQUNBO0FBQ0QsRTs7Ozs7Ozs7O2VBT0QsYywyQkFBZSxJLEVBQU0sSyxFQUFPO0FBQzNCLE1BQUksQ0FBQyxLQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBTCxFQUE2QjtBQUM1QjtBQUNBOztBQUVELE1BQUksS0FBSyxvQkFBTCxJQUE2QixNQUFNLGdCQUF2QyxFQUF5RDtBQUN4RCxXQUFRLEdBQVIsQ0FBWSxvQkFBWjtBQUNBO0FBQ0E7O0FBRUQsb0JBQVEsbUJBQVIsR0FBOEIsTUFBTSxtQkFBcEM7O0FBRUEsTUFBSSxpQkFBaUIsS0FBckI7QUFDQSxNQUFJO0FBQ0gsUUFBSyxRQUFMLENBQWMsZ0JBQU0sVUFBTixDQUFpQixJQUFqQixDQUFkO0FBQ0EsR0FGRCxDQUVFLE9BQU8sR0FBUCxFQUFZOztBQUViLG9CQUFpQixJQUFqQjtBQUNBOztBQUVELE1BQUksQ0FBQyxjQUFMLEVBQXFCO0FBQ3BCLFNBQU0sY0FBTjtBQUNBO0FBQ0QsRTs7Ozs7OztlQUtELG1DLGtEQUFzQztBQUNyQyxNQUFJLE9BQU8sa0JBQVEsTUFBUixDQUFlLFFBQWYsQ0FBd0IsSUFBbkM7QUFDQSxNQUFJLElBQUosRUFBVTtBQUNULE9BQUksZ0JBQWdCLGtCQUFRLFFBQVIsQ0FBaUIsY0FBakIsQ0FBZ0MsS0FBSyxTQUFMLENBQWUsQ0FBZixDQUFoQyxDQUFwQjtBQUNBLE9BQUksYUFBSixFQUFtQjtBQUNsQixzQkFBUSxNQUFSLENBQWUsUUFBZixDQUF3QixjQUFjLFVBQXRDLEVBQWtELGNBQWMsU0FBaEU7QUFDQTtBQUNEO0FBQ0QsRTs7Ozs7Ozs7ZUFNRCxtQyxrREFBc0M7QUFDckMsTUFBSSxLQUFLLGdDQUFMLElBQXlDLEtBQUssd0JBQWxELEVBQTRFO0FBQzNFLHFCQUFRLE1BQVIsQ0FBZSxPQUFmLENBQXVCLGlCQUF2QixHQUEyQyxLQUFLLHdCQUFoRDtBQUNBO0FBQ0QsRTs7Ozs7Ozs7OztlQVFELFEscUJBQVMsSSxFQUFNLGtCLEVBQW9CO0FBQ2xDLE1BQUksQ0FBQyxnQkFBTSx1QkFBTixFQUFMLEVBQXNDO0FBQ3JDLFNBQU0sSUFBSSxLQUFKLENBQVUsc0VBQVYsQ0FBTjtBQUNBOzs7O0FBSUQsTUFBSSxTQUFTLEtBQUssVUFBbEIsRUFBOEI7QUFDN0Isd0JBQXFCLElBQXJCO0FBQ0E7O0FBRUQsT0FBSyxJQUFMLENBQVUsZ0JBQVYsRUFBNEI7QUFDM0IsU0FBTSxJQURxQjtBQUUzQixtQkFBZ0IsQ0FBQyxDQUFDO0FBRlMsR0FBNUI7O0FBS0EsU0FBTyxLQUFLLGVBQVo7QUFDQSxFOzs7Ozs7Ozs7O2VBUUQsaUIsOEJBQWtCLEssRUFBTztBQUN4QixNQUFJLGtCQUFRLG1CQUFaLEVBQWlDO0FBQ2hDLFNBQU0sSUFBTixHQUFhLGtCQUFRLG1CQUFyQjtBQUNBO0FBQ0QsRTs7Ozs7Ozs7OztlQVFELHdCLHFDQUF5QixLLEVBQU87QUFDL0IsTUFBSSxLQUFLLGVBQVQsRUFBMEI7QUFDekIsT0FBSSxLQUFLLGVBQUwsQ0FBcUIsSUFBckIsS0FBOEIsTUFBTSxJQUF4QyxFQUE4QztBQUM3QyxZQUFRLEdBQVIsQ0FBWSxZQUFaO0FBQ0E7QUFDQTtBQUNEOztBQUVELE9BQUssSUFBTCxDQUFVLGVBQVYsRUFBMkI7QUFDMUIsU0FBTSxNQUFNLElBRGM7QUFFMUIsU0FBTSxNQUFNLElBRmM7QUFHMUIsbUJBQWdCLE1BQU07QUFISSxHQUEzQjtBQUtBLEU7Ozs7Ozs7Ozs7ZUFRRCxtQixnQ0FBb0IsSyxFQUFPO0FBQzFCLE1BQUksTUFBTSxNQUFOLElBQWdCLE1BQU0sT0FBdEIsSUFBaUMsTUFBTSxPQUF2QyxJQUFrRCxNQUFNLFFBQXhELElBQW9FLE1BQU0sTUFBOUUsRUFBc0Y7QUFDckYsV0FBUSxHQUFSLENBQVksaUVBQVo7QUFDQTtBQUNBO0FBQ0QsT0FBSyxjQUFMLENBQW9CLE1BQU0sY0FBTixDQUFxQixJQUF6QyxFQUErQyxLQUEvQztBQUNBLEU7Ozs7Ozs7Ozs7ZUFRRCxvQixpQ0FBcUIsSyxFQUFPO0FBQzNCLE1BQUksT0FBTyxNQUFNLGNBQWpCO0FBQ0EsTUFBSSxLQUFLLE1BQUwsS0FBZ0IsS0FBcEIsRUFBMkI7QUFDMUIsV0FBUSxHQUFSLENBQVksMEJBQVo7QUFDQTtBQUNBO0FBQ0QsUUFBTSxtQkFBTixHQUE0QixJQUE1QjtBQUNBLE9BQUssY0FBTCxDQUFvQixLQUFLLE1BQXpCLEVBQWlDLEtBQWpDO0FBQ0EsRTs7Ozs7Ozs7OztlQVFELE8sc0JBQVU7QUFBQTs7QUFDVCxPQUFLLGdCQUFMLEdBQXdCLElBQXhCO0FBQ0EsYUFBVyxZQUFNOzs7QUFHaEIsVUFBSyxnQkFBTCxHQUF3QixLQUF4QjtBQUNBLEdBSkQsRUFJRyxDQUpIOztBQU1BLE9BQUssbUNBQUw7QUFDQSxFOzs7Ozs7Ozs7Ozs7O2VBV0QsVyx3QkFBWSxLLEVBQU87QUFDbEIsTUFBSSxLQUFLLGdCQUFULEVBQTJCO0FBQzFCO0FBQ0E7O0FBRUQsTUFBSSxRQUFRLE1BQU0sS0FBbEI7O0FBRUEsTUFBSSxDQUFDLEtBQUwsRUFBWTtBQUNYLE9BQUksa0JBQVEsTUFBUixDQUFlLFFBQWYsQ0FBd0IsSUFBNUIsRUFBa0M7Ozs7O0FBS2pDLFFBQUksS0FBSyxZQUFMLElBQXFCLENBQUMsZ0JBQU0sb0JBQU4sQ0FBMkIsS0FBSyxZQUFoQyxDQUExQixFQUF5RTtBQUN4RSxVQUFLLFVBQUw7QUFDQTs7O0FBR0QsU0FBSyxtQ0FBTDtBQUNBLElBWEQsTUFXTztBQUNOLFNBQUssVUFBTDtBQUNBO0FBQ0Q7QUFDQTs7QUFFRCxNQUFJLE1BQU0sS0FBVixFQUFpQjtBQUNoQixXQUFRLEdBQVIsQ0FBWSw0QkFBNEIsTUFBTSxJQUFsQyxHQUF5QyxHQUFyRDtBQUNBLFFBQUssaUJBQUwsR0FBeUIsTUFBTSxTQUEvQjtBQUNBLFFBQUssa0JBQUwsR0FBMEIsTUFBTSxVQUFoQztBQUNBLE9BQUksQ0FBQyxLQUFLLGdDQUFWLEVBQTRDO0FBQzNDLFNBQUssMEJBQUw7QUFDQTtBQUNELFFBQUssUUFBTCxDQUFjLE1BQU0sSUFBcEIsRUFBMEIsSUFBMUI7QUFDQTtBQUNELEU7Ozs7Ozs7OztlQU9ELFMsd0JBQVk7QUFDWCxNQUFJLEtBQUssb0NBQVQsRUFBK0M7QUFDOUMsUUFBSyxxQ0FBTDtBQUNBO0FBQ0QsRTs7Ozs7Ozs7OztlQVFELGdCLDZCQUFpQixLLEVBQU87QUFBQTs7QUFDdkIsT0FBSyxtQ0FBTDtBQUNBLE9BQUssb0NBQUwsR0FBNEMsS0FBNUM7QUFDQSxnQkFBSSxVQUFKLENBQWUsa0JBQVEsUUFBUixDQUFpQixlQUFoQyxFQUFpRCxLQUFLLGVBQXREOztBQUVBLE1BQUkscUJBQXFCO0FBQ3hCLFNBQU0sTUFBTSxJQURZO0FBRXhCLFNBQU0sTUFBTTtBQUZZLEdBQXpCOztBQUtBLE9BQUssZUFBTCxHQUF1QixLQUFLLFdBQUwsQ0FBaUIsTUFBTSxJQUF2QixFQUE2QixNQUFNLGNBQW5DLEVBQ3JCLEtBRHFCLENBQ2YsVUFBQyxNQUFELEVBQVk7QUFDbEIsc0JBQW1CLEtBQW5CLEdBQTJCLE1BQTNCO0FBQ0EsU0FBTSxNQUFOO0FBQ0EsR0FKcUIsRUFLckIsVUFMcUIsQ0FLVixZQUFNO0FBQ2pCLE9BQUksQ0FBQyxPQUFLLGVBQVYsRUFBMkI7QUFDMUIsa0JBQUksYUFBSixDQUFrQixrQkFBUSxRQUFSLENBQWlCLGVBQW5DLEVBQW9ELE9BQUssZUFBekQ7QUFDQSxXQUFLLG1DQUFMO0FBQ0EsV0FBSyxvQ0FBTCxHQUE0QyxJQUE1QztBQUNBO0FBQ0QsVUFBSyxJQUFMLENBQVUsYUFBVixFQUF5QixrQkFBekI7QUFDQSxHQVpxQixDQUF2Qjs7QUFjQSxPQUFLLGVBQUwsQ0FBcUIsSUFBckIsR0FBNEIsTUFBTSxJQUFsQztBQUNBLEU7Ozs7Ozs7OztlQU9ELFEscUJBQVMsSSxFQUFNO0FBQUE7O0FBQ2QsTUFBSSxRQUFRLEtBQUssU0FBTCxDQUFlLElBQWYsQ0FBWjtBQUNBLE1BQUksQ0FBQyxLQUFMLEVBQVk7QUFDWCxVQUFPLGtCQUFtQixNQUFuQixDQUEwQixJQUFJLGtCQUFtQixpQkFBdkIsQ0FBeUMsa0JBQWtCLElBQTNELENBQTFCLENBQVA7QUFDQTs7QUFFRCxVQUFRLEdBQVIsQ0FBWSxrQkFBa0IsSUFBbEIsR0FBeUIsR0FBckM7O0FBRUEsTUFBSSxhQUFhLEtBQUssb0JBQUwsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBaEMsQ0FBakI7O0FBRUEsU0FBTyxXQUFXLElBQVgsQ0FBZ0IsSUFBaEIsRUFDTCxJQURLLENBQ0E7QUFBQSxVQUFNLE9BQUssT0FBTCxDQUFhLElBQWIsSUFBcUIsVUFBM0I7QUFBQSxHQURBLEVBRUwsS0FGSyxDQUVDLFVBQUMsTUFBRCxFQUFZO0FBQ2xCLFVBQUssb0JBQUwsQ0FBMEIsSUFBMUIsRUFBZ0MsVUFBaEMsRUFBNEMsTUFBNUM7QUFDQSxTQUFNLE1BQU47QUFDQSxHQUxLLENBQVA7QUFNQSxFOzs7Ozs7Ozs7O2VBUUQsdUIsb0NBQXdCLEksRUFBTSxVLEVBQVksa0IsRUFBb0I7QUFDN0QsTUFBSSxRQUFRLFdBQVcsUUFBWCxFQUFaO0FBQ0EsTUFBSSxDQUFDLFlBQUssUUFBTCxDQUFjLEtBQWQsQ0FBTCxFQUEyQjtBQUMxQixXQUFRLEtBQUssZUFBTCxFQUFSO0FBQ0E7QUFDRCxNQUFJLGVBQWUsV0FBVyx1QkFBWCxDQUFtQyxJQUFuQyxDQUFuQjtBQUNBLE1BQUksZUFBZTtBQUNsQixTQUFNLFlBQUssZUFBTCxDQUFxQixrQkFBUSxtQkFBN0IsQ0FEWTtBQUVsQixpQkFBYyxZQUZJO0FBR2xCLFNBQU0sSUFIWTtBQUlsQixVQUFPLElBSlc7QUFLbEIsY0FBVyxDQUxPO0FBTWxCLGVBQVk7QUFOTSxHQUFuQjtBQVFBLE1BQUksa0JBQUosRUFBd0I7QUFDdkIsZ0JBQWEsU0FBYixHQUF5QixLQUFLLGlCQUE5QjtBQUNBLGdCQUFhLFVBQWIsR0FBMEIsS0FBSyxrQkFBL0I7QUFDQTtBQUNELE9BQUssY0FBTCxDQUFvQixLQUFwQixFQUEyQixZQUEzQixFQUF5QyxXQUFXLHdCQUFYLENBQW9DLFlBQXBDLENBQXpDLEVBQTRGLGtCQUE1RjtBQUNBLE9BQUssWUFBTCxHQUFvQixZQUFwQjtBQUNBLEU7Ozs7Ozs7OztlQU9ELHdCLHFDQUF5QixVLEVBQVksUSxFQUFVO0FBQzlDLFNBQU8sSUFBUCxDQUFZLFFBQVosRUFBc0IsT0FBdEIsQ0FBOEIsVUFBQyxFQUFELEVBQVE7QUFDckMsT0FBSSxpQkFBaUIsV0FBVyxpQkFBWCxDQUE2QixFQUE3QixDQUFyQjtBQUNBLFlBQVMsRUFBVCxFQUFhLFVBQWIsQ0FBd0IsV0FBVyxLQUFYLEVBQXhCLEVBQTRDLGNBQTVDO0FBQ0EsV0FBUSxHQUFSLENBQVksYUFBYSxXQUFXLEtBQVgsRUFBYixHQUFrQywyQkFBbEMsR0FDWCxHQURXLEdBQ0wsU0FBUyxFQUFULENBREssR0FDVSxLQURWLElBQ21CLFlBQUssZUFBTCxDQUFxQixjQUFyQixJQUF1QyxLQUF2QyxHQUErQyxPQURsRSxJQUM2RSxHQUR6RjtBQUVBLEdBTEQ7QUFNQSxFOzs7Ozs7O2VBS0QsVSx5QkFBYTtBQUNaLG9CQUFRLE1BQVIsQ0FBZSxRQUFmLENBQXdCLE1BQXhCO0FBQ0EsRTs7Ozs7Ozs7O2VBT0QsVyx3QkFBWSxLLEVBQU87QUFDbEIsU0FBTyxhQUFNLE1BQU4sQ0FBYSxLQUFLLE1BQWxCLEVBQTBCLEtBQTFCLENBQVA7QUFDQSxFOzs7Ozs7OztlQU1ELFkseUJBQWEsSSxFQUFNO0FBQUE7O0FBQ2xCLE1BQUksU0FBUyxLQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWI7QUFDQSxNQUFJLE1BQUosRUFBWTtBQUNYLFVBQU8sSUFBUCxDQUFZLEtBQUssUUFBakIsRUFBMkIsT0FBM0IsQ0FBbUMsVUFBQyxTQUFEO0FBQUEsV0FBZSxPQUFLLFFBQUwsQ0FBYyxTQUFkLEVBQXlCLE1BQXpCLENBQWdDLE9BQU8sS0FBUCxFQUFoQyxDQUFmO0FBQUEsSUFBbkM7QUFDQSxVQUFPLE9BQVA7QUFDQSxVQUFPLEtBQUssT0FBTCxDQUFhLElBQWIsQ0FBUDtBQUNBO0FBQ0QsRTs7Ozs7OztlQUtELHFDLG9EQUF3QztBQUN2QyxNQUFJLFFBQVEsa0JBQVEsTUFBUixDQUFlLE9BQWYsQ0FBdUIsS0FBbkM7QUFDQSxNQUFJLFNBQVMsTUFBTSxLQUFuQixFQUEwQjtBQUN6QixTQUFNLFNBQU4sR0FBa0Isa0JBQVEsTUFBUixDQUFlLFdBQWpDO0FBQ0EsU0FBTSxVQUFOLEdBQW1CLGtCQUFRLE1BQVIsQ0FBZSxXQUFsQztBQUNBLHFCQUFRLE1BQVIsQ0FBZSxPQUFmLENBQXVCLFlBQXZCLENBQW9DLEtBQXBDLEVBQTJDLElBQTNDLEVBQWlELElBQWpEO0FBQ0E7QUFDRCxFOzs7Ozs7OztlQU1ELHVCLG9DQUF3QixvQixFQUFzQjtBQUM3QyxPQUFLLG9CQUFMLEdBQTRCLG9CQUE1QjtBQUNBLEU7Ozs7Ozs7O2VBTUQsVyx3QkFBWSxRLEVBQVU7QUFDckIsT0FBSyxRQUFMLEdBQWdCLFFBQWhCO0FBQ0EsRTs7Ozs7Ozs7ZUFNRCxlLDRCQUFnQixZLEVBQWM7QUFDN0IsT0FBSyxZQUFMLEdBQW9CLFlBQXBCO0FBQ0EsRTs7Ozs7Ozs7ZUFNRCxlLDRCQUFnQixZLEVBQWM7QUFDN0IsT0FBSyxZQUFMLEdBQW9CLFlBQXBCO0FBQ0EsTUFBSSxLQUFLLGlCQUFULEVBQTRCO0FBQzNCLFFBQUssaUJBQUwsQ0FBdUIsY0FBdkI7QUFDQTtBQUNELE9BQUssaUJBQUwsR0FBeUIsY0FBSSxRQUFKLENBQWEsUUFBYixFQUF1QixRQUF2QixFQUFpQyxLQUFLLFlBQXRDLEVBQW9ELEtBQUssb0JBQUwsQ0FBMEIsSUFBMUIsQ0FBK0IsSUFBL0IsQ0FBcEQsQ0FBekI7QUFDQSxFOzs7Ozs7OztlQU1ELGUsNEJBQWdCLFksRUFBYztBQUM3QixPQUFLLFlBQUwsR0FBb0IsWUFBcEI7QUFDQSxNQUFJLEtBQUssaUJBQVQsRUFBNEI7QUFDM0IsUUFBSyxpQkFBTCxDQUF1QixjQUF2QjtBQUNBO0FBQ0QsT0FBSyxpQkFBTCxHQUF5QixjQUFJLFFBQUosQ0FBYSxRQUFiLEVBQXVCLE9BQXZCLEVBQWdDLEtBQUssWUFBckMsRUFBbUQsS0FBSyxtQkFBTCxDQUF5QixJQUF6QixDQUE4QixJQUE5QixDQUFuRCxDQUF6QjtBQUNBLEU7Ozs7Ozs7O2VBTUQsa0IsK0JBQW1CLGUsRUFBaUI7QUFDbkMsT0FBSyxlQUFMLEdBQXVCLGVBQXZCO0FBQ0EsRTs7Ozs7Ozs7ZUFNRCx1QixvQ0FBd0Isb0IsRUFBc0I7QUFDN0MsT0FBSyxvQkFBTCxHQUE0QixvQkFBNUI7QUFDQSxFOzs7Ozs7OztlQU1ELG9CLG1DQUF1QjtBQUN0QixNQUFJLEtBQUssZUFBVCxFQUEwQjtBQUN6QixRQUFLLGVBQUwsQ0FBcUIsTUFBckIsQ0FBNEIsMkJBQTVCO0FBQ0EsUUFBSyxlQUFMLEdBQXVCLElBQXZCO0FBQ0E7QUFDRCxFOzs7Ozs7Ozs7OztlQVNELGdDLCtDQUFtQztBQUFBOztBQUNsQyxNQUFJLFFBQVEsa0JBQVEsTUFBUixDQUFlLE9BQWYsQ0FBdUIsS0FBbkM7QUFDQSxNQUFJLENBQUMsS0FBTCxFQUFZO0FBQ1g7QUFDQTs7QUFFRCxNQUFJLFlBQVksTUFBTSxTQUF0QjtBQUNBLE1BQUksYUFBYSxNQUFNLFVBQXZCOztBQUVBLE1BQUksT0FBTyxTQUFQLElBQU8sR0FBTTtBQUNoQixPQUFJLFFBQUssb0JBQVQsRUFBK0I7QUFDOUIsc0JBQVEsTUFBUixDQUFlLFFBQWYsQ0FBd0IsVUFBeEIsRUFBb0MsU0FBcEM7QUFDQTtBQUNELEdBSkQ7O0FBTUEsU0FBTyxzQkFBdUIsVUFBQyxPQUFEO0FBQUEsVUFBYSxTQUFTLGFBQU0sUUFBTixDQUFlO0FBQUEsV0FBTSxTQUFTLFNBQWY7QUFBQSxJQUFmLENBQXRCO0FBQUEsR0FBdkIsQ0FBUDtBQUNBLEU7Ozs7Ozs7Ozs7OztlQVVELGMsMkJBQWUsSyxFQUFPLEksRUFBTSxLLEVBQU8sa0IsRUFBb0I7QUFDdEQsTUFBSSxrQkFBSixFQUF3QjtBQUN2QixxQkFBUSxNQUFSLENBQWUsT0FBZixDQUF1QixZQUF2QixDQUFvQyxLQUFwQyxFQUEyQyxLQUEzQyxFQUFrRCxJQUFsRDtBQUNBLEdBRkQsTUFFTztBQUNOLHFCQUFRLE1BQVIsQ0FBZSxPQUFmLENBQXVCLFNBQXZCLENBQWlDLEtBQWpDLEVBQXdDLEtBQXhDLEVBQStDLElBQS9DO0FBQ0E7QUFDRCxvQkFBUSxRQUFSLENBQWlCLEtBQWpCLEdBQXlCLEtBQXpCO0FBQ0EsRTs7Ozs7a0JBSWEsRzs7O0FDeGhDZjs7Ozs7O0FBRUE7Ozs7Ozs7O0lBRU0sUzs7Ozs7Ozs7QUFNTCxzQkFBYztBQUFBOzs7Ozs7Ozs7QUFBQSwrQ0FDYixzQkFEYTs7QUFTYixRQUFLLEtBQUwsR0FBYSxJQUFiOzs7Ozs7OztBQVFBLFFBQUssU0FBTCxHQUFpQixLQUFqQjtBQWpCYTtBQWtCYjs7Ozs7Ozs7O3FCQU9ELFEscUJBQVMsTyxFQUFTO0FBQ2pCLE1BQUksS0FBSyxTQUFULEVBQW9CO0FBQ25CLFFBQUssS0FBTCxHQUFhLE9BQWI7QUFDQTtBQUNELFNBQU8sSUFBUDtBQUNBLEU7Ozs7Ozs7O3FCQU1ELFUseUJBQWE7QUFDWixPQUFLLEtBQUwsR0FBYSxJQUFiO0FBQ0EsU0FBTyxJQUFQO0FBQ0EsRTs7Ozs7Ozs7cUJBTUQsZSw4QkFBa0I7QUFDakIsT0FBSyxVQUFMO0FBQ0EsRTs7Ozs7Ozs7O3FCQU9ELFEsdUJBQVc7QUFDVixTQUFPLEtBQUssS0FBWjtBQUNBLEU7Ozs7Ozs7O3FCQU1ELFcsMEJBQWM7QUFDYixTQUFPLEtBQUssU0FBWjtBQUNBLEU7Ozs7Ozs7O3FCQU1ELFkseUJBQWEsUyxFQUFXO0FBQ3ZCLE1BQUksQ0FBQyxTQUFMLEVBQWdCO0FBQ2YsUUFBSyxVQUFMO0FBQ0E7QUFDRCxPQUFLLFNBQUwsR0FBaUIsU0FBakI7QUFDQSxFOzs7OztrQkFJYSxTOzs7QUN6RmY7Ozs7Ozs7Ozs7Ozs7SUFNTSxNOzs7Ozs7Ozs7OztBQVFOLE9BQU8sY0FBUCxHQUF3QixxQkFBeEI7Ozs7Ozs7QUFPQSxPQUFPLGFBQVAsR0FBdUIsZUFBdkI7Ozs7Ozs7QUFPQSxPQUFPLGVBQVAsR0FBeUIsaUJBQXpCOztrQkFFZSxNOzs7Ozs7OztBQzlCZixJQUFJLFVBQVU7QUFDYixXQUFVLFFBREc7QUFFYixTQUFRO0FBRkssQ0FBZDs7a0JBS2UsTzs7O0FDTGY7Ozs7OztBQUVBOzs7O0lBRU0sSzs7Ozs7Ozs7O0FBUUwsZ0JBQVksSUFBWixFQUFrQixPQUFsQixFQUEyQjtBQUFBOztBQUMxQixNQUFJLENBQUMsWUFBSyxlQUFMLENBQXFCLElBQXJCLENBQUwsRUFBaUM7QUFDaEMsU0FBTSxJQUFJLEtBQUosQ0FBVSwyQkFBVixDQUFOO0FBQ0E7QUFDRCxNQUFJLENBQUMsWUFBSyxVQUFMLENBQWdCLE9BQWhCLENBQUwsRUFBK0I7QUFDOUIsU0FBTSxJQUFJLEtBQUosQ0FBVSxrQ0FBVixDQUFOO0FBQ0E7Ozs7Ozs7O0FBUUQsT0FBSyxPQUFMLEdBQWUsT0FBZjs7Ozs7OztBQU9BLE9BQUssSUFBTCxHQUFZLElBQVo7QUFDQTs7Ozs7Ozs7aUJBTUQsVSx5QkFBYTtBQUNaLFNBQU8sS0FBSyxPQUFaO0FBQ0EsRTs7Ozs7Ozs7aUJBTUQsTyxzQkFBVTtBQUNULFNBQU8sS0FBSyxJQUFaO0FBQ0EsRTs7Ozs7Ozs7OztpQkFRRCxXLHdCQUFZLEssRUFBTztBQUNsQixNQUFJLE9BQU8sS0FBSyxJQUFoQjs7QUFFQSxNQUFJLFlBQUssUUFBTCxDQUFjLElBQWQsQ0FBSixFQUF5QjtBQUN4QixVQUFPLFVBQVUsSUFBakI7QUFDQTtBQUNELE1BQUksWUFBSyxVQUFMLENBQWdCLElBQWhCLENBQUosRUFBMkI7QUFDMUIsVUFBTyxLQUFLLEtBQUwsQ0FBUDtBQUNBO0FBQ0QsTUFBSSxnQkFBZ0IsTUFBcEIsRUFBNEI7QUFDM0IsVUFBTyxNQUFNLE1BQU4sQ0FBYSxJQUFiLElBQXFCLENBQUMsQ0FBN0I7QUFDQTs7QUFFRCxTQUFPLEtBQVA7QUFDQSxFOzs7OztrQkFJYSxLOzs7QUM1RWY7Ozs7OztBQUVBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0lBRU0sYTs7Ozs7Ozs7OztBQVFMLDBCQUFjO0FBQUE7Ozs7Ozs7QUFBQSwrQ0FDYixrQkFEYTs7QUFPYixRQUFLLFNBQUwsR0FBaUIsSUFBakI7Ozs7Ozs7Ozs7O0FBV0EsUUFBSyxXQUFMLEdBQW1CO0FBQ2xCLGFBQVUsTUFEUTtBQUVsQix1QkFBb0I7QUFGRixHQUFuQjs7Ozs7Ozs7QUFXQSxRQUFLLFVBQUwsR0FBa0IsY0FBYyxHQUFoQzs7Ozs7Ozs7QUFRQSxRQUFLLE9BQUwsR0FBZSxJQUFmOzs7Ozs7OztBQVFBLFFBQUssT0FBTCxHQUFlLEtBQWY7QUE3Q2E7QUE4Q2I7Ozs7Ozs7Ozt5QkFPRCw2QiwwQ0FBOEIsTSxFQUFRO0FBQ3JDLE1BQUksQ0FBQyxLQUFLLHlCQUFMLENBQStCLE1BQS9CLENBQUwsRUFBNkM7QUFDNUMsT0FBSSxRQUFRLElBQUksS0FBSixDQUFVLGlCQUFPLGNBQWpCLENBQVo7QUFDQSxTQUFNLGFBQU4sR0FBc0IsSUFBdEI7QUFDQSxTQUFNLEtBQU47QUFDQTtBQUNELEU7Ozs7Ozs7eUJBS0QsdUIsb0NBQXdCLEksRUFBTTtBQUM3QixNQUFJLGVBQWUsS0FBSyxjQUFMLEVBQW5CO0FBQ0EsTUFBSSxnQkFBZ0IsaUJBQWlCLElBQXJDLEVBQTJDO0FBQzFDLFVBQU8sWUFBUDtBQUNBO0FBQ0QsU0FBTyxJQUFQO0FBQ0EsRTs7Ozs7Ozt5QkFLRCx3QixxQ0FBeUIsSyxFQUFPOzs7O0FBSS9CLE1BQUksTUFBTSxLQUFOLElBQWUsTUFBTSxJQUFyQixJQUE2QixNQUFNLFlBQU4sS0FBdUIsTUFBTSxJQUE5RCxFQUFvRTtBQUNuRSxVQUFPLElBQVA7QUFDQTtBQUNELFNBQU8sS0FBUDtBQUNBLEU7Ozs7Ozs7Ozs7eUJBUUQsYywyQkFBZSxJLEVBQU07QUFDcEIsTUFBSSxhQUFHLFVBQUgsSUFBaUIsS0FBSyxVQUFMLEtBQW9CLGNBQWMsR0FBdkQsRUFBNEQ7QUFDM0QsVUFBTyxrQkFBUSxJQUFSLEVBQWMsVUFBZCxHQUEyQixRQUEzQixFQUFQO0FBQ0E7QUFDRCxTQUFPLElBQVA7QUFDQSxFOzs7Ozs7Ozt5QkFNRCxjLDZCQUFpQjtBQUNoQixTQUFPLEtBQUssV0FBWjtBQUNBLEU7Ozs7Ozs7O3lCQU1ELGEsNEJBQWdCO0FBQ2YsU0FBTyxLQUFLLFVBQVo7QUFDQSxFOzs7Ozs7Ozt5QkFNRCxjLDZCQUFpQjtBQUNoQixNQUFJLFVBQVUsS0FBSyxVQUFMLEVBQWQ7QUFDQSxNQUFJLE9BQUosRUFBYTtBQUNaLE9BQUksY0FBYyxRQUFRLFdBQTFCO0FBQ0EsT0FBSSxjQUFjLEtBQUssa0NBQUwsQ0FBd0MsT0FBeEMsQ0FBbEI7QUFDQSxPQUFJLFdBQUosRUFBaUI7QUFDaEIsa0JBQWMsV0FBZDtBQUNBO0FBQ0QsT0FBSSxhQUFHLFVBQUgsSUFBaUIsS0FBSyxVQUFMLEtBQW9CLGNBQWMsR0FBdkQsRUFBNEQ7QUFDM0Qsa0JBQWMsa0JBQVEsV0FBUixFQUFxQixZQUFyQixHQUFvQyxRQUFwQyxFQUFkO0FBQ0E7QUFDRCxVQUFPLGdCQUFNLFVBQU4sQ0FBaUIsV0FBakIsQ0FBUDtBQUNBO0FBQ0QsU0FBTyxJQUFQO0FBQ0EsRTs7Ozs7Ozs7eUJBTUQsVSx5QkFBYTtBQUNaLFNBQU8sS0FBSyxPQUFaO0FBQ0EsRTs7Ozs7Ozs7eUJBTUQsVSx5QkFBYTtBQUNaLFNBQU8sS0FBSyxPQUFaO0FBQ0EsRTs7Ozs7Ozs7O3lCQU9ELHlCLHNDQUEwQixVLEVBQVk7QUFDckMsU0FBTyxjQUFjLEdBQWQsSUFBcUIsY0FBYyxHQUExQztBQUNBLEU7Ozs7Ozs7eUJBS0QsSSxpQkFBSyxJLEVBQU07QUFBQTs7QUFDVixNQUFJLFFBQVEsS0FBSyxRQUFMLEVBQVo7QUFDQSxNQUFJLFlBQUssZUFBTCxDQUFxQixLQUFyQixDQUFKLEVBQWlDO0FBQ2hDLFVBQU8sa0JBQW1CLE9BQW5CLENBQTJCLEtBQTNCLENBQVA7QUFDQTs7QUFFRCxNQUFJLE9BQU8sSUFBWDtBQUNBLE1BQUksYUFBYSxLQUFLLFVBQXRCOztBQUVBLE1BQUksVUFBVSx3QkFBZDtBQUNBLFNBQU8sSUFBUCxDQUFZLEtBQUssV0FBakIsRUFBOEIsT0FBOUIsQ0FBc0M7QUFBQSxVQUFVLFFBQVEsR0FBUixDQUFZLE1BQVosRUFBb0IsT0FBSyxXQUFMLENBQWlCLE1BQWpCLENBQXBCLENBQVY7QUFBQSxHQUF0Qzs7QUFFQSxNQUFJLGtCQUFRLG1CQUFaLEVBQWlDO0FBQ2hDLFVBQU8sSUFBSSxRQUFKLENBQWEsa0JBQVEsbUJBQXJCLENBQVA7QUFDQSxnQkFBYSxjQUFjLElBQTNCO0FBQ0EsT0FBSSxhQUFHLFVBQVAsRUFBbUI7QUFDbEIsWUFBUSxHQUFSLENBQVksZUFBWixFQUE2QixLQUE3QjtBQUNBO0FBQ0Q7O0FBRUQsTUFBSSxjQUFjLEtBQUssY0FBTCxDQUFvQixJQUFwQixDQUFsQjtBQUNBLFNBQU8sZUFDTCxPQURLLENBQ0csV0FESCxFQUNnQixVQURoQixFQUM0QixJQUQ1QixFQUNrQyxPQURsQyxFQUMyQyxJQUQzQyxFQUNpRCxLQUFLLE9BRHRELEVBRUwsSUFGSyxDQUVBLGVBQU87QUFDWixVQUFLLFVBQUwsQ0FBZ0IsR0FBaEI7QUFDQSxVQUFLLDZCQUFMLENBQW1DLElBQUksTUFBdkM7QUFDQSxPQUFJLGVBQWUsY0FBYyxHQUE3QixJQUFvQyxPQUFLLFdBQUwsRUFBeEMsRUFBNEQ7QUFDM0QsV0FBSyxRQUFMLENBQWMsSUFBSSxZQUFsQjtBQUNBO0FBQ0QsT0FBSSxXQUFKLEdBQWtCLFdBQWxCO0FBQ0EsVUFBTyxJQUFJLFlBQVg7QUFDQSxHQVZLLEVBV0wsS0FYSyxDQVdDLFVBQUMsTUFBRCxFQUFZO0FBQ2xCLFdBQVEsT0FBTyxPQUFmO0FBQ0MsU0FBSyxpQkFBTyxlQUFaO0FBQ0MsWUFBTyxPQUFQLEdBQWlCLElBQWpCO0FBQ0E7QUFDRCxTQUFLLGlCQUFPLGFBQVo7QUFDQyxZQUFPLFlBQVAsR0FBc0IsSUFBdEI7QUFDQTtBQU5GO0FBUUEsU0FBTSxNQUFOO0FBQ0EsR0FyQkssQ0FBUDtBQXNCQSxFOzs7Ozs7Ozs7Ozs7Ozs7eUJBYUQsa0MsK0NBQW1DLE8sRUFBUztBQUMzQyxNQUFJLGNBQWMsUUFBUSxXQUExQjtBQUNBLE1BQUksV0FBSixFQUFpQjtBQUNoQixVQUFPLFdBQVA7QUFDQTtBQUNELFNBQU8sUUFBUSxpQkFBUixDQUEwQixjQUFjLG9CQUF4QyxDQUFQO0FBQ0EsRTs7Ozs7Ozs7eUJBTUQsYywyQkFBZSxXLEVBQWE7QUFDM0IsT0FBSyxXQUFMLEdBQW1CLFdBQW5CO0FBQ0EsRTs7Ozs7Ozs7eUJBTUQsYSwwQkFBYyxVLEVBQVk7QUFDekIsT0FBSyxVQUFMLEdBQWtCLFdBQVcsV0FBWCxFQUFsQjtBQUNBLEU7Ozs7Ozs7O3lCQU1ELFUsdUJBQVcsTyxFQUFTO0FBQ25CLE9BQUssT0FBTCxHQUFlLE9BQWY7QUFDQSxFOzs7Ozs7Ozt5QkFNRCxVLHVCQUFXLE8sRUFBUztBQUNuQixPQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0EsRTs7Ozs7Ozs7Ozs7OztBQVVGLGNBQWMsR0FBZCxHQUFvQixLQUFwQjs7Ozs7Ozs7QUFRQSxjQUFjLElBQWQsR0FBcUIsTUFBckI7Ozs7Ozs7O0FBUUEsY0FBYyxvQkFBZCxHQUFxQyxlQUFyQzs7a0JBRWUsYTs7O0FDalRmOzs7Ozs7QUFFQTs7QUFDQTs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7SUFFTSxNOzs7Ozs7Ozs7OztBQVNMLG1CQUFjO0FBQUE7Ozs7Ozs7O0FBQUEsK0NBQ2IscUJBRGE7O0FBUWIsUUFBSyxFQUFMLEdBQVUsTUFBSyxPQUFMLENBQWEsWUFBSyxNQUFMLEVBQWIsQ0FBVjs7Ozs7Ozs7O0FBU0EsUUFBSyxLQUFMLEdBQWEsSUFBYjtBQWpCYTtBQWtCYjs7Ozs7Ozs7a0JBTUQsUSx1QkFBVztBQUNWLFVBQVEsR0FBUixDQUFZLGFBQWEsSUFBYixHQUFvQixZQUFoQztBQUNBLEU7Ozs7Ozs7Ozs7OztrQkFVRCxnQiwrQkFBbUI7QUFDbEIsVUFBUSxHQUFSLENBQVksYUFBYSxJQUFiLEdBQW9CLG9CQUFoQztBQUNBLEU7Ozs7Ozs7OztrQkFPRCx1QixvQ0FBd0IsSSxFQUFNO0FBQzdCLFNBQU8sSUFBUDtBQUNBLEU7Ozs7Ozs7OztrQkFPRCx3QixxQ0FBeUIsSyxFQUFPO0FBQy9CLFNBQU8sS0FBUDtBQUNBLEU7Ozs7Ozs7OztrQkFPRCxVLHlCQUFhO0FBQ1osVUFBUSxHQUFSLENBQVksYUFBYSxJQUFiLEdBQW9CLGNBQWhDO0FBQ0EsRTs7Ozs7Ozs7O2tCQU9ELGUsOEJBQWtCO0FBQ2pCLHVCQUFNLGVBQU47QUFDQSxVQUFRLEdBQVIsQ0FBWSxhQUFhLElBQWIsR0FBb0IsV0FBaEM7QUFDQSxFOzs7Ozs7Ozs7OztrQkFTRCxlLDRCQUFnQixRLEVBQVU7QUFDekIsU0FBTyxJQUFQLENBQVksUUFBWixFQUFzQixPQUF0QixDQUE4QixlQUFPO0FBQ3BDLE9BQUksU0FBUyxHQUFULEVBQWMsV0FBbEIsRUFBK0I7QUFDOUIsb0JBQVcsbUJBQVgsQ0FBK0IsU0FBUyxHQUFULEVBQWMsV0FBN0M7QUFDQTtBQUNELEdBSkQ7QUFLQSxTQUFPLGtCQUFtQixPQUFuQixFQUFQO0FBQ0EsRTs7Ozs7Ozs7Ozs7a0JBU0QsYyw2QkFBaUI7QUFDaEIsU0FBTyxrQkFBbUIsT0FBbkIsRUFBUDtBQUNBLEU7Ozs7Ozs7Ozs7O2tCQVNELEksaUJBQUssUSxFQUFVO0FBQUE7O0FBQ2QsVUFBUSxHQUFSLENBQVksYUFBYSxJQUFiLEdBQW9CLFFBQWhDOztBQUVBLE1BQUksY0FBYyxFQUFsQjs7QUFFQSxTQUFPLElBQVAsQ0FBWSxRQUFaLEVBQXNCLE9BQXRCLENBQThCLGVBQU87QUFDcEMsT0FBSSxVQUFVLFNBQVMsR0FBVCxDQUFkO0FBQ0EsT0FBSSxXQUFXLFFBQVEsSUFBUixDQUFhLE9BQUssRUFBbEIsQ0FBZjtBQUNBLGVBQVksSUFBWixDQUFpQixRQUFqQjtBQUNBLEdBSkQ7O0FBTUEsU0FBTyxrQkFBbUIsR0FBbkIsQ0FBdUIsV0FBdkIsQ0FBUDtBQUNBLEU7Ozs7Ozs7O2tCQU1ELEssb0JBQVE7QUFDUCxTQUFPLEtBQUssRUFBWjtBQUNBLEU7Ozs7Ozs7Ozs7Ozs7a0JBV0QsaUIsZ0NBQW9CO0FBQ25CLFVBQVEsR0FBUixDQUFZLGFBQWEsSUFBYixHQUFvQixxQkFBaEM7QUFDQSxFOzs7Ozs7OztrQkFNRCxRLHVCQUFXO0FBQ1YsU0FBTyxLQUFLLEtBQVo7QUFDQSxFOzs7Ozs7Ozs7Ozs7O2tCQVdELEksbUJBQU87QUFDTixVQUFRLEdBQVIsQ0FBWSxhQUFhLElBQWIsR0FBb0IsUUFBaEM7QUFDQSxTQUFPLGtCQUFtQixPQUFuQixFQUFQO0FBQ0EsRTs7Ozs7Ozs7OztrQkFRRCxPLG9CQUFRLEUsRUFBSTtBQUNYLFNBQU8sWUFBWSxFQUFuQjtBQUNBLEU7Ozs7Ozs7O2tCQU1ELEssa0JBQU0sRSxFQUFJO0FBQ1QsT0FBSyxFQUFMLEdBQVUsRUFBVjtBQUNBLEU7Ozs7Ozs7O2tCQU1ELFEscUJBQVMsSyxFQUFPO0FBQ2YsT0FBSyxLQUFMLEdBQWEsS0FBYjtBQUNBLEU7Ozs7Ozs7a0JBS0QsUSx1QkFBVztBQUNWLFNBQU8sS0FBSyxFQUFaO0FBQ0EsRTs7Ozs7Ozs7Ozs7O0FBU0YsT0FBTyxlQUFQLEdBQXlCLFVBQVMsTUFBVCxFQUFpQjtBQUN6QyxRQUFPLGtCQUFrQixNQUF6QjtBQUNBLENBRkQ7O2tCQUllLE07OztBQ3BPZjs7Ozs7O0FBRUE7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7SUFFTSxPOzs7Ozs7Ozs7O0FBUUwsa0JBQVksRUFBWixFQUFnQjtBQUFBOztBQUFBLCtDQUNmLHNCQURlOztBQUdmLE1BQUksQ0FBQyxFQUFMLEVBQVM7QUFDUixTQUFNLElBQUksS0FBSixDQUFVLDBFQUFWLENBQU47QUFDQTs7Ozs7Ozs7QUFRRCxRQUFLLFdBQUwsR0FBbUIsSUFBbkI7Ozs7Ozs7O0FBUUEsUUFBSyxZQUFMLEdBQW9CLElBQXBCOzs7Ozs7Ozs7QUFTQSxRQUFLLE9BQUwsR0FBZSxJQUFmOzs7Ozs7OztBQVFBLFFBQUssRUFBTCxHQUFVLEVBQVY7Ozs7Ozs7O0FBUUEsUUFBSyxZQUFMLEdBQW9CLElBQXBCOztBQUVBLFFBQUssWUFBTCxHQUFvQixNQUFLLFFBQUwsQ0FBYyxRQUFRLE9BQXRCLENBQXBCO0FBQ0EsUUFBSywwQkFBTDtBQUNBLFFBQUssV0FBTCxHQUFtQixNQUFLLFlBQXhCO0FBbERlO0FBbURmOzs7Ozs7Ozs7Ozs7OzttQkFZRCxVLHVCQUFXLFEsRUFBVSxXLEVBQWE7QUFDakMsTUFBSSxRQUFRLEtBQUssWUFBakI7O0FBRUEsTUFBSSxZQUFLLGVBQUwsQ0FBcUIsV0FBckIsQ0FBSixFQUF1QztBQUN0QyxXQUFRLEtBQUssUUFBTCxDQUFjLFFBQWQsQ0FBUjtBQUNBLE9BQUksS0FBSixFQUFXO0FBQ1Ysa0JBQUksY0FBSixDQUFtQixLQUFuQjtBQUNBLElBRkQsTUFFTztBQUNOLFlBQVEsS0FBSyxXQUFMLENBQWlCLFFBQWpCLENBQVI7QUFDQSxTQUFLLFVBQUwsQ0FBZ0IsS0FBaEIsRUFBdUIsSUFBdkI7QUFDQTtBQUNELGlCQUFJLE1BQUosQ0FBVyxLQUFYLEVBQWtCLFdBQWxCO0FBQ0E7O0FBRUQsTUFBSSxVQUFVLEtBQUssVUFBTCxFQUFkOztBQUVBLE1BQUksV0FBVyxLQUFmLEVBQXNCO0FBQ3JCLGlCQUFJLE1BQUosQ0FBVyxPQUFYLEVBQW9CLEtBQXBCO0FBQ0E7O0FBRUQsU0FBTyxLQUFQO0FBQ0EsRTs7Ozs7Ozs7O21CQU9ELFcsd0JBQVksUSxFQUFVO0FBQ3JCLE1BQUksUUFBUSxrQkFBUSxRQUFSLENBQWlCLGFBQWpCLENBQStCLEtBQS9CLENBQVo7QUFDQSxRQUFNLFlBQU4sQ0FBbUIsSUFBbkIsRUFBeUIsS0FBSyxPQUFMLENBQWEsUUFBYixDQUF6QjtBQUNBLFNBQU8sS0FBUDtBQUNBLEU7Ozs7Ozs7OzttQkFPRCxRLHFCQUFTLFEsRUFBVTtBQUNsQixTQUFPLGtCQUFRLFFBQVIsQ0FBaUIsY0FBakIsQ0FBZ0MsS0FBSyxPQUFMLENBQWEsUUFBYixDQUFoQyxDQUFQO0FBQ0EsRTs7Ozs7Ozs7OzttQkFRRCxVLHlCQUFhO0FBQ1osTUFBSSxLQUFLLE9BQVQsRUFBa0I7QUFDakIsVUFBTyxLQUFLLE9BQVo7QUFDQTtBQUNELE9BQUssT0FBTCxHQUFlLGtCQUFRLFFBQVIsQ0FBaUIsY0FBakIsQ0FBZ0MsS0FBSyxFQUFyQyxDQUFmO0FBQ0EsU0FBTyxLQUFLLE9BQVo7QUFDQSxFOzs7Ozs7OzttQkFNRCxLLG9CQUFRO0FBQ1AsU0FBTyxLQUFLLEVBQVo7QUFDQSxFOzs7Ozs7Ozs7bUJBT0QsZSw4QkFBa0I7QUFDakIsU0FBTyxLQUFLLFlBQVo7QUFDQSxFOzs7Ozs7Ozs7O21CQVFELE8sb0JBQVEsUSxFQUFVO0FBQ2pCLFNBQU8sS0FBSyxFQUFMLEdBQVUsR0FBVixHQUFnQixRQUF2QjtBQUNBLEU7Ozs7Ozs7Ozs7bUJBUUQsMEIseUNBQTZCO0FBQzVCLE1BQUksVUFBVSxLQUFLLFVBQUwsRUFBZDtBQUNBLE1BQUksV0FBVyxDQUFDLEtBQUssWUFBckIsRUFBbUM7QUFDbEMsT0FBSSxXQUFXLGtCQUFRLFFBQVIsQ0FBaUIsc0JBQWpCLEVBQWY7QUFDQSxVQUFPLFFBQVEsVUFBZixFQUEyQjtBQUMxQixhQUFTLFdBQVQsQ0FBcUIsUUFBUSxVQUE3QjtBQUNBO0FBQ0QsUUFBSyxZQUFMLEdBQW9CLEtBQUssVUFBTCxDQUFnQixRQUFRLE9BQXhCLEVBQWlDLFFBQWpDLENBQXBCO0FBQ0EsUUFBSyxVQUFMLENBQWdCLElBQWhCLEVBQXNCLEtBQUssWUFBM0I7QUFDQTtBQUNELEU7Ozs7Ozs7O21CQU1ELEssa0JBQU0sRSxFQUFJO0FBQ1QsT0FBSyxFQUFMLEdBQVUsRUFBVjtBQUNBLEU7Ozs7Ozs7OzttQkFPRCxlLDRCQUFnQixZLEVBQWM7QUFDN0IsT0FBSyxZQUFMLEdBQW9CLFlBQXBCO0FBQ0EsRTs7Ozs7Ozs7O21CQU9ELEksaUJBQUssUSxFQUFVO0FBQ2QsTUFBSSxPQUFPLEtBQUssV0FBaEI7QUFDQSxNQUFJLEtBQUssS0FBSyxRQUFMLENBQWMsUUFBZCxDQUFUO0FBQ0EsTUFBSSxDQUFDLEVBQUwsRUFBUztBQUNSLFFBQUssS0FBSyxZQUFWO0FBQ0E7QUFDRCxPQUFLLFdBQUwsR0FBbUIsRUFBbkI7QUFDQSxTQUFPLEtBQUssVUFBTCxDQUFnQixJQUFoQixFQUFzQixFQUF0QixFQUEwQixVQUExQixDQUFxQyxZQUFNO0FBQ2pELE9BQUksUUFBUSxTQUFTLEVBQXJCLEVBQXlCO0FBQ3hCLGtCQUFJLFlBQUosQ0FBaUIsSUFBakI7QUFDQTtBQUNELEdBSk0sQ0FBUDtBQUtBLEU7Ozs7Ozs7O21CQU1ELE0sbUJBQU8sUSxFQUFVO0FBQ2hCLE1BQUksUUFBUSxLQUFLLFFBQUwsQ0FBYyxRQUFkLENBQVo7QUFDQSxNQUFJLEtBQUosRUFBVztBQUNWLGlCQUFJLFlBQUosQ0FBaUIsS0FBakI7QUFDQTtBQUNELEU7Ozs7Ozs7bUJBS0QsUSx1QkFBVztBQUNWLFNBQU8sS0FBSyxFQUFaO0FBQ0EsRTs7Ozs7Ozs7Ozs7bUJBU0QsVSx1QkFBVyxJLEVBQU0sRSxFQUFJO0FBQ3BCLE1BQUksZUFBZSxLQUFLLFlBQUwsSUFBcUIsUUFBUSxpQkFBaEQ7QUFDQSxTQUFPLGtCQUFtQixPQUFuQixDQUEyQixhQUFhLElBQWIsQ0FBa0IsSUFBbEIsRUFBd0IsSUFBeEIsRUFBOEIsRUFBOUIsQ0FBM0IsQ0FBUDtBQUNBLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJGLFFBQVEsT0FBUixHQUFrQixTQUFsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkEsUUFBUSxpQkFBUixHQUE0QixVQUFTLElBQVQsRUFBZSxFQUFmLEVBQW1CO0FBQzlDLEtBQUksSUFBSixFQUFVO0FBQ1QsT0FBSyxLQUFMLENBQVcsT0FBWCxHQUFxQixNQUFyQjtBQUNBLE9BQUssU0FBTCxDQUFlLE1BQWYsQ0FBc0IsU0FBdEI7QUFDQTtBQUNELEtBQUksRUFBSixFQUFRO0FBQ1AsS0FBRyxLQUFILENBQVMsT0FBVCxHQUFtQixPQUFuQjtBQUNBLEtBQUcsU0FBSCxDQUFhLEdBQWIsQ0FBaUIsU0FBakI7QUFDQTtBQUNELENBVEQ7O2tCQVdlLE87OztBQ2hUZjs7Ozs7O0FBRUE7Ozs7QUFDQTs7Ozs7Ozs7Ozs7OztJQU1NLEs7Ozs7Ozs7Ozs7O09BT0UscUIsb0NBQXdCO0FBQzlCLFNBQU8sS0FBSyxnQ0FBTCxLQUEwQyxrQkFBUSxNQUFSLENBQWUsUUFBZixDQUF3QixJQUF6RTtBQUNBLEU7Ozs7Ozs7OztPQU9NLGdDLCtDQUFtQztBQUN6QyxTQUFPLGtCQUFRLE1BQVIsQ0FBZSxRQUFmLENBQXdCLFFBQXhCLEdBQW1DLGtCQUFRLE1BQVIsQ0FBZSxRQUFmLENBQXdCLE1BQWxFO0FBQ0EsRTs7Ozs7Ozs7O09BT00sVSx1QkFBVyxHLEVBQUs7QUFDdEIsTUFBSSxNQUFNLGtCQUFRLEdBQVIsQ0FBVjtBQUNBLFNBQU8sSUFBSSxXQUFKLEtBQW9CLElBQUksU0FBSixFQUFwQixHQUFzQyxJQUFJLE9BQUosRUFBN0M7QUFDQSxFOzs7Ozs7Ozs7T0FPTSxxQixrQ0FBc0IsRyxFQUFLO0FBQ2pDLE1BQUksTUFBTSxrQkFBUSxHQUFSLENBQVY7QUFDQSxTQUFPLElBQUksV0FBSixLQUFvQixJQUFJLFNBQUosRUFBM0I7QUFDQSxFOzs7Ozs7Ozs7O09BUU0sb0IsaUNBQXFCLEcsRUFBSztBQUNoQyxNQUFJLEdBQUosRUFBUztBQUNSLFVBQU8sTUFBTSxxQkFBTixDQUE0QixHQUE1QixNQUFxQyxLQUFLLGdDQUFMLEVBQTVDO0FBQ0E7QUFDRCxTQUFPLEtBQVA7QUFDQSxFOzs7Ozs7Ozs7T0FPTSx1QixzQ0FBMEI7QUFDaEMsU0FBTyxDQUFDLEVBQUUsa0JBQVEsTUFBUixDQUFlLE9BQWYsSUFBMEIsa0JBQVEsTUFBUixDQUFlLE9BQWYsQ0FBdUIsU0FBbkQsQ0FBUjtBQUNBLEU7Ozs7O2tCQUlhLEs7OztBQ3pFZjs7Ozs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7OztJQUVNLEk7Ozs7O01BQ0UsRyxrQkFBbUI7QUFBQSxNQUFmLFFBQWUseURBQUosRUFBSTs7QUFDekIsa0JBQU0sUUFBTixDQUFlLGtCQUFRLFdBQVIsQ0FBb0IsUUFBcEIsQ0FBZjs7QUFFQSxNQUFJLFdBQVcsZ0JBQU0sUUFBTixHQUFpQixRQUFoQztBQUNBLG1CQUFPLE1BQVAsR0FBZ0IsV0FBaEIsQ0FBNEIsUUFBNUI7QUFDQSxtQkFBTyxLQUFQLENBQWEsWUFBYix1QkFBc0MsZ0JBQU0sUUFBNUMsRUFBc0QsSUFBdEQ7QUFDQSxtQkFBTyxLQUFQLENBQWEsbUJBQWIsNkJBQW1ELGdCQUFNLFFBQXpELEVBQW1FLElBQW5FO0FBQ0EsbUJBQU8sS0FBUCxDQUFhLGtCQUFiLDBCQUErQyxnQkFBTSxRQUFyRCxFQUErRCxJQUEvRDtBQUNBLG1CQUFPLEtBQVAsQ0FBYSx5QkFBYiwwQkFBc0QsZ0JBQU0sUUFBNUQsRUFBc0UsSUFBdEU7QUFDQSxtQkFBTyxNQUFQLEdBQWdCLFFBQWhCLENBQXlCLFdBQVcsWUFBcEMsRUFBa0QsSUFBbEQ7O0FBRUEsa0JBQU0sU0FBTixDQUFnQixLQUFLLFlBQXJCO0FBQ0EsU0FBTyxJQUFQO0FBQ0EsRTs7TUFFTSxZLDJCQUFlO0FBQ3JCLG1CQUFPLGVBQVAsQ0FBdUIsUUFBdkIsQ0FBZ0MsZ0JBQU0sUUFBTixFQUFoQztBQUNBLEU7Ozs7O2tCQUdhLEk7OztBQzlCZjs7Ozs7a0JBRWU7QUFDZCxnQkFBZSxlQUREO0FBRWQsMEJBQXlCLHlCQUZYO0FBR2QseUJBQXdCLHdCQUhWO0FBSWQsa0JBQWlCLGlCQUpIO0FBS2QsY0FBYTtBQUxDLEM7OztBQ0ZmOzs7Ozs7QUFFQTs7Ozs7O2tCQUVlO0FBQ2QsYUFEYyx3QkFDRCxRQURDLEVBQ1M7QUFDdEIsU0FBTztBQUNOLFNBQU0sc0JBQVksYUFEWjtBQUVOLGFBQVU7QUFGSixHQUFQO0FBSUEsRUFOYTtBQVFkLHNCQVJjLGlDQVFRLFNBUlIsRUFRbUI7QUFDaEMsU0FBTztBQUNOLFNBQU0sc0JBQVksdUJBRFo7QUFFTixjQUFXO0FBRkwsR0FBUDtBQUlBLEVBYmE7QUFlZCxxQkFmYyxnQ0FlTyxFQWZQLEVBZVcsU0FmWCxFQWVzQjtBQUNuQyxTQUFPO0FBQ04sU0FBTSxzQkFBWSxzQkFEWjtBQUVOLE9BQUksRUFGRTtBQUdOLGNBQVc7QUFITCxHQUFQO0FBS0EsRUFyQmE7QUF1QmQsZUF2QmMsMEJBdUJDLEVBdkJELEVBdUJLO0FBQ2xCLFNBQU87QUFDTixTQUFNLHNCQUFZLGVBRFo7QUFFTixPQUFJO0FBRkUsR0FBUDtBQUlBLEVBNUJhO0FBOEJkLFlBOUJjLHVCQThCRixLQTlCRSxFQThCSztBQUNsQixTQUFPO0FBQ04sU0FBTSxzQkFBWSxXQURaO0FBRU4sVUFBTztBQUZELEdBQVA7QUFJQTtBQW5DYSxDOzs7QUNKZjs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7OztJQUVNLFM7Ozs7Ozs7OztxQkFDTCxNLHFCQUFTO0FBQUEsa0RBQzRELFlBRDVELFdBQ1EsS0FBSyxNQUFMLENBQVksUUFBWixHQUF1QixLQUFLLE1BQUwsQ0FBWSxTQUQzQztBQUFBLHFEQUVLLCtCQUZMO0FBQUE7QUFBQTtBQUlSLEU7Ozs7O2tCQUdhLFM7OztBQ1pmOzs7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0lBRU0sTTs7Ozs7Ozs7O2tCQUNMLE0scUJBQVM7QUFDUixNQUFJLE9BQU8sQ0FDVjtBQUNDLFNBQU0sV0FEUDtBQUVDLFNBQU0sS0FBSyxNQUFMLENBQVksUUFBWixHQUF1QjtBQUY5QixHQURVLEVBS1Y7QUFDQyxTQUFNLGtCQURQO0FBRUMsU0FBTSxLQUFLLE1BQUwsQ0FBWSxRQUFaLEdBQXVCO0FBRjlCLEdBTFUsQ0FBWDs7QUFEUSxvREFZVSw2QkFaVjtBQUFBLG9EQWFJLFdBYko7QUFBQSxrREFnQkMsd0RBaEJELFdBZUMsS0FBSyxNQUFMLENBQVksUUFBWixHQUF1QixrQkFmeEIsa0JBaUJTLEtBQUssc0JBQUwsQ0FBNEIsSUFBNUIsQ0FBaUMsSUFBakMsQ0FqQlQ7QUFBQTtBQUFBO0FBQUEsbURBb0JJLG9EQXBCSjtBQUFBO0FBQUE7QUFBQTtBQUFBLG9EQXNCSSxXQXRCSjtBQUFBLGlFQXdCQyxJQXhCRCxtQkF5QlUsS0FBSyxNQUFMLENBQVksVUFBWixJQUEwQixtQkFBMUIsR0FBZ0QsQ0FBaEQsR0FBb0QsQ0F6QjlEO0FBQUE7QUFBQTtBQTZCUixFOztrQkFFRCxzQixxQ0FBeUI7QUFDeEIsa0JBQU0sUUFBTixDQUFlLGtCQUFRLHFCQUFSLENBQThCLEtBQUssTUFBTCxDQUFZLFVBQTFDLENBQWY7QUFDQSxFOzs7OztrQkFHYSxNOzs7QUM1Q2Y7Ozs7OztBQUVBOzs7Ozs7Ozs7Ozs7SUFFTSxJOzs7Ozs7Ozs7Z0JBQ0wsTSxxQkFBUztBQUFBOztBQUNSLE1BQUksUUFBUSxLQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLEdBQWpCLENBQXFCLFVBQUMsR0FBRCxFQUFNLEtBQU4sRUFBZ0I7QUFDaEQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FBa0IsT0FBSyxNQUFMLENBQVksYUFBWixJQUE2QixLQUE3QixHQUFxQyxRQUFyQyxHQUFnRCxFQUFsRSxFQUNVLElBQUksSUFEZCxFQUNxQixJQUFJLElBRHpCO0FBR0EsR0FKVyxDQUFaO0FBRFEsbURBTVMsb0NBTlQ7QUFBQSw4QkFNK0MsS0FOL0M7QUFBQTtBQU9SLEU7Ozs7O2tCQUdhLEk7OztBQ2ZmOzs7Ozs7QUFFQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7SUFFTSxJOzs7Ozs7Ozs7Z0JBQ0wsTSxxQkFBUztBQUFBLHlEQUNXLDRCQUE0QixLQUFLLE1BQUwsQ0FBWSxRQUFaLElBQXdCLEVBQXBELENBRFg7QUFBQSxvREFFSSxxQ0FGSjtBQUFBLDhCQUdMLEtBQUssTUFBTCxDQUFZLFFBSFA7QUFBQTtBQUFBO0FBTVIsRTs7Ozs7a0JBR2EsSTs7O0FDZmY7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztJQUVNLFM7Ozs7Ozs7OztxQkFDTCxNLHFCQUFTO0FBQUEsb0RBQ1UsNkJBRFY7QUFBQTtBQUFBLG9EQUdLLDZCQUhMO0FBQUEsOEJBSUosS0FBSyxNQUFMLENBQVksS0FKUjtBQUFBLHFEQUtPLGlCQUxQO0FBQUEsOEJBSzBCLEtBQUssTUFBTCxDQUFZLEtBTHRDO0FBQUE7QUFBQTtBQUFBO0FBQUEsdURBUUssS0FBSyxNQUFMLENBQVksUUFSakI7QUFBQTtBQUFBO0FBQUE7QUFZUixFOzs7OztrQkFHYSxTOzs7QUNyQmY7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztJQUVNLFM7Ozs7Ozs7OztxQkFDTCxNLHFCQUFTO0FBQ1IsTUFBSSxVQUFVLEtBQUssTUFBTCxDQUFZLE9BQVosQ0FBb0IsR0FBcEIsQ0FBd0IsVUFBQyxNQUFELEVBQVMsS0FBVCxFQUFtQjtBQUN4RDtBQUFBO0FBQUE7QUFBQTtBQUFBLE9BQWtCLGdCQUFnQixVQUFVLENBQVYsR0FBYyxFQUFkLEdBQW1CLGNBQW5DLENBQWxCLEVBQ0UsTUFERjtBQUdBLEdBSmEsQ0FBZDtBQUtBLE1BQUksT0FBTyxLQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLEdBQWpCLENBQXFCLGVBQU87QUFDdEMsT0FBSSxRQUFRLElBQUksR0FBSixDQUFRLFVBQUMsSUFBRCxFQUFPLEtBQVAsRUFBaUI7QUFDcEM7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUFrQixVQUFVLENBQVYsR0FBYyxFQUFkLEdBQW1CLGFBQXJDLEVBQXFELElBQXJEO0FBQ0EsSUFGVyxDQUFaO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQUFZLEtBQVo7QUFDQSxHQUxVLENBQVg7O0FBTlEsb0RBYVUsNkJBYlY7QUFBQTtBQUFBLG9EQWVLLDZCQWZMO0FBQUEsOEJBZW9DLEtBQUssTUFBTCxDQUFZLEtBZmhEO0FBQUE7QUFBQSxzREFnQk8sbUJBaEJQO0FBQUE7QUFBQTtBQUFBLDhCQWtCQyxPQWxCRDtBQUFBO0FBQUE7QUFBQTtBQUFBLDhCQW9CRyxJQXBCSDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBd0JSLEU7Ozs7O2tCQUdhLFM7OztBQ2pDZjs7Ozs7O0FBRUE7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0lBRU0sbUI7Ozs7Ozs7OzsrQkFDTCxXLHdCQUFZLEcsRUFBSztBQUNoQixTQUFPLE1BQU0sRUFBTixHQUFZLE1BQU0sR0FBbEIsR0FBeUIsR0FBaEM7QUFDQSxFOzsrQkFFRCxNLHFCQUFTO0FBQ1IsTUFBSSxXQUFXLGdCQUFLLGVBQUwsQ0FBcUIsS0FBSyxNQUFMLENBQVksY0FBakMsQ0FBZjtBQUNBLE1BQUksV0FBVyxXQUFXLEtBQUssTUFBTCxDQUFZLFNBQVosQ0FBc0IsS0FBSyxNQUFMLENBQVksY0FBbEMsQ0FBWCxHQUErRCxFQUE5RTs7QUFGUSxvREFJVSw4R0FKVjtBQUFBO0FBQUE7QUFBQTtBQUFBLG9EQU1JLFlBTko7QUFBQSxvREFPSyxFQVBMLFdBT2Msd0JBUGQ7QUFBQTtBQUFBO0FBQUEsb0RBUUssVUFSTDtBQUFBLHFEQVNPLE1BVFAsV0FTb0IsY0FUcEIsVUFTd0MsTUFUeEMsWUFTc0QsU0FBUyxJQUFULElBQWlCLEVBVHZFO0FBQUE7QUFBQSxtREFXSSxxQkFYSjtBQUFBLHNEQVlPLHdDQVpQO0FBQUE7QUFBQTtBQUFBLG9EQWFLLFVBYkw7QUFBQSxxREFjTyxNQWRQLFdBY29CLGNBZHBCLFVBY3dDLFFBZHhDLFlBY3dELFNBQVMsTUFBVCxJQUFtQixFQWQzRTtBQUFBO0FBQUEsb0RBZ0JLLFVBaEJMO0FBQUEsdURBaUJTLGNBakJUO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0RBdUJJLFlBdkJKO0FBQUEsb0RBd0JLLEVBeEJMLFdBd0JjLHdCQXhCZDtBQUFBO0FBQUE7QUFBQSxvREF5QkssV0F6Qkw7QUFBQSx5REEwQlcsY0ExQlgsVUEwQitCLEdBMUIvQixVQTBCd0MsSUExQnhDLFVBMEJrRCxhQTFCbEQ7QUFBQSw4QkEyQkgsU0FBUyxXQUFULElBQXdCLEVBM0JyQjtBQUFBO0FBQUE7QUFBQTtBQUFBLG9EQWdDSSxZQWhDSjtBQUFBLDhCQWlDTCxLQUFLLGlCQUFMLENBQXVCLFlBQXZCLEVBQXFDLFdBQXJDLEVBQWtELFNBQVMsU0FBM0QsQ0FqQ0s7QUFBQSxtREFrQ0kscUJBbENKO0FBQUEsb0RBbUNLLFVBbkNMO0FBQUE7QUFBQSw4QkFvQ0wsS0FBSyxpQkFBTCxDQUF1QixPQUF2QixFQUFnQyxTQUFoQyxFQUEyQyxTQUFTLE9BQXBELENBcENLO0FBQUE7QUFBQTtBQXVDUixFOzsrQkFFRCxpQiw4QkFBa0IsSyxFQUFPLFMsRUFBVyxJLEVBQU07QUFDekMsTUFBSSxjQUFjLEVBQWxCO0FBQ0EsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEVBQXBCLEVBQXdCLEdBQXhCLEVBQTZCO0FBQzVCLGVBQVksSUFBWjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQUNnQixDQURoQixFQUM4QixRQUFRLEtBQUssS0FBTCxLQUFlLENBQXhCLElBQThCLFNBRDNELEVBRUcsSUFBSSxFQUFKLEdBQVMsSUFBSSxFQUFiLEdBQWtCLENBRnJCLEVBRTRCLEtBQUssRUFBTCxHQUFVLElBQVYsR0FBaUIsSUFGN0M7QUFLQTs7QUFFRCxVQUFRLEdBQVIsQ0FBWSxPQUFaLEVBQXFCLFNBQXJCLEVBQWdDLE9BQU8sS0FBSyxJQUFMLEdBQVksR0FBWixHQUFrQixLQUFLLEtBQXZCLEdBQStCLEdBQS9CLEdBQXFDLEtBQUssSUFBakQsR0FBd0QsRUFBeEY7QUFWeUM7QUFBQSxvREFZN0IsRUFaNkIsV0FZcEIsd0JBWm9CO0FBQUEsOEJBWU0sS0FaTjtBQUFBO0FBQUEsb0RBYTdCLFVBYjZCO0FBQUEscURBZWpDLE1BZmlDLFdBZ0JoQyxjQWhCZ0MsV0FpQmhDLFNBakJnQyxXQWtCL0IsT0FBTyxLQUFLLElBQUwsR0FBWSxHQUFaLEdBQWtCLEtBQUssV0FBTCxDQUFpQixLQUFLLEtBQXRCLENBQWxCLEdBQWlELEdBQWpELEdBQXVELEtBQUssV0FBTCxDQUFpQixLQUFLLElBQXRCLENBQTlELEdBQTRGLEVBbEI3RDtBQUFBO0FBQUEsb0RBcUI3QixVQXJCNkI7QUFBQSx1REFzQnpCLGNBdEJ5QixXQXNCSixZQUFZLE1BdEJSO0FBQUEsOEJBc0JpQixXQXRCakI7QUFBQTtBQUFBO0FBQUEsb0RBd0I3QixVQXhCNkI7QUFBQSx1REF5QnpCLGNBekJ5QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQThCekMsRTs7Ozs7a0JBR2EsbUI7OztBQ3BGZjs7Ozs7O0FBRUE7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0lBRU0sZ0I7Ozs7Ozs7Ozs0QkFDTCxNLHFCQUFTO0FBQ1IsTUFBSSxXQUFXLGdCQUFLLGVBQUwsQ0FBcUIsS0FBSyxNQUFMLENBQVksY0FBakMsQ0FBZjtBQUNBLE1BQUksV0FBVyxXQUFXLEtBQUssTUFBTCxDQUFZLFNBQVosQ0FBc0IsS0FBSyxNQUFMLENBQVksY0FBbEMsQ0FBWCxHQUErRCxFQUE5RTs7QUFGUSxvREFJVSw4RUFKVjtBQUFBLG9EQUtJLHVCQUxKO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0RBT0sscUJBUEw7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxvREFVTSxZQVZOO0FBQUEsb0RBV1EsVUFYUjtBQUFBLHVEQVlhLGNBWmI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0RBZ0JRLFVBaEJSO0FBQUEscURBa0JFLE1BbEJGLFdBbUJHLGNBbkJILFVBb0JFLGtCQXBCRixZQXFCSSxTQUFTLElBQVQsR0FBZ0IsU0FBUyxJQUFULENBQWMsVUFBZCxDQUF5QixLQUF6QyxHQUFpRCxDQXJCckQ7QUFBQTtBQUFBLG9EQXlCUSxFQXpCUixXQXlCaUIsd0JBekJqQjtBQUFBLG9EQXlCcUQsWUF6QnJEO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0RBMEJRLFVBMUJSO0FBQUEsdURBMkJhLGNBM0JiO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG9EQStCUSxVQS9CUjtBQUFBLHVEQWdDYSxjQWhDYjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF1Q1IsRTs7Ozs7a0JBR2EsZ0I7OztBQ2hEZjs7Ozs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7SUFFTSxtQjs7Ozs7Ozs7OytCQUNMLE0scUJBQVM7QUFDUixNQUFJLFdBQVcsZ0JBQUssZUFBTCxDQUFxQixLQUFLLE1BQUwsQ0FBWSxjQUFqQyxDQUFmO0FBQ0EsTUFBSSxXQUFXLFdBQVcsS0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixLQUFLLE1BQUwsQ0FBWSxjQUFsQyxDQUFYLEdBQStELEVBQTlFOztBQUZRLG9EQUlVLDhHQUpWO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0RBTUkscUJBTko7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpRkFvQlEsS0FBSyxNQUFMLENBQVksWUFwQnBCLHVCQXFCYSxLQUFLLE1BQUwsQ0FBWSxpQkFyQnpCLGFBc0JHLEtBQUssTUFBTCxDQUFZLE9BdEJmO0FBQUEscURBeUJELFFBekJDLFVBMkJELFdBM0JDLFlBMEJDLEtBQUssTUFBTCxDQUFZLGlCQUFaLENBQThCLElBQTlCLENBQW1DLEdBQW5DLENBMUJEO0FBQUE7QUE4QlIsRTs7Ozs7a0JBR2EsbUI7OztBQ3hDZjs7Ozs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0lBRU0sUzs7Ozs7Ozs7O3FCQUNMLFEscUJBQVMsTSxFQUFRO0FBQ2hCLE1BQUksTUFBTSxPQUFPLFFBQVAsRUFBVjtBQUNBLE1BQUksV0FBVyxFQUFmOztBQUVBLE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxJQUFJLE1BQXhCLEVBQWdDLEdBQWhDLEVBQXFDO0FBQ3BDLE9BQUksSUFBSSxDQUFKLElBQVMsSUFBSSxJQUFJLE1BQUosR0FBYSxDQUExQixJQUFnQyxJQUFJLENBQUosS0FBVSxJQUFJLE1BQUosR0FBYSxDQUEzRCxFQUErRDtBQUM5RCxnQkFBWSxHQUFaO0FBQ0E7QUFDRCxlQUFZLElBQUksQ0FBSixDQUFaO0FBQ0E7QUFDRCxTQUFPLFFBQVA7QUFDQSxFOztxQkFFRCxNLHFCQUFTO0FBQUEsb0RBQ1Usa0NBRFY7QUFBQSxvREFFSSw0QkFGSjtBQUFBLHlFQUdjLEtBQUssTUFBTCxDQUFZLFVBSDFCLGNBR2dELEtBQUssTUFBTCxDQUFZLFFBSDVEO0FBQUEsb0RBSUssS0FKTDtBQUFBLGlEQU1ELDhCQU5DLFdBT0Usd0NBUEY7QUFBQSxnRUFRVyxVQVJYO0FBQUEsb0RBU1EsVUFUUjtBQUFBLHFEQVVrRSxLQVZsRSxVQVVRLEtBQUssTUFBTCxDQUFZLGVBQVosR0FBOEIsbUJBVnRDO0FBQUE7QUFBQSxvREFZUSxVQVpSO0FBQUEsb0RBYVMsZUFiVDtBQUFBLDhCQWEwQixLQUFLLE1BQUwsQ0FBWSxTQUFaLENBQXNCLE1BYmhEO0FBQUE7QUFBQSxvREFjUyw2QkFkVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpREFtQkQsOEJBbkJDLFdBb0JFLCtEQXBCRjtBQUFBLGdFQXFCVyxVQXJCWDtBQUFBLG9EQXNCUSxVQXRCUjtBQUFBLG9EQXVCUywrQkF2QlQ7QUFBQSxxREF3QlcsV0F4Qlg7QUFBQSw4QkF3QndCLEtBQUssUUFBTCxDQUFjLEtBQUssSUFBTCxDQUFVLGdCQUFWLENBQWQsQ0F4QnhCO0FBQUE7QUFBQSxxREF5QlcsWUF6Qlg7QUFBQTtBQUFBO0FBQUE7QUFBQSxvREEyQlMsNkJBM0JUO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0RBNkJRLFVBN0JSO0FBQUEsb0RBOEJTLCtCQTlCVDtBQUFBLHFEQStCVyxXQS9CWDtBQUFBLDhCQStCd0IsS0FBSyxRQUFMLENBQWMsS0FBSyxJQUFMLENBQVUsUUFBVixDQUFkLENBL0J4QjtBQUFBO0FBQUEscURBZ0NXLFlBaENYO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0RBa0NTLDZCQWxDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpREF1Q0QsNkJBdkNDLFdBd0NFLHdDQXhDRjtBQUFBLGdFQXlDVyxVQXpDWDtBQUFBLG9EQTBDUSxVQTFDUjtBQUFBLG9EQTJDUyxlQTNDVDtBQUFBLDhCQTJDMEIsS0FBSyxJQUFMLENBQVUsWUFBVixDQTNDMUI7QUFBQTtBQUFBLGtEQTRDTyw2QkE1Q1A7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxvREFpRFEsaURBakRSO0FBQUEsdURBa0RRLEtBQUssTUFBTCxDQUFZLGVBQVosR0FBOEIsbUJBbER0QztBQUFBO0FBQUEsb0RBb0RRLFVBcERSO0FBQUEsb0RBcURTLGVBckRUO0FBQUEsOEJBcUQwQixLQUFLLElBQUwsQ0FBVSxxQkFBVixDQXJEMUI7QUFBQTtBQUFBLGtEQXNETyw2QkF0RFA7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxvREE0REssc0JBNURMO0FBQUEsb0RBNkRNLHdDQTdETjtBQUFBLGtFQStESSxJQS9ESixXQWlFRyxvQkFqRUgsZUFnRU8sS0FBSyxNQUFMLENBQVksZUFBWixHQUE4QixrQkFoRXJDO0FBQUE7QUFBQSxvREFvRU0sd0NBcEVOO0FBQUEsa0VBOEVHLG9CQTlFSCxjQXNFTSxDQUFDLE1BQUQsRUFBUyxPQUFULEVBQWtCLEtBQWxCLENBdEVOLFVBdUVHLENBQ0wsQ0FBQyxzQkFBRCxFQUF5QixLQUF6QixFQUFnQyxJQUFoQyxDQURLLEVBRUwsQ0FBQyxzQkFBRCxFQUF5QixLQUF6QixFQUFnQyxJQUFoQyxDQUZLLEVBR0wsQ0FBQyxzQkFBRCxFQUF5QixLQUF6QixFQUFnQyxJQUFoQyxDQUhLLEVBSUwsQ0FBQyxzQkFBRCxFQUF5QixLQUF6QixFQUFnQyxJQUFoQyxDQUpLLEVBS0wsQ0FBQyxzQkFBRCxFQUF5QixLQUF6QixFQUFnQyxJQUFoQyxDQUxLLENBdkVIO0FBQUE7QUFBQSxvREFpRk0sd0NBakZOO0FBQUEsa0VBbUZJLElBbkZKLFdBcUZHLDBCQXJGSCxlQW9GTyxLQUFLLE1BQUwsQ0FBWSxlQUFaLEdBQThCLDRCQXBGckM7QUFBQTtBQUFBO0FBQUEsb0RBMEZLLG9CQTFGTDtBQUFBLG9EQTJGTSx3Q0EzRk47QUFBQSxrRUE2RkksSUE3RkosV0ErRkcsa0JBL0ZILGVBOEZPLEtBQUssTUFBTCxDQUFZLGVBQVosR0FBOEIsa0JBOUZyQztBQUFBO0FBQUEsb0RBa0dNLHdDQWxHTjtBQUFBLGtFQTBHRyx1QkExR0gsY0FvR00sQ0FBQyxNQUFELEVBQVMsY0FBVCxFQUF5QixTQUF6QixFQUFvQyxLQUFwQyxDQXBHTixVQXFHRyxDQUNMLENBQUMsS0FBRCxFQUFRLEtBQVIsRUFBZSxLQUFmLEVBQXNCLElBQXRCLENBREssRUFFTCxDQUFDLE9BQUQsRUFBVSxLQUFWLEVBQWlCLEtBQWpCLEVBQXdCLElBQXhCLENBRkssRUFHTCxDQUFDLE1BQUQsRUFBUyxJQUFULEVBQWUsS0FBZixFQUFzQixJQUF0QixDQUhLLENBckdIO0FBQUE7QUFBQSxvREE2R00sd0NBN0dOO0FBQUEsa0VBcUhHLG1CQXJISCxjQStHTSxDQUFDLFNBQUQsRUFBWSxRQUFaLEVBQXNCLE9BQXRCLEVBQStCLEtBQS9CLENBL0dOLFVBZ0hHLENBQ0wsQ0FBQyxVQUFELEVBQWEsS0FBYixFQUFvQixLQUFwQixFQUEyQixJQUEzQixDQURLLEVBRUwsQ0FBQyxTQUFELEVBQVksS0FBWixFQUFtQixLQUFuQixFQUEwQixJQUExQixDQUZLLEVBR0wsQ0FBQyxVQUFELEVBQWEsS0FBYixFQUFvQixLQUFwQixFQUEyQixJQUEzQixDQUhLLENBaEhIO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUEySFIsRTs7cUJBRUQsSSxpQkFBSyxJLEVBQU07QUFDVixTQUFPLEtBQUssTUFBTCxDQUFZLFNBQVosQ0FBc0IsTUFBdEIsQ0FBNkIsVUFBQyxJQUFELEVBQU8sSUFBUDtBQUFBLFVBQWdCLE9BQU8sS0FBSyxJQUFMLENBQXZCO0FBQUEsR0FBN0IsRUFBZ0UsQ0FBaEUsQ0FBUDtBQUNBLEU7Ozs7O2tCQUdhLFM7OztBQ3hKZjs7Ozs7O0FBRUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztJQUVNLFk7Ozs7Ozs7Ozt3QkFDTCxVLHVCQUFXLE8sRUFBUyxJLEVBQU07QUFDekIsTUFBSSxPQUFPLElBQUksSUFBSixDQUFTLFVBQVUsT0FBVixHQUFvQixLQUFLLEdBQUwsRUFBN0IsQ0FBWDtBQUNBLE9BQUssUUFBTCxDQUFjLElBQWQ7QUFDQSxTQUFPO0FBQ04sU0FBTSxLQUFLLE9BQUwsRUFEQTtBQUVOLFVBQU8sS0FBSyxRQUFMLEtBQWtCLENBRm5CO0FBR04sU0FBTSxLQUFLLFdBQUwsRUFIQTtBQUlOLFVBQU8sS0FBSyxRQUFMLEVBSkQ7QUFLTixZQUFTLEtBQUssVUFBTDtBQUxILEdBQVA7QUFPQSxFOzt3QkFFRCxRLHVCQUFXO0FBQ1YsTUFBSSxPQUFPLEVBQVg7QUFDQSxNQUFJLGNBQWMsS0FBSyxPQUFMLENBQWEsZ0JBQWIsQ0FBOEIsYUFBOUIsQ0FBbEI7QUFDQSxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksWUFBWSxNQUFoQyxFQUF3QyxHQUF4QyxFQUE2QztBQUM1QyxPQUFJLE9BQU8sWUFBWSxDQUFaLEVBQWUsWUFBZixDQUE0QixNQUE1QixDQUFYO0FBQ0EsUUFBSyxJQUFMLElBQWEsWUFBWSxDQUFaLEVBQWUsSUFBZixHQUFzQixZQUFZLENBQVosRUFBZSxJQUFyQyxHQUE0QyxZQUFZLENBQVosRUFBZSxLQUF4RTtBQUNBO0FBQ0QsU0FBTyxJQUFQO0FBQ0EsRTs7d0JBRUQsTSxxQkFBUztBQUNSLE1BQUksV0FBVyxZQUFLLGVBQUwsQ0FBcUIsS0FBSyxNQUFMLENBQVksY0FBakMsQ0FBZjtBQUNBLE1BQUksZUFDSCxXQUFXLEtBQUssTUFBTCxDQUFZLFNBQVosQ0FBc0IsS0FBSyxNQUFMLENBQVksY0FBbEMsQ0FBWCxHQUErRCxJQURoRTs7QUFGUSxvREFLVSxnQ0FMVjtBQUFBLG9EQU1JLDJDQU5KO0FBQUEsb0RBT0ssNkJBUEw7QUFBQSwwRUFTTSxLQUFLLE1BQUwsQ0FBWSxRQVRsQixlQVVPLEtBQUssTUFBTCxDQUFZLFNBVm5CO0FBQUE7QUFBQSw4QkFhSCxXQUFXLE1BQVgsR0FBb0IsS0FiakI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHFEQWtCSyxpQkFsQkw7QUFBQSxxRkFvQk0sS0FBSyxNQUFMLENBQVksU0FwQmxCLG9CQXFCVyxLQUFLLE1BQUwsQ0FBWSxjQXJCdkI7QUFBQSxvREF3QkssMEZBeEJMO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0RBMEJNLHFCQTFCTjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG9EQXFDTSxZQXJDTjtBQUFBLG9EQXNDTyxFQXRDUCxXQXNDZ0Isd0JBdENoQjtBQUFBO0FBQUE7QUFBQSxvREF1Q08sVUF2Q1A7QUFBQSx1REF3Q1csY0F4Q1gsVUF3QytCLFNBeEMvQjtBQUFBLHVEQXlDWSxHQXpDWjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0RBNENPLFVBNUNQO0FBQUEsa0RBNkNNLG9CQTdDTjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxrRkFtRE0sS0FBSyxNQUFMLENBQVksU0FuRGxCLG9CQW9EVyxLQUFLLE1BQUwsQ0FBWSxjQXBEdkI7QUFBQSx3RkF3RFMsS0FBSyxNQUFMLENBQVksWUF4RHJCLHVCQXlEYyxlQUFlLGFBQWEsU0FBNUIsR0FBd0MsRUF6RHRELGFBMERJLEtBQUssTUFBTCxDQUFZLE9BMURoQjtBQUFBLG9EQTZESyxtREE3REw7QUFBQSxvREE4RE0sWUE5RE47QUFBQSxvREErRE8sV0EvRFA7QUFBQSxrREFrRUksd0JBbEVKLFdBaUVJLEtBQUssTUFBTCxDQUFZLFFBQVosR0FBdUIsS0FBSyxNQUFMLENBQVksU0FqRXZDLGtCQW1FWSxLQUFLLEtBQUwsQ0FBVyxJQUFYLENBQWdCLElBQWhCLENBbkVaO0FBQUEsOEJBb0VELFdBQVcsTUFBWCxHQUFvQixRQXBFbkI7QUFBQTtBQUFBO0FBQUEsa0RBd0VJLHdCQXhFSixXQXVFSSxLQUFLLE1BQUwsQ0FBWSxRQUFaLEdBQXVCLEtBQUssTUFBTCxDQUFZLFNBdkV2QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBZ0ZSLEU7O3dCQUVELEssb0JBQVE7QUFDUCxNQUFJLE9BQU8sS0FBSyxRQUFMLEVBQVg7QUFDQSxrQkFBTSxRQUFOLENBQWUsa0JBQVEsWUFBUixDQUFxQixjQUFPLEtBQVAsQ0FBYSxJQUFiLEVBQW1CO0FBQ3RELE9BQUksWUFBSyxRQUFMLENBQWMsS0FBSyxNQUFMLENBQVksY0FBMUIsSUFBNEMsS0FBSyxNQUFMLENBQVksY0FBeEQsR0FBeUUsU0FEdkI7QUFFdEQsV0FBUSxTQUFTLEtBQUssTUFBZCxFQUFzQixFQUF0QixLQUE2QixDQUZpQjtBQUd0RCxjQUFXLEtBQUssVUFBTCxDQUFnQixLQUFLLFNBQXJCLEVBQWdDLEtBQUssYUFBckMsQ0FIMkM7QUFJdEQsWUFBUyxLQUFLLFVBQUwsQ0FBZ0IsS0FBSyxPQUFyQixFQUE4QixLQUFLLFdBQW5DLENBSjZDO0FBS3RELFNBQU07QUFDTCxnQkFBWTtBQUNYLFlBQU8sS0FBSyxrQkFBTDtBQURJO0FBRFAsSUFMZ0Q7QUFVdEQsWUFBUyxTQUFTLEtBQUssT0FBZCxFQUF1QixFQUF2QixDQVY2QztBQVd0RCxjQUFXLEtBQUssU0FBTCxDQUFlLEtBQWYsQ0FBcUIsR0FBckIsRUFBMEIsR0FBMUIsQ0FBOEI7QUFBQSxXQUFNLFNBQVMsRUFBVCxFQUFhLEVBQWIsQ0FBTjtBQUFBLElBQTlCLEVBQXNELE1BQXRELENBQTZEO0FBQUEsV0FBTSxDQUFDLENBQUMsRUFBUjtBQUFBLElBQTdEO0FBWDJDLEdBQW5CLENBQXJCLENBQWY7QUFhQSxFOzs7OztrQkFHYSxZOzs7QUN0SWY7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0lBRU0sZTs7Ozs7Ozs7OzJCQUNMLGdCLCtCQUFtQjtBQUFBOztBQUNsQixTQUFPLEtBQUssU0FBTCxDQUNMLE1BREssQ0FDRSxvQkFBWTtBQUNuQixVQUFPLENBQUMsT0FBSyxRQUFOLElBQ04sU0FBUyxJQUFULENBQWMsV0FBZCxHQUE0QixVQUE1QixDQUF1QyxPQUFLLFFBQUwsQ0FBYyxXQUFkLEVBQXZDLENBREQ7QUFFQSxHQUpLLEVBS0wsSUFMSyxDQUtBLFVBQUMsRUFBRCxFQUFLLEVBQUwsRUFBWTtBQUNqQixPQUFJLE9BQUssTUFBTCxLQUFnQixNQUFwQixFQUE0QjtBQUMzQixRQUFJLFFBQVEsT0FBSyxPQUFMLENBQWEsR0FBRyxTQUFoQixJQUE2QixPQUFLLE9BQUwsQ0FBYSxHQUFHLFNBQWhCLENBQXpDO0FBQ0EsV0FBTyxVQUFVLENBQVYsR0FBYyxLQUFkLEdBQXNCLE9BQUssT0FBTCxDQUFhLEdBQUcsT0FBaEIsSUFBMkIsT0FBSyxPQUFMLENBQWEsR0FBRyxPQUFoQixDQUF4RDtBQUNBLElBSEQsTUFHTztBQUNOLFdBQU8sR0FBRyxJQUFILENBQVEsYUFBUixDQUFzQixHQUFHLElBQXpCLENBQVA7QUFDQTtBQUNELEdBWkssQ0FBUDtBQWFBLEU7OzJCQUVELE0scUJBQVM7QUFBQSxvREFDVSxrQ0FEVjtBQUFBLG9EQUVJLG1DQUZKO0FBQUEseUVBR2MsS0FBSyxNQUFMLENBQVksVUFIMUIsY0FHZ0QsS0FBSyxNQUFMLENBQVksUUFINUQ7QUFBQSxvREFJSyxLQUpMO0FBQUEsb0RBS00sVUFMTjtBQUFBO0FBQUEsb0RBTU0sVUFOTjtBQUFBLHNFQU9hLEtBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsSUFBbEIsQ0FQYjtBQUFBO0FBQUE7QUFBQTtBQUFBLG9EQVdNLCtCQVhOO0FBQUE7QUFBQTtBQUFBO0FBQUEsdURBYVUsY0FiVjtBQUFBLHVEQWNXLE1BZFg7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG9EQWlCTSxvQkFqQk47QUFBQTtBQUFBO0FBQUE7QUFBQSx1REFtQlUsY0FuQlYsb0JBbUJ3QyxLQUFLLEtBQUwsQ0FBVyxJQUFYLENBQWdCLElBQWhCLENBbkJ4QztBQUFBLHVEQW9CVyxNQXBCWDtBQUFBO0FBQUE7QUFBQSx1REFxQlcsTUFyQlg7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDhFQXlCTSxLQUFLLE1BQUwsQ0FBWSxRQXpCbEIsZUEwQk8sS0FBSyxnQkFBTCxFQTFCUCxnQkEyQlEsS0FBSyxNQUFMLENBQVksVUEzQnBCO0FBQUE7QUFBQTtBQUFBO0FBZ0NSLEU7OzJCQUVELE8sb0JBQVEsSyxFQUFPO0FBQ2QsT0FBSyxRQUFMLEdBQWdCLE1BQU0sTUFBTixDQUFhLEtBQTdCO0FBQ0EsRTs7MkJBRUQsSyxrQkFBTSxLLEVBQU87QUFDWixPQUFLLE1BQUwsR0FBYyxNQUFNLE1BQU4sQ0FBYSxLQUEzQjtBQUNBLEU7OzJCQUVELE8sb0JBQVEsRyxFQUFLO0FBQ1osU0FBTyxJQUFJLElBQUosQ0FBUyxJQUFJLElBQWIsRUFBbUIsSUFBSSxLQUF2QixFQUE4QixJQUFJLElBQWxDLEVBQXdDLElBQUksS0FBNUMsRUFBbUQsSUFBSSxPQUF2RCxDQUFQO0FBQ0EsRTs7Ozs7QUFHRixnQkFBZ0IsS0FBaEIsR0FBd0I7QUFDdkIsWUFBVztBQUNWLGFBQVcsTUFBTTtBQURQLEVBRFk7QUFJdkIsV0FBVTtBQUNULGFBQVcsZ0JBQUs7QUFEUCxFQUphO0FBT3ZCLFNBQVE7QUFDUCxhQUFXLGdCQUFLO0FBRFQ7QUFQZSxDQUF4Qjs7a0JBWWUsZTs7O0FDckZmOzs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7O0lBRU0sTTs7Ozs7Ozs7O2tCQUNMLE0scUJBQVM7QUFBQSxvREFDVSxxQ0FEVjtBQUFBLHFEQUdELE1BSEMsV0FJQSx1QkFKQSxpQkFLTSxRQUxOLFlBTUMsS0FBSyxNQUFMLENBQVksS0FBWixJQUFxQixFQU50QixrQkFPUSxLQUFLLE1BQUwsQ0FBWSxPQVBwQjtBQUFBLG9EQVNJLDJDQVRKO0FBQUEscURBVU0sNEJBVk47QUFBQTtBQUFBO0FBQUE7QUFhUixFOzs7OztrQkFHYSxNOzs7QUNyQmY7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7SUFFTSxhOzs7Ozs7Ozs7eUJBQ0wsSyxrQkFBTSxLLEVBQU87QUFDWixNQUFJLEtBQUssS0FBSyxTQUFMLENBQWUsS0FBZixDQUFUO0FBQ0Esa0JBQU0sUUFBTixDQUFlLGtCQUFRLG9CQUFSLENBQTZCLEVBQTdCLEVBQWlDLEtBQUssTUFBTCxDQUFZLFVBQTdDLENBQWY7QUFDQSxFOzt5QkFFRCxTLHNCQUFVLEssRUFBTztBQUNoQixTQUFPLFNBQVMsY0FBSSxNQUFKLENBQVcsTUFBTSxNQUFqQixFQUF5QixJQUF6QixFQUErQixZQUEvQixDQUE0QyxTQUE1QyxDQUFULEVBQWlFLEVBQWpFLENBQVA7QUFDQSxFOzt5QkFFRCxPLG9CQUFRLEssRUFBTztBQUNkLE1BQUksS0FBSyxLQUFLLFNBQUwsQ0FBZSxLQUFmLENBQVQ7QUFDQSxrQkFBTSxRQUFOLENBQWUsa0JBQVEsY0FBUixDQUF1QixFQUF2QixDQUFmO0FBQ0EsRTs7eUJBRUQsTSxxQkFBUztBQUFBLG9EQUNVLHdEQURWO0FBQUEsc0RBRU0saUJBRk47QUFBQTtBQUFBO0FBQUEsbURBS00sWUFMTjtBQUFBO0FBQUE7QUFBQSxtREFNTSxZQU5OO0FBQUE7QUFBQTtBQUFBLG1EQU9NLFlBUE47QUFBQTtBQUFBO0FBQUEsbURBUU0sWUFSTjtBQUFBO0FBQUE7QUFBQSxtREFTTSxZQVROO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDhCQVlFLEtBQUssV0FBTCxFQVpGO0FBQUE7QUFBQTtBQUFBO0FBZVIsRTs7eUJBRUQsVyx3QkFBWSxJLEVBQU07QUFBQTtBQUFBLDhCQUNILE9BQU8sS0FBSyxLQUFMLEdBQWEsQ0FBcEIsSUFBeUIsR0FBekIsR0FBK0IsS0FBSyxJQUFwQyxHQUEyQyxJQUEzQyxHQUFrRCxLQUFLLElBRHBEO0FBQUE7QUFFakIsRTs7eUJBRUQsVywwQkFBYztBQUFBOztBQUNiLFNBQU8sS0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixHQUF0QixDQUEwQixvQkFBWTtBQUFBLDJEQUN4QixTQUFTLEVBRGU7QUFBQTtBQUFBO0FBQUEsK0JBRWhDLFNBQVMsSUFGdUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLCtCQUt4QyxPQUFLLFdBQUwsQ0FBaUIsU0FBUyxTQUExQixDQUx3QztBQUFBO0FBQUEsK0JBS0UsT0FBSyxXQUFMLENBQWlCLFNBQVMsT0FBMUIsQ0FMRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSwrQkFTakIsU0FBUyxJQUFULENBQWMsVUFBZCxDQUF5QixLQVRSO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx1REFhbkMsT0FBSyxNQUFMLENBQVksUUFBWixHQUF1QixpQkFBdkIsR0FBMkMsU0FBUyxFQWJqQixrQkFjM0IsT0FBSyxLQUFMLENBQVcsSUFBWCxRQWQyQjtBQUFBLHNEQWU3Qiw2REFmNkI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNEQW9CbkMsaUVBcEJtQyxtQkFxQjNCLE9BQUssT0FBTCxDQUFhLElBQWIsUUFyQjJCO0FBQUE7QUFBQTtBQUFBO0FBeUI1QyxHQXpCTSxDQUFQO0FBMEJBLEU7Ozs7O0FBR0YsSUFBSSxTQUFTLENBQUMsU0FBRCxFQUFZLFVBQVosRUFBd0IsT0FBeEIsRUFBaUMsT0FBakMsRUFBMEMsS0FBMUMsRUFBaUQsTUFBakQsRUFBeUQsTUFBekQsRUFDWixRQURZLEVBQ0YsV0FERSxFQUNXLFNBRFgsRUFDc0IsVUFEdEIsRUFDa0MsVUFEbEMsQ0FBYjs7a0JBR2UsYTs7O0FDNUVmOzs7Ozs7QUFFQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7SUFFTSxZOzs7Ozs7Ozs7d0JBQ0wsTyxzQkFBVTtBQUNULE1BQUksTUFBTSxTQUFTLGNBQUksTUFBSixDQUFXLE1BQU0sTUFBakIsRUFBeUIsSUFBekIsRUFBK0IsWUFBL0IsQ0FBNEMsVUFBNUMsQ0FBVCxFQUFrRSxFQUFsRSxDQUFWO0FBQ0EsTUFBSSxZQUFZLEtBQUssaUJBQUwsQ0FBdUIsTUFBdkIsRUFBaEI7QUFDQSxZQUFVLE1BQVYsQ0FBaUIsR0FBakIsRUFBc0IsQ0FBdEI7QUFDQSxPQUFLLGlCQUFMLEdBQXlCLFNBQXpCO0FBQ0EsRTs7d0JBRUQsTSxxQkFBUztBQUFBLG9EQUNVLHVEQURWO0FBQUEsc0RBRU0saUJBRk47QUFBQTtBQUFBO0FBQUEsbURBS00sWUFMTjtBQUFBO0FBQUE7QUFBQSxtREFNTSxZQU5OO0FBQUE7QUFBQTtBQUFBLG1EQU9NLFlBUE47QUFBQTtBQUFBO0FBQUEsbURBUU0sWUFSTjtBQUFBO0FBQUE7QUFBQSxtREFTTSxZQVROO0FBQUE7QUFBQTtBQUFBLG1EQVVNLFlBVk47QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsOEJBYUUsS0FBSyxXQUFMLEVBYkY7QUFBQTtBQUFBO0FBQUE7QUFnQlIsRTs7d0JBRUQsVywwQkFBYztBQUFBOztBQUNiLFNBQU8sS0FBSyxpQkFBTCxDQUF1QixHQUF2QixDQUEyQixVQUFDLEVBQUQsRUFBSyxLQUFMLEVBQWU7QUFBQSw0REFDM0IsS0FEMkI7QUFBQTtBQUFBO0FBQUEsK0JBSTVDLE9BQUssTUFBTCxDQUFZLFlBQVosQ0FBeUIsT0FBSyxNQUFMLENBQVksT0FBWixDQUFvQixFQUFwQixFQUF3QixhQUFqRCxFQUFnRSxJQUpwQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsK0JBT3BDLE9BQUssTUFBTCxDQUFZLE9BQVosQ0FBb0IsRUFBcEIsRUFBd0IsSUFQWTtBQUFBO0FBQUE7QUFBQTtBQUFBLDJEQVVyQyxPQUFLLE1BQUwsQ0FBWSxPQUFaLENBQW9CLEVBQXBCLEVBQXdCLGNBQXhCLENBQXVDLE1BQXZDLEdBQWdELENBQWpELEdBQXNELHdCQUF0RCxHQUFpRixFQVYzQztBQUFBO0FBQUE7QUFBQTtBQUFBLDJEQWVyQyxPQUFLLE1BQUwsQ0FBWSxPQUFaLENBQW9CLEVBQXBCLEVBQXdCLGNBQXhCLENBQXVDLE1BQXZDLEdBQWdELENBQWpELEdBQXNELHdCQUF0RCxHQUFpRixFQWYzQztBQUFBO0FBQUE7QUFBQTtBQUFBLDJEQW9CckMsT0FBSyxNQUFMLENBQVksT0FBWixDQUFvQixFQUFwQixFQUF3QixjQUF4QixDQUF1QyxNQUF2QyxHQUFnRCxDQUFqRCxHQUFzRCx3QkFBdEQsR0FBaUYsRUFwQjNDO0FBQUE7QUFBQTtBQUFBO0FBQUEsc0RBeUJ2QyxpRUF6QnVDLG1CQTBCL0IsT0FBSyxPQUFMLENBQWEsSUFBYixRQTFCK0I7QUFBQTtBQUFBO0FBQUE7QUE4QmhELEdBOUJNLENBQVA7QUErQkEsRTs7Ozs7QUFHRixhQUFhLEtBQWIsR0FBcUI7QUFDcEIsb0JBQW1CO0FBQ2xCLGFBQVcsTUFBTTtBQURDO0FBREMsQ0FBckI7O2tCQU1lLFk7OztBQ3hFZjs7Ozs7O0FBRUE7O0FBQ0E7Ozs7OztBQUVBLFNBQVMsU0FBVCxDQUFtQixLQUFuQixFQUEwQixNQUExQixFQUFrQztBQUNqQyxTQUFRLE9BQU8sSUFBZjtBQUNDLE9BQUssc0JBQVksZUFBakI7QUFDQyxXQUFRLE1BQU0sTUFBTixFQUFSO0FBQ0EsU0FBTSxNQUFOLENBQWEsT0FBTyxFQUFwQixFQUF3QixDQUF4QjtBQUNBLFVBQU8sS0FBUDtBQUNELE9BQUssc0JBQVksYUFBakI7QUFDQyxXQUFRLE1BQU0sTUFBTixFQUFSO0FBQ0EsT0FBSSxZQUFLLGVBQUwsQ0FBcUIsT0FBTyxRQUFQLENBQWdCLEVBQXJDLENBQUosRUFBOEM7QUFDN0MsVUFBTSxPQUFPLFFBQVAsQ0FBZ0IsRUFBdEIsSUFBNEIsY0FBTyxLQUFQLENBQzNCLE1BQU0sT0FBTyxRQUFQLENBQWdCLEVBQXRCLENBRDJCLEVBRTNCLE9BQU8sUUFGb0IsQ0FBNUI7QUFJQSxJQUxELE1BS087QUFDTixVQUFNLElBQU4sQ0FBVyxjQUFPLEtBQVAsQ0FBYSxPQUFPLFFBQXBCLEVBQThCO0FBQ3hDLFNBQUksTUFBTSxNQUQ4QjtBQUV4QywwQkFBcUIsQ0FGbUI7QUFHeEMscUJBQWdCLENBSHdCO0FBSXhDLGlCQUFZO0FBSjRCLEtBQTlCLENBQVg7QUFNQTtBQUNELFVBQU8sS0FBUDtBQXBCRjtBQXNCQSxRQUFPLFNBQVMsRUFBaEI7QUFDQTs7a0JBRWMsUzs7O0FDL0JmOzs7Ozs7QUFFQTs7Ozs7O0FBRUEsU0FBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCLE1BQS9CLEVBQXVDO0FBQ3RDLFNBQVEsT0FBTyxJQUFmO0FBQ0MsT0FBSyxzQkFBWSxzQkFBakI7QUFDQyxVQUFPLE9BQU8sRUFBZDtBQUNELE9BQUssc0JBQVksdUJBQWpCO0FBQ0MsVUFBTyxJQUFQO0FBSkY7QUFNQSxRQUFPLFNBQVMsSUFBaEI7QUFDQTs7a0JBRWMsYzs7O0FDZGY7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxTQUFTLFFBQVQsQ0FBa0IsS0FBbEIsRUFBeUI7QUFDeEIsUUFBTyxTQUFTLEVBQWhCO0FBQ0E7O0FBRUQsU0FBUyxlQUFULENBQXlCLEtBQXpCLEVBQWdDO0FBQy9CLFFBQU8sU0FBUyxHQUFoQjtBQUNBOztBQUVELFNBQVMsWUFBVCxDQUFzQixLQUF0QixFQUE2QjtBQUM1QixRQUFPLFNBQVMsRUFBaEI7QUFDQTs7QUFFRCxTQUFTLFNBQVQsQ0FBbUIsS0FBbkIsRUFBMEI7QUFDekIsUUFBTyxTQUFTLEVBQWhCO0FBQ0E7O0FBRUQsU0FBUyxPQUFULENBQWlCLEtBQWpCLEVBQXdCO0FBQ3ZCLFFBQU8sU0FBUyxFQUFoQjtBQUNBOztBQUVELFNBQVMsUUFBVCxDQUFrQixLQUFsQixFQUF5QjtBQUN4QixRQUFPLFNBQVMsRUFBaEI7QUFDQTs7QUFFRCxTQUFTLE9BQVQsQ0FBaUIsS0FBakIsRUFBd0I7QUFDdkIsUUFBTyxTQUFTLEVBQWhCO0FBQ0E7O0FBRUQsSUFBSSxXQUFXLE1BQU0sZUFBTixDQUFzQjtBQUNwQyxtQkFEb0M7QUFFcEMsaUNBRm9DO0FBR3BDLCtCQUhvQztBQUlwQyx5Q0FKb0M7QUFLcEMsMkJBTG9DO0FBTXBDLHFCQU5vQztBQU9wQyxpQkFQb0M7QUFRcEMsbUJBUm9DO0FBU3BDLGlCQVRvQztBQVVwQztBQVZvQyxDQUF0QixDQUFmOztBQWFBLFNBQVMsV0FBVCxDQUFxQixLQUFyQixFQUE0QixNQUE1QixFQUFvQztBQUNuQyxTQUFRLE9BQU8sSUFBZjtBQUNDLE9BQUssc0JBQVksV0FBakI7QUFDQyxVQUFPLE9BQU8sS0FBZDtBQUZGO0FBSUEsUUFBTyxTQUFTLEtBQVQsRUFBZ0IsTUFBaEIsQ0FBUDtBQUNBOztrQkFFYyxXOzs7QUN4RGY7Ozs7OztBQUVBOzs7Ozs7QUFFQSxTQUFTLFNBQVQsQ0FBbUIsS0FBbkIsRUFBMEIsTUFBMUIsRUFBa0M7QUFDakMsU0FBUSxPQUFPLElBQWY7QUFDQyxPQUFLLHNCQUFZLHVCQUFqQjtBQUNBLE9BQUssc0JBQVksc0JBQWpCO0FBQ0MsVUFBTyxPQUFPLFNBQVAsSUFBb0IsR0FBM0I7QUFIRjtBQUtBLFFBQU8sU0FBUyxHQUFoQjtBQUNBOztrQkFFYyxTOzs7QUNiZjs7Ozs7O0FBRUE7Ozs7OztrQkFFZSxNQUFNLFdBQU4sdUIiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdW5lc2NhcGUgZnJvbSAnLi91bmVzY2FwZSc7XG5cbnZhciBwYXJzZXJfO1xuXG5jbGFzcyBIVE1MMkluY0RvbSB7XG5cdC8qKlxuXHQgKiBTaG91bGQgY29udmVydCB0aGUgZ2l2ZW4gaHRtbCBzdHJpbmcgdG8gYSBmdW5jdGlvbiB3aXRoIGNhbGxzIHRvXG5cdCAqIGluY3JlbWVudGFsIGRvbSBtZXRob2RzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuXHQgKiBAcmV0dXJuIHshZnVuY3Rpb24oKX0gRnVuY3Rpb24gd2l0aCBpbmNyZW1lbnRhbCBkb20gY2FsbHMgZm9yIGJ1aWxkaW5nXG5cdCAqICAgICB0aGUgZ2l2ZW4gaHRtbCBzdHJpbmcuXG5cdCAqL1xuXHRzdGF0aWMgYnVpbGRGbihodG1sKSB7XG5cdFx0cmV0dXJuICgpID0+IEhUTUwySW5jRG9tLnJ1bihodG1sKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBodG1sIHBhcnNlciBiZWluZyBjdXJyZW50bHkgdXNlZC5cblx0ICogQHJldHVybiB7IWZ1bmN0aW9uKCl9XG5cdCAqL1xuXHRzdGF0aWMgZ2V0UGFyc2VyKCkge1xuXHRcdHJldHVybiBwYXJzZXJfIHx8IHdpbmRvdy5IVE1MUGFyc2VyO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNob3VsZCBjb252ZXJ0IHRoZSBnaXZlbiBodG1sIHN0cmluZyB0byBjYWxscyB0byBpbmNyZW1lbnRhbCBkb20gbWV0aG9kcy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcblx0ICovXG5cdHN0YXRpYyBydW4oaHRtbCkge1xuXHRcdEhUTUwySW5jRG9tLmdldFBhcnNlcigpKGh0bWwsIHtcblx0XHRcdHN0YXJ0OiBmdW5jdGlvbih0YWcsIGF0dHJzLCB1bmFyeSkge1xuXHRcdFx0XHR2YXIgZm4gPSB1bmFyeSA/IEluY3JlbWVudGFsRE9NLmVsZW1lbnRWb2lkIDogSW5jcmVtZW50YWxET00uZWxlbWVudE9wZW47XG5cdFx0XHRcdHZhciBhcmdzID0gW1xuXHRcdFx0XHRcdHRhZyxcblx0XHRcdFx0XHRudWxsLFxuXHRcdFx0XHRcdFtdXG5cdFx0XHRcdF07XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRhcmdzLnB1c2goYXR0cnNbaV0ubmFtZSwgYXR0cnNbaV0udmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuXHRcdFx0fSxcblxuXHRcdFx0ZW5kOiBmdW5jdGlvbih0YWcpIHtcblx0XHRcdFx0SW5jcmVtZW50YWxET00uZWxlbWVudENsb3NlKHRhZyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRjaGFyczogZnVuY3Rpb24odGV4dCkge1xuXHRcdFx0XHRJbmNyZW1lbnRhbERPTS50ZXh0KHRleHQsIHVuZXNjYXBlKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGFuZ2VzIHRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgdXNlZCB0byBwYXJzZSBodG1sIHN0cmluZ3MuIEJ5IGRlZmF1bHRcblx0ICogdGhpcyB3aWxsIHVzZSB0aGUgYEhUTUxQYXJzZXJgIGZ1bmN0aW9uIGZyb21cblx0ICogaHR0cHM6Ly9naXRodWIuY29tL2Jsb3dzaWUvUHVyZS1KYXZhU2NyaXB0LUhUTUw1LVBhcnNlci4gVGhpcyB3aWxsIGFjY2VwdFxuXHQgKiBhbnkgZnVuY3Rpb24gdGhhdCBmb2xsb3dzIHRoYXQgc2FtZSBhcGksIGJhc2ljYWxseSBhY2NlcHRpbmcgdGhlIGh0bWxcblx0ICogc3RyaW5nIGFuZCBhbiBvYmplY3Qgd2l0aCBgc3RhcnRgLCBgZW5kYCBhbmQgYGNoYXJzYCBmdW5jdGlvbnMgdG8gYmUgY2FsbGVkXG5cdCAqIGR1cmluZyB0aGUgcGFyc2luZy5cblx0ICogQHBhcmFtIHshZnVuY3Rpb24oc3RyaW5nLCAhT2JqZWN0fSBuZXdQYXJzZXJcblx0ICovXG5cdHN0YXRpYyBzZXRQYXJzZXIobmV3UGFyc2VyKSB7XG5cdFx0cGFyc2VyXyA9IG5ld1BhcnNlcjtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBIVE1MMkluY0RvbTtcbiIsIi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cblxuLypcbiAqIEhUTUw1IFBhcnNlciBCeSBTYW0gQmxvd2VzXG4gKlxuICogRGVzaWduZWQgZm9yIEhUTUw1IGRvY3VtZW50c1xuICpcbiAqIE9yaWdpbmFsIGNvZGUgYnkgSm9obiBSZXNpZyAoZWpvaG4ub3JnKVxuICogaHR0cDovL2Vqb2huLm9yZy9ibG9nL3B1cmUtamF2YXNjcmlwdC1odG1sLXBhcnNlci9cbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIGh0dHA6Ly9lcmlrLmVhZS5uZXQvc2ltcGxlaHRtbHBhcnNlci9zaW1wbGVodG1scGFyc2VyLmpzXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogTGljZW5zZVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIFRoaXMgY29kZSBpcyB0cmlwbGUgbGljZW5zZWQgdXNpbmcgQXBhY2hlIFNvZnR3YXJlIExpY2Vuc2UgMi4wLFxuICogTW96aWxsYSBQdWJsaWMgTGljZW5zZSBvciBHTlUgUHVibGljIExpY2Vuc2VcbiAqXG4gKiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3RcbiAqIHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICpcbiAqIFRoZSBjb250ZW50cyBvZiB0aGlzIGZpbGUgYXJlIHN1YmplY3QgdG8gdGhlIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIFZlcnNpb24gMS4xICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpblxuICogY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqIGh0dHA6Ly93d3cubW96aWxsYS5vcmcvTVBML1xuICpcbiAqIFNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIlxuICogYmFzaXMsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGVcbiAqIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcmlnaHRzIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogVGhlIE9yaWdpbmFsIENvZGUgaXMgU2ltcGxlIEhUTUwgUGFyc2VyLlxuICpcbiAqIFRoZSBJbml0aWFsIERldmVsb3BlciBvZiB0aGUgT3JpZ2luYWwgQ29kZSBpcyBFcmlrIEFydmlkc3Nvbi5cbiAqIFBvcnRpb25zIGNyZWF0ZWQgYnkgRXJpayBBcnZpZHNzc29uIGFyZSBDb3B5cmlnaHQgKEMpIDIwMDQuIEFsbCBSaWdodHNcbiAqIFJlc2VydmVkLlxuICpcbiAqIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gKiBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb247IGVpdGhlciB2ZXJzaW9uIDJcbiAqIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gKiBGb3VuZGF0aW9uLCBJbmMuLCA1MSBGcmFua2xpbiBTdHJlZXQsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BICAwMjExMC0xMzAxLCBVU0EuXG4gKiBAbGljZW5zZVxuICovXG5cbi8qXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVXNhZ2VcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiAvLyBVc2UgbGlrZSBzbzpcbiAqIEhUTUxQYXJzZXIoaHRtbFN0cmluZywge1xuICogICAgIHN0YXJ0OiBmdW5jdGlvbih0YWcsIGF0dHJzLCB1bmFyeSkge30sXG4gKiAgICAgZW5kOiBmdW5jdGlvbih0YWcpIHt9LFxuICogICAgIGNoYXJzOiBmdW5jdGlvbih0ZXh0KSB7fSxcbiAqICAgICBjb21tZW50OiBmdW5jdGlvbih0ZXh0KSB7fVxuICogfSk7XG4gKlxuICogLy8gb3IgdG8gZ2V0IGFuIFhNTCBzdHJpbmc6XG4gKiBIVE1MdG9YTUwoaHRtbFN0cmluZyk7XG4gKlxuICogLy8gb3IgdG8gZ2V0IGFuIFhNTCBET00gRG9jdW1lbnRcbiAqIEhUTUx0b0RPTShodG1sU3RyaW5nKTtcbiAqXG4gKiAvLyBvciB0byBpbmplY3QgaW50byBhbiBleGlzdGluZyBkb2N1bWVudC9ET00gbm9kZVxuICogSFRNTHRvRE9NKGh0bWxTdHJpbmcsIGRvY3VtZW50KTtcbiAqIEhUTUx0b0RPTShodG1sU3RyaW5nLCBkb2N1bWVudC5ib2R5KTtcbiAqXG4gKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0Ly8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG5cdHZhciBzdGFydFRhZyA9IC9ePChbLUEtWmEtejAtOV9dKykoKD86XFxzK1thLXpBLVpfOl1bLWEtekEtWjAtOV86Ll0qKD86XFxzKj1cXHMqKD86KD86XCJbXlwiXSpcIil8KD86J1teJ10qJyl8W14+XFxzXSspKT8pKilcXHMqKFxcLz8pPi8sXG5cdFx0ZW5kVGFnID0gL148XFwvKFstQS1aYS16MC05X10rKVtePl0qPi8sXG5cdFx0YXR0ciA9IC8oW2EtekEtWl86XVstYS16QS1aMC05XzouXSopKD86XFxzKj1cXHMqKD86KD86XCIoKD86XFxcXC58W15cIl0pKilcIil8KD86JygoPzpcXFxcLnxbXiddKSopJyl8KFtePlxcc10rKSkpPy9nO1xuXG5cdC8vIEVtcHR5IEVsZW1lbnRzIC0gSFRNTCA1XG5cdHZhciBlbXB0eSA9IG1ha2VNYXAoXCJhcmVhLGJhc2UsYmFzZWZvbnQsYnIsY29sLGZyYW1lLGhyLGltZyxpbnB1dCxsaW5rLG1ldGEscGFyYW0sZW1iZWQsY29tbWFuZCxrZXlnZW4sc291cmNlLHRyYWNrLHdiclwiKTtcblxuXHQvLyBCbG9jayBFbGVtZW50cyAtIEhUTUwgNVxuXHR2YXIgYmxvY2sgPSBtYWtlTWFwKFwiYSxhZGRyZXNzLGFydGljbGUsYXBwbGV0LGFzaWRlLGF1ZGlvLGJsb2NrcXVvdGUsYnV0dG9uLGNhbnZhcyxjZW50ZXIsZGQsZGVsLGRpcixkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sZnJhbWVzZXQsaDEsaDIsaDMsaDQsaDUsaDYsaGVhZGVyLGhncm91cCxocixpZnJhbWUsaW5zLGlzaW5kZXgsbGksbWFwLG1lbnUsbm9mcmFtZXMsbm9zY3JpcHQsb2JqZWN0LG9sLG91dHB1dCxwLHByZSxzZWN0aW9uLHNjcmlwdCx0YWJsZSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCx0cix1bCx2aWRlb1wiKTtcblxuXHQvLyBJbmxpbmUgRWxlbWVudHMgLSBIVE1MIDVcblx0dmFyIGlubGluZSA9IG1ha2VNYXAoXCJhYmJyLGFjcm9ueW0sYXBwbGV0LGIsYmFzZWZvbnQsYmRvLGJpZyxicixidXR0b24sY2l0ZSxjb2RlLGRlbCxkZm4sZW0sZm9udCxpLGlmcmFtZSxpbWcsaW5wdXQsaW5zLGtiZCxsYWJlbCxtYXAsb2JqZWN0LHEscyxzYW1wLHNjcmlwdCxzZWxlY3Qsc21hbGwsc3BhbixzdHJpa2Usc3Ryb25nLHN1YixzdXAsdGV4dGFyZWEsdHQsdSx2YXJcIik7XG5cblx0Ly8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG5cdC8vIChhbmQgd2hpY2ggY2xvc2UgdGhlbXNlbHZlcylcblx0dmFyIGNsb3NlU2VsZiA9IG1ha2VNYXAoXCJjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHJcIik7XG5cblx0Ly8gQXR0cmlidXRlcyB0aGF0IGhhdmUgdGhlaXIgdmFsdWVzIGZpbGxlZCBpbiBkaXNhYmxlZD1cImRpc2FibGVkXCJcblx0dmFyIGZpbGxBdHRycyA9IG1ha2VNYXAoXCJjaGVja2VkLGNvbXBhY3QsZGVjbGFyZSxkZWZlcixkaXNhYmxlZCxpc21hcCxtdWx0aXBsZSxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3dyYXAscmVhZG9ubHksc2VsZWN0ZWRcIik7XG5cblx0Ly8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG5cdHZhciBzcGVjaWFsID0gbWFrZU1hcChcInNjcmlwdCxzdHlsZVwiKTtcblxuXHR2YXIgSFRNTFBhcnNlciA9IHdpbmRvdy5IVE1MUGFyc2VyID0gZnVuY3Rpb24gKGh0bWwsIGhhbmRsZXIpIHtcblx0XHR2YXIgaW5kZXgsIGNoYXJzLCBtYXRjaCwgc3RhY2sgPSBbXSwgbGFzdCA9IGh0bWw7XG5cdFx0c3RhY2subGFzdCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzW3RoaXMubGVuZ3RoIC0gMV07XG5cdFx0fTtcblxuXHRcdHdoaWxlIChodG1sKSB7XG5cdFx0XHRjaGFycyA9IHRydWU7XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBzY3JpcHQgb3Igc3R5bGUgZWxlbWVudFxuXHRcdFx0aWYgKCFzdGFjay5sYXN0KCkgfHwgIXNwZWNpYWxbc3RhY2subGFzdCgpXSkge1xuXG5cdFx0XHRcdC8vIENvbW1lbnRcblx0XHRcdFx0aWYgKGh0bWwuaW5kZXhPZihcIjwhLS1cIikgPT0gMCkge1xuXHRcdFx0XHRcdGluZGV4ID0gaHRtbC5pbmRleE9mKFwiLS0+XCIpO1xuXG5cdFx0XHRcdFx0aWYgKGluZGV4ID49IDApIHtcblx0XHRcdFx0XHRcdGlmIChoYW5kbGVyLmNvbW1lbnQpXG5cdFx0XHRcdFx0XHRcdGhhbmRsZXIuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBpbmRleCkpO1xuXHRcdFx0XHRcdFx0aHRtbCA9IGh0bWwuc3Vic3RyaW5nKGluZGV4ICsgMyk7XG5cdFx0XHRcdFx0XHRjaGFycyA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGVuZCB0YWdcblx0XHRcdFx0fSBlbHNlIGlmIChodG1sLmluZGV4T2YoXCI8L1wiKSA9PSAwKSB7XG5cdFx0XHRcdFx0bWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG5cblx0XHRcdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0XHRcdGh0bWwgPSBodG1sLnN1YnN0cmluZyhtYXRjaFswXS5sZW5ndGgpO1xuXHRcdFx0XHRcdFx0bWF0Y2hbMF0ucmVwbGFjZShlbmRUYWcsIHBhcnNlRW5kVGFnKTtcblx0XHRcdFx0XHRcdGNoYXJzID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gc3RhcnQgdGFnXG5cdFx0XHRcdH0gZWxzZSBpZiAoaHRtbC5pbmRleE9mKFwiPFwiKSA9PSAwKSB7XG5cdFx0XHRcdFx0bWF0Y2ggPSBodG1sLm1hdGNoKHN0YXJ0VGFnKTtcblxuXHRcdFx0XHRcdGlmIChtYXRjaCkge1xuXHRcdFx0XHRcdFx0aHRtbCA9IGh0bWwuc3Vic3RyaW5nKG1hdGNoWzBdLmxlbmd0aCk7XG5cdFx0XHRcdFx0XHRtYXRjaFswXS5yZXBsYWNlKHN0YXJ0VGFnLCBwYXJzZVN0YXJ0VGFnKTtcblx0XHRcdFx0XHRcdGNoYXJzID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGNoYXJzKSB7XG5cdFx0XHRcdFx0aW5kZXggPSBodG1sLmluZGV4T2YoXCI8XCIpO1xuXG5cdFx0XHRcdFx0dmFyIHRleHQgPSBpbmRleCA8IDAgPyBodG1sIDogaHRtbC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuXHRcdFx0XHRcdGh0bWwgPSBpbmRleCA8IDAgPyBcIlwiIDogaHRtbC5zdWJzdHJpbmcoaW5kZXgpO1xuXG5cdFx0XHRcdFx0aWYgKGhhbmRsZXIuY2hhcnMpXG5cdFx0XHRcdFx0XHRoYW5kbGVyLmNoYXJzKHRleHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLnJlcGxhY2UobmV3IFJlZ0V4cChcIihbXFxcXHNcXFxcU10qPyk8XFwvXCIgKyBzdGFjay5sYXN0KCkgKyBcIltePl0qPlwiKSwgZnVuY3Rpb24gKGFsbCwgdGV4dCkge1xuXHRcdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoLzwhLS0oW1xcc1xcU10qPyktLT58PCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCBcIiQxJDJcIik7XG5cdFx0XHRcdFx0aWYgKGhhbmRsZXIuY2hhcnMpXG5cdFx0XHRcdFx0XHRoYW5kbGVyLmNoYXJzKHRleHQpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHBhcnNlRW5kVGFnKFwiXCIsIHN0YWNrLmxhc3QoKSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChodG1sID09IGxhc3QpXG5cdFx0XHRcdHRocm93IFwiUGFyc2UgRXJyb3I6IFwiICsgaHRtbDtcblx0XHRcdGxhc3QgPSBodG1sO1xuXHRcdH1cblxuXHRcdC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuXHRcdHBhcnNlRW5kVGFnKCk7XG5cblx0XHRmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnKHRhZywgdGFnTmFtZSwgcmVzdCwgdW5hcnkpIHtcblx0XHRcdHRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmIChibG9ja1t0YWdOYW1lXSkge1xuXHRcdFx0XHR3aGlsZSAoc3RhY2subGFzdCgpICYmIGlubGluZVtzdGFjay5sYXN0KCldKSB7XG5cdFx0XHRcdFx0cGFyc2VFbmRUYWcoXCJcIiwgc3RhY2subGFzdCgpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2xvc2VTZWxmW3RhZ05hbWVdICYmIHN0YWNrLmxhc3QoKSA9PSB0YWdOYW1lKSB7XG5cdFx0XHRcdHBhcnNlRW5kVGFnKFwiXCIsIHRhZ05hbWUpO1xuXHRcdFx0fVxuXG5cdFx0XHR1bmFyeSA9IGVtcHR5W3RhZ05hbWVdIHx8ICEhdW5hcnk7XG5cblx0XHRcdGlmICghdW5hcnkpXG5cdFx0XHRcdHN0YWNrLnB1c2godGFnTmFtZSk7XG5cblx0XHRcdGlmIChoYW5kbGVyLnN0YXJ0KSB7XG5cdFx0XHRcdHZhciBhdHRycyA9IFtdO1xuXG5cdFx0XHRcdHJlc3QucmVwbGFjZShhdHRyLCBmdW5jdGlvbiAobWF0Y2gsIG5hbWUpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBhcmd1bWVudHNbMl0gPyBhcmd1bWVudHNbMl0gOlxuXHRcdFx0XHRcdFx0YXJndW1lbnRzWzNdID8gYXJndW1lbnRzWzNdIDpcblx0XHRcdFx0XHRcdGFyZ3VtZW50c1s0XSA/IGFyZ3VtZW50c1s0XSA6XG5cdFx0XHRcdFx0XHRmaWxsQXR0cnNbbmFtZV0gPyBuYW1lIDogXCJcIjtcblxuXHRcdFx0XHRcdGF0dHJzLnB1c2goe1xuXHRcdFx0XHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGVzY2FwZWQ6IHZhbHVlLnJlcGxhY2UoLyhefFteXFxcXF0pXCIvZywgJyQxXFxcXFxcXCInKSAvL1wiXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChoYW5kbGVyLnN0YXJ0KVxuXHRcdFx0XHRcdGhhbmRsZXIuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUVuZFRhZyh0YWcsIHRhZ05hbWUpIHtcblx0XHRcdC8vIElmIG5vIHRhZyBuYW1lIGlzIHByb3ZpZGVkLCBjbGVhbiBzaG9wXG5cdFx0XHRpZiAoIXRhZ05hbWUpXG5cdFx0XHRcdHZhciBwb3MgPSAwO1xuXG5cdFx0XHRcdC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG5cdFx0XHRlbHNlXG5cdFx0XHRcdGZvciAodmFyIHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSlcblx0XHRcdFx0XHRpZiAoc3RhY2tbcG9zXSA9PSB0YWdOYW1lKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGlmIChwb3MgPj0gMCkge1xuXHRcdFx0XHQvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuXHRcdFx0XHRmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSlcblx0XHRcdFx0XHRpZiAoaGFuZGxlci5lbmQpXG5cdFx0XHRcdFx0XHRoYW5kbGVyLmVuZChzdGFja1tpXSk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG5cdFx0XHRcdHN0YWNrLmxlbmd0aCA9IHBvcztcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gbWFrZU1hcChzdHIpIHtcblx0XHR2YXIgb2JqID0ge30sIGl0ZW1zID0gc3RyLnNwbGl0KFwiLFwiKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxuXHRcdFx0b2JqW2l0ZW1zW2ldXSA9IHRydWU7XG5cdFx0cmV0dXJuIG9iajtcblx0fVxufSkuY2FsbCh0aGlzKTtcblxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gQ29weXJpZ2h0IDIwMDYgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8qKlxuICogVW5lc2NhcGVzIGFuIEhUTUwgc3RyaW5nIHVzaW5nIGEgRE9NIHRvIHJlc29sdmUgbm9uLVhNTCwgbm9uLW51bWVyaWNcbiAqIGVudGl0aWVzLiBUaGlzIGZ1bmN0aW9uIGlzIFhTUy1zYWZlIGFuZCB3aGl0ZXNwYWNlLXByZXNlcnZpbmcuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgdW5lc2NhcGVkIHtAY29kZSBzdHJ9IHN0cmluZy5cbiAqL1xuIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cikge1xuICAgLyoqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn0gKi9cbiAgIHZhciBzZWVuID0geycmYW1wOyc6ICcmJywgJyZsdDsnOiAnPCcsICcmZ3Q7JzogJz4nLCAnJnF1b3Q7JzogJ1wiJ307XG4gICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgIC8vIE1hdGNoIGFzIG1hbnkgdmFsaWQgZW50aXR5IGNoYXJhY3RlcnMgYXMgcG9zc2libGUuIElmIHRoZSBhY3R1YWwgZW50aXR5XG4gICAvLyBoYXBwZW5zIHRvIGJlIHNob3J0ZXIsIGl0IHdpbGwgc3RpbGwgd29yayBhcyBpbm5lckhUTUwgd2lsbCByZXR1cm4gdGhlXG4gICAvLyB0cmFpbGluZyBjaGFyYWN0ZXJzIHVuY2hhbmdlZC4gU2luY2UgdGhlIGVudGl0eSBjaGFyYWN0ZXJzIGRvIG5vdCBpbmNsdWRlXG4gICAvLyBvcGVuIGFuZ2xlIGJyYWNrZXQsIHRoZXJlIGlzIG5vIGNoYW5jZSBvZiBYU1MgZnJvbSB0aGUgaW5uZXJIVE1MIHVzZS5cbiAgIC8vIFNpbmNlIG5vIHdoaXRlc3BhY2UgaXMgcGFzc2VkIHRvIGlubmVySFRNTCwgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWQuXG4gICByZXR1cm4gc3RyLnJlcGxhY2UoSFRNTF9FTlRJVFlfUEFUVEVSTl8sIGZ1bmN0aW9uKHMsIGVudGl0eSkge1xuICAgICAvLyBDaGVjayBmb3IgY2FjaGVkIGVudGl0eS5cbiAgICAgdmFyIHZhbHVlID0gc2VlbltzXTtcbiAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICB9XG4gICAgIC8vIENoZWNrIGZvciBudW1lcmljIGVudGl0eS5cbiAgICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgIC8vIFByZWZpeCB3aXRoIDAgc28gdGhhdCBoZXggZW50aXRpZXMgKGUuZy4gJiN4MTApIHBhcnNlIGFzIGhleCBudW1iZXJzLlxuICAgICAgIHZhciBuID0gTnVtYmVyKCcwJyArIGVudGl0eS5zdWJzdHIoMSkpO1xuICAgICAgIGlmICghaXNOYU4obikpIHtcbiAgICAgICAgIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZShuKTtcbiAgICAgICB9XG4gICAgIH1cbiAgICAgLy8gRmFsbCBiYWNrIHRvIGlubmVySFRNTCBvdGhlcndpc2UuXG4gICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAvLyBBcHBlbmQgYSBub24tZW50aXR5IGNoYXJhY3RlciB0byBhdm9pZCBhIGJ1ZyBpbiBXZWJraXQgdGhhdCBwYXJzZXNcbiAgICAgICAvLyBhbiBpbnZhbGlkIGVudGl0eSBhdCB0aGUgZW5kIG9mIGlubmVySFRNTCB0ZXh0IGFzIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICAgZGl2LmlubmVySFRNTCA9IHMgKyAnICc7XG4gICAgICAgLy8gVGhlbiByZW1vdmUgdGhlIHRyYWlsaW5nIGNoYXJhY3RlciBmcm9tIHRoZSByZXN1bHQuXG4gICAgICAgdmFsdWUgPSBkaXYuZmlyc3RDaGlsZC5ub2RlVmFsdWUuc2xpY2UoMCwgLTEpO1xuICAgICB9XG4gICAgIC8vIENhY2hlIGFuZCByZXR1cm4uXG4gICAgIHNlZW5bc10gPSB2YWx1ZTtcbiAgICAgcmV0dXJuIHZhbHVlO1xuICAgfSk7XG4gfVxuXG5leHBvcnQgZGVmYXVsdCB1bmVzY2FwZTtcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGFuIEhUTUwgZW50aXR5LlxuICogQHR5cGUgeyFSZWdFeHB9XG4gKi9cbnZhciBIVE1MX0VOVElUWV9QQVRURVJOXyA9IC8mKFteO1xcczwmXSspOz8vZztcbiIsImltcG9ydCAnLi9IVE1MUGFyc2VyJztcbmltcG9ydCBIVE1MMkluY0RvbSBmcm9tICcuL0hUTUwySW5jRG9tJztcbmV4cG9ydCBkZWZhdWx0IEhUTUwySW5jRG9tO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IFVyaSBmcm9tICdtZXRhbC11cmknO1xuaW1wb3J0IHsgQ2FuY2VsbGFibGVQcm9taXNlIGFzIFByb21pc2UgfSBmcm9tICdtZXRhbC1wcm9taXNlJztcblxuY2xhc3MgQWpheCB7XG5cblx0LyoqXG5cdCAqIFhtbEh0dHBSZXF1ZXN0J3MgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgbWV0aG9kIHJldHVybnMgYSBzdHJpbmcgb2Zcblx0ICogcmVzcG9uc2UgaGVhZGVycyBhY2NvcmRpbmcgdG8gdGhlIGZvcm1hdCBkZXNjcmliZWQgb24gdGhlIHNwZWM6XG5cdCAqIHtAbGluayBodHRwOi8vd3d3LnczLm9yZy9UUi9YTUxIdHRwUmVxdWVzdC8jdGhlLWdldGFsbHJlc3BvbnNlaGVhZGVycy1tZXRob2R9LlxuXHQgKiBUaGlzIG1ldGhvZCBwYXJzZXMgdGhhdCBzdHJpbmcgaW50byBhIHVzZXItZnJpZW5kbHkgbmFtZS92YWx1ZSBwYWlyXG5cdCAqIG9iamVjdC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGFsbEhlYWRlcnMgQWxsIGhlYWRlcnMgYXMgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHshQXJyYXkuPE9iamVjdDxzdHJpbmcsIHN0cmluZz4+fVxuXHQgKi9cblx0c3RhdGljIHBhcnNlUmVzcG9uc2VIZWFkZXJzKGFsbEhlYWRlcnMpIHtcblx0XHR2YXIgaGVhZGVycyA9IFtdO1xuXHRcdGlmICghYWxsSGVhZGVycykge1xuXHRcdFx0cmV0dXJuIGhlYWRlcnM7XG5cdFx0fVxuXHRcdHZhciBwYWlycyA9IGFsbEhlYWRlcnMuc3BsaXQoJ1xcdTAwMGRcXHUwMDBhJyk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGluZGV4ID0gcGFpcnNbaV0uaW5kZXhPZignXFx1MDAzYVxcdTAwMjAnKTtcblx0XHRcdGlmIChpbmRleCA+IDApIHtcblx0XHRcdFx0dmFyIG5hbWUgPSBwYWlyc1tpXS5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBwYWlyc1tpXS5zdWJzdHJpbmcoaW5kZXggKyAyKTtcblx0XHRcdFx0aGVhZGVycy5wdXNoKHtcblx0XHRcdFx0XHRuYW1lOiBuYW1lLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGhlYWRlcnM7XG5cdH1cblxuXHQvKipcblx0ICogUmVxdWVzdHMgdGhlIHVybCB1c2luZyBYTUxIdHRwUmVxdWVzdC5cblx0ICogQHBhcmFtIHshc3RyaW5nfSB1cmxcblx0ICogQHBhcmFtIHshc3RyaW5nfSBtZXRob2Rcblx0ICogQHBhcmFtIHs/c3RyaW5nfSBib2R5XG5cdCAqIEBwYXJhbSB7TXVsdGlNYXA9fSBvcHRfaGVhZGVyc1xuXHQgKiBAcGFyYW0ge011bHRpTWFwPX0gb3B0X3BhcmFtc1xuXHQgKiBAcGFyYW0ge251bWJlcj19IG9wdF90aW1lb3V0XG5cdCAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9zeW5jXG5cdCAqIEByZXR1cm4ge1Byb21pc2V9IERlZmVycmVkIGFqYXggcmVxdWVzdC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c3RhdGljIHJlcXVlc3QodXJsLCBtZXRob2QsIGJvZHksIG9wdF9oZWFkZXJzLCBvcHRfcGFyYW1zLCBvcHRfdGltZW91dCwgb3B0X3N5bmMpIHtcblx0XHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG5cdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChyZXF1ZXN0LmFib3J0ZWQpIHtcblx0XHRcdFx0XHRyZXF1ZXN0Lm9uZXJyb3IoKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVzb2x2ZShyZXF1ZXN0KTtcblx0XHRcdH07XG5cdFx0XHRyZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVycm9yID0gbmV3IEVycm9yKCdSZXF1ZXN0IGVycm9yJyk7XG5cdFx0XHRcdGVycm9yLnJlcXVlc3QgPSByZXF1ZXN0O1xuXHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0fTtcblx0XHR9KS50aGVuQ2F0Y2goZnVuY3Rpb24ocmVhc29uKSB7XG5cdFx0XHRyZXF1ZXN0LmFib3J0KCk7XG5cdFx0XHR0aHJvdyByZWFzb247XG5cdFx0fSkudGhlbkFsd2F5cyhmdW5jdGlvbigpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHR9KTtcblxuXHRcdGlmIChvcHRfcGFyYW1zKSB7XG5cdFx0XHR1cmwgPSBuZXcgVXJpKHVybCkuYWRkUGFyYW1ldGVyc0Zyb21NdWx0aU1hcChvcHRfcGFyYW1zKS50b1N0cmluZygpO1xuXHRcdH1cblxuXHRcdHJlcXVlc3Qub3BlbihtZXRob2QsIHVybCwgIW9wdF9zeW5jKTtcblxuXHRcdGlmIChvcHRfaGVhZGVycykge1xuXHRcdFx0b3B0X2hlYWRlcnMubmFtZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0cmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIG9wdF9oZWFkZXJzLmdldEFsbChuYW1lKS5qb2luKCcsICcpKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJlcXVlc3Quc2VuZChjb3JlLmlzRGVmKGJvZHkpID8gYm9keSA6IG51bGwpO1xuXG5cdFx0aWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKG9wdF90aW1lb3V0KSkge1xuXHRcdFx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRwcm9taXNlLmNhbmNlbCgnUmVxdWVzdCB0aW1lb3V0Jyk7XG5cdFx0XHR9LCBvcHRfdGltZW91dCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByb21pc2U7XG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBBamF4O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBhcnJheSwgY29yZSwgb2JqZWN0IH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IHsgZG9tLCBEb21FdmVudEVtaXR0ZXJQcm94eSB9IGZyb20gJ21ldGFsLWRvbSc7XG5pbXBvcnQgQ29tcG9uZW50UmVnaXN0cnkgZnJvbSAnLi9Db21wb25lbnRSZWdpc3RyeSc7XG5pbXBvcnQgQ29tcG9uZW50UmVuZGVyZXIgZnJvbSAnLi9Db21wb25lbnRSZW5kZXJlcic7XG5pbXBvcnQgeyBFdmVudEhhbmRsZXIgfSBmcm9tICdtZXRhbC1ldmVudHMnO1xuaW1wb3J0IFN0YXRlIGZyb20gJ21ldGFsLXN0YXRlJztcblxuLyoqXG4gKiBDb21wb25lbnQgY29sbGVjdHMgY29tbW9uIGJlaGF2aW9ycyB0byBiZSBmb2xsb3dlZCBieSBVSSBjb21wb25lbnRzLCBzdWNoXG4gKiBhcyBMaWZlY3ljbGUsIENTUyBjbGFzc2VzIG1hbmFnZW1lbnQsIGV2ZW50cyBlbmNhcHN1bGF0aW9uIGFuZCBzdXBwb3J0IGZvclxuICogZGlmZmVyZW50IHR5cGVzIG9mIHJlbmRlcmluZy5cbiAqIFJlbmRlcmluZyBsb2dpYyBjYW4gYmUgZG9uZSBieSBlaXRoZXI6XG4gKiAgICAgLSBMaXN0ZW5pbmcgdG8gdGhlIGByZW5kZXJgIGV2ZW50IGluc2lkZSB0aGUgYGNyZWF0ZWRgIGxpZmVjeWNsZSBmdW5jdGlvblxuICogICAgICAgYW5kIGFkZGluZyB0aGUgcmVuZGVyaW5nIGxvZ2ljIHRvIHRoZSBsaXN0ZW5lci5cbiAqICAgICAtIFVzaW5nIGFuIGV4aXN0aW5nIGltcGxlbWVudGF0aW9uIG9mIGBDb21wb25lbnRSZW5kZXJlcmAgbGlrZSBgU295YCxcbiAqICAgICAgIGFuZCBmb2xsb3dpbmcgaXRzIHBhdHRlcm5zLlxuICogICAgIC0gQnVpbGRpbmcgeW91ciBvd24gaW1wbGVtZW50YXRpb24gb2YgYSBgQ29tcG9uZW50UmVuZGVyZXJgLlxuICogU3BlY2lmeWluZyB0aGUgcmVuZGVyZXIgdGhhdCB3aWxsIGJlIHVzZWQgY2FuIGJlIGRvbmUgYnkgc2V0dGluZyB0aGUgUkVOREVSRVJcbiAqIHN0YXRpYyB2YXJpYWJsZSB0byB0aGUgcmVuZGVyZXIncyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIDxjb2RlPlxuICogY2xhc3MgQ3VzdG9tQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAqICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gKiAgICAgc3VwZXIoY29uZmlnKTtcbiAqICAgfVxuICpcbiAqICAgY3JlYXRlZCgpIHtcbiAqICAgfVxuICpcbiAqICAgYXR0YWNoZWQoKSB7XG4gKiAgIH1cbiAqXG4gKiAgIGRldGFjaGVkKCkge1xuICogICB9XG4gKiB9XG4gKlxuICogQ3VzdG9tQ29tcG9uZW50LlJFTkRFUkVSID0gTXlSZW5kZXJlcjtcbiAqXG4gKiBDdXN0b21Db21wb25lbnQuU1RBVEUgPSB7XG4gKiAgIHRpdGxlOiB7IHZhbHVlOiAnVGl0bGUnIH0sXG4gKiAgIGZvbnRTaXplOiB7IHZhbHVlOiAnMTBweCcgfVxuICogfTtcbiAqIDwvY29kZT5cbiAqXG4gKiBAZXh0ZW5kcyB7U3RhdGV9XG4gKi9cbmNsYXNzIENvbXBvbmVudCBleHRlbmRzIFN0YXRlIHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBgQ29tcG9uZW50YC5cblx0ICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfY29uZmlnIEFuIG9iamVjdCB3aXRoIHRoZSBpbml0aWFsIHZhbHVlcyBmb3IgdGhpc1xuXHQgKiAgICAgY29tcG9uZW50J3Mgc3RhdGUuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbnxzdHJpbmd8RWxlbWVudD19IG9wdF9wYXJlbnRFbGVtZW50IFRoZSBlbGVtZW50IHdoZXJlIHRoZVxuXHQgKiAgICAgY29tcG9uZW50IHNob3VsZCBiZSByZW5kZXJlZC4gQ2FuIGJlIGdpdmVuIGFzIGEgc2VsZWN0b3Igb3IgYW4gZWxlbWVudC5cblx0ICogICAgIElmIGBmYWxzZWAgaXMgcGFzc2VkLCB0aGUgY29tcG9uZW50IHdvbid0IGJlIHJlbmRlcmVkIGF1dG9tYXRpY2FsbHlcblx0ICogICAgIGFmdGVyIGNyZWF0ZWQuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3Iob3B0X2NvbmZpZywgb3B0X3BhcmVudEVsZW1lbnQpIHtcblx0XHRzdXBlcihvcHRfY29uZmlnKTtcblxuXHRcdC8qKlxuXHRcdCAqIEFsbCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGF0dGFjaGVkIHVudGlsIHRoZSBgRG9tRXZlbnRFbWl0dGVyUHJveHlgIGluc3RhbmNlXG5cdFx0ICogd2FzIGNyZWF0ZWQuXG5cdFx0ICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBib29sPn1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5hdHRhY2hlZExpc3RlbmVyc18gPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYWxsIG5lc3RlZCBjb21wb25lbnRzLlxuXHRcdCAqIEB0eXBlIHshQXJyYXk8IUNvbXBvbmVudD59XG5cdFx0ICovXG5cdFx0dGhpcy5jb21wb25lbnRzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBJbnN0YW5jZSBvZiBgRG9tRXZlbnRFbWl0dGVyUHJveHlgIHdoaWNoIHByb3hpZXMgZXZlbnRzIGZyb20gdGhlIGNvbXBvbmVudCdzXG5cdFx0ICogZWxlbWVudCB0byB0aGUgY29tcG9uZW50IGl0c2VsZi5cblx0XHQgKiBAdHlwZSB7RG9tRXZlbnRFbWl0dGVyUHJveHl9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuZWxlbWVudEV2ZW50UHJveHlfID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBgRXZlbnRIYW5kbGVyYCBpbnN0YW5jZSBmb3IgZXZlbnRzIGF0dGFjaGVkIGZyb20gdGhlIGBldmVudHNgIHN0YXRlIGtleS5cblx0XHQgKiBAdHlwZSB7IUV2ZW50SGFuZGxlcn1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5ldmVudHNTdGF0ZUtleUhhbmRsZXJfID0gbmV3IEV2ZW50SGFuZGxlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0aGUgZWxlbWVudCBpcyBpbiBkb2N1bWVudC5cblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHR0aGlzLmluRG9jdW1lbnQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBpbml0aWFsIGNvbmZpZyBvcHRpb24gcGFzc2VkIHRvIHRoaXMgY29uc3RydWN0b3IuXG5cdFx0ICogQHR5cGUgeyFPYmplY3R9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuaW5pdGlhbENvbmZpZ18gPSBvcHRfY29uZmlnIHx8IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0aGUgZWxlbWVudCB3YXMgcmVuZGVyZWQuXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0dGhpcy53YXNSZW5kZXJlZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNvbXBvbmVudCdzIGVsZW1lbnQgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgZWxlbWVudCB0aGlzIHZhcmlhYmxlIGlzXG5cdFx0ICogc2V0IHRvLCB1bmxlc3MgdGhlIHVzZXIgc3BlY2lmaWVzIGFub3RoZXIgcGFyZW50IHdoZW4gY2FsbGluZyBgcmVuZGVyYCBvclxuXHRcdCAqIGBhdHRhY2hgLlxuXHRcdCAqIEB0eXBlIHshRWxlbWVudH1cblx0XHQgKi9cblx0XHR0aGlzLkRFRkFVTFRfRUxFTUVOVF9QQVJFTlQgPSBkb2N1bWVudC5ib2R5O1xuXG5cdFx0Y29yZS5tZXJnZVN1cGVyQ2xhc3Nlc1Byb3BlcnR5KHRoaXMuY29uc3RydWN0b3IsICdFTEVNRU5UX0NMQVNTRVMnLCB0aGlzLm1lcmdlRWxlbWVudENsYXNzZXNfKTtcblxuXHRcdHRoaXMucmVuZGVyZXJfID0gdGhpcy5jcmVhdGVSZW5kZXJlcigpO1xuXG5cdFx0dGhpcy5vbignc3RhdGVDaGFuZ2VkJywgdGhpcy5oYW5kbGVTdGF0ZUNoYW5nZWRfKTtcblx0XHR0aGlzLm5ld0xpc3RlbmVySGFuZGxlXyA9IHRoaXMub24oJ25ld0xpc3RlbmVyJywgdGhpcy5oYW5kbGVOZXdMaXN0ZW5lcl8pO1xuXHRcdHRoaXMub24oJ2V2ZW50c0NoYW5nZWQnLCB0aGlzLm9uRXZlbnRzQ2hhbmdlZF8pO1xuXHRcdHRoaXMuYWRkTGlzdGVuZXJzRnJvbU9ial8odGhpcy5ldmVudHMpO1xuXG5cdFx0dGhpcy5jcmVhdGVkKCk7XG5cdFx0aWYgKG9wdF9wYXJlbnRFbGVtZW50ICE9PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5yZW5kZXJfKG9wdF9wYXJlbnRFbGVtZW50KTtcblx0XHR9XG5cdFx0dGhpcy5vbignZWxlbWVudENoYW5nZWQnLCB0aGlzLm9uRWxlbWVudENoYW5nZWRfKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBuZWNlc3NhcnkgY2xhc3NlcyB0byB0aGUgY29tcG9uZW50J3MgZWxlbWVudC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0YWRkRWxlbWVudENsYXNzZXNfKCkge1xuXHRcdHZhciBjbGFzc2VzVG9BZGQgPSB0aGlzLmNvbnN0cnVjdG9yLkVMRU1FTlRfQ0xBU1NFU19NRVJHRUQ7XG5cdFx0aWYgKHRoaXMuZWxlbWVudENsYXNzZXMpIHtcblx0XHRcdGNsYXNzZXNUb0FkZCA9IGNsYXNzZXNUb0FkZCArICcgJyArIHRoaXMuZWxlbWVudENsYXNzZXM7XG5cdFx0fVxuXHRcdGRvbS5hZGRDbGFzc2VzKHRoaXMuZWxlbWVudCwgY2xhc3Nlc1RvQWRkKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBsaXN0ZW5lcnMgc3BlY2lmaWVkIGluIHRoZSBnaXZlbiBvYmplY3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0YWRkTGlzdGVuZXJzRnJvbU9ial8oZXZlbnRzKSB7XG5cdFx0dmFyIGV2ZW50TmFtZXMgPSBPYmplY3Qua2V5cyhldmVudHMgfHwge30pO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnROYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGluZm8gPSB0aGlzLmV4dHJhY3RMaXN0ZW5lckluZm9fKGV2ZW50c1tldmVudE5hbWVzW2ldXSk7XG5cdFx0XHRpZiAoaW5mby5mbikge1xuXHRcdFx0XHR2YXIgaGFuZGxlcjtcblx0XHRcdFx0aWYgKGluZm8uc2VsZWN0b3IpIHtcblx0XHRcdFx0XHRoYW5kbGVyID0gdGhpcy5kZWxlZ2F0ZShldmVudE5hbWVzW2ldLCBpbmZvLnNlbGVjdG9yLCBpbmZvLmZuKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRoYW5kbGVyID0gdGhpcy5vbihldmVudE5hbWVzW2ldLCBpbmZvLmZuKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmV2ZW50c1N0YXRlS2V5SGFuZGxlcl8uYWRkKGhhbmRsZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBJbnZva2VzIHRoZSBhdHRhY2hlZCBMaWZlY3ljbGUuIFdoZW4gYXR0YWNoZWQsIHRoZSBjb21wb25lbnQgZWxlbWVudCBpc1xuXHQgKiBhcHBlbmRlZCB0byB0aGUgRE9NIGFuZCBhbnkgb3RoZXIgYWN0aW9uIHRvIGJlIHBlcmZvcm1lZCBtdXN0IGJlXG5cdCAqIGltcGxlbWVudGVkIGluIHRoaXMgbWV0aG9kLCBzdWNoIGFzLCBiaW5kaW5nIERPTSBldmVudHMuIEEgY29tcG9uZW50IGNhblxuXHQgKiBiZSByZS1hdHRhY2hlZCBtdWx0aXBsZSB0aW1lcy5cblx0ICogQHBhcmFtIHsoc3RyaW5nfEVsZW1lbnQpPX0gb3B0X3BhcmVudEVsZW1lbnQgT3B0aW9uYWwgcGFyZW50IGVsZW1lbnRcblx0ICogICAgIHRvIHJlbmRlciB0aGUgY29tcG9uZW50LlxuXHQgKiBAcGFyYW0geyhzdHJpbmd8RWxlbWVudCk9fSBvcHRfc2libGluZ0VsZW1lbnQgT3B0aW9uYWwgc2libGluZyBlbGVtZW50XG5cdCAqICAgICB0byByZW5kZXIgdGhlIGNvbXBvbmVudCBiZWZvcmUgaXQuIFJlbGV2YW50IHdoZW4gdGhlIGNvbXBvbmVudCBuZWVkc1xuXHQgKiAgICAgdG8gYmUgcmVuZGVyZWQgYmVmb3JlIGFuIGV4aXN0aW5nIGVsZW1lbnQgaW4gdGhlIERPTS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRhdHRhY2gob3B0X3BhcmVudEVsZW1lbnQsIG9wdF9zaWJsaW5nRWxlbWVudCkge1xuXHRcdGlmICghdGhpcy5lbGVtZW50KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoQ29tcG9uZW50LkVycm9yLkVMRU1FTlRfTk9UX0NSRUFURUQpO1xuXHRcdH1cblx0XHRpZiAoIXRoaXMuaW5Eb2N1bWVudCkge1xuXHRcdFx0dGhpcy5yZW5kZXJFbGVtZW50XyhvcHRfcGFyZW50RWxlbWVudCwgb3B0X3NpYmxpbmdFbGVtZW50KTtcblx0XHRcdHRoaXMuaW5Eb2N1bWVudCA9IHRydWU7XG5cdFx0XHR0aGlzLmVtaXQoJ2F0dGFjaGVkJyk7XG5cdFx0XHR0aGlzLmF0dGFjaGVkKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gV2hlbiBhdHRhY2hlZCwgdGhlIGNvbXBvbmVudCBlbGVtZW50IGlzIGFwcGVuZGVkIHRvIHRoZSBET01cblx0ICogYW5kIGFueSBvdGhlciBhY3Rpb24gdG8gYmUgcGVyZm9ybWVkIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gdGhpcyBtZXRob2QsXG5cdCAqIHN1Y2ggYXMsIGJpbmRpbmcgRE9NIGV2ZW50cy4gQSBjb21wb25lbnQgY2FuIGJlIHJlLWF0dGFjaGVkIG11bHRpcGxlXG5cdCAqIHRpbWVzLCB0aGVyZWZvcmUgdGhlIHVuZG8gYmVoYXZpb3IgZm9yIGFueSBhY3Rpb24gcGVyZm9ybWVkIGluIHRoaXMgcGhhc2Vcblx0ICogbXVzdCBiZSBpbXBsZW1lbnRlZCBvbiB0aGUgZGV0YWNoIHBoYXNlLlxuXHQgKi9cblx0YXR0YWNoZWQoKSB7fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgc3ViIGNvbXBvbmVudCwgY3JlYXRpbmcgaXQgaWYgaXQgZG9lc24ndCB5ZXQgZXhpc3QuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcblx0ICogQHBhcmFtIHtzdHJpbmd8IUZ1bmN0aW9ufSBjb21wb25lbnROYW1lT3JDdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2RhdGFcblx0ICogQHJldHVybiB7IUNvbXBvbmVudH1cblx0ICovXG5cdGFkZFN1YkNvbXBvbmVudChrZXksIGNvbXBvbmVudE5hbWVPckN0b3IsIG9wdF9kYXRhKSB7XG5cdFx0aWYgKCF0aGlzLmNvbXBvbmVudHNba2V5XSkge1xuXHRcdFx0dmFyIENvbnN0cnVjdG9yRm4gPSBjb21wb25lbnROYW1lT3JDdG9yO1xuXHRcdFx0aWYgKGNvcmUuaXNTdHJpbmcoQ29uc3RydWN0b3JGbikpIHtcblx0XHRcdFx0Q29uc3RydWN0b3JGbiA9IENvbXBvbmVudFJlZ2lzdHJ5LmdldENvbnN0cnVjdG9yKGNvbXBvbmVudE5hbWVPckN0b3IpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5jb21wb25lbnRzW2tleV0gPSBuZXcgQ29uc3RydWN0b3JGbihvcHRfZGF0YSwgZmFsc2UpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5jb21wb25lbnRzW2tleV07XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGp1c3QgYmVlbiBjcmVhdGVkLCBiZWZvcmVcblx0ICogaXQncyByZW5kZXJlZC5cblx0ICovXG5cdGNyZWF0ZWQoKSB7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyB0aGUgcmVuZGVyZXIgZm9yIHRoaXMgY29tcG9uZW50LiBTdWIgY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyB0b1xuXHQgKiByZXR1cm4gYSBjdXN0b20gcmVuZGVyZXIgYXMgbmVlZGVkLlxuXHQgKiBAcmV0dXJuIHshQ29tcG9uZW50UmVuZGVyZXJ9XG5cdCAqL1xuXHRjcmVhdGVSZW5kZXJlcigpIHtcblx0XHRjb3JlLm1lcmdlU3VwZXJDbGFzc2VzUHJvcGVydHkodGhpcy5jb25zdHJ1Y3RvciwgJ1JFTkRFUkVSJywgYXJyYXkuZmlyc3REZWZpbmVkVmFsdWUpO1xuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvci5SRU5ERVJFUl9NRVJHRUQodGhpcyk7XG5cdH1cblxuXHQvKipcblx0ICogTGlzdGVucyB0byBhIGRlbGVnYXRlIGV2ZW50IG9uIHRoZSBjb21wb25lbnQncyBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gdG8uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBUaGUgc2VsZWN0b3IgdGhhdCBtYXRjaGVzIHRoZSBjaGlsZCBlbGVtZW50cyB0aGF0XG5cdCAqICAgdGhlIGV2ZW50IHNob3VsZCBiZSB0cmlnZ2VyZWQgZm9yLlxuXHQgKiBAcGFyYW0geyFmdW5jdGlvbighT2JqZWN0KX0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzXG5cdCAqICAgdHJpZ2dlcmVkLiBJdCB3aWxsIHJlY2VpdmUgdGhlIG5vcm1hbGl6ZWQgZXZlbnQgb2JqZWN0LlxuXHQgKiBAcmV0dXJuIHshRXZlbnRIYW5kbGV9IENhbiBiZSB1c2VkIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG5cdCAqL1xuXHRkZWxlZ2F0ZShldmVudE5hbWUsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuXHRcdHJldHVybiB0aGlzLm9uKCdkZWxlZ2F0ZTonICsgZXZlbnROYW1lICsgJzonICsgc2VsZWN0b3IsIGNhbGxiYWNrKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbnZva2VzIHRoZSBkZXRhY2hlZCBMaWZlY3ljbGUuIFdoZW4gZGV0YWNoZWQsIHRoZSBjb21wb25lbnQgZWxlbWVudCBpc1xuXHQgKiByZW1vdmVkIGZyb20gdGhlIERPTSBhbmQgYW55IG90aGVyIGFjdGlvbiB0byBiZSBwZXJmb3JtZWQgbXVzdCBiZVxuXHQgKiBpbXBsZW1lbnRlZCBpbiB0aGlzIG1ldGhvZCwgc3VjaCBhcywgdW5iaW5kaW5nIERPTSBldmVudHMuIEEgY29tcG9uZW50XG5cdCAqIGNhbiBiZSBkZXRhY2hlZCBtdWx0aXBsZSB0aW1lcy5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0ZGV0YWNoKCkge1xuXHRcdGlmICh0aGlzLmluRG9jdW1lbnQpIHtcblx0XHRcdGlmICh0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5pbkRvY3VtZW50ID0gZmFsc2U7XG5cdFx0XHR0aGlzLmRldGFjaGVkKCk7XG5cdFx0fVxuXHRcdHRoaXMuZW1pdCgnZGV0YWNoZWQnKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFdoZW4gZGV0YWNoZWQsIHRoZSBjb21wb25lbnQgZWxlbWVudCBpcyByZW1vdmVkIGZyb20gdGhlIERPTVxuXHQgKiBhbmQgYW55IG90aGVyIGFjdGlvbiB0byBiZSBwZXJmb3JtZWQgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiB0aGlzIG1ldGhvZCxcblx0ICogc3VjaCBhcywgdW5iaW5kaW5nIERPTSBldmVudHMuIEEgY29tcG9uZW50IGNhbiBiZSBkZXRhY2hlZCBtdWx0aXBsZVxuXHQgKiB0aW1lcywgdGhlcmVmb3JlIHRoZSB1bmRvIGJlaGF2aW9yIGZvciBhbnkgYWN0aW9uIHBlcmZvcm1lZCBpbiB0aGlzIHBoYXNlXG5cdCAqIG11c3QgYmUgaW1wbGVtZW50ZWQgb24gdGhlIGF0dGFjaCBwaGFzZS5cblx0ICovXG5cdGRldGFjaGVkKCkge31cblxuXHQvKipcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG5cdGRpc3Bvc2VJbnRlcm5hbCgpIHtcblx0XHR0aGlzLmRldGFjaCgpO1xuXG5cdFx0aWYgKHRoaXMuZWxlbWVudEV2ZW50UHJveHlfKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnRFdmVudFByb3h5Xy5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLmVsZW1lbnRFdmVudFByb3h5XyA9IG51bGw7XG5cdFx0fVxuXG5cdFx0dGhpcy5kaXNwb3NlU3ViQ29tcG9uZW50cyhPYmplY3Qua2V5cyh0aGlzLmNvbXBvbmVudHMpKTtcblx0XHR0aGlzLmNvbXBvbmVudHMgPSBudWxsO1xuXG5cdFx0dGhpcy5yZW5kZXJlcl8uZGlzcG9zZSgpO1xuXHRcdHRoaXMucmVuZGVyZXJfID0gbnVsbDtcblxuXHRcdHN1cGVyLmRpc3Bvc2VJbnRlcm5hbCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGxzIGBkaXNwb3NlYCBvbiBhbGwgc3ViY29tcG9uZW50cy5cblx0ICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0ga2V5c1xuXHQgKi9cblx0ZGlzcG9zZVN1YkNvbXBvbmVudHMoa2V5cykge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c1trZXlzW2ldXTtcblx0XHRcdGlmICghY29tcG9uZW50LmlzRGlzcG9zZWQoKSkge1xuXHRcdFx0XHRjb21wb25lbnQuZGlzcG9zZSgpO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5jb21wb25lbnRzW2tleXNbaV1dO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBFeHRyYWN0cyBsaXN0ZW5lciBpbmZvIGZyb20gdGhlIGdpdmVuIHZhbHVlLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uKCl8c3RyaW5nfHtzZWxlY3RvcjpzdHJpbmcsZm46ZnVuY3Rpb24oKXxzdHJpbmd9fSB2YWx1ZVxuXHQgKiBAcmV0dXJuIHshe3NlbGVjdG9yOnN0cmluZyxmbjpmdW5jdGlvbigpfX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0ZXh0cmFjdExpc3RlbmVySW5mb18odmFsdWUpIHtcblx0XHR2YXIgaW5mbyA9IHtcblx0XHRcdGZuOiB2YWx1ZVxuXHRcdH07XG5cdFx0aWYgKGNvcmUuaXNPYmplY3QodmFsdWUpICYmICFjb3JlLmlzRnVuY3Rpb24odmFsdWUpKSB7XG5cdFx0XHRpbmZvLnNlbGVjdG9yID0gdmFsdWUuc2VsZWN0b3I7XG5cdFx0XHRpbmZvLmZuID0gdmFsdWUuZm47XG5cdFx0fVxuXHRcdGlmIChjb3JlLmlzU3RyaW5nKGluZm8uZm4pKSB7XG5cdFx0XHRpbmZvLmZuID0gdGhpcy5nZXRMaXN0ZW5lckZuKGluZm8uZm4pO1xuXHRcdH1cblx0XHRyZXR1cm4gaW5mbztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgdG8gdGhpcyBjb21wb25lbnQncyBjb25zdHJ1Y3Rvci5cblx0ICogQHJldHVybiB7IU9iamVjdH1cblx0ICovXG5cdGdldEluaXRpYWxDb25maWcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5pdGlhbENvbmZpZ187XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gZnJvbSBpdHMgbmFtZS4gSWYgdGhlIG5hbWUgaXMgcHJlZml4ZWQgd2l0aCBhXG5cdCAqIGNvbXBvbmVudCBpZCwgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIG9uIHRoYXQgc3BlY2lmaWVkIGNvbXBvbmVudC4gT3RoZXJ3aXNlXG5cdCAqIGl0IHdpbGwgYmUgY2FsbGVkIG9uIHRoaXMgY29tcG9uZW50IGluc3RlYWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmbk5hbWVcblx0ICogQHJldHVybiB7ZnVuY3Rpb24oKX1cblx0ICovXG5cdGdldExpc3RlbmVyRm4oZm5OYW1lKSB7XG5cdFx0aWYgKGNvcmUuaXNGdW5jdGlvbih0aGlzW2ZuTmFtZV0pKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1tmbk5hbWVdLmJpbmQodGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ05vIGZ1bmN0aW9uIG5hbWVkIFwiJyArIGZuTmFtZSArICdcIiB3YXMgZm91bmQgaW4gdGhlICcgK1xuXHRcdFx0ICAnY29tcG9uZW50IFwiJyArIGNvcmUuZ2V0RnVuY3Rpb25OYW1lKHRoaXMuY29uc3RydWN0b3IpICsgJ1wiLiBNYWtlICcgK1xuXHRcdFx0XHQnc3VyZSB0aGF0IHlvdSBzcGVjaWZ5IHZhbGlkIGZ1bmN0aW9uIG5hbWVzIHdoZW4gYWRkaW5nIGlubGluZSBsaXN0ZW5lcnMuJ1xuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbHMgdGhlIHN5bmNocm9uaXphdGlvbiBmdW5jdGlvbiBmb3IgdGhlIHN0YXRlIGtleS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleVxuXHQgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBPYmplY3Q+PX0gb3B0X2NoYW5nZSBPYmplY3QgY29udGFpbmluZyBuZXdWYWwgYW5kXG5cdCAqICAgICBwcmV2VmFsIGtleXMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGZpcmVTdGF0ZUtleUNoYW5nZV8oa2V5LCBvcHRfY2hhbmdlKSB7XG5cdFx0dmFyIGZuID0gdGhpc1snc3luYycgKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSldO1xuXHRcdGlmIChjb3JlLmlzRnVuY3Rpb24oZm4pKSB7XG5cdFx0XHRpZiAoIW9wdF9jaGFuZ2UpIHtcblx0XHRcdFx0b3B0X2NoYW5nZSA9IHtcblx0XHRcdFx0XHRuZXdWYWw6IHRoaXNba2V5XSxcblx0XHRcdFx0XHRwcmV2VmFsOiB1bmRlZmluZWRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGZuLmNhbGwodGhpcywgb3B0X2NoYW5nZS5uZXdWYWwsIG9wdF9jaGFuZ2UucHJldlZhbCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGBDb21wb25lbnRSZW5kZXJlcmAgaW5zdGFuY2UgYmVpbmcgdXNlZC5cblx0ICogQHJldHVybiB7IUNvbXBvbmVudFJlbmRlcmVyfVxuXHQgKi9cblx0Z2V0UmVuZGVyZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVuZGVyZXJfO1xuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgc3RhdGUgYmF0Y2ggY2hhbmdlcy4gQ2FsbHMgYW55IGV4aXN0aW5nIGBzeW5jYCBmdW5jdGlvbnMgdGhhdFxuXHQgKiBtYXRjaCB0aGUgY2hhbmdlZCBzdGF0ZSBrZXlzLlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRoYW5kbGVTdGF0ZUNoYW5nZWRfKGV2ZW50KSB7XG5cdFx0dGhpcy5zeW5jU3RhdGVGcm9tQ2hhbmdlc18oZXZlbnQuY2hhbmdlcyk7XG5cdFx0dGhpcy5lbWl0KCdzdGF0ZVN5bmNlZCcsIGV2ZW50KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIHRoZSBgbmV3TGlzdGVuZXJgIGV2ZW50LiBKdXN0IGZsYWdzIHRoYXQgdGhpcyBldmVudCB0eXBlIGhhcyBiZWVuXG5cdCAqIGF0dGFjaGVkLCBzbyB3ZSBjYW4gc3RhcnQgcHJveHlpbmcgaXQgd2hlbiBgRG9tRXZlbnRFbWl0dGVyUHJveHlgIGlzIGNyZWF0ZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRoYW5kbGVOZXdMaXN0ZW5lcl8oZXZlbnQpIHtcblx0XHR0aGlzLmF0dGFjaGVkTGlzdGVuZXJzX1tldmVudF0gPSB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1lcmdlcyBhbiBhcnJheSBvZiB2YWx1ZXMgZm9yIHRoZSBFTEVNRU5UX0NMQVNTRVMgcHJvcGVydHkgaW50byBhIHNpbmdsZSBvYmplY3QuXG5cdCAqIEBwYXJhbSB7IUFycmF5LjxzdHJpbmc+fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBiZSBtZXJnZWQuXG5cdCAqIEByZXR1cm4geyFzdHJpbmd9IFRoZSBtZXJnZWQgdmFsdWUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdG1lcmdlRWxlbWVudENsYXNzZXNfKHZhbHVlcykge1xuXHRcdHZhciBtYXJrZWQgPSB7fTtcblx0XHRyZXR1cm4gdmFsdWVzLmZpbHRlcihmdW5jdGlvbih2YWwpIHtcblx0XHRcdGlmICghdmFsIHx8IG1hcmtlZFt2YWxdKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hcmtlZFt2YWxdID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fSkuam9pbignICcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZpcmVkIHdoZW4gdGhlIGBlbGVtZW50YCBzdGF0ZSB2YWx1ZSBpcyBjaGFuZ2VkLlxuXHQgKiBAcGFyYW0geyFPYmplY3R9IGV2ZW50XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdG9uRWxlbWVudENoYW5nZWRfKGV2ZW50KSB7XG5cdFx0aWYgKGV2ZW50LnByZXZWYWwgPT09IGV2ZW50Lm5ld1ZhbCkge1xuXHRcdFx0Ly8gVGhlIGBlbGVtZW50Q2hhbmdlZGAgZXZlbnQgd2lsbCBiZSBmaXJlZCB3aGVuZXZlciB0aGUgZWxlbWVudCBpcyBzZXQsXG5cdFx0XHQvLyBldmVuIGlmIGl0cyB2YWx1ZSBoYXNuJ3QgYWN0dWFsbHkgY2hhbmdlZCwgc2luY2UgdGhhdCdzIGhvdyBTdGF0ZVxuXHRcdFx0Ly8gaGFuZGxlcyBvYmplY3RzLiBXZSBuZWVkIHRvIGNoZWNrIG1hbnVhbGx5IGhlcmUuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRVcFByb3h5XygpO1xuXHRcdHRoaXMuZWxlbWVudEV2ZW50UHJveHlfLnNldE9yaWdpbkVtaXR0ZXIoZXZlbnQubmV3VmFsKTtcblx0XHR0aGlzLmFkZEVsZW1lbnRDbGFzc2VzXygpO1xuXHRcdHRoaXMuc3luY1Zpc2libGUodGhpcy52aXNpYmxlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBGaXJlZCB3aGVuIHRoZSBgZXZlbnRzYCBzdGF0ZSB2YWx1ZSBpcyBjaGFuZ2VkLlxuXHQgKiBAcGFyYW0geyFPYmplY3R9IGV2ZW50XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdG9uRXZlbnRzQ2hhbmdlZF8oZXZlbnQpIHtcblx0XHR0aGlzLmV2ZW50c1N0YXRlS2V5SGFuZGxlcl8ucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cdFx0dGhpcy5hZGRMaXN0ZW5lcnNGcm9tT2JqXyhldmVudC5uZXdWYWwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgY29tcG9uZW50IGludG8gdGhlIERPTS5cblx0ICpcblx0ICogUmVuZGVyIExpZmVjeWNsZTpcblx0ICogICByZW5kZXIgZXZlbnQgLSBUaGUgXCJyZW5kZXJcIiBldmVudCBpcyBlbWl0dGVkLiBSZW5kZXJlcnMgYWN0IG9uIHRoaXMgc3RlcC5cblx0ICogICBzdGF0ZSBzeW5jaHJvbml6YXRpb24gLSBBbGwgc3luY2hyb25pemF0aW9uIG1ldGhvZHMgYXJlIGNhbGxlZC5cblx0ICogICBhdHRhY2ggLSBBdHRhY2ggTGlmZWN5Y2xlIGlzIGNhbGxlZC5cblx0ICpcblx0ICogQHBhcmFtIHsoc3RyaW5nfEVsZW1lbnR8Ym9vbGVhbik9fSBvcHRfcGFyZW50RWxlbWVudCBPcHRpb25hbCBwYXJlbnQgZWxlbWVudFxuXHQgKiAgICAgdG8gcmVuZGVyIHRoZSBjb21wb25lbnQuIElmIHNldCB0byBgZmFsc2VgLCB0aGUgZWxlbWVudCB3b24ndCBiZVxuXHQgKiAgICAgYXR0YWNoZWQgdG8gYW55IGVsZW1lbnQgYWZ0ZXIgcmVuZGVyaW5nLiBJbiB0aGlzIGNhc2UsIGBhdHRhY2hgIHNob3VsZFxuXHQgKiAgICAgYmUgY2FsbGVkIG1hbnVhbGx5IGxhdGVyIHRvIGFjdHVhbGx5IGF0dGFjaCBpdCB0byB0aGUgZG9tLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfc2tpcFJlbmRlciBPcHRpb25hbCBmbGFnIGluZGljYXRpbmcgdGhhdCB0aGUgYWN0dWFsXG5cdCAqICAgICByZW5kZXJpbmcgc2hvdWxkIGJlIHNraXBwZWQuIE9ubHkgdGhlIG90aGVyIHJlbmRlciBsaWZlY3ljbGUgbG9naWMgd2lsbFxuXHQgKiAgICAgYmUgcnVuLCBsaWtlIHN5bmNpbmcgc3RhdGUgYW5kIGF0dGFjaGluZyB0aGUgZWxlbWVudC4gU2hvdWxkIG9ubHlcblx0ICogICAgIGJlIHNldCBpZiB0aGUgY29tcG9uZW50IGhhcyBhbHJlYWR5IGJlZW4gcmVuZGVyZWQsIGxpa2Ugc3ViIGNvbXBvbmVudHMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHJlbmRlcl8ob3B0X3BhcmVudEVsZW1lbnQsIG9wdF9za2lwUmVuZGVyKSB7XG5cdFx0aWYgKCFvcHRfc2tpcFJlbmRlcikge1xuXHRcdFx0dGhpcy5lbWl0KCdyZW5kZXInKTtcblx0XHR9XG5cdFx0dGhpcy5zZXRVcFByb3h5XygpO1xuXHRcdHRoaXMuc3luY1N0YXRlXygpO1xuXHRcdHRoaXMuYXR0YWNoKG9wdF9wYXJlbnRFbGVtZW50KTtcblx0XHR0aGlzLndhc1JlbmRlcmVkID0gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50IGFzIGEgc3ViY29tcG9uZW50LCBtZWFuaW5nIHRoYXQgbm8gYWN0dWFsIHJlbmRlcmluZyBpc1xuXHQgKiBuZWVkZWQgc2luY2UgaXQgd2FzIGFscmVhZHkgcmVuZGVyZWQgYnkgdGhlIHBhcmVudCBjb21wb25lbnQuIFRoaXMganVzdCBoYW5kbGVzXG5cdCAqIG90aGVyIGxvZ2ljcyBmcm9tIHRoZSByZW5kZXJpbmcgbGlmZWN5Y2xlLCBsaWtlIGNhbGxpbmcgc3luYyBtZXRob2RzIGZvciB0aGVcblx0ICogc3RhdGUuXG5cdCAqL1xuXHRyZW5kZXJBc1N1YkNvbXBvbmVudCgpIHtcblx0XHR0aGlzLnJlbmRlcl8obnVsbCwgdHJ1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVuZGVycyB0aGUgY29tcG9uZW50IGVsZW1lbnQgaW50byB0aGUgRE9NLlxuXHQgKiBAcGFyYW0geyhzdHJpbmd8RWxlbWVudCk9fSBvcHRfcGFyZW50RWxlbWVudCBPcHRpb25hbCBwYXJlbnQgZWxlbWVudFxuXHQgKiAgICAgdG8gcmVuZGVyIHRoZSBjb21wb25lbnQuXG5cdCAqIEBwYXJhbSB7KHN0cmluZ3xFbGVtZW50KT19IG9wdF9zaWJsaW5nRWxlbWVudCBPcHRpb25hbCBzaWJsaW5nIGVsZW1lbnRcblx0ICogICAgIHRvIHJlbmRlciB0aGUgY29tcG9uZW50IGJlZm9yZSBpdC4gUmVsZXZhbnQgd2hlbiB0aGUgY29tcG9uZW50IG5lZWRzXG5cdCAqICAgICB0byBiZSByZW5kZXJlZCBiZWZvcmUgYW4gZXhpc3RpbmcgZWxlbWVudCBpbiB0aGUgRE9NLCBlLmcuXG5cdCAqICAgICBgY29tcG9uZW50LmF0dGFjaChudWxsLCBleGlzdGluZ0VsZW1lbnQpYC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cmVuZGVyRWxlbWVudF8ob3B0X3BhcmVudEVsZW1lbnQsIG9wdF9zaWJsaW5nRWxlbWVudCkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXHRcdGlmIChvcHRfc2libGluZ0VsZW1lbnQgfHwgIWVsZW1lbnQucGFyZW50Tm9kZSkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGRvbS50b0VsZW1lbnQob3B0X3BhcmVudEVsZW1lbnQpIHx8IHRoaXMuREVGQVVMVF9FTEVNRU5UX1BBUkVOVDtcblx0XHRcdHBhcmVudC5pbnNlcnRCZWZvcmUoZWxlbWVudCwgZG9tLnRvRWxlbWVudChvcHRfc2libGluZ0VsZW1lbnQpKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU2V0dGVyIGxvZ2ljIGZvciBlbGVtZW50IHN0YXRlIGtleS5cblx0ICogQHBhcmFtIHtzdHJpbmd8RWxlbWVudH0gbmV3VmFsXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gY3VycmVudFZhbFxuXHQgKiBAcmV0dXJuIHtFbGVtZW50fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzZXR0ZXJFbGVtZW50Rm5fKG5ld1ZhbCwgY3VycmVudFZhbCkge1xuXHRcdHJldHVybiBkb20udG9FbGVtZW50KG5ld1ZhbCkgfHwgY3VycmVudFZhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIHRoZSBgRG9tRXZlbnRFbWl0dGVyUHJveHlgIGluc3RhbmNlIGFuZCBoYXMgaXQgc3RhcnQgcHJveHlpbmcgYW55XG5cdCAqIGxpc3RlbmVycyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGxpc3RlbmVkIHRvLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzZXRVcFByb3h5XygpIHtcblx0XHRpZiAodGhpcy5lbGVtZW50RXZlbnRQcm94eV8pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcHJveHkgPSBuZXcgRG9tRXZlbnRFbWl0dGVyUHJveHkodGhpcy5lbGVtZW50LCB0aGlzKTtcblx0XHR0aGlzLmVsZW1lbnRFdmVudFByb3h5XyA9IHByb3h5O1xuXG5cdFx0b2JqZWN0Lm1hcCh0aGlzLmF0dGFjaGVkTGlzdGVuZXJzXywgcHJveHkucHJveHlFdmVudC5iaW5kKHByb3h5KSk7XG5cdFx0dGhpcy5hdHRhY2hlZExpc3RlbmVyc18gPSBudWxsO1xuXG5cdFx0dGhpcy5uZXdMaXN0ZW5lckhhbmRsZV8ucmVtb3ZlTGlzdGVuZXIoKTtcblx0XHR0aGlzLm5ld0xpc3RlbmVySGFuZGxlXyA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogRmlyZXMgc3RhdGUgc3luY2hyb25pemF0aW9uIGZ1bmN0aW9ucy5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c3luY1N0YXRlXygpIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuZ2V0U3RhdGVLZXlzKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLmZpcmVTdGF0ZUtleUNoYW5nZV8oa2V5c1tpXSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEZpcmVzIHN5bmNocm9uaXphdGlvbiBjaGFuZ2VzIGZvciBzdGF0ZSBrZXlzLlxuXHQgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBPYmplY3Q+fSBjaGFuZ2VzIE9iamVjdCBjb250YWluaW5nIHRoZSBzdGF0ZSBrZXlcblx0ICogICAgIG5hbWUgYXMga2V5IGFuZCBhbiBvYmplY3Qgd2l0aCBuZXdWYWwgYW5kIHByZXZWYWwgYXMgdmFsdWUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHN5bmNTdGF0ZUZyb21DaGFuZ2VzXyhjaGFuZ2VzKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIGNoYW5nZXMpIHtcblx0XHRcdHRoaXMuZmlyZVN0YXRlS2V5Q2hhbmdlXyhrZXksIGNoYW5nZXNba2V5XSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXRlIHN5bmNocm9uaXphdGlvbiBsb2dpYyBmb3IgdGhlIGBlbGVtZW50Q2xhc3Nlc2Agc3RhdGUga2V5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmV3VmFsXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwcmV2VmFsXG5cdCAqL1xuXHRzeW5jRWxlbWVudENsYXNzZXMobmV3VmFsLCBwcmV2VmFsKSB7XG5cdFx0aWYgKHRoaXMuZWxlbWVudCAmJiBwcmV2VmFsKSB7XG5cdFx0XHRkb20ucmVtb3ZlQ2xhc3Nlcyh0aGlzLmVsZW1lbnQsIHByZXZWYWwpO1xuXHRcdH1cblx0XHR0aGlzLmFkZEVsZW1lbnRDbGFzc2VzXygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXRlIHN5bmNocm9uaXphdGlvbiBsb2dpYyBmb3IgYHZpc2libGVgIHN0YXRlIGtleS5cblx0ICogVXBkYXRlcyB0aGUgZWxlbWVudCdzIGRpc3BsYXkgdmFsdWUgYWNjb3JkaW5nIHRvIGl0cyB2aXNpYmlsaXR5LlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IG5ld1ZhbFxuXHQgKi9cblx0c3luY1Zpc2libGUobmV3VmFsKSB7XG5cdFx0aWYgKHRoaXMuZWxlbWVudCkge1xuXHRcdFx0dGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBuZXdWYWwgPyAnJyA6ICdub25lJztcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVmFsaWRhdG9yIGxvZ2ljIGZvciBlbGVtZW50Q2xhc3NlcyBzdGF0ZSBrZXkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWxcblx0ICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWwgaXMgYSB2YWxpZCBlbGVtZW50IGNsYXNzZXMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHZhbGlkYXRvckVsZW1lbnRDbGFzc2VzRm5fKHZhbCkge1xuXHRcdHJldHVybiBjb3JlLmlzU3RyaW5nKHZhbCk7XG5cdH1cblxuXHQvKipcblx0ICogVmFsaWRhdG9yIGxvZ2ljIGZvciBlbGVtZW50IHN0YXRlIGtleS5cblx0ICogQHBhcmFtIHtzdHJpbmd8RWxlbWVudH0gdmFsXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmFsIGlzIGEgdmFsaWQgZWxlbWVudC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0dmFsaWRhdG9yRWxlbWVudEZuXyh2YWwpIHtcblx0XHRyZXR1cm4gY29yZS5pc0VsZW1lbnQodmFsKSB8fCBjb3JlLmlzU3RyaW5nKHZhbCk7XG5cdH1cblxuXHQvKipcblx0ICogVmFsaWRhdG9yIGxvZ2ljIGZvciB0aGUgYGV2ZW50c2Agc3RhdGUga2V5LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdmFsXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHZhbGlkYXRvckV2ZW50c0ZuXyh2YWwpIHtcblx0XHRyZXR1cm4gIWNvcmUuaXNEZWZBbmROb3ROdWxsKHZhbCkgfHwgY29yZS5pc09iamVjdCh2YWwpO1xuXHR9XG59XG5cbi8qKlxuICogQ29tcG9uZW50IHN0YXRlIGRlZmluaXRpb24uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHN0YXRpY1xuICovXG5Db21wb25lbnQuU1RBVEUgPSB7XG5cdC8qKlxuXHQgKiBDb21wb25lbnQgZWxlbWVudCBib3VuZGluZyBib3guXG5cdCAqIEB0eXBlIHtFbGVtZW50fVxuXHQgKiBAd3JpdGVPbmNlXG5cdCAqL1xuXHRlbGVtZW50OiB7XG5cdFx0c2V0dGVyOiAnc2V0dGVyRWxlbWVudEZuXycsXG5cdFx0dmFsaWRhdG9yOiAndmFsaWRhdG9yRWxlbWVudEZuXydcblx0fSxcblxuXHQvKipcblx0ICogQ1NTIGNsYXNzZXMgdG8gYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudC5cblx0ICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuXHQgKi9cblx0ZWxlbWVudENsYXNzZXM6IHtcblx0XHR2YWxpZGF0b3I6ICd2YWxpZGF0b3JFbGVtZW50Q2xhc3Nlc0ZuXydcblx0fSxcblxuXHQvKipcblx0ICogTGlzdGVuZXJzIHRoYXQgc2hvdWxkIGJlIGF0dGFjaGVkIHRvIHRoaXMgY29tcG9uZW50LiBTaG91bGQgYmUgcHJvdmlkZWQgYXMgYW4gb2JqZWN0LFxuXHQgKiB3aGVyZSB0aGUga2V5cyBhcmUgZXZlbnQgbmFtZXMgYW5kIHRoZSB2YWx1ZXMgYXJlIHRoZSBsaXN0ZW5lciBmdW5jdGlvbnMgKG9yIGZ1bmN0aW9uXG5cdCAqIG5hbWVzKS5cblx0ICogQHR5cGUge09iamVjdDxzdHJpbmcsIChmdW5jdGlvbigpfHN0cmluZ3x7c2VsZWN0b3I6IHN0cmluZywgZm46IGZ1bmN0aW9uKCl8c3RyaW5nfSk+fVxuXHQgKi9cblx0ZXZlbnRzOiB7XG5cdFx0dmFsaWRhdG9yOiAndmFsaWRhdG9yRXZlbnRzRm5fJyxcblx0XHR2YWx1ZTogbnVsbFxuXHR9LFxuXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgaWYgdGhlIGNvbXBvbmVudCBpcyB2aXNpYmxlIG9yIG5vdC5cblx0ICogQHR5cGUge2Jvb2xlYW59XG5cdCAqL1xuXHR2aXNpYmxlOiB7XG5cdFx0dmFsaWRhdG9yOiBjb3JlLmlzQm9vbGVhbixcblx0XHR2YWx1ZTogdHJ1ZVxuXHR9XG59O1xuXG4vKipcbiAqIENTUyBjbGFzc2VzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByb3RlY3RlZFxuICogQHN0YXRpY1xuICovXG5Db21wb25lbnQuRUxFTUVOVF9DTEFTU0VTID0gJyc7XG5cbi8qKlxuICogVGhlIGBDb21wb25lbnRSZW5kZXJlcmAgdGhhdCBzaG91bGQgYmUgdXNlZC4gQ29tcG9uZW50cyBuZWVkIHRvIHNldCB0aGlzXG4gKiB0byBhIHN1YmNsYXNzIG9mIGBDb21wb25lbnRSZW5kZXJlcmAgdGhhdCBoYXMgdGhlIHJlbmRlcmluZyBsb2dpYywgbGlrZVxuICogYFNveVJlbmRlcmVyYC5cbiAqIEB0eXBlIHshQ29tcG9uZW50UmVuZGVyZXJ9XG4gKiBAc3RhdGljXG4gKi9cbkNvbXBvbmVudC5SRU5ERVJFUiA9IENvbXBvbmVudFJlbmRlcmVyO1xuXG4vKipcbiAqIEVycm9ycyB0aHJvd24gYnkgdGhlIGNvbXBvbmVudC5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbkNvbXBvbmVudC5FcnJvciA9IHtcblx0LyoqXG5cdCAqIEVycm9yIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhdHRhY2hlZCBidXQgaXRzIGVsZW1lbnQgaGFzbid0IGJlZW4gY3JlYXRlZCB5ZXQuXG5cdCAqL1xuXHRFTEVNRU5UX05PVF9DUkVBVEVEOiAnQ2FuXFwndCBhdHRhY2ggY29tcG9uZW50IGVsZW1lbnQuIEl0IGhhc25cXCd0IGJlZW4gY3JlYXRlZCB5ZXQuJ1xufTtcblxuLyoqXG4gKiBBIGxpc3Qgd2l0aCBzdGF0ZSBrZXkgbmFtZXMgdGhhdCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgcmVqZWN0ZWQgYXMgaW52YWxpZC5cbiAqIEB0eXBlIHshQXJyYXk8c3RyaW5nPn1cbiAqL1xuQ29tcG9uZW50LklOVkFMSURfS0VZUyA9IFsnY29tcG9uZW50cyddO1xuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGNvcmUgfSBmcm9tICdtZXRhbCc7XG5cbi8qKlxuICogVGhlIGNvbXBvbmVudCByZWdpc3RyeSBpcyB1c2VkIHRvIHJlZ2lzdGVyIGNvbXBvbmVudHMsIHNvIHRoZXkgY2FuXG4gKiBiZSBhY2Nlc3NpYmxlIGJ5IG5hbWUuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5jbGFzcyBDb21wb25lbnRSZWdpc3RyeSB7XG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIGNvbXBvbmVudCBuYW1lLCBvclxuXHQgKiB1bmRlZmluZWQgaWYgaXQgaGFzbid0IGJlZW4gcmVnaXN0ZXJlZCB5ZXQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBjb21wb25lbnQncyBuYW1lLlxuXHQgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBnZXRDb25zdHJ1Y3RvcihuYW1lKSB7XG5cdFx0dmFyIGNvbnN0cnVjdG9yRm4gPSBDb21wb25lbnRSZWdpc3RyeS5jb21wb25lbnRzX1tuYW1lXTtcblx0XHRpZiAoIWNvbnN0cnVjdG9yRm4pIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXG5cdFx0XHRcdCdUaGVyZVxcJ3Mgbm8gY29uc3RydWN0b3IgcmVnaXN0ZXJlZCBmb3IgdGhlIGNvbXBvbmVudCAnICtcblx0XHRcdFx0J25hbWVkICcgKyBuYW1lICsgJy4gQ29tcG9uZW50cyBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgdmlhICcgK1xuXHRcdFx0XHQnQ29tcG9uZW50UmVnaXN0cnkucmVnaXN0ZXIuJ1xuXHRcdFx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvbnN0cnVjdG9yRm47XG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGEgY29tcG9uZW50LCBzbyBpdCBjYW4gYmUgZm91bmQgYnkgaXRzIG5hbWUuXG5cdCAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjb25zdHJ1Y3RvckZuIFRoZSBjb21wb25lbnQncyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbmFtZSBOYW1lIG9mIHRoZSByZWdpc3RlcmVkIGNvbXBvbmVudC4gSWYgbm9uZSBpcyBnaXZlblxuXHQgKiAgIHRoZSBuYW1lIGRlZmluZWQgYnkgdGhlIE5BTUUgc3RhdGljIHZhcmlhYmxlIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBJZiB0aGF0XG5cdCAqICAgaXNuJ3Qgc2V0IGFzIHdlbGwsIHRoZSBuYW1lIG9mIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB3aWxsIGJlIHVzZWQuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyByZWdpc3Rlcihjb25zdHJ1Y3RvckZuLCBvcHRfbmFtZSkge1xuXHRcdHZhciBuYW1lID0gb3B0X25hbWU7XG5cdFx0aWYgKCFuYW1lKSB7XG5cdFx0XHRpZiAoY29uc3RydWN0b3JGbi5oYXNPd25Qcm9wZXJ0eSgnTkFNRScpKSB7XG5cdFx0XHRcdG5hbWUgPSBjb25zdHJ1Y3RvckZuLk5BTUU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuYW1lID0gY29yZS5nZXRGdW5jdGlvbk5hbWUoY29uc3RydWN0b3JGbik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnN0cnVjdG9yRm4uTkFNRSA9IG5hbWU7XG5cdFx0Q29tcG9uZW50UmVnaXN0cnkuY29tcG9uZW50c19bbmFtZV0gPSBjb25zdHJ1Y3RvckZuO1xuXHR9XG59XG5cbi8qKlxuICogSG9sZHMgYWxsIHJlZ2lzdGVyZWQgY29tcG9uZW50cywgaW5kZXhlZCBieSB0aGVpciBuYW1lcy5cbiAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgZnVuY3Rpb24oKT59XG4gKiBAcHJvdGVjdGVkXG4gKiBAc3RhdGljXG4gKi9cbkNvbXBvbmVudFJlZ2lzdHJ5LmNvbXBvbmVudHNfID0ge307XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudFJlZ2lzdHJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIEV2ZW50SGFuZGxlciB9IGZyb20gJ21ldGFsLWV2ZW50cyc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyB0aGF0IGNvbXBvbmVudCByZW5kZXJlcnMgc2hvdWxkIGV4dGVuZCBmcm9tLiBJdCBkZWZpbmVzIHRoZVxuICogcmVxdWlyZWQgbWV0aG9kcyBhbGwgcmVuZGVyZXJzIHNob3VsZCBoYXZlLlxuICovXG5jbGFzcyBDb21wb25lbnRSZW5kZXJlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgYENvbXBvbmVudFJlbmRlcmVyYC5cblx0ICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0aGF0IHRoaXMgcmVuZGVyZXIgaXNcblx0ICogICAgIHJlc3BvbnNpYmxlIGZvci5cblx0ICovXG5cdGNvbnN0cnVjdG9yKGNvbXBvbmVudCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5jb21wb25lbnRfID0gY29tcG9uZW50O1xuXHRcdHRoaXMuY29tcG9uZW50UmVuZGVyZXJFdmVudHNfID0gbmV3IEV2ZW50SGFuZGxlcigpO1xuXHRcdHRoaXMuY29tcG9uZW50UmVuZGVyZXJFdmVudHNfLmFkZChcblx0XHRcdHRoaXMuY29tcG9uZW50Xy5vbignc3RhdGVDaGFuZ2VkJywgdGhpcy5oYW5kbGVDb21wb25lbnRSZW5kZXJlclN0YXRlQ2hhbmdlZF8uYmluZCh0aGlzKSksXG5cdFx0XHR0aGlzLmNvbXBvbmVudF8ub25jZSgncmVuZGVyJywgdGhpcy5yZW5kZXIuYmluZCh0aGlzKSlcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRkaXNwb3NlSW50ZXJuYWwoKSB7XG5cdFx0dGhpcy5jb21wb25lbnRSZW5kZXJlckV2ZW50c18ucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cdFx0dGhpcy5jb21wb25lbnRSZW5kZXJlckV2ZW50c18gPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgYW4gYHN0YXRlQ2hhbmdlZGAgZXZlbnQgZnJvbSB0aGlzIHJlbmRlcmVyJ3MgY29tcG9uZW50LiBDYWxscyB0aGVcblx0ICogYHVwZGF0ZWAgZnVuY3Rpb24gaWYgdGhlIGNvbXBvbmVudCBoYXMgYWxyZWFkeSBiZWVuIHJlbmRlcmVkIGZvciB0aGUgZmlyc3Rcblx0ICogdGltZS5cblx0ICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgT2JqZWN0Pn0gY2hhbmdlcyBPYmplY3QgY29udGFpbmluZyB0aGUgbmFtZXNcblx0ICogICAgIG9mIGFsbCBjaGFuZ2VkIHN0YXRlIGtleXMsIGVhY2ggbWFwcGVkIHRvIGFuIG9iamVjdCB3aXRoIGl0cyBuZXdcblx0ICogICAgIChuZXdWYWwpIGFuZCBwcmV2aW91cyAocHJldlZhbCkgdmFsdWVzLlxuXHQgKi9cblx0aGFuZGxlQ29tcG9uZW50UmVuZGVyZXJTdGF0ZUNoYW5nZWRfKGNoYW5nZXMpIHtcblx0XHRpZiAodGhpcy5jb21wb25lbnRfLndhc1JlbmRlcmVkKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZShjaGFuZ2VzKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVuZGVycyB0aGUgY29tcG9uZW50J3Mgd2hvbGUgY29udGVudCAoaW5jbHVkaW5nIGl0cyBtYWluIGVsZW1lbnQpLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGlmICghdGhpcy5jb21wb25lbnRfLmVsZW1lbnQpIHtcblx0XHRcdHRoaXMuY29tcG9uZW50Xy5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCdzIGVsZW1lbnQgaHRtbC4gVGhpcyBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieVxuXHQgKiB0aGUgY29tcG9uZW50IHdoZW4gdGhlIHZhbHVlIG9mIGF0IGxlYXN0IG9uZSBvZiBpdHMgc3RhdGUga2V5cyBoYXMgY2hhbmdlZC5cblx0ICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgT2JqZWN0Pn0gY2hhbmdlcyBPYmplY3QgY29udGFpbmluZyB0aGUgbmFtZXNcblx0ICogICAgIG9mIGFsbCBjaGFuZ2VkIHN0YXRlIGtleXMsIGVhY2ggbWFwcGVkIHRvIGFuIG9iamVjdCB3aXRoIGl0cyBuZXdcblx0ICogICAgIChuZXdWYWwpIGFuZCBwcmV2aW91cyAocHJldlZhbCkgdmFsdWVzLlxuXHQgKi9cblx0dXBkYXRlKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50UmVuZGVyZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IERpc3Bvc2FibGUgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgeyBFdmVudEhhbmRsZXIgfSBmcm9tICdtZXRhbC1ldmVudHMnO1xuXG4vKipcbiAqIENvbGxlY3RzIGlubGluZSBldmVudHMgZnJvbSBhIHBhc3NlZCBlbGVtZW50LCBkZXRhY2hpbmcgcHJldmlvdXNseVxuICogYXR0YWNoZWQgZXZlbnRzIHRoYXQgYXJlIG5vdCBiZWluZyB1c2VkIGFueW1vcmUuXG4gKiBAcGFyYW0ge0NvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtEaXNwb3NhYmxlfVxuICovXG5jbGFzcyBFdmVudHNDb2xsZWN0b3IgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcblx0Y29uc3RydWN0b3IoY29tcG9uZW50KSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdGlmICghY29tcG9uZW50KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjb21wb25lbnQgaW5zdGFuY2UgaXMgbWFuZGF0b3J5Jyk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgdGhlIGNvbXBvbmVudCBpbnRhbmNlLlxuXHRcdCAqIEB0eXBlIHshQ29tcG9uZW50fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLmNvbXBvbmVudF8gPSBjb21wb25lbnQ7XG5cblx0XHQvKipcblx0XHQgKiBIb2xkcyB0aGUgYXR0YWNoZWQgZGVsZWdhdGUgZXZlbnQgaGFuZGxlcywgaW5kZXhlZCBieSB0aGUgY3NzIHNlbGVjdG9yLlxuXHRcdCAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgRXZlbnRIYW5kbGVyPn1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5ldmVudEhhbmRsZXNfID0ge307XG5cblx0XHQvKipcblx0XHQgKiBIb2xkcyBmbGFncyBpbmRpY2F0aW5nIHdoaWNoIHNlbGVjdG9ycyBoYXZlIGxpc3RlbmVycy5cblx0XHQgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGJvb2xlYW4+fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLmhhc0xpc3RlbmVyXyA9IHt9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEF0dGFjaGVzIHRoZSBsaXN0ZW5lciBkZXNjcmliZWQgYnkgdGhlIGdpdmVuIHBhcmFtcywgdW5sZXNzIGl0IGhhcyBhbHJlYWR5XG5cdCAqIGJlZW4gYXR0YWNoZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZXNTdHJpbmdcblx0ICovXG5cdGF0dGFjaExpc3RlbmVyKGV2ZW50VHlwZSwgZm5OYW1lc1N0cmluZykge1xuXHRcdHZhciBzZWxlY3RvciA9ICdbZGF0YS1vbicgKyBldmVudFR5cGUgKyAnPVwiJyArIGZuTmFtZXNTdHJpbmcgKyAnXCJdJztcblxuXHRcdHRoaXMuaGFzTGlzdGVuZXJfW3NlbGVjdG9yXSA9IHRydWU7XG5cblx0XHRpZiAoIXRoaXMuZXZlbnRIYW5kbGVzX1tzZWxlY3Rvcl0pIHtcblx0XHRcdHRoaXMuZXZlbnRIYW5kbGVzX1tzZWxlY3Rvcl0gPSBuZXcgRXZlbnRIYW5kbGVyKCk7XG5cdFx0XHR2YXIgZm5OYW1lcyA9IGZuTmFtZXNTdHJpbmcuc3BsaXQoJywnKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZm5OYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgZm4gPSB0aGlzLmNvbXBvbmVudF8uZ2V0TGlzdGVuZXJGbihmbk5hbWVzW2ldKTtcblx0XHRcdFx0aWYgKGZuKSB7XG5cdFx0XHRcdFx0dGhpcy5ldmVudEhhbmRsZXNfW3NlbGVjdG9yXS5hZGQodGhpcy5jb21wb25lbnRfLmRlbGVnYXRlKGV2ZW50VHlwZSwgc2VsZWN0b3IsIHRoaXMub25FdmVudF8uYmluZCh0aGlzLCBmbikpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFsbCBwcmV2aW91c2x5IGF0dGFjaGVkIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgY29tcG9uZW50LlxuXHQgKi9cblx0ZGV0YWNoQWxsTGlzdGVuZXJzKCkge1xuXHRcdGZvciAodmFyIHNlbGVjdG9yIGluIHRoaXMuZXZlbnRIYW5kbGVzXykge1xuXHRcdFx0aWYgKHRoaXMuZXZlbnRIYW5kbGVzX1tzZWxlY3Rvcl0pIHtcblx0XHRcdFx0dGhpcy5ldmVudEhhbmRsZXNfW3NlbGVjdG9yXS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5ldmVudEhhbmRsZXNfID0ge307XG5cdFx0dGhpcy5saXN0ZW5lckNvdW50c18gPSB7fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXRhY2hlcyBhbGwgZXhpc3RpbmcgbGlzdGVuZXJzIHRoYXQgYXJlIG5vdCBiZWluZyB1c2VkIGFueW1vcmUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGRldGFjaFVudXNlZExpc3RlbmVycygpIHtcblx0XHRmb3IgKHZhciBzZWxlY3RvciBpbiB0aGlzLmV2ZW50SGFuZGxlc18pIHtcblx0XHRcdGlmICh0aGlzLmV2ZW50SGFuZGxlc19bc2VsZWN0b3JdICYmICF0aGlzLmhhc0xpc3RlbmVyX1tzZWxlY3Rvcl0pIHtcblx0XHRcdFx0dGhpcy5ldmVudEhhbmRsZXNfW3NlbGVjdG9yXS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblx0XHRcdFx0dGhpcy5ldmVudEhhbmRsZXNfW3NlbGVjdG9yXSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRkaXNwb3NlSW50ZXJuYWwoKSB7XG5cdFx0dGhpcy5kZXRhY2hBbGxMaXN0ZW5lcnMoKTtcblx0XHR0aGlzLmNvbXBvbmVudF8gPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZpcmVzIHdoZW4gYW4gZXZlbnQgdGhhdCB3YXMgcmVnaXN0ZXJlZCBieSB0aGlzIGNvbGxlY3RvciBpcyB0cmlnZ2VyZWQuIE1ha2VzXG5cdCAqIHN1cmUgdGhhdCB0aGUgZXZlbnQgd2FzIG1lYW50IGZvciB0aGlzIGNvbXBvbmVudCBhbmQgY2FsbHMgdGhlIGFwcHJvcHJpYXRlXG5cdCAqIGxpc3RlbmVyIGZ1bmN0aW9uIGZvciBpdC5cblx0ICogQHBhcmFtIHshZnVuY3Rpb24oIU9iamVjdCl9IGZuXG5cdCAqIEBwYXJhbSB7IU9iamVjdH0gZXZlbnRcblx0ICogQHJldHVybiB7Kn0gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbCB0byB0aGUgbGlzdGVuZXIgZnVuY3Rpb24sIG9yIHVuZGVmaW5lZFxuXHQgKiAgIGlmIG5vIGZ1bmN0aW9uIHdhcyBjYWxsZWQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdG9uRXZlbnRfKGZuLCBldmVudCkge1xuXHRcdC8vIFRoaXMgY2hlY2sgcHJldmVudHMgcGFyZW50IGNvbXBvbmVudHMgZnJvbSBoYW5kbGluZyB0aGVpciBjaGlsZCBpbmxpbmUgbGlzdGVuZXJzLlxuXHRcdHZhciBldmVudENvbXAgPSBldmVudC5oYW5kbGVkQnlDb21wb25lbnQ7XG5cdFx0aWYgKCFldmVudENvbXAgfHwgZXZlbnRDb21wID09PSB0aGlzLmNvbXBvbmVudF8gfHwgZXZlbnQuZGVsZWdhdGVUYXJnZXQuY29udGFpbnMoZXZlbnRDb21wLmVsZW1lbnQpKSB7XG5cdFx0XHRldmVudC5oYW5kbGVkQnlDb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudF87XG5cdFx0XHRyZXR1cm4gZm4oZXZlbnQpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBQcmVwYXJlcyB0aGUgY29sbGVjdG9yIHRvIHN0YXJ0IGNvbGxlY3RpbmcgbGlzdGVuZXJzLiBTaG91bGQgYmUgY2FsbGVkXG5cdCAqIGJlZm9yZSBhbGwgY2FsbHMgdG8gYGF0dGFjaExpc3RlbmVyYC5cblx0ICovXG5cdHN0YXJ0Q29sbGVjdGluZygpIHtcblx0XHR0aGlzLmhhc0xpc3RlbmVyXyA9IHt9O1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50c0NvbGxlY3RvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9Db21wb25lbnQnO1xuaW1wb3J0IENvbXBvbmVudFJlZ2lzdHJ5IGZyb20gJy4uL0NvbXBvbmVudFJlZ2lzdHJ5JztcbmltcG9ydCBDb21wb25lbnRSZW5kZXJlciBmcm9tICcuLi9Db21wb25lbnRSZW5kZXJlcic7XG5pbXBvcnQgRXZlbnRzQ29sbGVjdG9yIGZyb20gJy4uL0V2ZW50c0NvbGxlY3Rvcic7XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudDtcbmV4cG9ydCB7XG5cdENvbXBvbmVudCxcblx0Q29tcG9uZW50UmVnaXN0cnksXG5cdENvbXBvbmVudFJlbmRlcmVyLFxuXHRFdmVudHNDb2xsZWN0b3Jcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBkb20gZnJvbSAnLi9kb20nO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyUHJveHkgfSBmcm9tICdtZXRhbC1ldmVudHMnO1xuXG4vKipcbiAqIERvbUV2ZW50RW1pdHRlclByb3h5IHV0aWxpdHkuIEl0IGV4dGVuZHMgYEV2ZW50RW1pdHRlclByb3h5YCB0byBhbHNvIGFjY2VwdFxuICogZG9tIGVsZW1lbnRzIGFzIG9yaWdpbiBlbWl0dGVycy5cbiAqIEBleHRlbmRzIHtFdmVudEVtaXR0ZXJQcm94eX1cbiAqL1xuY2xhc3MgRG9tRXZlbnRFbWl0dGVyUHJveHkgZXh0ZW5kcyBFdmVudEVtaXR0ZXJQcm94eSB7XG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBnaXZlbiBsaXN0ZW5lciBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQuXG5cdCAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGxpc3RlbmVyXG5cdCAqIEByZXR1cm4geyFFdmVudEhhbmRsZX0gVGhlIGxpc3RlbmVkIGV2ZW50J3MgaGFuZGxlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBvdmVycmlkZVxuXHQgKi9cblx0YWRkTGlzdGVuZXJfKGV2ZW50LCBsaXN0ZW5lcikge1xuXHRcdGlmICh0aGlzLm9yaWdpbkVtaXR0ZXJfLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdGlmIChldmVudC5zdGFydHNXaXRoKCdkZWxlZ2F0ZTonKSkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSBldmVudC5pbmRleE9mKCc6JywgOSk7XG5cdFx0XHRcdHZhciBldmVudE5hbWUgPSBldmVudC5zdWJzdHJpbmcoOSwgaW5kZXgpO1xuXHRcdFx0XHR2YXIgc2VsZWN0b3IgPSBldmVudC5zdWJzdHJpbmcoaW5kZXggKyAxKTtcblx0XHRcdFx0cmV0dXJuIGRvbS5kZWxlZ2F0ZSh0aGlzLm9yaWdpbkVtaXR0ZXJfLCBldmVudE5hbWUsIHNlbGVjdG9yLCBsaXN0ZW5lcik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gZG9tLm9uKHRoaXMub3JpZ2luRW1pdHRlcl8sIGV2ZW50LCBsaXN0ZW5lcik7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBzdXBlci5hZGRMaXN0ZW5lcl8oZXZlbnQsIGxpc3RlbmVyKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBldmVudCBpcyBzdXBwb3J0ZWQgYnkgdGhlIG9yaWdpbiBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0aXNTdXBwb3J0ZWREb21FdmVudF8oZXZlbnQpIHtcblx0XHRyZXR1cm4gKGV2ZW50LnN0YXJ0c1dpdGgoJ2RlbGVnYXRlOicpICYmIGV2ZW50LmluZGV4T2YoJzonLCA5KSAhPT0gLTEpIHx8XG5cdFx0XHRkb20uc3VwcG9ydHNFdmVudCh0aGlzLm9yaWdpbkVtaXR0ZXJfLCBldmVudCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBldmVudCBzaG91bGQgYmUgcHJveGllZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQG92ZXJyaWRlXG5cdCAqL1xuXHRzaG91bGRQcm94eUV2ZW50XyhldmVudCkge1xuXHRcdHJldHVybiBzdXBlci5zaG91bGRQcm94eUV2ZW50XyhldmVudCkgJiZcblx0XHRcdCghdGhpcy5vcmlnaW5FbWl0dGVyXy5hZGRFdmVudExpc3RlbmVyIHx8IHRoaXMuaXNTdXBwb3J0ZWREb21FdmVudF8oZXZlbnQpKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBEb21FdmVudEVtaXR0ZXJQcm94eTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgRXZlbnRIYW5kbGUgfSBmcm9tICdtZXRhbC1ldmVudHMnO1xuXG4vKipcbiAqIFRoaXMgaXMgYSBzcGVjaWFsIEV2ZW50SGFuZGxlLCB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBkb20gZXZlbnRzLCBpbnN0ZWFkXG4gKiBvZiBFdmVudEVtaXR0ZXIgZXZlbnRzLlxuICogQGV4dGVuZHMge0V2ZW50SGFuZGxlfVxuICovXG5jbGFzcyBEb21FdmVudEhhbmRsZSBleHRlbmRzIEV2ZW50SGFuZGxlIHtcblx0LyoqXG5cdCAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgYERvbUV2ZW50SGFuZGxlYC5cblx0ICogQHBhcmFtIHshRXZlbnRFbWl0dGVyfSBlbWl0dGVyIEVtaXR0ZXIgdGhlIGV2ZW50IHdhcyBzdWJzY3JpYmVkIHRvLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRoYXQgd2FzIHN1YnNjcmliZWQgdG8uXG5cdCAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgc3Vic2NyaWJlZCB0byB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0X2NhcHR1cmUgRmxhZyBpbmRpY2F0aW5nIGlmIGxpc3RlbmVyIHNob3VsZCBiZSB0cmlnZ2VyZWRcblx0ICogICBkdXJpbmcgY2FwdHVyZSBwaGFzZSwgaW5zdGVhZCBvZiBkdXJpbmcgdGhlIGJ1YmJsaW5nIHBoYXNlLiBEZWZhdWx0cyB0byBmYWxzZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihlbWl0dGVyLCBldmVudCwgbGlzdGVuZXIsIG9wdF9jYXB0dXJlKSB7XG5cdFx0c3VwZXIoZW1pdHRlciwgZXZlbnQsIGxpc3RlbmVyKTtcblx0XHR0aGlzLmNhcHR1cmVfID0gb3B0X2NhcHR1cmU7XG5cdH1cblxuXHQvKipcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG5cdHJlbW92ZUxpc3RlbmVyKCkge1xuXHRcdHRoaXMuZW1pdHRlcl8ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50XywgdGhpcy5saXN0ZW5lcl8sIHRoaXMuY2FwdHVyZV8pO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERvbUV2ZW50SGFuZGxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgZG9tIGZyb20gJy4uL2RvbSc7XG5pbXBvcnQgRG9tRXZlbnRFbWl0dGVyUHJveHkgZnJvbSAnLi4vRG9tRXZlbnRFbWl0dGVyUHJveHknO1xuaW1wb3J0IERvbUV2ZW50SGFuZGxlIGZyb20gJy4uL0RvbUV2ZW50SGFuZGxlJztcbmltcG9ydCBmZWF0dXJlcyBmcm9tICcuLi9mZWF0dXJlcyc7XG5pbXBvcnQgZ2xvYmFsRXZhbCBmcm9tICcuLi9nbG9iYWxFdmFsJztcbmltcG9ydCBnbG9iYWxFdmFsU3R5bGVzIGZyb20gJy4uL2dsb2JhbEV2YWxTdHlsZXMnO1xuaW1wb3J0ICcuLi9ldmVudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBkb207XG5leHBvcnQgeyBkb20sIERvbUV2ZW50RW1pdHRlclByb3h5LCBEb21FdmVudEhhbmRsZSwgZmVhdHVyZXMsIGdsb2JhbEV2YWwsIGdsb2JhbEV2YWxTdHlsZXMgfTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSwgb2JqZWN0IH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IERvbUV2ZW50SGFuZGxlIGZyb20gJy4vRG9tRXZlbnRIYW5kbGUnO1xuXG5jbGFzcyBkb20ge1xuXHQvKipcblx0ICogQWRkcyB0aGUgcmVxdWVzdGVkIENTUyBjbGFzc2VzIHRvIGFuIGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gYWRkIENTUyBjbGFzc2VzIHRvLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NlcyBDU1MgY2xhc3NlcyB0byBhZGQuXG5cdCAqL1xuXHRzdGF0aWMgYWRkQ2xhc3NlcyhlbGVtZW50LCBjbGFzc2VzKSB7XG5cdFx0aWYgKCFjb3JlLmlzT2JqZWN0KGVsZW1lbnQpIHx8ICFjb3JlLmlzU3RyaW5nKGNsYXNzZXMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCdjbGFzc0xpc3QnIGluIGVsZW1lbnQpIHtcblx0XHRcdGRvbS5hZGRDbGFzc2VzV2l0aE5hdGl2ZV8oZWxlbWVudCwgY2xhc3Nlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRvbS5hZGRDbGFzc2VzV2l0aG91dE5hdGl2ZV8oZWxlbWVudCwgY2xhc3Nlcyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIHJlcXVlc3RlZCBDU1MgY2xhc3NlcyB0byBhbiBlbGVtZW50IHVzaW5nIGNsYXNzTGlzdC5cblx0ICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBhZGQgQ1NTIGNsYXNzZXMgdG8uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc2VzIENTUyBjbGFzc2VzIHRvIGFkZC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c3RhdGljIGFkZENsYXNzZXNXaXRoTmF0aXZlXyhlbGVtZW50LCBjbGFzc2VzKSB7XG5cdFx0Y2xhc3Nlcy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG5cdFx0XHRpZiAoY2xhc3NOYW1lKSB7XG5cdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIHJlcXVlc3RlZCBDU1MgY2xhc3NlcyB0byBhbiBlbGVtZW50IHdpdGhvdXQgdXNpbmcgY2xhc3NMaXN0LlxuXHQgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGFkZCBDU1MgY2xhc3NlcyB0by5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzZXMgQ1NTIGNsYXNzZXMgdG8gYWRkLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzdGF0aWMgYWRkQ2xhc3Nlc1dpdGhvdXROYXRpdmVfKGVsZW1lbnQsIGNsYXNzZXMpIHtcblx0XHR2YXIgZWxlbWVudENsYXNzTmFtZSA9ICcgJyArIGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnO1xuXHRcdHZhciBjbGFzc2VzVG9BcHBlbmQgPSAnJztcblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzLnNwbGl0KCcgJyk7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBjbGFzc05hbWUgPSBjbGFzc2VzW2ldO1xuXG5cdFx0XHRpZiAoZWxlbWVudENsYXNzTmFtZS5pbmRleE9mKCcgJyArIGNsYXNzTmFtZSArICcgJykgPT09IC0xKSB7XG5cdFx0XHRcdGNsYXNzZXNUb0FwcGVuZCArPSAnICcgKyBjbGFzc05hbWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGNsYXNzZXNUb0FwcGVuZCkge1xuXHRcdFx0ZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZSArIGNsYXNzZXNUb0FwcGVuZDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgY2xvc2VzdCBlbGVtZW50IHVwIHRoZSB0cmVlIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQgKGluY2x1ZGluZ1xuXHQgKiBpdHNlbGYpIHRoYXQgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIHNlbGVjdG9yLCBvciBudWxsIGlmIG5vbmUgbWF0Y2guXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3Jcblx0ICogQHJldHVybiB7RWxlbWVudH1cblx0ICovXG5cdHN0YXRpYyBjbG9zZXN0KGVsZW1lbnQsIHNlbGVjdG9yKSB7XG5cdFx0d2hpbGUgKGVsZW1lbnQgJiYgIWRvbS5tYXRjaChlbGVtZW50LCBzZWxlY3RvcikpIHtcblx0XHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtZW50O1xuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGVuZHMgYSBjaGlsZCBub2RlIHdpdGggdGV4dCBvciBvdGhlciBub2RlcyB0byBhIHBhcmVudCBub2RlLiBJZlxuXHQgKiBjaGlsZCBpcyBhIEhUTUwgc3RyaW5nIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYSBkb2N1bWVudFxuXHQgKiBmcmFnbWVudCBiZWZvcmUgYXBwZW5kaW5nIGl0IHRvIHRoZSBwYXJlbnQuXG5cdCAqIEBwYXJhbSB7IUVsZW1lbnR9IHBhcmVudCBUaGUgbm9kZSB0byBhcHBlbmQgbm9kZXMgdG8uXG5cdCAqIEBwYXJhbSB7IShFbGVtZW50fE5vZGVMaXN0fHN0cmluZyl9IGNoaWxkIFRoZSB0aGluZyB0byBhcHBlbmQgdG8gdGhlIHBhcmVudC5cblx0ICogQHJldHVybiB7IUVsZW1lbnR9IFRoZSBhcHBlbmRlZCBjaGlsZC5cblx0ICovXG5cdHN0YXRpYyBhcHBlbmQocGFyZW50LCBjaGlsZCkge1xuXHRcdGlmIChjb3JlLmlzU3RyaW5nKGNoaWxkKSkge1xuXHRcdFx0Y2hpbGQgPSBkb20uYnVpbGRGcmFnbWVudChjaGlsZCk7XG5cdFx0fVxuXHRcdGlmIChjaGlsZCBpbnN0YW5jZW9mIE5vZGVMaXN0KSB7XG5cdFx0XHR2YXIgY2hpbGRBcnIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjaGlsZCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkQXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZEFycltpXSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0fVxuXHRcdHJldHVybiBjaGlsZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBIZWxwZXIgZm9yIGNvbnZlcnRpbmcgYSBIVE1MIHN0cmluZyBpbnRvIGEgZG9jdW1lbnQgZnJhZ21lbnQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sU3RyaW5nIFRoZSBIVE1MIHN0cmluZyB0byBjb252ZXJ0LlxuXHQgKiBAcmV0dXJuIHshRWxlbWVudH0gVGhlIHJlc3VsdGluZyBkb2N1bWVudCBmcmFnbWVudC5cblx0ICovXG5cdHN0YXRpYyBidWlsZEZyYWdtZW50KGh0bWxTdHJpbmcpIHtcblx0XHR2YXIgdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdHRlbXBEaXYuaW5uZXJIVE1MID0gJzxicj4nICsgaHRtbFN0cmluZztcblx0XHR0ZW1wRGl2LnJlbW92ZUNoaWxkKHRlbXBEaXYuZmlyc3RDaGlsZCk7XG5cblx0XHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0d2hpbGUgKHRlbXBEaXYuZmlyc3RDaGlsZCkge1xuXHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQodGVtcERpdi5maXJzdENoaWxkKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZyYWdtZW50O1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgZmlyc3QgZWxlbWVudCBjb250YWlucyB0aGUgc2Vjb25kIG9uZS5cblx0ICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudDFcblx0ICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudDJcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdHN0YXRpYyBjb250YWlucyhlbGVtZW50MSwgZWxlbWVudDIpIHtcblx0XHRpZiAoY29yZS5pc0RvY3VtZW50KGVsZW1lbnQxKSkge1xuXHRcdFx0Ly8gZG9jdW1lbnQuY29udGFpbnMgaXMgbm90IGRlZmluZWQgb24gSUU5LCBzbyBjYWxsIGl0IG9uIGRvY3VtZW50RWxlbWVudCBpbnN0ZWFkLlxuXHRcdFx0cmV0dXJuIGVsZW1lbnQxLmRvY3VtZW50RWxlbWVudC5jb250YWlucyhlbGVtZW50Mik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBlbGVtZW50MS5jb250YWlucyhlbGVtZW50Mik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIExpc3RlbnMgdG8gdGhlIHNwZWNpZmllZCBldmVudCBvbiB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQsIGJ1dCBvbmx5IGNhbGxzIHRoZVxuXHQgKiBjYWxsYmFjayB3aXRoIHRoZSBldmVudCB3aGVuIGl0IHRyaWdnZXJlZCBieSBlbGVtZW50cyB0aGF0IG1hdGNoIHRoZSBnaXZlblxuXHQgKiBzZWxlY3Rvci5cblx0ICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudCBUaGUgY29udGFpbmVyIERPTSBlbGVtZW50IHRvIGxpc3RlbiB0byB0aGUgZXZlbnQgb24uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiB0by5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFRoZSBzZWxlY3RvciB0aGF0IG1hdGNoZXMgdGhlIGNoaWxkIGVsZW1lbnRzIHRoYXRcblx0ICogICB0aGUgZXZlbnQgc2hvdWxkIGJlIHRyaWdnZXJlZCBmb3IuXG5cdCAqIEBwYXJhbSB7IWZ1bmN0aW9uKCFPYmplY3QpfSBjYWxsYmFjayBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXNcblx0ICogICB0cmlnZ2VyZWQuIEl0IHdpbGwgcmVjZWl2ZSB0aGUgbm9ybWFsaXplZCBldmVudCBvYmplY3QuXG5cdCAqIEByZXR1cm4geyFEb21FdmVudEhhbmRsZX0gQ2FuIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cblx0ICovXG5cdHN0YXRpYyBkZWxlZ2F0ZShlbGVtZW50LCBldmVudE5hbWUsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuXHRcdHZhciBjdXN0b21Db25maWcgPSBkb20uY3VzdG9tRXZlbnRzW2V2ZW50TmFtZV07XG5cdFx0aWYgKGN1c3RvbUNvbmZpZyAmJiBjdXN0b21Db25maWcuZGVsZWdhdGUpIHtcblx0XHRcdGV2ZW50TmFtZSA9IGN1c3RvbUNvbmZpZy5vcmlnaW5hbEV2ZW50O1xuXHRcdFx0Y2FsbGJhY2sgPSBjdXN0b21Db25maWcuaGFuZGxlci5iaW5kKGN1c3RvbUNvbmZpZywgY2FsbGJhY2spO1xuXHRcdH1cblx0XHRyZXR1cm4gZG9tLm9uKFxuXHRcdFx0ZWxlbWVudCxcblx0XHRcdGV2ZW50TmFtZSxcblx0XHRcdGRvbS5oYW5kbGVEZWxlZ2F0ZUV2ZW50Xy5iaW5kKG51bGwsIHNlbGVjdG9yLCBjYWxsYmFjaylcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluc2VydHMgbm9kZSBpbiBkb2N1bWVudCBhcyBsYXN0IGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBFbGVtZW50IHRvIHJlbW92ZSBjaGlsZHJlbiBmcm9tLlxuXHQgKi9cblx0c3RhdGljIGVudGVyRG9jdW1lbnQobm9kZSkge1xuXHRcdGRvbS5hcHBlbmQoZG9jdW1lbnQuYm9keSwgbm9kZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBub2RlIGZyb20gZG9jdW1lbnQuXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBFbGVtZW50IHRvIHJlbW92ZSBjaGlsZHJlbiBmcm9tLlxuXHQgKi9cblx0c3RhdGljIGV4aXREb2N1bWVudChub2RlKSB7XG5cdFx0aWYgKG5vZGUucGFyZW50Tm9kZSkge1xuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIGFuIGV2ZW50IGlzIHRyaWdnZXJlZCBieSBhIGRlbGVnYXRlIGxpc3RlbmVyIChzZWVcblx0ICogYGRvbS5kZWxlZ2F0ZWAgZm9yIG1vcmUgZGV0YWlscykuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBUaGUgc2VsZWN0b3Igb3IgZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIGNoaWxkXG5cdCAqICAgZWxlbWVudHMgdGhhdCB0aGUgZXZlbnQgc2hvdWxkIGJlIHRyaWdnZXJlZCBmb3IuXG5cdCAqIEBwYXJhbSB7IWZ1bmN0aW9uKCFPYmplY3QpfSBjYWxsYmFjayBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnRcblx0ICogICBpcyB0cmlnZ2VyZWQuIEl0IHdpbGwgcmVjZWl2ZSB0aGUgbm9ybWFsaXplZCBldmVudCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7IUV2ZW50fSBldmVudCBUaGUgZXZlbnQgcGF5bG9hZC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gRmFsc2UgaWYgYXQgbGVhc3Qgb25lIG9mIHRoZSB0cmlnZ2VyZWQgY2FsbGJhY2tzIHJldHVybnNcblx0ICogICBmYWxzZSwgb3IgdHJ1ZSBvdGhlcndpc2UuXG5cdCAqL1xuXHRzdGF0aWMgaGFuZGxlRGVsZWdhdGVFdmVudF8oc2VsZWN0b3IsIGNhbGxiYWNrLCBldmVudCkge1xuXHRcdGRvbS5ub3JtYWxpemVEZWxlZ2F0ZUV2ZW50XyhldmVudCk7XG5cblx0XHR2YXIgY3VycmVudEVsZW1lbnQgPSBldmVudC50YXJnZXQ7XG5cdFx0dmFyIHJldHVyblZhbHVlID0gdHJ1ZTtcblxuXHRcdHdoaWxlIChjdXJyZW50RWxlbWVudCAmJiAhZXZlbnQuc3RvcHBlZCkge1xuXHRcdFx0aWYgKGNvcmUuaXNTdHJpbmcoc2VsZWN0b3IpICYmIGRvbS5tYXRjaChjdXJyZW50RWxlbWVudCwgc2VsZWN0b3IpKSB7XG5cdFx0XHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gY3VycmVudEVsZW1lbnQ7XG5cdFx0XHRcdHJldHVyblZhbHVlICY9IGNhbGxiYWNrKGV2ZW50KTtcblx0XHRcdH1cblx0XHRcdGlmIChjdXJyZW50RWxlbWVudCA9PT0gZXZlbnQuY3VycmVudFRhcmdldCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGN1cnJlbnRFbGVtZW50ID0gY3VycmVudEVsZW1lbnQucGFyZW50Tm9kZTtcblx0XHR9XG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSBudWxsO1xuXG5cdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBoYXMgdGhlIHJlcXVlc3RlZCBjc3MgY2xhc3MuXG5cdCAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0c3RhdGljIGhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuXHRcdGlmICgnY2xhc3NMaXN0JyBpbiBlbGVtZW50KSB7XG5cdFx0XHRyZXR1cm4gZG9tLmhhc0NsYXNzV2l0aE5hdGl2ZV8oZWxlbWVudCwgY2xhc3NOYW1lKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGRvbS5oYXNDbGFzc1dpdGhvdXROYXRpdmVfKGVsZW1lbnQsIGNsYXNzTmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBoYXMgdGhlIHJlcXVlc3RlZCBjc3MgY2xhc3MgdXNpbmcgY2xhc3NMaXN0LlxuXHQgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c3RhdGljIGhhc0NsYXNzV2l0aE5hdGl2ZV8oZWxlbWVudCwgY2xhc3NOYW1lKSB7XG5cdFx0cmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBlbGVtZW50IGhhcyB0aGUgcmVxdWVzdGVkIGNzcyBjbGFzcyB3aXRob3V0IHVzaW5nIGNsYXNzTGlzdC5cblx0ICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHN0YXRpYyBoYXNDbGFzc1dpdGhvdXROYXRpdmVfKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuXHRcdHJldHVybiAoJyAnICsgZWxlbWVudC5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgY2xhc3NOYW1lICsgJyAnKSA+PSAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBlbXB0eSBvciBub3QuXG5cdCAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdHN0YXRpYyBpc0VtcHR5KGVsZW1lbnQpIHtcblx0XHRyZXR1cm4gZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBhbiBlbGVtZW50IG1hdGNoZXMgYSBnaXZlbiBzZWxlY3Rvci5cblx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0c3RhdGljIG1hdGNoKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG5cdFx0aWYgKCFlbGVtZW50IHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IDEpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgcCA9IEVsZW1lbnQucHJvdG90eXBlO1xuXHRcdHZhciBtID0gcC5tYXRjaGVzIHx8IHAud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IHAubW96TWF0Y2hlc1NlbGVjdG9yIHx8IHAubXNNYXRjaGVzU2VsZWN0b3IgfHwgcC5vTWF0Y2hlc1NlbGVjdG9yO1xuXHRcdGlmIChtKSB7XG5cdFx0XHRyZXR1cm4gbS5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZG9tLm1hdGNoRmFsbGJhY2tfKGVsZW1lbnQsIHNlbGVjdG9yKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBhbiBlbGVtZW50IG1hdGNoZXMgYSBnaXZlbiBzZWxlY3RvciwgdXNpbmcgYW4gaW50ZXJuYWwgaW1wbGVtZW50YXRpb25cblx0ICogaW5zdGVhZCBvZiBjYWxsaW5nIGV4aXN0aW5nIGphdmFzY3JpcHQgZnVuY3Rpb25zLlxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHN0YXRpYyBtYXRjaEZhbGxiYWNrXyhlbGVtZW50LCBzZWxlY3Rvcikge1xuXHRcdHZhciBub2RlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IsIGVsZW1lbnQucGFyZW50Tm9kZSk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0aWYgKG5vZGVzW2ldID09PSBlbGVtZW50KSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBnaXZlbiBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkXG5cdCAqIHNlbGVjdG9yLCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmUuXG5cdCAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcblx0ICogQHBhcmFtIHs/c3RyaW5nfSBzZWxlY3RvclxuXHQgKi9cblx0c3RhdGljIG5leHQoZWxlbWVudCwgc2VsZWN0b3IpIHtcblx0XHRkbyB7XG5cdFx0XHRlbGVtZW50ID0gZWxlbWVudC5uZXh0U2libGluZztcblx0XHRcdGlmIChlbGVtZW50ICYmIGRvbS5tYXRjaChlbGVtZW50LCBzZWxlY3RvcikpIHtcblx0XHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdFx0XHR9XG5cdFx0fSB3aGlsZSAoZWxlbWVudCk7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogTm9ybWFsaXplcyB0aGUgZXZlbnQgcGF5bG9hZCBmb3IgZGVsZWdhdGUgbGlzdGVuZXJzLlxuXHQgKiBAcGFyYW0geyFFdmVudH0gZXZlbnRcblx0ICovXG5cdHN0YXRpYyBub3JtYWxpemVEZWxlZ2F0ZUV2ZW50XyhldmVudCkge1xuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGRvbS5zdG9wUHJvcGFnYXRpb25fO1xuXHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9IGRvbS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25fO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpc3RlbnMgdG8gdGhlIHNwZWNpZmllZCBldmVudCBvbiB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQuIFRoaXMgZnVuY3Rpb24gbm9ybWFsaXplc1xuXHQgKiBET00gZXZlbnQgcGF5bG9hZHMgYW5kIGZ1bmN0aW9ucyBzbyB0aGV5J2xsIHdvcmsgdGhlIHNhbWUgd2F5IG9uIGFsbCBzdXBwb3J0ZWRcblx0ICogYnJvd3NlcnMuXG5cdCAqIEBwYXJhbSB7IUVsZW1lbnR8c3RyaW5nfSBlbGVtZW50IFRoZSBET00gZWxlbWVudCB0byBsaXN0ZW4gdG8gdGhlIGV2ZW50IG9uLCBvclxuXHQgKiAgIGEgc2VsZWN0b3IgdGhhdCBzaG91bGQgYmUgZGVsZWdhdGVkIG9uIHRoZSBlbnRpcmUgZG9jdW1lbnQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiB0by5cblx0ICogQHBhcmFtIHshZnVuY3Rpb24oIU9iamVjdCl9IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpc1xuXHQgKiAgIHRyaWdnZXJlZC4gSXQgd2lsbCByZWNlaXZlIHRoZSBub3JtYWxpemVkIGV2ZW50IG9iamVjdC5cblx0ICogQHBhcmFtIHtib29sZWFufSBvcHRfY2FwdHVyZSBGbGFnIGluZGljYXRpbmcgaWYgbGlzdGVuZXIgc2hvdWxkIGJlIHRyaWdnZXJlZFxuXHQgKiAgIGR1cmluZyBjYXB0dXJlIHBoYXNlLCBpbnN0ZWFkIG9mIGR1cmluZyB0aGUgYnViYmxpbmcgcGhhc2UuIERlZmF1bHRzIHRvIGZhbHNlLlxuXHQgKiBAcmV0dXJuIHshRG9tRXZlbnRIYW5kbGV9IENhbiBiZSB1c2VkIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG5cdCAqL1xuXHRzdGF0aWMgb24oZWxlbWVudCwgZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0X2NhcHR1cmUpIHtcblx0XHRpZiAoY29yZS5pc1N0cmluZyhlbGVtZW50KSkge1xuXHRcdFx0cmV0dXJuIGRvbS5kZWxlZ2F0ZShkb2N1bWVudCwgZXZlbnROYW1lLCBlbGVtZW50LCBjYWxsYmFjayk7XG5cdFx0fVxuXHRcdHZhciBjdXN0b21Db25maWcgPSBkb20uY3VzdG9tRXZlbnRzW2V2ZW50TmFtZV07XG5cdFx0aWYgKGN1c3RvbUNvbmZpZyAmJiBjdXN0b21Db25maWcuZXZlbnQpIHtcblx0XHRcdGV2ZW50TmFtZSA9IGN1c3RvbUNvbmZpZy5vcmlnaW5hbEV2ZW50O1xuXHRcdFx0Y2FsbGJhY2sgPSBjdXN0b21Db25maWcuaGFuZGxlci5iaW5kKGN1c3RvbUNvbmZpZywgY2FsbGJhY2spO1xuXHRcdH1cblx0XHRlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0X2NhcHR1cmUpO1xuXHRcdHJldHVybiBuZXcgRG9tRXZlbnRIYW5kbGUoZWxlbWVudCwgZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0X2NhcHR1cmUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpc3RlbnMgdG8gdGhlIHNwZWNpZmllZCBldmVudCBvbiB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQgb25jZS4gVGhpc1xuXHQgKiBmdW5jdGlvbiBub3JtYWxpemVzIERPTSBldmVudCBwYXlsb2FkcyBhbmQgZnVuY3Rpb25zIHNvIHRoZXknbGwgd29yayB0aGVcblx0ICogc2FtZSB3YXkgb24gYWxsIHN1cHBvcnRlZCBicm93c2Vycy5cblx0ICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudCBUaGUgRE9NIGVsZW1lbnQgdG8gbGlzdGVuIHRvIHRoZSBldmVudCBvbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIHRvLlxuXHQgKiBAcGFyYW0geyFmdW5jdGlvbighT2JqZWN0KX0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50XG5cdCAqICAgaXMgdHJpZ2dlcmVkLiBJdCB3aWxsIHJlY2VpdmUgdGhlIG5vcm1hbGl6ZWQgZXZlbnQgb2JqZWN0LlxuXHQgKiBAcmV0dXJuIHshRG9tRXZlbnRIYW5kbGV9IENhbiBiZSB1c2VkIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG5cdCAqL1xuXHRzdGF0aWMgb25jZShlbGVtZW50LCBldmVudE5hbWUsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIGRvbUV2ZW50SGFuZGxlID0gdGhpcy5vbihlbGVtZW50LCBldmVudE5hbWUsIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZG9tRXZlbnRIYW5kbGUucmVtb3ZlTGlzdGVuZXIoKTtcblx0XHRcdHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0pO1xuXHRcdHJldHVybiBkb21FdmVudEhhbmRsZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBmaXJzdCBwYXJlbnQgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHNwZWNpZmllZFxuXHQgKiBzZWxlY3Rvciwgb3IgbnVsbCBpZiBub25lIG1hdGNoLlxuXHQgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuXHQgKiBAcmV0dXJuIHtFbGVtZW50fVxuXHQgKi9cblx0c3RhdGljIHBhcmVudChlbGVtZW50LCBzZWxlY3Rvcikge1xuXHRcdHJldHVybiBkb20uY2xvc2VzdChlbGVtZW50LnBhcmVudE5vZGUsIHNlbGVjdG9yKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYSBjdXN0b20gZXZlbnQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGN1c3RvbSBldmVudC5cblx0ICogQHBhcmFtIHshT2JqZWN0fSBjdXN0b21Db25maWcgQW4gb2JqZWN0IHdpdGggaW5mb3JtYXRpb24gYWJvdXQgaG93IHRoZSBldmVudFxuXHQgKiAgIHNob3VsZCBiZSBoYW5kbGVkLlxuXHQgKi9cblx0c3RhdGljIHJlZ2lzdGVyQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBjdXN0b21Db25maWcpIHtcblx0XHRkb20uY3VzdG9tRXZlbnRzW2V2ZW50TmFtZV0gPSBjdXN0b21Db25maWc7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwgdGhlIGNoaWxkIG5vZGVzIG9uIGEgRE9NIG5vZGUuXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBFbGVtZW50IHRvIHJlbW92ZSBjaGlsZHJlbiBmcm9tLlxuXHQgKi9cblx0c3RhdGljIHJlbW92ZUNoaWxkcmVuKG5vZGUpIHtcblx0XHR2YXIgY2hpbGQ7XG5cdFx0d2hpbGUgKChjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZCkpIHtcblx0XHRcdG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSByZXF1ZXN0ZWQgQ1NTIGNsYXNzZXMgZnJvbSBhbiBlbGVtZW50LlxuXHQgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHJlbW92ZSBDU1MgY2xhc3NlcyBmcm9tLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NlcyBDU1MgY2xhc3NlcyB0byByZW1vdmUuXG5cdCAqL1xuXHRzdGF0aWMgcmVtb3ZlQ2xhc3NlcyhlbGVtZW50LCBjbGFzc2VzKSB7XG5cdFx0aWYgKCFjb3JlLmlzT2JqZWN0KGVsZW1lbnQpIHx8ICFjb3JlLmlzU3RyaW5nKGNsYXNzZXMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCdjbGFzc0xpc3QnIGluIGVsZW1lbnQpIHtcblx0XHRcdGRvbS5yZW1vdmVDbGFzc2VzV2l0aE5hdGl2ZV8oZWxlbWVudCwgY2xhc3Nlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRvbS5yZW1vdmVDbGFzc2VzV2l0aG91dE5hdGl2ZV8oZWxlbWVudCwgY2xhc3Nlcyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIHJlcXVlc3RlZCBDU1MgY2xhc3NlcyBmcm9tIGFuIGVsZW1lbnQgdXNpbmcgY2xhc3NMaXN0LlxuXHQgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHJlbW92ZSBDU1MgY2xhc3NlcyBmcm9tLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NlcyBDU1MgY2xhc3NlcyB0byByZW1vdmUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHN0YXRpYyByZW1vdmVDbGFzc2VzV2l0aE5hdGl2ZV8oZWxlbWVudCwgY2xhc3Nlcykge1xuXHRcdGNsYXNzZXMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuXHRcdFx0aWYgKGNsYXNzTmFtZSkge1xuXHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSByZXF1ZXN0ZWQgQ1NTIGNsYXNzZXMgZnJvbSBhbiBlbGVtZW50IHdpdGhvdXQgdXNpbmcgY2xhc3NMaXN0LlxuXHQgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHJlbW92ZSBDU1MgY2xhc3NlcyBmcm9tLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NlcyBDU1MgY2xhc3NlcyB0byByZW1vdmUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHN0YXRpYyByZW1vdmVDbGFzc2VzV2l0aG91dE5hdGl2ZV8oZWxlbWVudCwgY2xhc3Nlcykge1xuXHRcdHZhciBlbGVtZW50Q2xhc3NOYW1lID0gJyAnICsgZWxlbWVudC5jbGFzc05hbWUgKyAnICc7XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlcy5zcGxpdCgnICcpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRlbGVtZW50Q2xhc3NOYW1lID0gZWxlbWVudENsYXNzTmFtZS5yZXBsYWNlKCcgJyArIGNsYXNzZXNbaV0gKyAnICcsICcgJyk7XG5cdFx0fVxuXG5cdFx0ZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50Q2xhc3NOYW1lLnRyaW0oKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXBsYWNlcyB0aGUgZmlyc3QgZWxlbWVudCB3aXRoIHRoZSBzZWNvbmQuXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudDFcblx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50MlxuXHQgKi9cblx0c3RhdGljIHJlcGxhY2UoZWxlbWVudDEsIGVsZW1lbnQyKSB7XG5cdFx0aWYgKGVsZW1lbnQxICYmIGVsZW1lbnQyICYmIGVsZW1lbnQxICE9PSBlbGVtZW50MiAmJiBlbGVtZW50MS5wYXJlbnROb2RlKSB7XG5cdFx0XHRlbGVtZW50MS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50MiwgZWxlbWVudDEpO1xuXHRcdFx0ZWxlbWVudDEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50MSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBmdW5jdGlvbiB0aGF0IHJlcGxhY2VzIGBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25fYCBmb3IgZXZlbnRzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzdGF0aWMgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXygpIHtcblx0XHR0aGlzLnN0b3BwZWQgPSB0cnVlO1xuXHRcdEV2ZW50LnByb3RvdHlwZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24uY2FsbCh0aGlzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgZnVuY3Rpb24gdGhhdCByZXBsYWNlcyBgc3RvcFByb3BhZ2F0aW9uYCBmb3IgZXZlbnRzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzdGF0aWMgc3RvcFByb3BhZ2F0aW9uXygpIHtcblx0XHR0aGlzLnN0b3BwZWQgPSB0cnVlO1xuXHRcdEV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24uY2FsbCh0aGlzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGVsZW1lbnQgc3VwcG9ydHMgdGhlIGdpdmVuIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7IUVsZW1lbnR8c3RyaW5nfSBlbGVtZW50IFRoZSBET00gZWxlbWVudCBvciBlbGVtZW50IHRhZyBuYW1lIHRvIGNoZWNrLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBjaGVjay5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdHN0YXRpYyBzdXBwb3J0c0V2ZW50KGVsZW1lbnQsIGV2ZW50TmFtZSkge1xuXHRcdGlmIChkb20uY3VzdG9tRXZlbnRzW2V2ZW50TmFtZV0pIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmIChjb3JlLmlzU3RyaW5nKGVsZW1lbnQpKSB7XG5cdFx0XHRpZiAoIWVsZW1lbnRzQnlUYWdbZWxlbWVudF0pIHtcblx0XHRcdFx0ZWxlbWVudHNCeVRhZ1tlbGVtZW50XSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0XHRlbGVtZW50ID0gZWxlbWVudHNCeVRhZ1tlbGVtZW50XTtcblx0XHR9XG5cdFx0cmV0dXJuICdvbicgKyBldmVudE5hbWUgaW4gZWxlbWVudDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gYSBET00gZWxlbWVudC4gU3RyaW5ncyBhcmUgYXNzdW1lZCB0b1xuXHQgKiBiZSBzZWxlY3RvcnMsIGFuZCBzbyBhIG1hdGNoZWQgZWxlbWVudCB3aWxsIGJlIHJldHVybmVkLiBJZiB0aGUgYXJnXG5cdCAqIGlzIGFscmVhZHkgYSBET00gZWxlbWVudCBpdCB3aWxsIGJlIHRoZSByZXR1cm4gdmFsdWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnR8RG9jdW1lbnR9IHNlbGVjdG9yT3JFbGVtZW50XG5cdCAqIEByZXR1cm4ge0VsZW1lbnR9IFRoZSBjb252ZXJ0ZWQgZWxlbWVudCwgb3IgbnVsbCBpZiBub25lIHdhcyBmb3VuZC5cblx0ICovXG5cdHN0YXRpYyB0b0VsZW1lbnQoc2VsZWN0b3JPckVsZW1lbnQpIHtcblx0XHRpZiAoY29yZS5pc0VsZW1lbnQoc2VsZWN0b3JPckVsZW1lbnQpIHx8IGNvcmUuaXNEb2N1bWVudChzZWxlY3Rvck9yRWxlbWVudCkpIHtcblx0XHRcdHJldHVybiBzZWxlY3Rvck9yRWxlbWVudDtcblx0XHR9IGVsc2UgaWYgKGNvcmUuaXNTdHJpbmcoc2VsZWN0b3JPckVsZW1lbnQpKSB7XG5cdFx0XHRpZiAoc2VsZWN0b3JPckVsZW1lbnRbMF0gPT09ICcjJyAmJiBzZWxlY3Rvck9yRWxlbWVudC5pbmRleE9mKCcgJykgPT09IC0xKSB7XG5cdFx0XHRcdHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxlY3Rvck9yRWxlbWVudC5zdWJzdHIoMSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3JPckVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBvciByZW1vdmVzIG9uZSBvciBtb3JlIGNsYXNzZXMgZnJvbSBhbiBlbGVtZW50LiBJZiBhbnkgb2YgdGhlIGNsYXNzZXNcblx0ICogaXMgcHJlc2VudCwgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGVsZW1lbnQsIG9yIGFkZGVkIG90aGVyd2lzZS5cblx0ICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB3aGljaCBjbGFzc2VzIHdpbGwgYmUgdG9nZ2xlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzZXMgVGhlIGNsYXNzZXMgd2hpY2ggaGF2ZSB0byBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhlIGVsZW1lbnQuXG5cdCAqL1xuXHRzdGF0aWMgdG9nZ2xlQ2xhc3NlcyhlbGVtZW50LCBjbGFzc2VzKSB7XG5cdFx0aWYgKCFjb3JlLmlzT2JqZWN0KGVsZW1lbnQpIHx8ICFjb3JlLmlzU3RyaW5nKGNsYXNzZXMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCdjbGFzc0xpc3QnIGluIGVsZW1lbnQpIHtcblx0XHRcdGRvbS50b2dnbGVDbGFzc2VzV2l0aE5hdGl2ZV8oZWxlbWVudCwgY2xhc3Nlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRvbS50b2dnbGVDbGFzc2VzV2l0aG91dE5hdGl2ZV8oZWxlbWVudCwgY2xhc3Nlcyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgb3IgcmVtb3ZlcyBvbmUgb3IgbW9yZSBjbGFzc2VzIGZyb20gYW4gZWxlbWVudCB1c2luZyBjbGFzc0xpc3QuXG5cdCAqIElmIGFueSBvZiB0aGUgY2xhc3NlcyBpcyBwcmVzZW50LCBpdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudCxcblx0ICogb3IgYWRkZWQgb3RoZXJ3aXNlLlxuXHQgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHdoaWNoIGNsYXNzZXMgd2lsbCBiZSB0b2dnbGVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NlcyBUaGUgY2xhc3NlcyB3aGljaCBoYXZlIHRvIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudC5cblx0ICovXG5cdHN0YXRpYyB0b2dnbGVDbGFzc2VzV2l0aE5hdGl2ZV8oZWxlbWVudCwgY2xhc3Nlcykge1xuXHRcdGNsYXNzZXMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuXHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZSk7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBvciByZW1vdmVzIG9uZSBvciBtb3JlIGNsYXNzZXMgZnJvbSBhbiBlbGVtZW50IHdpdGhvdXQgdXNpbmcgY2xhc3NMaXN0LlxuXHQgKiBJZiBhbnkgb2YgdGhlIGNsYXNzZXMgaXMgcHJlc2VudCwgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGVsZW1lbnQsXG5cdCAqIG9yIGFkZGVkIG90aGVyd2lzZS5cblx0ICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB3aGljaCBjbGFzc2VzIHdpbGwgYmUgdG9nZ2xlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzZXMgVGhlIGNsYXNzZXMgd2hpY2ggaGF2ZSB0byBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhlIGVsZW1lbnQuXG5cdCAqL1xuXHRzdGF0aWMgdG9nZ2xlQ2xhc3Nlc1dpdGhvdXROYXRpdmVfKGVsZW1lbnQsIGNsYXNzZXMpIHtcblx0XHR2YXIgZWxlbWVudENsYXNzTmFtZSA9ICcgJyArIGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnO1xuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXMuc3BsaXQoJyAnKTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSA9ICcgJyArIGNsYXNzZXNbaV0gKyAnICc7XG5cdFx0XHR2YXIgY2xhc3NJbmRleCA9IGVsZW1lbnRDbGFzc05hbWUuaW5kZXhPZihjbGFzc05hbWUpO1xuXG5cdFx0XHRpZiAoY2xhc3NJbmRleCA9PT0gLTEpIHtcblx0XHRcdFx0ZWxlbWVudENsYXNzTmFtZSA9IGVsZW1lbnRDbGFzc05hbWUgKyBjbGFzc2VzW2ldICsgJyAnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudENsYXNzTmFtZSA9IGVsZW1lbnRDbGFzc05hbWUuc3Vic3RyaW5nKDAsIGNsYXNzSW5kZXgpICsgJyAnICtcblx0XHRcdFx0XHRlbGVtZW50Q2xhc3NOYW1lLnN1YnN0cmluZyhjbGFzc0luZGV4ICsgY2xhc3NOYW1lLmxlbmd0aCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50Q2xhc3NOYW1lLnRyaW0oKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUcmlnZ2VycyB0aGUgc3BlY2lmaWVkIGV2ZW50IG9uIHRoZSBnaXZlbiBlbGVtZW50LlxuXHQgKiBOT1RFOiBUaGlzIHNob3VsZCBtb3N0bHkgYmUgdXNlZCBmb3IgdGVzdGluZywgbm90IG9uIHJlYWwgY29kZS5cblx0ICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudCBUaGUgbm9kZSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgdHJpZ2dyZWQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2V2ZW50T2JqIEFuIG9iamVjdCB3aXRoIGRhdGEgdGhhdCBzaG91bGQgYmUgb24gdGhlXG5cdCAqICAgdHJpZ2dlcmVkIGV2ZW50J3MgcGF5bG9hZC5cblx0ICovXG5cdHN0YXRpYyB0cmlnZ2VyRXZlbnQoZWxlbWVudCwgZXZlbnROYW1lLCBvcHRfZXZlbnRPYmopIHtcblx0XHR2YXIgZXZlbnRPYmogPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuXHRcdGV2ZW50T2JqLmluaXRFdmVudChldmVudE5hbWUsIHRydWUsIHRydWUpO1xuXHRcdG9iamVjdC5taXhpbihldmVudE9iaiwgb3B0X2V2ZW50T2JqKTtcblx0XHRlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnRPYmopO1xuXHR9XG59XG5cbnZhciBlbGVtZW50c0J5VGFnID0ge307XG5kb20uY3VzdG9tRXZlbnRzID0ge307XG5cbmV4cG9ydCBkZWZhdWx0IGRvbTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGRvbSBmcm9tICcuL2RvbSc7XG5pbXBvcnQgZmVhdHVyZXMgZnJvbSAnLi9mZWF0dXJlcyc7XG5cbnZhciBtb3VzZUV2ZW50TWFwID0ge1xuXHRtb3VzZWVudGVyOiAnbW91c2VvdmVyJyxcblx0bW91c2VsZWF2ZTogJ21vdXNlb3V0Jyxcblx0cG9pbnRlcmVudGVyOiAncG9pbnRlcm92ZXInLFxuXHRwb2ludGVybGVhdmU6ICdwb2ludGVyb3V0J1xufTtcbk9iamVjdC5rZXlzKG1vdXNlRXZlbnRNYXApLmZvckVhY2goZnVuY3Rpb24oZXZlbnROYW1lKSB7XG5cdGRvbS5yZWdpc3RlckN1c3RvbUV2ZW50KGV2ZW50TmFtZSwge1xuXHRcdGRlbGVnYXRlOiB0cnVlLFxuXHRcdGhhbmRsZXI6IGZ1bmN0aW9uKGNhbGxiYWNrLCBldmVudCkge1xuXHRcdFx0dmFyIHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuXHRcdFx0dmFyIHRhcmdldCA9IGV2ZW50LmRlbGVnYXRlVGFyZ2V0O1xuXHRcdFx0aWYgKCFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0YXJnZXQgJiYgIXRhcmdldC5jb250YWlucyhyZWxhdGVkKSkpIHtcblx0XHRcdFx0ZXZlbnQuY3VzdG9tVHlwZSA9IGV2ZW50TmFtZTtcblx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKGV2ZW50KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9yaWdpbmFsRXZlbnQ6IG1vdXNlRXZlbnRNYXBbZXZlbnROYW1lXVxuXHR9KTtcbn0pO1xuXG52YXIgYW5pbWF0aW9uRXZlbnRNYXAgPSB7XG5cdGFuaW1hdGlvbjogJ2FuaW1hdGlvbmVuZCcsXG5cdHRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJ1xufTtcbk9iamVjdC5rZXlzKGFuaW1hdGlvbkV2ZW50TWFwKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50VHlwZSkge1xuXHR2YXIgZXZlbnROYW1lID0gYW5pbWF0aW9uRXZlbnRNYXBbZXZlbnRUeXBlXTtcblx0ZG9tLnJlZ2lzdGVyQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7XG5cdFx0ZXZlbnQ6IHRydWUsXG5cdFx0ZGVsZWdhdGU6IHRydWUsXG5cdFx0aGFuZGxlcjogZnVuY3Rpb24oY2FsbGJhY2ssIGV2ZW50KSB7XG5cdFx0XHRldmVudC5jdXN0b21UeXBlID0gZXZlbnROYW1lO1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKGV2ZW50KTtcblx0XHR9LFxuXHRcdG9yaWdpbmFsRXZlbnQ6IGZlYXR1cmVzLmNoZWNrQW5pbWF0aW9uRXZlbnROYW1lKClbZXZlbnRUeXBlXVxuXHR9KTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgZG9tIGZyb20gJy4vZG9tJztcbmltcG9ydCB7IHN0cmluZyB9IGZyb20gJ21ldGFsJztcblxuLyoqXG4gKiBDbGFzcyB3aXRoIHN0YXRpYyBtZXRob2RzIHJlc3BvbnNpYmxlIGZvciBkb2luZyBicm93c2VyIGZlYXR1cmUgY2hlY2tzLlxuICovXG5jbGFzcyBmZWF0dXJlcyB7XG5cdC8qKlxuXHQgKiBTb21lIGJyb3dzZXJzIHN0aWxsIHN1cHBvcnRzIHByZWZpeGVkIGFuaW1hdGlvbiBldmVudHMuIFRoaXMgbWV0aG9kIGNhblxuXHQgKiBiZSB1c2VkIHRvIHJldHJpZXZlIHRoZSBjdXJyZW50IGJyb3dzZXIgZXZlbnQgbmFtZSBmb3IgYm90aCwgYW5pbWF0aW9uXG5cdCAqIGFuZCB0cmFuc2l0aW9uLlxuXHQgKiBAcmV0dXJuIHtvYmplY3R9XG5cdCAqL1xuXHRzdGF0aWMgY2hlY2tBbmltYXRpb25FdmVudE5hbWUoKSB7XG5cdFx0aWYgKGZlYXR1cmVzLmFuaW1hdGlvbkV2ZW50TmFtZV8gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0ZmVhdHVyZXMuYW5pbWF0aW9uRXZlbnROYW1lXyA9IHtcblx0XHRcdFx0YW5pbWF0aW9uOiBmZWF0dXJlcy5jaGVja0FuaW1hdGlvbkV2ZW50TmFtZV8oJ2FuaW1hdGlvbicpLFxuXHRcdFx0XHR0cmFuc2l0aW9uOiBmZWF0dXJlcy5jaGVja0FuaW1hdGlvbkV2ZW50TmFtZV8oJ3RyYW5zaXRpb24nKVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIGZlYXR1cmVzLmFuaW1hdGlvbkV2ZW50TmFtZV87XG5cdH1cblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlIHRvIHRlc3Q6IGFuaW1hdGlvbiwgdHJhbnNpdGlvbi5cblx0ICogQHJldHVybiB7c3RyaW5nfSBCcm93c2VyIGV2ZW50IG5hbWUuXG5cdCAqL1xuXHRzdGF0aWMgY2hlY2tBbmltYXRpb25FdmVudE5hbWVfKHR5cGUpIHtcblx0XHR2YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNUycsICdPJywgJyddO1xuXHRcdHZhciB0eXBlVGl0bGVDYXNlID0gc3RyaW5nLnJlcGxhY2VJbnRlcnZhbCh0eXBlLCAwLCAxLCB0eXBlLnN1YnN0cmluZygwLCAxKS50b1VwcGVyQ2FzZSgpKTtcblx0XHR2YXIgc3VmZml4ZXMgPSBbdHlwZVRpdGxlQ2FzZSArICdFbmQnLCB0eXBlVGl0bGVDYXNlICsgJ0VuZCcsIHR5cGVUaXRsZUNhc2UgKyAnRW5kJywgdHlwZSArICdlbmQnXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoZmVhdHVyZXMuYW5pbWF0aW9uRWxlbWVudF8uc3R5bGVbcHJlZml4ZXNbaV0gKyB0eXBlVGl0bGVDYXNlXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiBwcmVmaXhlc1tpXS50b0xvd2VyQ2FzZSgpICsgc3VmZml4ZXNbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0eXBlICsgJ2VuZCc7XG5cdH1cblxuXHQvKipcblx0ICogU29tZSBicm93c2VycyAobGlrZSBJRTkpIGNoYW5nZSB0aGUgb3JkZXIgb2YgZWxlbWVudCBhdHRyaWJ1dGVzLCB3aGVuIGh0bWxcblx0ICogaXMgcmVuZGVyZWQuIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGNoZWNrIGlmIHRoaXMgYmVoYXZpb3IgaGFwcGVucyBvblxuXHQgKiB0aGUgY3VycmVudCBicm93c2VyLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0c3RhdGljIGNoZWNrQXR0ck9yZGVyQ2hhbmdlKCkge1xuXHRcdGlmIChmZWF0dXJlcy5hdHRyT3JkZXJDaGFuZ2VfID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHZhciBvcmlnaW5hbENvbnRlbnQgPSAnPGRpdiBkYXRhLWNvbXBvbmVudD1cIlwiIGRhdGEtcmVmPVwiXCI+PC9kaXY+Jztcblx0XHRcdHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRkb20uYXBwZW5kKGVsZW1lbnQsIG9yaWdpbmFsQ29udGVudCk7XG5cdFx0XHRmZWF0dXJlcy5hdHRyT3JkZXJDaGFuZ2VfID0gb3JpZ2luYWxDb250ZW50ICE9PSBlbGVtZW50LmlubmVySFRNTDtcblx0XHR9XG5cdFx0cmV0dXJuIGZlYXR1cmVzLmF0dHJPcmRlckNoYW5nZV87XG5cdH1cbn1cblxuZmVhdHVyZXMuYW5pbWF0aW9uRWxlbWVudF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbmZlYXR1cmVzLmFuaW1hdGlvbkV2ZW50TmFtZV8gPSB1bmRlZmluZWQ7XG5mZWF0dXJlcy5hdHRyT3JkZXJDaGFuZ2VfID0gdW5kZWZpbmVkO1xuXG5leHBvcnQgZGVmYXVsdCBmZWF0dXJlcztcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgYXN5bmMgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgZG9tIGZyb20gJy4vZG9tJztcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgcnVubmluZyBqYXZhc2NyaXB0IGNvZGUgaW4gdGhlIGdsb2JhbCBzY29wZS5cbiAqL1xuY2xhc3MgZ2xvYmFsRXZhbCB7XG5cdC8qKlxuXHQgKiBFdmFsdWF0ZXMgdGhlIGdpdmVuIHN0cmluZyBpbiB0aGUgZ2xvYmFsIHNjb3BlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBvcHRfYXBwZW5kRm4gT3B0aW9uYWwgZnVuY3Rpb24gdG8gYXBwZW5kIHRoZSBub2RlXG5cdCAqICAgaW50byBkb2N1bWVudC5cblx0ICogQHJldHVybiB7RWxlbWVudH0gc2NyaXB0XG5cdCAqL1xuXHRzdGF0aWMgcnVuKHRleHQsIG9wdF9hcHBlbmRGbikge1xuXHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblx0XHRzY3JpcHQudGV4dCA9IHRleHQ7XG5cdFx0aWYgKG9wdF9hcHBlbmRGbikge1xuXHRcdFx0b3B0X2FwcGVuZEZuKHNjcmlwdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblx0XHR9XG5cdFx0ZG9tLmV4aXREb2N1bWVudChzY3JpcHQpO1xuXHRcdHJldHVybiBzY3JpcHQ7XG5cdH1cblxuXHQvKipcblx0ICogRXZhbHVhdGVzIHRoZSBnaXZlbiBqYXZhc2NyaXB0IGZpbGUgaW4gdGhlIGdsb2JhbCBzY29wZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHNyYyBUaGUgZmlsZSdzIHBhdGguXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdF9jYWxsYmFjayBPcHRpb25hbCBmdW5jdGlvbiB0byBiZSBjYWxsZWRcblx0ICogICB3aGVuIHRoZSBzY3JpcHQgaGFzIGJlZW4gcnVuLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBvcHRfYXBwZW5kRm4gT3B0aW9uYWwgZnVuY3Rpb24gdG8gYXBwZW5kIHRoZSBub2RlXG5cdCAqICAgaW50byBkb2N1bWVudC5cblx0ICogQHJldHVybiB7RWxlbWVudH0gc2NyaXB0XG5cdCAqL1xuXHRzdGF0aWMgcnVuRmlsZShzcmMsIG9wdF9jYWxsYmFjaywgb3B0X2FwcGVuZEZuKSB7XG5cdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXHRcdHNjcmlwdC5zcmMgPSBzcmM7XG5cblx0XHR2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGRvbS5leGl0RG9jdW1lbnQoc2NyaXB0KTtcblx0XHRcdG9wdF9jYWxsYmFjayAmJiBvcHRfY2FsbGJhY2soKTtcblx0XHR9O1xuXHRcdGRvbS5vbihzY3JpcHQsICdsb2FkJywgY2FsbGJhY2spO1xuXHRcdGRvbS5vbihzY3JpcHQsICdlcnJvcicsIGNhbGxiYWNrKTtcblxuXHRcdGlmIChvcHRfYXBwZW5kRm4pIHtcblx0XHRcdG9wdF9hcHBlbmRGbihzY3JpcHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNjcmlwdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBFdmFsdWF0ZXMgdGhlIGNvZGUgcmVmZXJlbmNlZCBieSB0aGUgZ2l2ZW4gc2NyaXB0IGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7IUVsZW1lbnR9IHNjcmlwdFxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBvcHRfY2FsbGJhY2sgT3B0aW9uYWwgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG5cdCAqICAgd2hlbiB0aGUgc2NyaXB0IGhhcyBiZWVuIHJ1bi5cblx0ICogQHBhcmFtIHtmdW5jdGlvbigpPX0gb3B0X2FwcGVuZEZuIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFwcGVuZCB0aGUgbm9kZVxuXHQgKiAgIGludG8gZG9jdW1lbnQuXG5cdCAqIEByZXR1cm4ge0VsZW1lbnR9IHNjcmlwdFxuXHQgKi9cblx0c3RhdGljIHJ1blNjcmlwdChzY3JpcHQsIG9wdF9jYWxsYmFjaywgb3B0X2FwcGVuZEZuKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRvcHRfY2FsbGJhY2sgJiYgb3B0X2NhbGxiYWNrKCk7XG5cdFx0fTtcblx0XHRpZiAoc2NyaXB0LnR5cGUgJiYgc2NyaXB0LnR5cGUgIT09ICd0ZXh0L2phdmFzY3JpcHQnKSB7XG5cdFx0XHRhc3luYy5uZXh0VGljayhjYWxsYmFjayk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGRvbS5leGl0RG9jdW1lbnQoc2NyaXB0KTtcblx0XHRpZiAoc2NyaXB0LnNyYykge1xuXHRcdFx0cmV0dXJuIGdsb2JhbEV2YWwucnVuRmlsZShzY3JpcHQuc3JjLCBvcHRfY2FsbGJhY2ssIG9wdF9hcHBlbmRGbik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFzeW5jLm5leHRUaWNrKGNhbGxiYWNrKTtcblx0XHRcdHJldHVybiBnbG9iYWxFdmFsLnJ1bihzY3JpcHQudGV4dCwgb3B0X2FwcGVuZEZuKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRXZhbHVhdGVzIGFueSBzY3JpcHQgdGFncyBwcmVzZW50IGluIHRoZSBnaXZlbiBlbGVtZW50LlxuXHQgKiBAcGFyYW1zIHshRWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBvcHRfY2FsbGJhY2sgT3B0aW9uYWwgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG5cdCAqICAgd2hlbiB0aGUgc2NyaXB0IGhhcyBiZWVuIHJ1bi5cblx0ICogQHBhcmFtIHtmdW5jdGlvbigpPX0gb3B0X2FwcGVuZEZuIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFwcGVuZCB0aGUgbm9kZVxuXHQgKiAgIGludG8gZG9jdW1lbnQuXG5cdCAqL1xuXHRzdGF0aWMgcnVuU2NyaXB0c0luRWxlbWVudChlbGVtZW50LCBvcHRfY2FsbGJhY2ssIG9wdF9hcHBlbmRGbikge1xuXHRcdHZhciBzY3JpcHRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHQnKTtcblx0XHRpZiAoc2NyaXB0cy5sZW5ndGgpIHtcblx0XHRcdGdsb2JhbEV2YWwucnVuU2NyaXB0c0luT3JkZXIoc2NyaXB0cywgMCwgb3B0X2NhbGxiYWNrLCBvcHRfYXBwZW5kRm4pO1xuXHRcdH0gZWxzZSBpZiAob3B0X2NhbGxiYWNrKSB7XG5cdFx0XHRhc3luYy5uZXh0VGljayhvcHRfY2FsbGJhY2spO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSdW5zIHRoZSBnaXZlbiBzY3JpcHRzIGVsZW1lbnRzIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgYXBwZWFyLlxuXHQgKiBAcGFyYW0geyFOb2RlTGlzdH0gc2NyaXB0c1xuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHBhcmFtIHtmdW5jdGlvbigpPX0gb3B0X2NhbGxiYWNrIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuXHQgKiAgIHdoZW4gdGhlIHNjcmlwdCBoYXMgYmVlbiBydW4uXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdF9hcHBlbmRGbiBPcHRpb25hbCBmdW5jdGlvbiB0byBhcHBlbmQgdGhlIG5vZGVcblx0ICogICBpbnRvIGRvY3VtZW50LlxuXHQgKi9cblx0c3RhdGljIHJ1blNjcmlwdHNJbk9yZGVyKHNjcmlwdHMsIGluZGV4LCBvcHRfY2FsbGJhY2ssIG9wdF9hcHBlbmRGbikge1xuXHRcdGdsb2JhbEV2YWwucnVuU2NyaXB0KHNjcmlwdHMuaXRlbShpbmRleCksIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKGluZGV4IDwgc2NyaXB0cy5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdGdsb2JhbEV2YWwucnVuU2NyaXB0c0luT3JkZXIoc2NyaXB0cywgaW5kZXggKyAxLCBvcHRfY2FsbGJhY2ssIG9wdF9hcHBlbmRGbik7XG5cdFx0XHR9IGVsc2UgaWYgKG9wdF9jYWxsYmFjaykge1xuXHRcdFx0XHRhc3luYy5uZXh0VGljayhvcHRfY2FsbGJhY2spO1xuXHRcdFx0fVxuXHRcdH0sIG9wdF9hcHBlbmRGbik7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2xvYmFsRXZhbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgYXN5bmMgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgZG9tIGZyb20gJy4vZG9tJztcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgcnVubmluZyBzdHlsZXMuXG4gKi9cbmNsYXNzIGdsb2JhbEV2YWxTdHlsZXMge1xuXHQvKipcblx0ICogRXZhbHVhdGVzIHRoZSBnaXZlbiBzdHlsZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRleHRcblx0ICogQHBhcmFtIHtmdW5jdGlvbigpPX0gb3B0X2FwcGVuZEZuIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFwcGVuZCB0aGUgbm9kZVxuXHQgKiAgIGludG8gZG9jdW1lbnQuXG5cdCAqIEByZXR1cm4ge0VsZW1lbnR9IHN0eWxlXG5cdCAqL1xuXHRzdGF0aWMgcnVuKHRleHQsIG9wdF9hcHBlbmRGbikge1xuXHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cdFx0c3R5bGUuaW5uZXJIVE1MID0gdGV4dDtcblx0XHRpZiAob3B0X2FwcGVuZEZuKSB7XG5cdFx0XHRvcHRfYXBwZW5kRm4oc3R5bGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHN0eWxlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV2YWx1YXRlcyB0aGUgZ2l2ZW4gc3R5bGUgZmlsZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGhyZWYgVGhlIGZpbGUncyBwYXRoLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBvcHRfY2FsbGJhY2sgT3B0aW9uYWwgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG5cdCAqICAgd2hlbiB0aGUgc3R5bGVzIGhhcyBiZWVuIHJ1bi5cblx0ICogQHBhcmFtIHtmdW5jdGlvbigpPX0gb3B0X2FwcGVuZEZuIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFwcGVuZCB0aGUgbm9kZVxuXHQgKiAgIGludG8gZG9jdW1lbnQuXG5cdCAqIEByZXR1cm4ge0VsZW1lbnR9IHN0eWxlXG5cdCAqL1xuXHRzdGF0aWMgcnVuRmlsZShocmVmLCBvcHRfY2FsbGJhY2ssIG9wdF9hcHBlbmRGbikge1xuXHRcdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuXHRcdGxpbmsucmVsID0gJ3N0eWxlc2hlZXQnO1xuXHRcdGxpbmsuaHJlZiA9IGhyZWY7XG5cdFx0Z2xvYmFsRXZhbFN0eWxlcy5ydW5TdHlsZShsaW5rLCBvcHRfY2FsbGJhY2ssIG9wdF9hcHBlbmRGbik7XG5cdFx0cmV0dXJuIGxpbms7XG5cdH1cblxuXHQvKipcblx0ICogRXZhbHVhdGVzIHRoZSBjb2RlIHJlZmVyZW5jZWQgYnkgdGhlIGdpdmVuIHN0eWxlL2xpbmsgZWxlbWVudC5cblx0ICogQHBhcmFtIHshRWxlbWVudH0gc3R5bGVcblx0ICogQHBhcmFtIHtmdW5jdGlvbigpPX0gb3B0X2NhbGxiYWNrIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuXHQgKiAgIHdoZW4gdGhlIHNjcmlwdCBoYXMgYmVlbiBydW4uXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdF9hcHBlbmRGbiBPcHRpb25hbCBmdW5jdGlvbiB0byBhcHBlbmQgdGhlIG5vZGVcblx0ICogICBpbnRvIGRvY3VtZW50LlxuXHQgKiAgQHJldHVybiB7RWxlbWVudH0gc3R5bGVcblx0ICovXG5cdHN0YXRpYyBydW5TdHlsZShzdHlsZSwgb3B0X2NhbGxiYWNrLCBvcHRfYXBwZW5kRm4pIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdG9wdF9jYWxsYmFjayAmJiBvcHRfY2FsbGJhY2soKTtcblx0XHR9O1xuXHRcdGlmIChzdHlsZS5yZWwgJiYgc3R5bGUucmVsICE9PSAnc3R5bGVzaGVldCcpIHtcblx0XHRcdGFzeW5jLm5leHRUaWNrKGNhbGxiYWNrKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoc3R5bGUudGFnTmFtZSA9PT0gJ1NUWUxFJykge1xuXHRcdFx0YXN5bmMubmV4dFRpY2soY2FsbGJhY2spO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb20ub24oc3R5bGUsICdsb2FkJywgY2FsbGJhY2spO1xuXHRcdFx0ZG9tLm9uKHN0eWxlLCAnZXJyb3InLCBjYWxsYmFjayk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdF9hcHBlbmRGbikge1xuXHRcdFx0b3B0X2FwcGVuZEZuKHN0eWxlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0eWxlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV2YWx1YXRlcyBhbnkgc3R5bGUgcHJlc2VudCBpbiB0aGUgZ2l2ZW4gZWxlbWVudC5cblx0ICogQHBhcmFtcyB7IUVsZW1lbnR9IGVsZW1lbnRcblx0ICogQHBhcmFtIHtmdW5jdGlvbigpPX0gb3B0X2NhbGxiYWNrIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZVxuXHQgKiAgIHN0eWxlIGhhcyBiZWVuIHJ1bi5cblx0ICogQHBhcmFtIHtmdW5jdGlvbigpPX0gb3B0X2FwcGVuZEZuIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFwcGVuZCB0aGUgbm9kZVxuXHQgKiAgIGludG8gZG9jdW1lbnQuXG5cdCAqL1xuXHRzdGF0aWMgcnVuU3R5bGVzSW5FbGVtZW50KGVsZW1lbnQsIG9wdF9jYWxsYmFjaywgb3B0X2FwcGVuZEZuKSB7XG5cdFx0dmFyIHN0eWxlcyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGUsbGluaycpO1xuXHRcdGlmIChzdHlsZXMubGVuZ3RoID09PSAwICYmIG9wdF9jYWxsYmFjaykge1xuXHRcdFx0YXN5bmMubmV4dFRpY2sob3B0X2NhbGxiYWNrKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgbG9hZENvdW50ID0gMDtcblx0XHR2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChvcHRfY2FsbGJhY2sgJiYgKytsb2FkQ291bnQgPT09IHN0eWxlcy5sZW5ndGgpIHtcblx0XHRcdFx0YXN5bmMubmV4dFRpY2sob3B0X2NhbGxiYWNrKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRnbG9iYWxFdmFsU3R5bGVzLnJ1blN0eWxlKHN0eWxlc1tpXSwgY2FsbGJhY2ssIG9wdF9hcHBlbmRGbik7XG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdsb2JhbEV2YWxTdHlsZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IGNvcmUsIGFycmF5LCBEaXNwb3NhYmxlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IEV2ZW50SGFuZGxlIGZyb20gJy4vRXZlbnRIYW5kbGUnO1xuXG4vKipcbiAqIEV2ZW50RW1pdHRlciB1dGlsaXR5LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7RGlzcG9zYWJsZX1cbiAqL1xuY2xhc3MgRXZlbnRFbWl0dGVyIGV4dGVuZHMgRGlzcG9zYWJsZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBIb2xkcyBldmVudCBsaXN0ZW5lcnMgc2NvcGVkIGJ5IGV2ZW50IHR5cGUuXG5cdFx0ICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCAhQXJyYXk8IWZ1bmN0aW9uKCk+Pn1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5ldmVudHNfID0gW107XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgbGlzdGVuZXJzIGFsbG93ZWQgZm9yIGVhY2ggZXZlbnQgdHlwZS4gSWYgdGhlIG51bWJlclxuXHRcdCAqIGJlY29tZXMgaGlnaGVyIHRoYW4gdGhlIG1heCwgYSB3YXJuaW5nIHdpbGwgYmUgaXNzdWVkLlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMubWF4TGlzdGVuZXJzXyA9IDEwO1xuXG5cdFx0LyoqXG5cdFx0ICogQ29uZmlndXJhdGlvbiBvcHRpb24gd2hpY2ggZGV0ZXJtaW5lcyBpZiBhbiBldmVudCBmYWNhZGUgc2hvdWxkIGJlIHNlbnRcblx0XHQgKiBhcyBhIHBhcmFtIG9mIGxpc3RlbmVycyB3aGVuIGVtaXR0aW5nIGV2ZW50cy4gSWYgc2V0IHRvIHRydWUsIHRoZSBmYWNhZGVcblx0XHQgKiB3aWxsIGJlIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGxpc3RlbmVyLlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLnNob3VsZFVzZUZhY2FkZV8gPSBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgbGlzdGVuZXIgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdGVuZXJzIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50cy5cblx0ICogQHBhcmFtIHshKEFycmF5fHN0cmluZyl9IGV2ZW50c1xuXHQgKiBAcGFyYW0geyFGdW5jdGlvbn0gbGlzdGVuZXJcblx0ICogQHBhcmFtIHtib29sZWFufSBvcHRfZGVmYXVsdCBGbGFnIGluZGljYXRpbmcgaWYgdGhpcyBsaXN0ZW5lciBpcyBhIGRlZmF1bHRcblx0ICogICBhY3Rpb24gZm9yIHRoaXMgZXZlbnQuIERlZmF1bHQgYWN0aW9ucyBhcmUgcnVuIGxhc3QsIGFuZCBvbmx5IGlmIG5vIHByZXZpb3VzXG5cdCAqICAgbGlzdGVuZXIgY2FsbCBgcHJldmVudERlZmF1bHQoKWAgb24gdGhlIHJlY2VpdmVkIGV2ZW50IGZhY2FkZS5cblx0ICogQHJldHVybiB7IUV2ZW50SGFuZGxlfSBDYW4gYmUgdXNlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxuXHQgKi9cblx0YWRkTGlzdGVuZXIoZXZlbnRzLCBsaXN0ZW5lciwgb3B0X2RlZmF1bHQpIHtcblx0XHR0aGlzLnZhbGlkYXRlTGlzdGVuZXJfKGxpc3RlbmVyKTtcblxuXHRcdGV2ZW50cyA9IHRoaXMubm9ybWFsaXplRXZlbnRzXyhldmVudHMpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLmFkZFNpbmdsZUxpc3RlbmVyXyhldmVudHNbaV0sIGxpc3RlbmVyLCBvcHRfZGVmYXVsdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBFdmVudEhhbmRsZSh0aGlzLCBldmVudHMsIGxpc3RlbmVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgbGlzdGVuZXIgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdGVuZXJzIGFycmF5IGZvciBhIHNpbmdsZSBldmVudC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG5cdCAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBsaXN0ZW5lclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdF9kZWZhdWx0IEZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIGxpc3RlbmVyIGlzIGEgZGVmYXVsdFxuXHQgKiAgIGFjdGlvbiBmb3IgdGhpcyBldmVudC4gRGVmYXVsdCBhY3Rpb25zIGFyZSBydW4gbGFzdCwgYW5kIG9ubHkgaWYgbm8gcHJldmlvdXNcblx0ICogICBsaXN0ZW5lciBjYWxsIGBwcmV2ZW50RGVmYXVsdCgpYCBvbiB0aGUgcmVjZWl2ZWQgZXZlbnQgZmFjYWRlLlxuXHQgKiBAcmV0dXJuIHshRXZlbnRIYW5kbGV9IENhbiBiZSB1c2VkIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRfb3JpZ2luIFRoZSBvcmlnaW5hbCBmdW5jdGlvbiB0aGF0IHdhcyBhZGRlZCBhcyBhXG5cdCAqICAgbGlzdGVuZXIsIGlmIHRoZXJlIGlzIGFueS5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0YWRkU2luZ2xlTGlzdGVuZXJfKGV2ZW50LCBsaXN0ZW5lciwgb3B0X2RlZmF1bHQsIG9wdF9vcmlnaW4pIHtcblx0XHR0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgZXZlbnQsIGxpc3RlbmVyKTtcblxuXHRcdGlmICghdGhpcy5ldmVudHNfW2V2ZW50XSkge1xuXHRcdFx0dGhpcy5ldmVudHNfW2V2ZW50XSA9IFtdO1xuXHRcdH1cblx0XHR0aGlzLmV2ZW50c19bZXZlbnRdLnB1c2goe1xuXHRcdFx0ZGVmYXVsdDogb3B0X2RlZmF1bHQsXG5cdFx0XHRmbjogbGlzdGVuZXIsXG5cdFx0XHRvcmlnaW46IG9wdF9vcmlnaW5cblx0XHR9KTtcblxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c19bZXZlbnRdO1xuXHRcdGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gdGhpcy5tYXhMaXN0ZW5lcnNfICYmICFsaXN0ZW5lcnMud2FybmVkKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZCAnICtcblx0XHRcdFx0J2ZvciBldmVudCAlcy4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcblx0XHRcdFx0bGlzdGVuZXJzLmxlbmd0aCxcblx0XHRcdFx0ZXZlbnRcblx0XHRcdCk7XG5cdFx0XHRsaXN0ZW5lcnMud2FybmVkID0gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRGlzcG9zZXMgb2YgdGhpcyBpbnN0YW5jZSdzIG9iamVjdCByZWZlcmVuY2VzLlxuXHQgKiBAb3ZlcnJpZGVcblx0ICovXG5cdGRpc3Bvc2VJbnRlcm5hbCgpIHtcblx0XHR0aGlzLmV2ZW50c18gPSBbXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFeGVjdXRlIGVhY2ggb2YgdGhlIGxpc3RlbmVycyBpbiBvcmRlciB3aXRoIHRoZSBzdXBwbGllZCBhcmd1bWVudHMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuXHQgKiBAcGFyYW0geyp9IG9wdF9hcmdzIFthcmcxXSwgW2FyZzJdLCBbLi4uXVxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgZXZlbnQgaGFkIGxpc3RlbmVycywgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKi9cblx0ZW1pdChldmVudCkge1xuXHRcdHZhciBhcmdzID0gYXJyYXkuc2xpY2UoYXJndW1lbnRzLCAxKTtcblx0XHR2YXIgbGlzdGVuZXJzID0gKHRoaXMuZXZlbnRzX1tldmVudF0gfHwgW10pLmNvbmNhdCgpO1xuXG5cdFx0dmFyIGZhY2FkZTtcblx0XHRpZiAodGhpcy5nZXRTaG91bGRVc2VGYWNhZGUoKSkge1xuXHRcdFx0ZmFjYWRlID0ge1xuXHRcdFx0XHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZmFjYWRlLnByZXZlbnRlZERlZmF1bHQgPSB0cnVlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0YXJnZXQ6IHRoaXMsXG5cdFx0XHRcdHR5cGU6IGV2ZW50XG5cdFx0XHR9O1xuXHRcdFx0YXJncy5wdXNoKGZhY2FkZSk7XG5cdFx0fVxuXG5cdFx0dmFyIGRlZmF1bHRMaXN0ZW5lcnMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGxpc3RlbmVyc1tpXS5kZWZhdWx0KSB7XG5cdFx0XHRcdGRlZmF1bHRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcnNbaV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGlzdGVuZXJzW2ldLmZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIWZhY2FkZSB8fCAhZmFjYWRlLnByZXZlbnRlZERlZmF1bHQpIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZGVmYXVsdExpc3RlbmVycy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkZWZhdWx0TGlzdGVuZXJzW2pdLmZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0aWYgKGV2ZW50ICE9PSAnKicpIHtcblx0XHRcdHRoaXMuZW1pdC5hcHBseSh0aGlzLCBbJyonLCBldmVudF0uY29uY2F0KGFyZ3MpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGlzdGVuZXJzLmxlbmd0aCA+IDA7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgY29uZmlndXJhdGlvbiBvcHRpb24gd2hpY2ggZGV0ZXJtaW5lcyBpZiBhbiBldmVudCBmYWNhZGUgc2hvdWxkXG5cdCAqIGJlIHNlbnQgYXMgYSBwYXJhbSBvZiBsaXN0ZW5lcnMgd2hlbiBlbWl0dGluZyBldmVudHMuIElmIHNldCB0byB0cnVlLCB0aGVcblx0ICogZmFjYWRlIHdpbGwgYmUgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgbGlzdGVuZXIuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRnZXRTaG91bGRVc2VGYWNhZGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2hvdWxkVXNlRmFjYWRlXztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGxpc3RlbmVycyBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG5cdCAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBsaXN0ZW5lcnMuXG5cdCAqL1xuXHRsaXN0ZW5lcnMoZXZlbnQpIHtcblx0XHRyZXR1cm4gKHRoaXMuZXZlbnRzX1tldmVudF0gfHwgW10pLm1hcChsaXN0ZW5lciA9PiBsaXN0ZW5lci5mbik7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgZml4ZWQgbnVtYmVyIG9mIHRpbWVzIGZvciB0aGVcblx0ICogZXZlbnRzLiBBZnRlciBlYWNoIGV2ZW50IGlzIHRyaWdnZXJlZCB0aGUgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lcywgdGhlXG5cdCAqIGxpc3RlbmVyIGlzIHJlbW92ZWQgZm9yIGl0LlxuXHQgKiBAcGFyYW0geyEoQXJyYXl8c3RyaW5nKX0gZXZlbnRzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgVGhlIGFtb3VudCBvZiB0aW1lcyB0aGlzIGV2ZW50IHNob3VsZCBiZSBsaXN0ZW5lZFxuXHQgKiB0by5cblx0ICogQHBhcmFtIHshRnVuY3Rpb259IGxpc3RlbmVyXG5cdCAqIEByZXR1cm4geyFFdmVudEhhbmRsZX0gQ2FuIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cblx0ICovXG5cdG1hbnkoZXZlbnRzLCBhbW91bnQsIGxpc3RlbmVyKSB7XG5cdFx0ZXZlbnRzID0gdGhpcy5ub3JtYWxpemVFdmVudHNfKGV2ZW50cyk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMubWFueV8oZXZlbnRzW2ldLCBhbW91bnQsIGxpc3RlbmVyKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IEV2ZW50SGFuZGxlKHRoaXMsIGV2ZW50cywgbGlzdGVuZXIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIGZpeGVkIG51bWJlciBvZiB0aW1lcyBmb3IgYSBzaW5nbGVcblx0ICogZXZlbnQuIEFmdGVyIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQgdGhlIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZXMsIHRoZVxuXHQgKiBsaXN0ZW5lciBpcyByZW1vdmVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCBUaGUgYW1vdW50IG9mIHRpbWVzIHRoaXMgZXZlbnQgc2hvdWxkIGJlIGxpc3RlbmVkXG5cdCAqIHRvLlxuXHQgKiBAcGFyYW0geyFGdW5jdGlvbn0gbGlzdGVuZXJcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0bWFueV8oZXZlbnQsIGFtb3VudCwgbGlzdGVuZXIpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoYW1vdW50IDw9IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVySW50ZXJuYWwoKSB7XG5cdFx0XHRpZiAoLS1hbW91bnQgPT09IDApIHtcblx0XHRcdFx0c2VsZi5yZW1vdmVMaXN0ZW5lcihldmVudCwgaGFuZGxlckludGVybmFsKTtcblx0XHRcdH1cblx0XHRcdGxpc3RlbmVyLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXG5cdFx0c2VsZi5hZGRTaW5nbGVMaXN0ZW5lcl8oZXZlbnQsIGhhbmRsZXJJbnRlcm5hbCwgZmFsc2UsIGxpc3RlbmVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYSBsaXN0ZW5lciBvYmplY3QgbWF0Y2hlcyB0aGUgZ2l2ZW4gbGlzdGVuZXIgZnVuY3Rpb24uIFRvIG1hdGNoLFxuXHQgKiBpdCBuZWVkcyB0byBlaXRoZXIgcG9pbnQgdG8gdGhhdCBsaXN0ZW5lciBvciBoYXZlIGl0IGFzIGl0cyBvcmlnaW4uXG5cdCAqIEBwYXJhbSB7IU9iamVjdH0gbGlzdGVuZXJPYmpcblx0ICogQHBhcmFtIHshRnVuY3Rpb259IGxpc3RlbmVyXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdG1hdGNoZXNMaXN0ZW5lcl8obGlzdGVuZXJPYmosIGxpc3RlbmVyKSB7XG5cdFx0cmV0dXJuIGxpc3RlbmVyT2JqLmZuID09PSBsaXN0ZW5lciB8fFxuXHRcdFx0KGxpc3RlbmVyT2JqLm9yaWdpbiAmJiBsaXN0ZW5lck9iai5vcmlnaW4gPT09IGxpc3RlbmVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgcGFyYW1ldGVyIHRvIGFuIGFycmF5IGlmIG9ubHkgb25lIGV2ZW50IGlzIGdpdmVuLlxuXHQgKiBAcGFyYW0gIHshKEFycmF5fHN0cmluZyl9IGV2ZW50c1xuXHQgKiBAcmV0dXJuIHshQXJyYXl9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdG5vcm1hbGl6ZUV2ZW50c18oZXZlbnRzKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNTdHJpbmcoZXZlbnRzKSA/IFtldmVudHNdIDogZXZlbnRzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudHMuXG5cdCAqIENhdXRpb246IGNoYW5nZXMgYXJyYXkgaW5kaWNlcyBpbiB0aGUgbGlzdGVuZXIgYXJyYXkgYmVoaW5kIHRoZSBsaXN0ZW5lci5cblx0ICogQHBhcmFtIHshKEFycmF5fHN0cmluZyl9IGV2ZW50c1xuXHQgKiBAcGFyYW0geyFGdW5jdGlvbn0gbGlzdGVuZXJcblx0ICogQHJldHVybiB7IU9iamVjdH0gUmV0dXJucyBlbWl0dGVyLCBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICovXG5cdG9mZihldmVudHMsIGxpc3RlbmVyKSB7XG5cdFx0dGhpcy52YWxpZGF0ZUxpc3RlbmVyXyhsaXN0ZW5lcik7XG5cblx0XHRldmVudHMgPSB0aGlzLm5vcm1hbGl6ZUV2ZW50c18oZXZlbnRzKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGxpc3RlbmVyT2JqcyA9IHRoaXMuZXZlbnRzX1tldmVudHNbaV1dIHx8IFtdO1xuXHRcdFx0dGhpcy5yZW1vdmVNYXRjaGluZ0xpc3RlbmVyT2Jqc18obGlzdGVuZXJPYmpzLCBsaXN0ZW5lcik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGxpc3RlbmVyIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RlbmVycyBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCBldmVudHMuXG5cdCAqIEBwYXJhbSB7IShBcnJheXxzdHJpbmcpfSBldmVudHNcblx0ICogQHBhcmFtIHshRnVuY3Rpb259IGxpc3RlbmVyXG5cdCAqIEByZXR1cm4geyFFdmVudEhhbmRsZX0gQ2FuIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cblx0ICovXG5cdG9uKCkge1xuXHRcdHJldHVybiB0aGlzLmFkZExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIG9uZSB0aW1lIGxpc3RlbmVyIGZvciB0aGUgZXZlbnRzLiBUaGlzIGxpc3RlbmVyIGlzIGludm9rZWQgb25seSB0aGVcblx0ICogbmV4dCB0aW1lIGVhY2ggZXZlbnQgaXMgZmlyZWQsIGFmdGVyIHdoaWNoIGl0IGlzIHJlbW92ZWQuXG5cdCAqIEBwYXJhbSB7IShBcnJheXxzdHJpbmcpfSBldmVudHNcblx0ICogQHBhcmFtIHshRnVuY3Rpb259IGxpc3RlbmVyXG5cdCAqIEByZXR1cm4geyFFdmVudEhhbmRsZX0gQ2FuIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cblx0ICovXG5cdG9uY2UoZXZlbnRzLCBsaXN0ZW5lcikge1xuXHRcdHJldHVybiB0aGlzLm1hbnkoZXZlbnRzLCAxLCBsaXN0ZW5lcik7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50cy4gSXQncyBub3QgYSBnb29kXG5cdCAqIGlkZWEgdG8gcmVtb3ZlIGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQgZWxzZXdoZXJlIGluIHRoZSBjb2RlLFxuXHQgKiBlc3BlY2lhbGx5IHdoZW4gaXQncyBvbiBhbiBlbWl0dGVyIHRoYXQgeW91IGRpZG4ndCBjcmVhdGUuXG5cdCAqIEBwYXJhbSB7KEFycmF5fHN0cmluZyk9fSBvcHRfZXZlbnRzXG5cdCAqIEByZXR1cm4geyFPYmplY3R9IFJldHVybnMgZW1pdHRlciwgc28gY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqL1xuXHRyZW1vdmVBbGxMaXN0ZW5lcnMob3B0X2V2ZW50cykge1xuXHRcdGlmIChvcHRfZXZlbnRzKSB7XG5cdFx0XHR2YXIgZXZlbnRzID0gdGhpcy5ub3JtYWxpemVFdmVudHNfKG9wdF9ldmVudHMpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5ldmVudHNfW2V2ZW50c1tpXV0gPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmV2ZW50c18gPSB7fTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXIgb2JqZWN0cyBmcm9tIHRoZSBnaXZlbiBhcnJheSB0aGF0IG1hdGNoIHRoZSBnaXZlblxuXHQgKiBsaXN0ZW5lciBmdW5jdGlvbi5cblx0ICogQHBhcmFtIHshQXJyYXkuPE9iamVjdD59IGxpc3RlbmVyT2Jqc1xuXHQgKiBAcGFyYW0geyFGdW5jdGlvbn0gbGlzdGVuZXJcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cmVtb3ZlTWF0Y2hpbmdMaXN0ZW5lck9ianNfKGxpc3RlbmVyT2JqcywgbGlzdGVuZXIpIHtcblx0XHRmb3IgKHZhciBpID0gbGlzdGVuZXJPYmpzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRpZiAodGhpcy5tYXRjaGVzTGlzdGVuZXJfKGxpc3RlbmVyT2Jqc1tpXSwgbGlzdGVuZXIpKSB7XG5cdFx0XHRcdGxpc3RlbmVyT2Jqcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudHMuXG5cdCAqIENhdXRpb246IGNoYW5nZXMgYXJyYXkgaW5kaWNlcyBpbiB0aGUgbGlzdGVuZXIgYXJyYXkgYmVoaW5kIHRoZSBsaXN0ZW5lci5cblx0ICogQHBhcmFtIHshKEFycmF5fHN0cmluZyl9IGV2ZW50c1xuXHQgKiBAcGFyYW0geyFGdW5jdGlvbn0gbGlzdGVuZXJcblx0ICogQHJldHVybiB7IU9iamVjdH0gUmV0dXJucyBlbWl0dGVyLCBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICovXG5cdHJlbW92ZUxpc3RlbmVyKCkge1xuXHRcdHJldHVybiB0aGlzLm9mZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzXG5cdCAqIGFyZSBhZGRlZCBmb3IgYSBwYXJ0aWN1bGFyIGV2ZW50LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHNcblx0ICogZmluZGluZyBtZW1vcnkgbGVha3MuIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLlxuXHQgKiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuXHQgKiBAcmV0dXJuIHshT2JqZWN0fSBSZXR1cm5zIGVtaXR0ZXIsIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKi9cblx0c2V0TWF4TGlzdGVuZXJzKG1heCkge1xuXHRcdHRoaXMubWF4TGlzdGVuZXJzXyA9IG1heDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbiB3aGljaCBkZXRlcm1pbmVzIGlmIGFuIGV2ZW50IGZhY2FkZSBzaG91bGRcblx0ICogYmUgc2VudCBhcyBhIHBhcmFtIG9mIGxpc3RlbmVycyB3aGVuIGVtaXR0aW5nIGV2ZW50cy4gSWYgc2V0IHRvIHRydWUsIHRoZVxuXHQgKiBmYWNhZGUgd2lsbCBiZSBwYXNzZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBsaXN0ZW5lci5cblx0ICogQHBhcmFtIHtib29sZWFufSBzaG91bGRVc2VGYWNhZGVcblx0ICogQHJldHVybiB7IU9iamVjdH0gUmV0dXJucyBlbWl0dGVyLCBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICovXG5cdHNldFNob3VsZFVzZUZhY2FkZShzaG91bGRVc2VGYWNhZGUpIHtcblx0XHR0aGlzLnNob3VsZFVzZUZhY2FkZV8gPSBzaG91bGRVc2VGYWNhZGU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBsaXN0ZW5lciBpcyB2YWxpZCwgdGhyb3dpbmcgYW4gZXhjZXB0aW9uIHdoZW4gaXQncyBub3QuXG5cdCAqIEBwYXJhbSAgeyp9IGxpc3RlbmVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHZhbGlkYXRlTGlzdGVuZXJfKGxpc3RlbmVyKSB7XG5cdFx0aWYgKCFjb3JlLmlzRnVuY3Rpb24obGlzdGVuZXIpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdMaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRFbWl0dGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBhcnJheSwgRGlzcG9zYWJsZSB9IGZyb20gJ21ldGFsJztcblxuLyoqXG4gKiBFdmVudEVtaXR0ZXJQcm94eSB1dGlsaXR5LiBJdCdzIHJlc3BvbnNpYmxlIGZvciBsaW5raW5nIHR3byBFdmVudEVtaXR0ZXJcbiAqIGluc3RhbmNlcyB0b2dldGhlciwgZW1pdHRpbmcgZXZlbnRzIGZyb20gdGhlIGZpcnN0IGVtaXR0ZXIgdGhyb3VnaCB0aGVcbiAqIHNlY29uZCBvbmUuIFRoYXQgbWVhbnMgdGhhdCBsaXN0ZW5pbmcgdG8gYSBzdXBwb3J0ZWQgZXZlbnQgb24gdGhlIHRhcmdldFxuICogZW1pdHRlciB3aWxsIG1lYW4gbGlzdGVuaW5nIHRvIGl0IG9uIHRoZSBvcmlnaW4gZW1pdHRlciBhcyB3ZWxsLlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IG9yaWdpbkVtaXR0ZXIgRXZlbnRzIG9yaWdpbmF0ZWQgb24gdGhpcyBlbWl0dGVyXG4gKiAgIHdpbGwgYmUgZmlyZWQgZm9yIHRoZSB0YXJnZXQgZW1pdHRlcidzIGxpc3RlbmVycyBhcyB3ZWxsLlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IHRhcmdldEVtaXR0ZXIgRXZlbnQgbGlzdGVuZXJzIGF0dGFjaGVkIHRvIHRoaXMgZW1pdHRlclxuICogICB3aWxsIGFsc28gYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIGV2ZW50IGlzIGZpcmVkIGJ5IHRoZSBvcmlnaW4gZW1pdHRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRfYmxhY2tsaXN0IE9wdGlvbmFsIGJsYWNrbGlzdCBvZiBldmVudHMgdGhhdCBzaG91bGQgbm90IGJlXG4gKiAgIHByb3hpZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtEaXNwb3NhYmxlfVxuICovXG5jbGFzcyBFdmVudEVtaXR0ZXJQcm94eSBleHRlbmRzIERpc3Bvc2FibGUge1xuXHRjb25zdHJ1Y3RvcihvcmlnaW5FbWl0dGVyLCB0YXJnZXRFbWl0dGVyLCBvcHRfYmxhY2tsaXN0LCBvcHRfd2hpdGVsaXN0KSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIE1hcCBvZiBldmVudHMgdGhhdCBzaG91bGQgbm90IGJlIHByb3hpZWQuXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5ibGFja2xpc3RfID0gb3B0X2JsYWNrbGlzdCB8fCB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBvcmlnaW4gZW1pdHRlci4gVGhpcyBlbWl0dGVyJ3MgZXZlbnRzIHdpbGwgYmUgcHJveGllZCB0aHJvdWdoIHRoZVxuXHRcdCAqIHRhcmdldCBlbWl0dGVyLlxuXHRcdCAqIEB0eXBlIHtFdmVudEVtaXR0ZXJ9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMub3JpZ2luRW1pdHRlcl8gPSBvcmlnaW5FbWl0dGVyO1xuXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgYSBtYXAgb2YgZXZlbnRzIGZyb20gdGhlIG9yaWdpbiBlbWl0dGVyIHRoYXQgYXJlIGFscmVhZHkgYmVpbmcgcHJveGllZC5cblx0XHQgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgIUV2ZW50SGFuZGxlPn1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5wcm94aWVkRXZlbnRzXyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRhcmdldCBlbWl0dGVyLiBUaGlzIGVtaXR0ZXIgd2lsbCBlbWl0IGFsbCBldmVudHMgdGhhdCBjb21lIGZyb21cblx0XHQgKiB0aGUgb3JpZ2luIGVtaXR0ZXIuXG5cdFx0ICogQHR5cGUge0V2ZW50RW1pdHRlcn1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy50YXJnZXRFbWl0dGVyXyA9IHRhcmdldEVtaXR0ZXI7XG5cblx0XHQvKipcblx0XHQgKiBNYXAgb2YgZXZlbnRzIHRoYXQgc2hvdWxkIGJlIHByb3hpZWQuIElmIHdoaXRlbGlzdCBpcyBzZXQgYmxhY2tsaXN0IGlzIGlnbm9yZWQuXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy53aGl0ZWxpc3RfID0gb3B0X3doaXRlbGlzdDtcblxuXHRcdHRoaXMuc3RhcnRQcm94eV8oKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBnaXZlbiBsaXN0ZW5lciBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcblx0ICogQHBhcmFtIHshZnVuY3Rpb24oKX0gbGlzdGVuZXJcblx0ICogQHJldHVybiB7IUV2ZW50SGFuZGxlfSBUaGUgbGlzdGVuZWQgZXZlbnQncyBoYW5kbGUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGFkZExpc3RlbmVyXyhldmVudCwgbGlzdGVuZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5vcmlnaW5FbWl0dGVyXy5vbihldmVudCwgbGlzdGVuZXIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIHByb3h5IGxpc3RlbmVyIGZvciB0aGUgZ2l2ZW4gZXZlbnQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuXHQgKiBAcmV0dXJuIHshRXZlbnRIYW5kbGV9IFRoZSBsaXN0ZW5lZCBldmVudCdzIGhhbmRsZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0YWRkTGlzdGVuZXJGb3JFdmVudF8oZXZlbnQpIHtcblx0XHRyZXR1cm4gdGhpcy5hZGRMaXN0ZW5lcl8oZXZlbnQsIHRoaXMuZW1pdE9uVGFyZ2V0Xy5iaW5kKHRoaXMsIGV2ZW50KSk7XG5cdH1cblxuXHQvKipcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG5cdGRpc3Bvc2VJbnRlcm5hbCgpIHtcblx0XHR0aGlzLnJlbW92ZUxpc3RlbmVyc18oKTtcblx0XHR0aGlzLnByb3hpZWRFdmVudHNfID0gbnVsbDtcblx0XHR0aGlzLm9yaWdpbkVtaXR0ZXJfID0gbnVsbDtcblx0XHR0aGlzLnRhcmdldEVtaXR0ZXJfID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbWl0cyB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUgb24gdGhlIHRhcmdldCBlbWl0dGVyLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGVtaXRPblRhcmdldF8oZXZlbnRUeXBlKSB7XG5cdFx0dmFyIGFyZ3MgPSBbZXZlbnRUeXBlXS5jb25jYXQoYXJyYXkuc2xpY2UoYXJndW1lbnRzLCAxKSk7XG5cdFx0dGhpcy50YXJnZXRFbWl0dGVyXy5lbWl0LmFwcGx5KHRoaXMudGFyZ2V0RW1pdHRlcl8sIGFyZ3MpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFByb3hpZXMgdGhlIGdpdmVuIGV2ZW50IGZyb20gdGhlIG9yaWdpbiB0byB0aGUgdGFyZ2V0IGVtaXR0ZXIuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuXHQgKi9cblx0cHJveHlFdmVudChldmVudCkge1xuXHRcdGlmICh0aGlzLnNob3VsZFByb3h5RXZlbnRfKGV2ZW50KSkge1xuXHRcdFx0dGhpcy5wcm94aWVkRXZlbnRzX1tldmVudF0gPSB0aGlzLmFkZExpc3RlbmVyRm9yRXZlbnRfKGV2ZW50KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgcHJveHkgbGlzdGVuZXIgZm9yIGFsbCBldmVudHMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHJlbW92ZUxpc3RlbmVyc18oKSB7XG5cdFx0dmFyIGV2ZW50cyA9IE9iamVjdC5rZXlzKHRoaXMucHJveGllZEV2ZW50c18pO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLnByb3hpZWRFdmVudHNfW2V2ZW50c1tpXV0ucmVtb3ZlTGlzdGVuZXIoKTtcblx0XHR9XG5cdFx0dGhpcy5wcm94aWVkRXZlbnRzXyA9IHt9O1xuXHR9XG5cblx0LyoqXG5cdCAqIENoYW5nZXMgdGhlIG9yaWdpbiBlbWl0dGVyLiBUaGlzIGF1dG9tYXRpY2FsbHkgZGV0YWNoZXMgYW55IGV2ZW50cyB0aGF0XG5cdCAqIHdlcmUgYWxyZWFkeSBiZWluZyBwcm94aWVkIGZyb20gdGhlIHByZXZpb3VzIGVtaXR0ZXIsIGFuZCBzdGFydHMgcHJveHlpbmdcblx0ICogdGhlbSBvbiB0aGUgbmV3IGVtaXR0ZXIgaW5zdGVhZC5cblx0ICovXG5cdHNldE9yaWdpbkVtaXR0ZXIob3JpZ2luRW1pdHRlcikge1xuXHRcdHZhciBoYW5kbGVzID0gdGhpcy5wcm94aWVkRXZlbnRzXztcblx0XHR0aGlzLnJlbW92ZUxpc3RlbmVyc18oKTtcblx0XHR0aGlzLm9yaWdpbkVtaXR0ZXJfID0gb3JpZ2luRW1pdHRlcjtcblxuXHRcdHZhciBldmVudHMgPSBPYmplY3Qua2V5cyhoYW5kbGVzKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5wcm94aWVkRXZlbnRzX1tldmVudHNbaV1dID0gdGhpcy5hZGRMaXN0ZW5lckZvckV2ZW50XyhldmVudHNbaV0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGV2ZW50IHNob3VsZCBiZSBwcm94aWVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c2hvdWxkUHJveHlFdmVudF8oZXZlbnQpIHtcblx0XHRpZiAodGhpcy53aGl0ZWxpc3RfICYmICF0aGlzLndoaXRlbGlzdF9bZXZlbnRdKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmJsYWNrbGlzdF9bZXZlbnRdKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiAhdGhpcy5wcm94aWVkRXZlbnRzX1tldmVudF07XG5cdH1cblxuXHQvKipcblx0ICogU3RhcnRzIHByb3h5aW5nIGFsbCBldmVudHMgZnJvbSB0aGUgb3JpZ2luIHRvIHRoZSB0YXJnZXQgZW1pdHRlci5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c3RhcnRQcm94eV8oKSB7XG5cdFx0dGhpcy50YXJnZXRFbWl0dGVyXy5vbignbmV3TGlzdGVuZXInLCB0aGlzLnByb3h5RXZlbnQuYmluZCh0aGlzKSk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRFbWl0dGVyUHJveHk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IERpc3Bvc2FibGUgfSBmcm9tICdtZXRhbCc7XG5cbi8qKlxuICogRXZlbnRIYW5kbGUgdXRpbGl0eS4gSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgYW4gZXZlbnQgc3Vic2NyaXB0aW9uLCBhbmRcbiAqIGFsbG93cyByZW1vdmluZyB0aGVtIGVhc2lseS5cbiAqIEV2ZW50SGFuZGxlIGlzIGEgRGlzcG9zYWJsZSwgYnV0IGl0J3MgaW1wb3J0YW50IHRvIG5vdGUgdGhhdCB0aGVcbiAqIEV2ZW50RW1pdHRlciB0aGF0IGNyZWF0ZWQgaXQgaXMgbm90IHRoZSBvbmUgcmVzcG9uc2libGUgZm9yIGRpc3Bvc2luZyBpdC5cbiAqIFRoYXQgcmVzcG9uc2liaWxpdHkgaXMgZm9yIHRoZSBjb2RlIHRoYXQgaG9sZHMgYSByZWZlcmVuY2UgdG8gaXQuXG4gKiBAcGFyYW0geyFFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgRW1pdHRlciB0aGUgZXZlbnQgd2FzIHN1YnNjcmliZWQgdG8uXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRoYXQgd2FzIHN1YnNjcmliZWQgdG8uXG4gKiBAcGFyYW0geyFGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHN1YnNjcmliZWQgdG8gdGhlIGV2ZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7RGlzcG9zYWJsZX1cbiAqL1xuY2xhc3MgRXZlbnRIYW5kbGUgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcblx0Y29uc3RydWN0b3IoZW1pdHRlciwgZXZlbnQsIGxpc3RlbmVyKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBFdmVudEVtaXR0ZXIgaW5zdGFuY2UgdGhhdCB0aGUgZXZlbnQgd2FzIHN1YnNjcmliZWQgdG8uXG5cdFx0ICogQHR5cGUge0V2ZW50RW1pdHRlcn1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5lbWl0dGVyXyA9IGVtaXR0ZXI7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdGhhdCB3YXMgc3Vic2NyaWJlZCB0by5cblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLmV2ZW50XyA9IGV2ZW50O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxpc3RlbmVyIHN1YnNjcmliZWQgdG8gdGhlIGV2ZW50LlxuXHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5saXN0ZW5lcl8gPSBsaXN0ZW5lcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNwb3NlcyBvZiB0aGlzIGluc3RhbmNlJ3Mgb2JqZWN0IHJlZmVyZW5jZXMuXG5cdCAqIEBvdmVycmlkZVxuXHQgKi9cblx0ZGlzcG9zZUludGVybmFsKCkge1xuXHRcdHRoaXMucmVtb3ZlTGlzdGVuZXIoKTtcblx0XHR0aGlzLmVtaXR0ZXJfID0gbnVsbDtcblx0XHR0aGlzLmxpc3RlbmVyXyA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgbGlzdGVuZXIgc3Vic2NyaXB0aW9uIGZyb20gdGhlIGVtaXR0ZXIuXG5cdCAqL1xuXHRyZW1vdmVMaXN0ZW5lcigpIHtcblx0XHRpZiAoIXRoaXMuZW1pdHRlcl8uaXNEaXNwb3NlZCgpKSB7XG5cdFx0XHR0aGlzLmVtaXR0ZXJfLnJlbW92ZUxpc3RlbmVyKHRoaXMuZXZlbnRfLCB0aGlzLmxpc3RlbmVyXyk7XG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50SGFuZGxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBEaXNwb3NhYmxlIH0gZnJvbSAnbWV0YWwnO1xuXG4vKipcbiAqIEV2ZW50SGFuZGxlciB1dGlsaXR5LiBJdCdzIHVzZWZ1bCBmb3IgZWFzaWx5IHJlbW92aW5nIGEgZ3JvdXAgb2ZcbiAqIGxpc3RlbmVycyBmcm9tIGRpZmZlcmVudCBFdmVudEVtaXR0ZXIgaW5zdGFuY2VzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7RGlzcG9zYWJsZX1cbiAqL1xuY2xhc3MgRXZlbnRIYW5kbGVyIGV4dGVuZHMgRGlzcG9zYWJsZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSB0aGF0IGhvbGRzIHRoZSBhZGRlZCBldmVudCBoYW5kbGVzLCBzbyB0aGUgbGlzdGVuZXJzIGNhbiBiZVxuXHRcdCAqIHJlbW92ZWQgbGF0ZXIuXG5cdFx0ICogQHR5cGUge0FycmF5LjxFdmVudEhhbmRsZT59XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuZXZlbnRIYW5kbGVzXyA9IFtdO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgZXZlbnQgaGFuZGxlcyB0byBiZSByZW1vdmVkIGxhdGVyIHRocm91Z2ggdGhlIGByZW1vdmVBbGxMaXN0ZW5lcnNgXG5cdCAqIG1ldGhvZC5cblx0ICogQHBhcmFtIHsuLi4oIUV2ZW50SGFuZGxlKX0gdmFyX2FyZ3Ncblx0ICovXG5cdGFkZCgpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5ldmVudEhhbmRsZXNfLnB1c2goYXJndW1lbnRzW2ldKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRGlzcG9zZXMgb2YgdGhpcyBpbnN0YW5jZSdzIG9iamVjdCByZWZlcmVuY2VzLlxuXHQgKiBAb3ZlcnJpZGVcblx0ICovXG5cdGRpc3Bvc2VJbnRlcm5hbCgpIHtcblx0XHR0aGlzLmV2ZW50SGFuZGxlc18gPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyB0aGF0IGhhdmUgYmVlbiBhZGRlZCB0aHJvdWdoIHRoZSBgYWRkYCBtZXRob2QuXG5cdCAqL1xuXHRyZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50SGFuZGxlc18ubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMuZXZlbnRIYW5kbGVzX1tpXS5yZW1vdmVMaXN0ZW5lcigpO1xuXHRcdH1cblxuXHRcdHRoaXMuZXZlbnRIYW5kbGVzXyA9IFtdO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50SGFuZGxlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuL0V2ZW50RW1pdHRlcic7XG5pbXBvcnQgRXZlbnRFbWl0dGVyUHJveHkgZnJvbSAnLi9FdmVudEVtaXR0ZXJQcm94eSc7XG5pbXBvcnQgRXZlbnRIYW5kbGUgZnJvbSAnLi9FdmVudEhhbmRsZSc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4vRXZlbnRIYW5kbGVyJztcblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRFbWl0dGVyO1xuZXhwb3J0IHsgRXZlbnRFbWl0dGVyLCBFdmVudEVtaXR0ZXJQcm94eSwgRXZlbnRIYW5kbGUsIEV2ZW50SGFuZGxlciB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgJy4vaW5jcmVtZW50YWwtZG9tJztcbmltcG9ydCB7IGFycmF5LCBvYmplY3QgfSBmcm9tICdtZXRhbCc7XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIGludGVyY2VwdGluZyBpbmNyZW1lbnRhbCBkb20gZnVuY3Rpb25zIHRocm91Z2ggQU9QLlxuICovXG5jbGFzcyBJbmNyZW1lbnRhbERvbUFvcCB7XG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBvcmlnaW5hbCBmdW5jdGlvbnMgdGhhdCBhcmUgaW50ZXJjZXB0ZWQgYnkgYEluY3JlbWVudGFsRG9tQW9wYC5cblx0ICogQHJldHVybiB7IU9iamVjdH1cblx0ICovXG5cdHN0YXRpYyBnZXRPcmlnaW5hbEZucygpIHtcblx0XHRyZXR1cm4gZm5TdGFja1swXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTdGFydHMgaW50ZXJjZXB0aW5nIGNhbGxzIHRvIGluY3JlbWVudGFsIGRvbSwgcmVwbGFjaW5nIHRoZW0gd2l0aCB0aGUgZ2l2ZW5cblx0ICogZnVuY3Rpb25zLiBOb3RlIHRoYXQgYGVsZW1lbnRWb2lkYCwgYGVsZW1lbnRPcGVuU3RhcnRgLCBgZWxlbWVudE9wZW5FbmRgXG5cdCAqIGFuZCBgYXR0cmAgYXJlIHRoZSBvbmx5IG9uZXMgdGhhdCBjYW4ndCBiZSBpbnRlcmNlcHRlZCwgc2luY2UgdGhleSdsbFxuXHQgKiBhdXRvbWF0aWNhbGx5IGJlIGNvbnZlcnRlZCBpbnRvIGVxdWl2YWxlbnQgY2FsbHMgdG8gYGVsZW1lbnRPcGVuYCBhbmRcblx0ICogYGVsZW1lbnRDbG9zZWAuXG5cdCAqIEBwYXJhbSB7IU9iamVjdH0gZm5zIEZ1bmN0aW9ucyB0byBiZSBjYWxsZWQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgb25lc1xuXHQgKiAgICAgZnJvbSBpbmNyZW1lbnRhbCBET00uIFNob3VsZCBiZSBnaXZlbiBhcyBhIG1hcCBmcm9tIHRoZSBmdW5jdGlvbiBuYW1lXG5cdCAqICAgICB0byB0aGUgZnVuY3Rpb24gdGhhdCBzaG91bGQgaW50ZXJjZXB0IGl0LiBBbGwgaW50ZXJjZXB0b3JzIHdpbGwgcmVjZWl2ZVxuXHQgKiAgICAgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgdGhlIGFjdHVhbCBhcmd1bWVudHMgZnJvbVxuXHQgKiAgICAgZnJvbSB0aGUgb3JpZ2luYWwgY2FsbCBmb2xsb3dpbmcgaXQuXG5cdCAqL1xuXHRzdGF0aWMgc3RhcnRJbnRlcmNlcHRpb24oZm5zKSB7XG5cdFx0dmFyIG9yaWdpbmFscyA9IEluY3JlbWVudGFsRG9tQW9wLmdldE9yaWdpbmFsRm5zKCk7XG5cdFx0Zm5zID0gb2JqZWN0Lm1hcChmbnMsIChuYW1lLCB2YWx1ZSkgPT4gdmFsdWUuYmluZChudWxsLCBvcmlnaW5hbHNbbmFtZV0pKTtcblx0XHRmblN0YWNrLnB1c2gob2JqZWN0Lm1peGluKHt9LCBvcmlnaW5hbHMsIGZucywge1xuXHRcdFx0YXR0cjogZm5BdHRyLFxuXHRcdFx0ZWxlbWVudE9wZW5FbmQ6IGZuT3BlbkVuZCxcblx0XHRcdGVsZW1lbnRPcGVuU3RhcnQ6IGZuT3BlblN0YXJ0LFxuXHRcdFx0ZWxlbWVudFZvaWQ6IGZuVm9pZFxuXHRcdH0pKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgYGVsZW1lbnRPcGVuYCBmdW5jdGlvbiBmcm9tIGluY3JlbWVudGFsIGRvbSB0byB0aGVcblx0ICogaW1wbGVtZW50YXRpb24gaXQgdXNlZCBiZWZvcmUgdGhlIGxhc3QgY2FsbCB0byBgc3RhcnRJbnRlcmNlcHRpb25gLlxuXHQgKi9cblx0c3RhdGljIHN0b3BJbnRlcmNlcHRpb24oKSB7XG5cdFx0aWYgKGZuU3RhY2subGVuZ3RoID4gMSkge1xuXHRcdFx0Zm5TdGFjay5wb3AoKTtcblx0XHR9XG5cdH1cbn1cblxudmFyIGZuU3RhY2sgPSBbe1xuXHRhdHRyOiBJbmNyZW1lbnRhbERPTS5hdHRyLFxuXHRhdHRyaWJ1dGVzOiBJbmNyZW1lbnRhbERPTS5hdHRyaWJ1dGVzW0luY3JlbWVudGFsRE9NLnN5bWJvbHMuZGVmYXVsdF0sXG5cdGVsZW1lbnRDbG9zZTogSW5jcmVtZW50YWxET00uZWxlbWVudENsb3NlLFxuXHRlbGVtZW50T3BlbjogSW5jcmVtZW50YWxET00uZWxlbWVudE9wZW4sXG5cdGVsZW1lbnRPcGVuRW5kOiBJbmNyZW1lbnRhbERPTS5lbGVtZW50T3BlbkVuZCxcblx0ZWxlbWVudE9wZW5TdGFydDogSW5jcmVtZW50YWxET00uZWxlbWVudE9wZW5TdGFydCxcblx0ZWxlbWVudFZvaWQ6IEluY3JlbWVudGFsRE9NLmVsZW1lbnRWb2lkLFxuXHR0ZXh0OiBJbmNyZW1lbnRhbERPTS50ZXh0XG59XTtcblxudmFyIGNvbGxlY3RlZEFyZ3MgPSBbXTtcblxuZnVuY3Rpb24gZm5BdHRyKG5hbWUsIHZhbHVlKSB7XG5cdGNvbGxlY3RlZEFyZ3MucHVzaChuYW1lLCB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGZuT3BlblN0YXJ0KHRhZywga2V5LCBzdGF0aWNzKSB7XG5cdGNvbGxlY3RlZEFyZ3MgPSBbdGFnLCBrZXksIHN0YXRpY3NdO1xufVxuXG5mdW5jdGlvbiBmbk9wZW5FbmQoKSB7XG5cdHJldHVybiBnZXRGbignZWxlbWVudE9wZW4nKS5hcHBseShudWxsLCBjb2xsZWN0ZWRBcmdzKTtcbn1cblxuZnVuY3Rpb24gZm5Wb2lkKHRhZykge1xuXHRnZXRGbignZWxlbWVudE9wZW4nKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXHRyZXR1cm4gZ2V0Rm4oJ2VsZW1lbnRDbG9zZScpKHRhZyk7XG59XG5cbmZ1bmN0aW9uIGdldEZuKG5hbWUpIHtcblx0cmV0dXJuIGZuU3RhY2tbZm5TdGFjay5sZW5ndGggLSAxXVtuYW1lXTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQ2FsbChuYW1lKSB7XG5cdHJldHVybiBnZXRGbihuYW1lKS5hcHBseShudWxsLCBhcnJheS5zbGljZShhcmd1bWVudHMsIDEpKTtcbn1cblxuSW5jcmVtZW50YWxET00uYXR0ciA9IGhhbmRsZUNhbGwuYmluZChudWxsLCAnYXR0cicpO1xuSW5jcmVtZW50YWxET00uZWxlbWVudENsb3NlID0gaGFuZGxlQ2FsbC5iaW5kKG51bGwsICdlbGVtZW50Q2xvc2UnKTtcbkluY3JlbWVudGFsRE9NLmVsZW1lbnRPcGVuID0gaGFuZGxlQ2FsbC5iaW5kKG51bGwsICdlbGVtZW50T3BlbicpO1xuSW5jcmVtZW50YWxET00uZWxlbWVudE9wZW5FbmQgPSBoYW5kbGVDYWxsLmJpbmQobnVsbCwgJ2VsZW1lbnRPcGVuRW5kJyk7XG5JbmNyZW1lbnRhbERPTS5lbGVtZW50T3BlblN0YXJ0ID0gaGFuZGxlQ2FsbC5iaW5kKG51bGwsICdlbGVtZW50T3BlblN0YXJ0Jyk7XG5JbmNyZW1lbnRhbERPTS5lbGVtZW50Vm9pZCA9IGhhbmRsZUNhbGwuYmluZChudWxsLCAnZWxlbWVudFZvaWQnKTtcbkluY3JlbWVudGFsRE9NLnRleHQgPSBoYW5kbGVDYWxsLmJpbmQobnVsbCwgJ3RleHQnKTtcblxuSW5jcmVtZW50YWxET00uYXR0cmlidXRlc1tJbmNyZW1lbnRhbERPTS5zeW1ib2xzLmRlZmF1bHRdID0gaGFuZGxlQ2FsbC5iaW5kKFxuXHRudWxsLFxuXHQnYXR0cmlidXRlcydcbik7XG5cbmV4cG9ydCBkZWZhdWx0IEluY3JlbWVudGFsRG9tQW9wO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgJy4vaW5jcmVtZW50YWwtZG9tJztcbmltcG9ydCB7IGFycmF5LCBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IGRvbSBmcm9tICdtZXRhbC1kb20nO1xuaW1wb3J0IHsgQ29tcG9uZW50UmVuZGVyZXIsIEV2ZW50c0NvbGxlY3RvciB9IGZyb20gJ21ldGFsLWNvbXBvbmVudCc7XG5pbXBvcnQgSW5jcmVtZW50YWxEb21Bb3AgZnJvbSAnLi9JbmNyZW1lbnRhbERvbUFvcCc7XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIHJlbmRlcmluZyBjb21wb25lbnRzIHZpYSBpbmNyZW1lbnRhbCBkb20uXG4gKi9cbmNsYXNzIEluY3JlbWVudGFsRG9tUmVuZGVyZXIgZXh0ZW5kcyBDb21wb25lbnRSZW5kZXJlciB7XG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0Y29uc3RydWN0b3IoY29tcCkge1xuXHRcdHN1cGVyKGNvbXApO1xuXG5cdFx0dGhpcy5jaGFuZ2VzXyA9IHt9O1xuXHRcdHRoaXMuZXZlbnRzQ29sbGVjdG9yXyA9IG5ldyBFdmVudHNDb2xsZWN0b3IoY29tcCk7XG5cdFx0Y29tcC5vbignc3RhdGVLZXlDaGFuZ2VkJywgdGhpcy5oYW5kbGVTdGF0ZUtleUNoYW5nZWRfLmJpbmQodGhpcykpO1xuXHRcdGNvbXAub24oJ2RldGFjaGVkJywgdGhpcy5oYW5kbGVEZXRhY2hlZF8uYmluZCh0aGlzKSk7XG5cblx0XHQvLyBCaW5kcyBmdW5jdGlvbnMgdGhhdCB3aWxsIGJlIHVzZWQgbWFueSB0aW1lcywgdG8gYXZvaWQgY3JlYXRpbmcgbmV3XG5cdFx0Ly8gZnVuY3Rpb25zIGVhY2ggdGltZS5cblx0XHR0aGlzLmhhbmRsZUludGVyY2VwdGVkQXR0cmlidXRlc0NhbGxfID1cblx0XHRcdHRoaXMuaGFuZGxlSW50ZXJjZXB0ZWRBdHRyaWJ1dGVzQ2FsbF8uYmluZCh0aGlzKTtcblx0XHR0aGlzLmhhbmRsZUludGVyY2VwdGVkT3BlbkNhbGxfID1cblx0XHRcdHRoaXMuaGFuZGxlSW50ZXJjZXB0ZWRPcGVuQ2FsbF8uYmluZCh0aGlzKTtcblx0XHR0aGlzLmhhbmRsZUludGVyY2VwdGVkQ2hpbGRyZW5DbG9zZUNhbGxfID1cblx0XHRcdHRoaXMuaGFuZGxlSW50ZXJjZXB0ZWRDaGlsZHJlbkNsb3NlQ2FsbF8uYmluZCh0aGlzKTtcblx0XHR0aGlzLmhhbmRsZUludGVyY2VwdGVkQ2hpbGRyZW5PcGVuQ2FsbF8gPVxuXHRcdFx0dGhpcy5oYW5kbGVJbnRlcmNlcHRlZENoaWxkcmVuT3BlbkNhbGxfLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5oYW5kbGVJbnRlcmNlcHRlZENoaWxkcmVuVGV4dENhbGxfID1cblx0XHRcdHRoaXMuaGFuZGxlSW50ZXJjZXB0ZWRDaGlsZHJlblRleHRDYWxsXy5iaW5kKHRoaXMpO1xuXHRcdHRoaXMucmVuZGVyV2l0aG91dFBhdGNoID0gdGhpcy5yZW5kZXJXaXRob3V0UGF0Y2guYmluZCh0aGlzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGFsbCBpbmxpbmUgbGlzdGVuZXIgYXR0cmlidXRlcyBpbmNsdWRlZCBpbiB0aGUgZ2l2ZW4gY29uZmlnLlxuXHQgKiBAcGFyYW0geyFBcnJheX0gbGlzdGVuZXJzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGFkZElubGluZUxpc3RlbmVyc18obGlzdGVuZXJzKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpICs9IDIpIHtcblx0XHRcdHZhciBuYW1lID0gbGlzdGVuZXJzW2ldO1xuXHRcdFx0dmFyIGZuID0gbGlzdGVuZXJzW2kgKyAxXTtcblx0XHRcdGlmIChuYW1lLnN0YXJ0c1dpdGgoJ2RhdGEtb24nKSAmJiBjb3JlLmlzU3RyaW5nKGZuKSkge1xuXHRcdFx0XHR0aGlzLmxpc3RlbmVyc1RvQXR0YWNoXy5wdXNoKHtcblx0XHRcdFx0XHRldmVudE5hbWU6IG5hbWUuc3Vic3RyKDcpLFxuXHRcdFx0XHRcdGZuXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBdHRhY2hlcyBhbnkgaW5saW5lIGxpc3RlbmVycyBmb3VuZCBpbiB0aGUgY29udGVudHMgYnVpbHQgdmlhIHRoZSBsYXN0XG5cdCAqIGluY3JlbWVudGFsIGRvbSBwYXRjaC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0YXR0YWNoSW5saW5lTGlzdGVuZXJzXygpIHtcblx0XHR0aGlzLmV2ZW50c0NvbGxlY3Rvcl8uc3RhcnRDb2xsZWN0aW5nKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3RlbmVyc1RvQXR0YWNoXy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGxpc3RlbmVyID0gdGhpcy5saXN0ZW5lcnNUb0F0dGFjaF9baV07XG5cdFx0XHR0aGlzLmV2ZW50c0NvbGxlY3Rvcl8uYXR0YWNoTGlzdGVuZXIobGlzdGVuZXIuZXZlbnROYW1lLCBsaXN0ZW5lci5mbik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEJ1aWxkcyB0aGUgXCJjaGlsZHJlblwiIGNvbmZpZyBwcm9wZXJ0eSB0byBiZSBwYXNzZWQgdG8gdGhlIGN1cnJlbnRcblx0ICogY29tcG9uZW50LlxuXHQgKiBAcGFyYW0geyFBcnJheTwhe25hbWU6IHN0cmluZywgYXJnczogIUFycmF5fT59IGNhbGxzXG5cdCAqIEByZXR1cm4geyFmdW5jdGlvbigpfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRidWlsZENoaWxkcmVuRm5fKGNhbGxzKSB7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdHRoaXMuaW50ZXJjZXB0XygpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjYWxscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRJbmNyZW1lbnRhbERPTVtjYWxsc1tpXS5uYW1lXS5hcHBseShudWxsLCBhcnJheS5zbGljZShjYWxsc1tpXS5hcmdzLCAxKSk7XG5cdFx0XHR9XG5cdFx0XHRJbmNyZW1lbnRhbERvbUFvcC5zdG9wSW50ZXJjZXB0aW9uKCk7XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNwb3NlcyBhbGwgc3ViIGNvbXBvbmVudHMgdGhhdCB3ZXJlIG5vdCBmb3VuZCBhZnRlciBhbiB1cGRhdGUgYW55bW9yZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0ZGlzcG9zZVVudXNlZFN1YkNvbXBvbmVudHNfKCkge1xuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5jb21wb25lbnRfLmNvbXBvbmVudHMpO1xuXHRcdHZhciB1bnVzZWQgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICghdGhpcy5zdWJDb21wb25lbnRzRm91bmRfW2tleXNbaV1dKSB7XG5cdFx0XHRcdHVudXNlZC5wdXNoKGtleXNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLmNvbXBvbmVudF8uZGlzcG9zZVN1YkNvbXBvbmVudHModW51c2VkKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBzdWIgY29tcG9uZW50IHJlZmVyZW5jZWQgYnkgdGhlIGdpdmVuIHRhZyBhbmQgY29uZmlnIGRhdGEsXG5cdCAqIGNyZWF0aW5nIGl0IGlmIGl0IGRvZXNuJ3QgeWV0IGV4aXN0LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBzdWIgY29tcG9uZW50J3Mga2V5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ3whRnVuY3Rpb259IHRhZ09yQ3RvciBUaGUgdGFnIG5hbWUuXG5cdCAqIEBwYXJhbSB7IU9iamVjdH0gY29uZmlnIFRoZSBjb25maWcgb2JqZWN0IGZvciB0aGUgc3ViIGNvbXBvbmVudC5cblx0ICogQHJldHVybiB7IUNvbXBvbmVudH0gVGhlIHN1YiBjb21wb25lbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGdldFN1YkNvbXBvbmVudF8oa2V5LCB0YWdPckN0b3IsIGNvbmZpZykge1xuXHRcdHZhciBjb21wID0gdGhpcy5jb21wb25lbnRfLmFkZFN1YkNvbXBvbmVudChrZXksIHRhZ09yQ3RvciwgY29uZmlnKTtcblx0XHRpZiAoY29tcC53YXNSZW5kZXJlZCkge1xuXHRcdFx0Y29tcC5zZXRTdGF0ZShjb25maWcpO1xuXHRcdH1cblx0XHRyZXR1cm4gY29tcDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHdWFyYW50ZWVzIHRoYXQgdGhlIGNvbXBvbmVudCdzIGVsZW1lbnQgaGFzIGEgcGFyZW50LiBUaGF0J3MgbmVjZXNzYXJ5XG5cdCAqIHdoZW4gY2FsbGluZyBpbmNyZW1lbnRhbCBkb20ncyBgcGF0Y2hPdXRlcmAgZm9yIG5vdywgYXMgb3RoZXJ3aXNlIGl0IHdpbGxcblx0ICogdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGVsZW1lbnQgbmVlZHMgdG8gYmUgcmVwbGFjZWQuXG5cdCAqIEByZXR1cm4ge0VsZW1lbnR9IFRoZSBwYXJlbnQsIGluIGNhc2UgaXQgd2FzIGFkZGVkLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRndWFyYW50ZWVQYXJlbnRfKCkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5jb21wb25lbnRfLmVsZW1lbnQ7XG5cdFx0aWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LnBhcmVudE5vZGUpIHtcblx0XHRcdHZhciBwYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRcdGRvbS5hcHBlbmQocGFyZW50LCBlbGVtZW50KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwYXJlbnQ7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgdGhlIGBkZXRhY2hlZGAgbGlzdGVuZXIuIFJlbW92ZXMgYWxsIGlubGluZSBsaXN0ZW5lcnMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGhhbmRsZURldGFjaGVkXygpIHtcblx0XHR0aGlzLmV2ZW50c0NvbGxlY3Rvcl8uZGV0YWNoQWxsTGlzdGVuZXJzKCk7XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyBhbiBpbnRlcmNlcHRlZCBjYWxsIHRvIHRoZSBhdHRyaWJ1dGVzIGRlZmF1bHQgaGFuZGxlciBmcm9tXG5cdCAqIGluY3JlbWVudGFsIGRvbS5cblx0ICogQHBhcmFtIHshZnVuY3Rpb24oKX0gb3JpZ2luYWxGbiBUaGUgb3JpZ2luYWwgZnVuY3Rpb24gYmVmb3JlIGludGVyY2VwdGlvbi5cblx0ICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGhhbmRsZUludGVyY2VwdGVkQXR0cmlidXRlc0NhbGxfKG9yaWdpbmFsRm4sIGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG5cdFx0aWYgKG5hbWUuc3RhcnRzV2l0aCgnZGF0YS1vbicpKSB7XG5cdFx0XHR2YXIgZXZlbnROYW1lID0gbmFtZS5zdWJzdHIoNyk7XG5cdFx0XHRpZiAoY29yZS5pc0Z1bmN0aW9uKGVsZW1lbnRbbmFtZV0pKSB7XG5cdFx0XHRcdGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGVsZW1lbnRbbmFtZV0pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvcmUuaXNGdW5jdGlvbih2YWx1ZSkpIHtcblx0XHRcdFx0ZG9tLm9uKGVsZW1lbnQsIGV2ZW50TmFtZSwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NoZWNrZWQnKSB7XG5cdFx0XHQvLyBUaGlzIGlzIGEgdGVtcG9yYXJ5IGZpeCB0byBhY2NvdW50IGZvciBpbmNyZW1lbnRhbCBkb20gc2V0dGluZ1xuXHRcdFx0Ly8gXCJjaGVja2VkXCIgYXMgYW4gYXR0cmlidXRlIG9ubHksIHdoaWNoIGNhbiBjYXVzZSBidWdzIHNpbmNlIHRoYXQgd29uJ3Rcblx0XHRcdC8vIG5lY2Vzc2FyaWx5IGNoZWNrL3VuY2hlY2sgdGhlIGVsZW1lbnQgaXQncyBzZXQgb24uIFNlZVxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9pbmNyZW1lbnRhbC1kb20vaXNzdWVzLzE5OCBmb3IgbW9yZSBkZXRhaWxzLlxuXHRcdFx0ZWxlbWVudC5jaGVja2VkID0gY29yZS5pc0RlZkFuZE5vdE51bGwodmFsdWUpICYmIHZhbHVlICE9PSBmYWxzZTtcblx0XHR9XG5cdFx0b3JpZ2luYWxGbihlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyBhbiBpbnRlcmNlcHRlZCBjYWxsIHRvIHRoZSBgZWxlbWVudENsb3NlYCBmdW5jdGlvbiBmcm9tIGluY3JlbWVudGFsXG5cdCAqIGRvbSwgd2hpbGUgY29sbGVjdGluZyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuLlxuXHQgKiBAcGFyYW0geyFmdW5jdGlvbigpfSBvcmlnaW5hbEZuIFRoZSBvcmlnaW5hbCBmdW5jdGlvbiBiZWZvcmUgaW50ZXJjZXB0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY2FsbFRhZ1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRoYW5kbGVJbnRlcmNlcHRlZENoaWxkcmVuQ2xvc2VDYWxsXyhvcmlnaW5hbEZuLCBjYWxsVGFnKSB7XG5cdFx0aWYgKHRoaXMuaXNDdXJyZW50Q29tcG9uZW50VGFnXyhjYWxsVGFnKSAmJlxuXHRcdFx0XHQtLXRoaXMuY29tcG9uZW50VG9SZW5kZXJfLnRhZ3NDb3VudCA9PT0gMCkge1xuXG5cdFx0XHR2YXIge2NhbGxzLCBjb25maWcsIHRhZ30gPSB0aGlzLmNvbXBvbmVudFRvUmVuZGVyXztcblx0XHRcdGNvbmZpZy5jaGlsZHJlbiA9IHRoaXMuYnVpbGRDaGlsZHJlbkZuXyhjYWxscyk7XG5cdFx0XHR0aGlzLmNvbXBvbmVudFRvUmVuZGVyXyA9IG51bGw7XG5cdFx0XHRJbmNyZW1lbnRhbERvbUFvcC5zdG9wSW50ZXJjZXB0aW9uKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZW5kZXJTdWJDb21wb25lbnRfKHRhZywgY29uZmlnKS5lbGVtZW50O1xuXHRcdH1cblx0XHR0aGlzLmNvbXBvbmVudFRvUmVuZGVyXy5jYWxscy5wdXNoKHtcblx0XHRcdG5hbWU6ICdlbGVtZW50Q2xvc2UnLFxuXHRcdFx0YXJnczogYXJndW1lbnRzXG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyBhbiBpbnRlcmNlcHRlZCBjYWxsIHRvIHRoZSBgZWxlbWVudE9wZW5gIGZ1bmN0aW9uIGZyb20gaW5jcmVtZW50YWxcblx0ICogZG9tLCB3aGlsZSBjb2xsZWN0aW5nIGEgY29tcG9uZW50J3MgY2hpbGRyZW4uXG5cdCAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IG9yaWdpbmFsRm4gVGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGJlZm9yZSBpbnRlcmNlcHRpb24uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0YWdcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0aGFuZGxlSW50ZXJjZXB0ZWRDaGlsZHJlbk9wZW5DYWxsXyhvcmlnaW5hbEZuLCB0YWcpIHtcblx0XHRpZiAodGhpcy5pc0N1cnJlbnRDb21wb25lbnRUYWdfKHRhZykpIHtcblx0XHRcdHRoaXMuY29tcG9uZW50VG9SZW5kZXJfLnRhZ3NDb3VudCsrO1xuXHRcdH1cblx0XHR0aGlzLmNvbXBvbmVudFRvUmVuZGVyXy5jYWxscy5wdXNoKHtcblx0XHRcdG5hbWU6ICdlbGVtZW50T3BlbicsXG5cdFx0XHRhcmdzOiBhcmd1bWVudHNcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIGFuIGludGVyY2VwdGVkIGNhbGwgdG8gdGhlIGB0ZXh0YCBmdW5jdGlvbiBmcm9tIGluY3JlbWVudGFsIGRvbSxcblx0ICogd2hpbGUgY29sbGVjdGluZyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRoYW5kbGVJbnRlcmNlcHRlZENoaWxkcmVuVGV4dENhbGxfKCkge1xuXHRcdHRoaXMuY29tcG9uZW50VG9SZW5kZXJfLmNhbGxzLnB1c2goe1xuXHRcdFx0bmFtZTogJ3RleHQnLFxuXHRcdFx0YXJnczogYXJndW1lbnRzXG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyBhbiBpbnRlcmNlcHRlZCBjYWxsIHRvIHRoZSBgZWxlbWVudE9wZW5gIGZ1bmN0aW9uIGZyb20gaW5jcmVtZW50YWxcblx0ICogZG9tLlxuXHQgKiBAcGFyYW0geyFmdW5jdGlvbigpfSBvcmlnaW5hbEZuIFRoZSBvcmlnaW5hbCBmdW5jdGlvbiBiZWZvcmUgaW50ZXJjZXB0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGFnXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGhhbmRsZUludGVyY2VwdGVkT3BlbkNhbGxfKG9yaWdpbmFsRm4sIHRhZykge1xuXHRcdGlmICh0aGlzLmlzQ29tcG9uZW50VGFnXyh0YWcpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5oYW5kbGVTdWJDb21wb25lbnRDYWxsXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5oYW5kbGVSZWd1bGFyQ2FsbF8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyBhbiBpbnRlcmNlcHRlZCBjYWxsIHRvIHRoZSBgZWxlbWVudE9wZW5gIGZ1bmN0aW9uIGZyb20gaW5jcmVtZW50YWxcblx0ICogZG9tLCBkb25lIGZvciBhIHJlZ3VsYXIgZWxlbWVudC4gQWRkcyBhbnkgaW5saW5lIGxpc3RlbmVycyBmb3VuZCBhbmQgbWFrZXNcblx0ICogc3VyZSB0aGF0IGNvbXBvbmVudCByb290IGVsZW1lbnRzIGFyZSBhbHdheXMgcmV1c2VkLlxuXHQgKiBAcGFyYW0geyFmdW5jdGlvbigpfSBvcmlnaW5hbEZuIFRoZSBvcmlnaW5hbCBmdW5jdGlvbiBiZWZvcmUgaW50ZXJjZXB0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGFnXG5cdCAqIEBwYXJhbSB7P3N0cmluZ30ga2V5XG5cdCAqIEBwYXJhbSB7P0FycmF5fSBzdGF0aWNzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGhhbmRsZVJlZ3VsYXJDYWxsXyhvcmlnaW5hbEZuLCB0YWcsIGtleSwgc3RhdGljcykge1xuXHRcdHZhciBhdHRyc0FyciA9IGFycmF5LnNsaWNlKGFyZ3VtZW50cywgNCk7XG5cdFx0dGhpcy5hZGRJbmxpbmVMaXN0ZW5lcnNfKChzdGF0aWNzIHx8IFtdKS5jb25jYXQoYXR0cnNBcnIpKTtcblx0XHR2YXIgYXJncyA9IGFycmF5LnNsaWNlKGFyZ3VtZW50cywgMSk7XG5cdFx0aWYgKCF0aGlzLnJvb3RFbGVtZW50UmVhY2hlZF8gJiYgdGhpcy5jb21wb25lbnRfLmNvbmZpZy5rZXkpIHtcblx0XHRcdGFyZ3NbMV0gPSB0aGlzLmNvbXBvbmVudF8uY29uZmlnLmtleTtcblx0XHR9XG5cdFx0dmFyIG5vZGUgPSBvcmlnaW5hbEZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuXHRcdGlmICghdGhpcy5yb290RWxlbWVudFJlYWNoZWRfKSB7XG5cdFx0XHR0aGlzLnJvb3RFbGVtZW50UmVhY2hlZF8gPSB0cnVlO1xuXHRcdFx0aWYgKHRoaXMuY29tcG9uZW50Xy5lbGVtZW50ICE9PSBub2RlKSB7XG5cdFx0XHRcdHRoaXMuY29tcG9uZW50Xy5lbGVtZW50ID0gbm9kZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyB0aGUgYHN0YXRlS2V5Q2hhbmdlZGAgZXZlbnQuIE1ha2VzIHN1cmUgdGhhdCwgd2hlbiBgc3RhdGVDaGFuZ2VkYFxuXHQgKiBpcyBmaXJlZCwgdGhlIGNvbXBvbmVudCdzIGNvbnRlbnRzIHdpbGwgb25seSBiZSB1cGRhdGVkIGlmIHRoZSBjaGFuZ2VkXG5cdCAqIHN0YXRlIGtleSB3YXNuJ3QgYGVsZW1lbnRgLCBzaW5jZSB0aGF0IHdvdWxkbid0IGNhdXNlIGEgcmVyZW5kZXIuXG5cdCAqIEBwYXJhbSB7IU9iamVjdH0gZGF0YVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRoYW5kbGVTdGF0ZUtleUNoYW5nZWRfKGRhdGEpIHtcblx0XHRpZiAoZGF0YS5rZXkgIT09ICdlbGVtZW50Jykge1xuXHRcdFx0dGhpcy5jaGFuZ2VzX1tkYXRhLmtleV0gPSBkYXRhO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIGFuIGludGVyY2VwdGVkIGNhbGwgdG8gdGhlIGBlbGVtZW50T3BlbmAgZnVuY3Rpb24gZnJvbSBpbmNyZW1lbnRhbFxuXHQgKiBkb20sIGRvbmUgZm9yIGEgc3ViIGNvbXBvbmVudCBlbGVtZW50LiBDcmVhdGVzIGFuZCB1cGRhdGVzIHRoZSBhcHByb3ByaWF0ZVxuXHQgKiBzdWIgY29tcG9uZW50LlxuXHQgKiBAcGFyYW0geyFmdW5jdGlvbigpfSBvcmlnaW5hbEZuIFRoZSBvcmlnaW5hbCBmdW5jdGlvbiBiZWZvcmUgaW50ZXJjZXB0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGFnXG5cdCAqIEBwYXJhbSB7P3N0cmluZ30ga2V5XG5cdCAqIEBwYXJhbSB7P0FycmF5fSBzdGF0aWNzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGhhbmRsZVN1YkNvbXBvbmVudENhbGxfKG9yaWdpbmFsRm4sIHRhZywga2V5LCBzdGF0aWNzKSB7XG5cdFx0dmFyIGNvbmZpZyA9IHtrZXl9O1xuXHRcdHZhciBhdHRyc0FyciA9IChzdGF0aWNzIHx8IFtdKS5jb25jYXQoYXJyYXkuc2xpY2UoYXJndW1lbnRzLCA0KSk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyc0Fyci5sZW5ndGg7IGkgKz0gMikge1xuXHRcdFx0Y29uZmlnW2F0dHJzQXJyW2ldXSA9IGF0dHJzQXJyW2kgKyAxXTtcblx0XHR9XG5cblx0XHR0aGlzLmNvbXBvbmVudFRvUmVuZGVyXyA9IHtcblx0XHRcdGNhbGxzOiBbXSxcblx0XHRcdGNvbmZpZyxcblx0XHRcdHRhZyxcblx0XHRcdHRhZ3NDb3VudDogMVxuXHRcdH07XG5cdFx0SW5jcmVtZW50YWxEb21Bb3Auc3RhcnRJbnRlcmNlcHRpb24oe1xuXHRcdFx0ZWxlbWVudENsb3NlOiB0aGlzLmhhbmRsZUludGVyY2VwdGVkQ2hpbGRyZW5DbG9zZUNhbGxfLFxuXHRcdFx0ZWxlbWVudE9wZW46IHRoaXMuaGFuZGxlSW50ZXJjZXB0ZWRDaGlsZHJlbk9wZW5DYWxsXyxcblx0XHRcdHRleHQ6IHRoaXMuaGFuZGxlSW50ZXJjZXB0ZWRDaGlsZHJlblRleHRDYWxsX1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEludGVyY2VwdHMgaW5jcmVtZW50YWwgZG9tIGNhbGxzIGZyb20gdGhpcyBjb21wb25lbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGludGVyY2VwdF8oKSB7XG5cdFx0SW5jcmVtZW50YWxEb21Bb3Auc3RhcnRJbnRlcmNlcHRpb24oe1xuXHRcdFx0YXR0cmlidXRlczogdGhpcy5oYW5kbGVJbnRlcmNlcHRlZEF0dHJpYnV0ZXNDYWxsXyxcblx0XHRcdGVsZW1lbnRPcGVuOiB0aGlzLmhhbmRsZUludGVyY2VwdGVkT3BlbkNhbGxfXG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB0YWcgcmVwcmVzZW50cyBhIG1ldGFsIGNvbXBvbmVudC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRpc0NvbXBvbmVudFRhZ18odGFnKSB7XG5cdFx0cmV0dXJuICFjb3JlLmlzU3RyaW5nKHRhZykgfHwgdGFnWzBdID09PSB0YWdbMF0udG9VcHBlckNhc2UoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIGdpdmVuIHRhZyByZXByZXNlbnRzIHRoZSBtZXRhbCBjb21wb25lbnQgY3VycmVudGx5IGJlaW5nXG5cdCAqIHJlbmRlcmVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGFnXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGlzQ3VycmVudENvbXBvbmVudFRhZ18odGFnKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNDb21wb25lbnRUYWdfKHRhZykgJiYgdGhpcy5jb21wb25lbnRUb1JlbmRlcl8udGFnID09PSB0YWc7XG5cdH1cblxuXHQvKipcblx0ICogUmVuZGVycyB0aGUgcmVuZGVyZXIncyBjb21wb25lbnQgZm9yIHRoZSBmaXJzdCB0aW1lLCBwYXRjaGluZyBpdHMgZWxlbWVudFxuXHQgKiB0aHJvdWdoIHRoZSBpbmNyZW1lbnRhbCBkb20gZnVuY3Rpb24gY2FsbHMgZG9uZSBieSBgcmVuZGVySW5jRG9tYC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHR0aGlzLnBhdGNoKCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbHMgZnVuY3Rpb25zIGZyb20gYEluY3JlbWVudGFsRE9NYCB0byBidWlsZCB0aGUgY29tcG9uZW50IGVsZW1lbnQnc1xuXHQgKiBjb250ZW50LiBDYW4gYmUgb3ZlcnJpZGVuIGJ5IHN1YmNsYXNzZXMgKGZvciBpbnRlZ3JhdGlvbiB3aXRoIHRlbXBsYXRlXG5cdCAqIGVuZ2luZXMgZm9yIGV4YW1wbGUpLlxuXHQgKi9cblx0cmVuZGVySW5jRG9tKCkge1xuXHRcdEluY3JlbWVudGFsRE9NLmVsZW1lbnRWb2lkKCdkaXYnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSdW5zIHRoZSBpbmNyZW1lbnRhbCBkb20gZnVuY3Rpb25zIGZvciByZW5kZXJpbmcgdGhpcyBjb21wb25lbnQsIGJ1dFxuXHQgKiBkb2Vzbid0IGNhbGwgYHBhdGNoYCB5ZXQuIFJhdGhlciwgdGhpcyB3aWxsIGJlIHRoZSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZVxuXHQgKiBjYWxsZWQgYnkgYHBhdGNoYC5cblx0ICovXG5cdHJlbmRlcldpdGhvdXRQYXRjaCgpIHtcblx0XHQvLyBNYXJrIHRoYXQgdGhlcmUgc2hvdWxkbid0IGJlIGFuIHVwZGF0ZSBmb3Igc3RhdGUgY2hhbmdlcyBzbyBmYXIsIHNpbmNlXG5cdFx0Ly8gcmVuZGVyIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkLlxuXHRcdHRoaXMuY2hhbmdlc18gPSB7fTtcblxuXHRcdHRoaXMucm9vdEVsZW1lbnRSZWFjaGVkXyA9IGZhbHNlO1xuXHRcdHRoaXMuc3ViQ29tcG9uZW50c0ZvdW5kXyA9IHt9O1xuXHRcdHRoaXMuZ2VuZXJhdGVkS2V5Q291bnRfID0gMDtcblx0XHR0aGlzLmxpc3RlbmVyc1RvQXR0YWNoXyA9IFtdO1xuXHRcdHRoaXMuaW50ZXJjZXB0XygpO1xuXHRcdHRoaXMucmVuZGVySW5jRG9tKCk7XG5cdFx0SW5jcmVtZW50YWxEb21Bb3Auc3RvcEludGVyY2VwdGlvbigpO1xuXHRcdHRoaXMuYXR0YWNoSW5saW5lTGlzdGVuZXJzXygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBiZSB1cGRhdGVkIHdpdGggdGhlIGN1cnJlbnQgc3RhdGUgY2hhbmdlcy5cblx0ICogQ2FuIGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3NlcyB0byBwcm92aWRlIGN1c3RvbWl6ZWQgYmVoYXZpb3IgKG9ubHlcblx0ICogdXBkYXRpbmcgd2hlbiBhIHN0YXRlIGtleSB1c2VkIGJ5IHRoZSB0ZW1wbGF0ZSBpcyBjaGFuZ2VkIGZvciBleGFtcGxlKS5cblx0ICogQHBhcmFtIHshT2JqZWN0fSBjaGFuZ2VzXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRzaG91bGRVcGRhdGUoKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogUGF0Y2hlcyB0aGUgY29tcG9uZW50J3MgZWxlbWVudCB3aXRoIHRoZSBpbmNyZW1lbnRhbCBkb20gZnVuY3Rpb24gY2FsbHNcblx0ICogZG9uZSBieSBgcmVuZGVySW5jRG9tYC5cblx0ICovXG5cdHBhdGNoKCkge1xuXHRcdHZhciB0ZW1wUGFyZW50ID0gdGhpcy5ndWFyYW50ZWVQYXJlbnRfKCk7XG5cdFx0aWYgKHRlbXBQYXJlbnQpIHtcblx0XHRcdEluY3JlbWVudGFsRE9NLnBhdGNoKHRlbXBQYXJlbnQsIHRoaXMucmVuZGVyV2l0aG91dFBhdGNoKTtcblx0XHRcdGRvbS5leGl0RG9jdW1lbnQodGhpcy5jb21wb25lbnRfLmVsZW1lbnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRJbmNyZW1lbnRhbERPTS5wYXRjaE91dGVyKHRoaXMuY29tcG9uZW50Xy5lbGVtZW50LCB0aGlzLnJlbmRlcldpdGhvdXRQYXRjaCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVyJ3MgY29tcG9uZW50IHdoZW4gc3RhdGUgY2hhbmdlcywgcGF0Y2hpbmcgaXRzIGVsZW1lbnRcblx0ICogdGhyb3VnaCB0aGUgaW5jcmVtZW50YWwgZG9tIGZ1bmN0aW9uIGNhbGxzIGRvbmUgYnkgYHJlbmRlckluY0RvbWAuXG5cdCAqL1xuXHR1cGRhdGUoKSB7XG5cdFx0dmFyIGNoYW5nZWRLZXlzID0gT2JqZWN0LmtleXModGhpcy5jaGFuZ2VzXyk7XG5cdFx0aWYgKGNoYW5nZWRLZXlzLmxlbmd0aCA+IDAgJiYgdGhpcy5zaG91bGRVcGRhdGUodGhpcy5jaGFuZ2VzXykpIHtcblx0XHRcdHRoaXMucGF0Y2goKTtcblx0XHRcdHRoaXMuZXZlbnRzQ29sbGVjdG9yXy5kZXRhY2hVbnVzZWRMaXN0ZW5lcnMoKTtcblx0XHRcdHRoaXMuZGlzcG9zZVVudXNlZFN1YkNvbXBvbmVudHNfKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFRoaXMgdXBkYXRlcyB0aGUgc3ViIGNvbXBvbmVudCB0aGF0IGlzIHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiBkYXRhLlxuXHQgKiBUaGUgc3ViIGNvbXBvbmVudCBpcyBjcmVhdGVkLCBhZGRlZCB0byBpdHMgcGFyZW50IGFuZCByZW5kZXJlZC4gSWYgaXRcblx0ICogaGFkIGFscmVhZHkgYmVlbiByZW5kZXJlZCBiZWZvcmUgdGhvdWdoLCBpdCB3aWxsIG9ubHkgaGF2ZSBpdHMgc3RhdGVcblx0ICogdXBkYXRlZCBpbnN0ZWFkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ3whZnVuY3Rpb24oKX0gdGFnT3JDdG9yIFRoZSB0YWcgbmFtZSBvciBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cblx0ICogQHBhcmFtIHshT2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBvYmplY3QgZm9yIHRoZSBzdWIgY29tcG9uZW50LlxuXHQgKiBAcmV0dXJuIHshQ29tcG9uZW50fSBUaGUgdXBkYXRlZCBzdWIgY29tcG9uZW50LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRyZW5kZXJTdWJDb21wb25lbnRfKHRhZ09yQ3RvciwgY29uZmlnKSB7XG5cdFx0dmFyIGtleSA9IGNvbmZpZy5rZXkgfHwgKCdzdWInICsgdGhpcy5nZW5lcmF0ZWRLZXlDb3VudF8rKyk7XG5cdFx0dmFyIGNvbXAgPSB0aGlzLmdldFN1YkNvbXBvbmVudF8oa2V5LCB0YWdPckN0b3IsIGNvbmZpZyk7XG5cdFx0dmFyIHJlbmRlcmVyID0gY29tcC5nZXRSZW5kZXJlcigpO1xuXHRcdGlmIChyZW5kZXJlciBpbnN0YW5jZW9mIEluY3JlbWVudGFsRG9tUmVuZGVyZXIpIHtcblx0XHRcdHJlbmRlcmVyLnJlbmRlcldpdGhvdXRQYXRjaCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdCdJbmNyZW1lbnRhbERvbVJlbmRlcmVyIGRvZXNuXFwndCBzdXBwb3J0IHJlbmRlcmluZyBzdWIgY29tcG9uZW50cyAnICtcblx0XHRcdFx0J3RoYXQgZG9uXFwndCB1c2UgSW5jcmVtZW50YWxEb21SZW5kZXJlciBhcyB3ZWxsLCBsaWtlOicsXG5cdFx0XHRcdGNvbXBcblx0XHRcdCk7XG5cdFx0fVxuXHRcdGlmICghY29tcC53YXNSZW5kZXJlZCkge1xuXHRcdFx0Y29tcC5yZW5kZXJBc1N1YkNvbXBvbmVudCgpO1xuXHRcdH1cblx0XHR0aGlzLnN1YkNvbXBvbmVudHNGb3VuZF9ba2V5XSA9IHRydWU7XG5cdFx0cmV0dXJuIGNvbXA7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5jcmVtZW50YWxEb21SZW5kZXJlcjtcbiIsIi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTUgVGhlIEluY3JlbWVudGFsIERPTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgKGZhY3RvcnkoKGdsb2JhbC5JbmNyZW1lbnRhbERPTSA9IGdsb2JhbC5JbmNyZW1lbnRhbERPTSB8fCB7fSkpKVxufSh3aW5kb3csIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogQ29weXJpZ2h0IDIwMTUgVGhlIEluY3JlbWVudGFsIERPTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgKlxuICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgKlxuICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbiAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBIGNhY2hlZCByZWZlcmVuY2UgdG8gdGhlIGhhc093blByb3BlcnR5IGZ1bmN0aW9uLlxuICAgKi9cbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICAvKipcbiAgICogQSBjYWNoZWQgcmVmZXJlbmNlIHRvIHRoZSBjcmVhdGUgZnVuY3Rpb24uXG4gICAqL1xuICB2YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuICAvKipcbiAgICogVXNlZCB0byBwcmV2ZW50IHByb3BlcnR5IGNvbGxpc2lvbnMgYmV0d2VlbiBvdXIgXCJtYXBcIiBhbmQgaXRzIHByb3RvdHlwZS5cbiAgICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgKj59IG1hcCBUaGUgbWFwIHRvIGNoZWNrLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG1hcCBoYXMgcHJvcGVydHkuXG4gICAqL1xuICB2YXIgaGFzID0gZnVuY3Rpb24gKG1hcCwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIHByb3BlcnR5KTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBtYXAgb2JqZWN0IHdpdGhvdXQgYSBwcm90b3R5cGUuXG4gICAqIEByZXR1cm4geyFPYmplY3R9XG4gICAqL1xuICB2YXIgY3JlYXRlTWFwID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGUobnVsbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEtlZXBzIHRyYWNrIG9mIGluZm9ybWF0aW9uIG5lZWRlZCB0byBwZXJmb3JtIGRpZmZzIGZvciBhIGdpdmVuIERPTSBub2RlLlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IG5vZGVOYW1lXG4gICAqIEBwYXJhbSB7P3N0cmluZz19IGtleVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIE5vZGVEYXRhKG5vZGVOYW1lLCBrZXkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYXR0cmlidXRlcyBhbmQgdGhlaXIgdmFsdWVzLlxuICAgICAqIEBjb25zdCB7IU9iamVjdDxzdHJpbmcsICo+fVxuICAgICAqL1xuICAgIHRoaXMuYXR0cnMgPSBjcmVhdGVNYXAoKTtcblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzLCB1c2VkIGZvciBxdWlja2x5IGRpZmZpbmcgdGhlXG4gICAgICogaW5jb21taW5nIGF0dHJpYnV0ZXMgdG8gc2VlIGlmIHRoZSBET00gbm9kZSdzIGF0dHJpYnV0ZXMgbmVlZCB0byBiZVxuICAgICAqIHVwZGF0ZWQuXG4gICAgICogQGNvbnN0IHtBcnJheTwqPn1cbiAgICAgKi9cbiAgICB0aGlzLmF0dHJzQXJyID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5jb21pbmcgYXR0cmlidXRlcyBmb3IgdGhpcyBOb2RlLCBiZWZvcmUgdGhleSBhcmUgdXBkYXRlZC5cbiAgICAgKiBAY29uc3QgeyFPYmplY3Q8c3RyaW5nLCAqPn1cbiAgICAgKi9cbiAgICB0aGlzLm5ld0F0dHJzID0gY3JlYXRlTWFwKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUga2V5IHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBub2RlLCB1c2VkIHRvIHByZXNlcnZlIERPTSBub2RlcyB3aGVuIHRoZXlcbiAgICAgKiBtb3ZlIHdpdGhpbiB0aGVpciBwYXJlbnQuXG4gICAgICogQGNvbnN0XG4gICAgICovXG4gICAgdGhpcy5rZXkgPSBrZXk7XG5cbiAgICAvKipcbiAgICAgKiBLZWVwcyB0cmFjayBvZiBjaGlsZHJlbiB3aXRoaW4gdGhpcyBub2RlIGJ5IHRoZWlyIGtleS5cbiAgICAgKiB7P09iamVjdDxzdHJpbmcsICFFbGVtZW50Pn1cbiAgICAgKi9cbiAgICB0aGlzLmtleU1hcCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUga2V5TWFwIGlzIGN1cnJlbnRseSB2YWxpZC5cbiAgICAgKiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmtleU1hcFZhbGlkID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBub2RlIG5hbWUgZm9yIHRoaXMgbm9kZS5cbiAgICAgKiBAY29uc3Qge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm5vZGVOYW1lID0gbm9kZU5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnRleHQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgTm9kZURhdGEgb2JqZWN0IGZvciBhIE5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byBpbml0aWFsaXplIGRhdGEgZm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgVGhlIG5vZGUgbmFtZSBvZiBub2RlLlxuICAgKiBAcGFyYW0gez9zdHJpbmc9fSBrZXkgVGhlIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIG5vZGUuXG4gICAqIEByZXR1cm4geyFOb2RlRGF0YX0gVGhlIG5ld2x5IGluaXRpYWxpemVkIGRhdGEgb2JqZWN0XG4gICAqL1xuICB2YXIgaW5pdERhdGEgPSBmdW5jdGlvbiAobm9kZSwgbm9kZU5hbWUsIGtleSkge1xuICAgIHZhciBkYXRhID0gbmV3IE5vZGVEYXRhKG5vZGVOYW1lLCBrZXkpO1xuICAgIG5vZGVbJ19faW5jcmVtZW50YWxET01EYXRhJ10gPSBkYXRhO1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIE5vZGVEYXRhIG9iamVjdCBmb3IgYSBOb2RlLCBjcmVhdGluZyBpdCBpZiBuZWNlc3NhcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZXRyaWV2ZSB0aGUgZGF0YSBmb3IuXG4gICAqIEByZXR1cm4geyFOb2RlRGF0YX0gVGhlIE5vZGVEYXRhIGZvciB0aGlzIE5vZGUuXG4gICAqL1xuICB2YXIgZ2V0RGF0YSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIGRhdGEgPSBub2RlWydfX2luY3JlbWVudGFsRE9NRGF0YSddO1xuXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICB2YXIgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIga2V5ID0gbnVsbDtcblxuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgIGtleSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdrZXknKTtcbiAgICAgIH1cblxuICAgICAgZGF0YSA9IGluaXREYXRhKG5vZGUsIG5vZGVOYW1lLCBrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb3B5cmlnaHQgMjAxNSBUaGUgSW5jcmVtZW50YWwgRE9NIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAqXG4gICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAqXG4gICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICovXG5cbiAgLyoqIEBjb25zdCAqL1xuICB2YXIgc3ltYm9scyA9IHtcbiAgICBkZWZhdWx0OiAnX19kZWZhdWx0JyxcblxuICAgIHBsYWNlaG9sZGVyOiAnX19wbGFjZWhvbGRlcidcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGhlIG5hbWVzcGFjZSB0byB1c2UgZm9yIHRoZSBhdHRyaWJ1dGUuXG4gICAqL1xuICB2YXIgZ2V0TmFtZXNwYWNlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZS5sYXN0SW5kZXhPZigneG1sOicsIDApID09PSAwKSB7XG4gICAgICByZXR1cm4gJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSc7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUubGFzdEluZGV4T2YoJ3hsaW5rOicsIDApID09PSAwKSB7XG4gICAgICByZXR1cm4gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQXBwbGllcyBhbiBhdHRyaWJ1dGUgb3IgcHJvcGVydHkgdG8gYSBnaXZlbiBFbGVtZW50LiBJZiB0aGUgdmFsdWUgaXMgbnVsbFxuICAgKiBvciB1bmRlZmluZWQsIGl0IGlzIHJlbW92ZWQgZnJvbSB0aGUgRWxlbWVudC4gT3RoZXJ3aXNlLCB0aGUgdmFsdWUgaXMgc2V0XG4gICAqIGFzIGFuIGF0dHJpYnV0ZS5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGF0dHJpYnV0ZSdzIG5hbWUuXG4gICAqIEBwYXJhbSB7Pyhib29sZWFufG51bWJlcnxzdHJpbmcpPX0gdmFsdWUgVGhlIGF0dHJpYnV0ZSdzIHZhbHVlLlxuICAgKi9cbiAgdmFyIGFwcGx5QXR0ciA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXR0ck5TID0gZ2V0TmFtZXNwYWNlKG5hbWUpO1xuICAgICAgaWYgKGF0dHJOUykge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyhhdHRyTlMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgcHJvcGVydHkgdG8gYSBnaXZlbiBFbGVtZW50LlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgcHJvcGVydHkncyBuYW1lLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwcm9wZXJ0eSdzIHZhbHVlLlxuICAgKi9cbiAgdmFyIGFwcGx5UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgICBlbFtuYW1lXSA9IHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgc3R5bGUgdG8gYW4gRWxlbWVudC4gTm8gdmVuZG9yIHByZWZpeCBleHBhbnNpb24gaXMgZG9uZSBmb3JcbiAgICogcHJvcGVydHkgbmFtZXMvdmFsdWVzLlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYXR0cmlidXRlJ3MgbmFtZS5cbiAgICogQHBhcmFtIHsqfSBzdHlsZSBUaGUgc3R5bGUgdG8gc2V0LiBFaXRoZXIgYSBzdHJpbmcgb2YgY3NzIG9yIGFuIG9iamVjdFxuICAgKiAgICAgY29udGFpbmluZyBwcm9wZXJ0eS12YWx1ZSBwYWlycy5cbiAgICovXG4gIHZhciBhcHBseVN0eWxlID0gZnVuY3Rpb24gKGVsLCBuYW1lLCBzdHlsZSkge1xuICAgIGlmICh0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbC5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmNzc1RleHQgPSAnJztcbiAgICAgIHZhciBlbFN0eWxlID0gZWwuc3R5bGU7XG4gICAgICB2YXIgb2JqID0gLyoqIEB0eXBlIHshT2JqZWN0PHN0cmluZyxzdHJpbmc+fSAqL3N0eWxlO1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICBpZiAoaGFzKG9iaiwgcHJvcCkpIHtcbiAgICAgICAgICBlbFN0eWxlW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgc2luZ2xlIGF0dHJpYnV0ZSBvbiBhbiBFbGVtZW50LlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYXR0cmlidXRlJ3MgbmFtZS5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgYXR0cmlidXRlJ3MgdmFsdWUuIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3Qgb3JcbiAgICogICAgIGZ1bmN0aW9uIGl0IGlzIHNldCBvbiB0aGUgRWxlbWVudCwgb3RoZXJ3aXNlLCBpdCBpcyBzZXQgYXMgYW4gSFRNTFxuICAgKiAgICAgYXR0cmlidXRlLlxuICAgKi9cbiAgdmFyIGFwcGx5QXR0cmlidXRlVHlwZWQgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYXBwbHlQcm9wKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGx5QXR0cihlbCwgbmFtZSwgLyoqIEB0eXBlIHs/KGJvb2xlYW58bnVtYmVyfHN0cmluZyl9ICovdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsbHMgdGhlIGFwcHJvcHJpYXRlIGF0dHJpYnV0ZSBtdXRhdG9yIGZvciB0aGlzIGF0dHJpYnV0ZS5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGF0dHJpYnV0ZSdzIG5hbWUuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGF0dHJpYnV0ZSdzIHZhbHVlLlxuICAgKi9cbiAgdmFyIHVwZGF0ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgZGF0YSA9IGdldERhdGEoZWwpO1xuICAgIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG5cbiAgICBpZiAoYXR0cnNbbmFtZV0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG11dGF0b3IgPSBhdHRyaWJ1dGVzW25hbWVdIHx8IGF0dHJpYnV0ZXNbc3ltYm9scy5kZWZhdWx0XTtcbiAgICBtdXRhdG9yKGVsLCBuYW1lLCB2YWx1ZSk7XG5cbiAgICBhdHRyc1tuYW1lXSA9IHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIHB1YmxpY2x5IG11dGFibGUgb2JqZWN0IHRvIHByb3ZpZGUgY3VzdG9tIG11dGF0b3JzIGZvciBhdHRyaWJ1dGVzLlxuICAgKiBAY29uc3QgeyFPYmplY3Q8c3RyaW5nLCBmdW5jdGlvbighRWxlbWVudCwgc3RyaW5nLCAqKT59XG4gICAqL1xuICB2YXIgYXR0cmlidXRlcyA9IGNyZWF0ZU1hcCgpO1xuXG4gIC8vIFNwZWNpYWwgZ2VuZXJpYyBtdXRhdG9yIHRoYXQncyBjYWxsZWQgZm9yIGFueSBhdHRyaWJ1dGUgdGhhdCBkb2VzIG5vdFxuICAvLyBoYXZlIGEgc3BlY2lmaWMgbXV0YXRvci5cbiAgYXR0cmlidXRlc1tzeW1ib2xzLmRlZmF1bHRdID0gYXBwbHlBdHRyaWJ1dGVUeXBlZDtcblxuICBhdHRyaWJ1dGVzW3N5bWJvbHMucGxhY2Vob2xkZXJdID0gZnVuY3Rpb24gKCkge307XG5cbiAgYXR0cmlidXRlc1snc3R5bGUnXSA9IGFwcGx5U3R5bGU7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG5hbWVzcGFjZSB0byBjcmVhdGUgYW4gZWxlbWVudCAob2YgYSBnaXZlbiB0YWcpIGluLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSB0YWcgdG8gZ2V0IHRoZSBuYW1lc3BhY2UgZm9yLlxuICAgKiBAcGFyYW0gez9Ob2RlfSBwYXJlbnRcbiAgICogQHJldHVybiB7P3N0cmluZ30gVGhlIG5hbWVzcGFjZSB0byBjcmVhdGUgdGhlIHRhZyBpbi5cbiAgICovXG4gIHZhciBnZXROYW1lc3BhY2VGb3JUYWcgPSBmdW5jdGlvbiAodGFnLCBwYXJlbnQpIHtcbiAgICBpZiAodGFnID09PSAnc3ZnJykge1xuICAgICAgcmV0dXJuICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gICAgfVxuXG4gICAgaWYgKGdldERhdGEocGFyZW50KS5ub2RlTmFtZSA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50Lm5hbWVzcGFjZVVSSTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBFbGVtZW50LlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBkb2MgVGhlIGRvY3VtZW50IHdpdGggd2hpY2ggdG8gY3JlYXRlIHRoZSBFbGVtZW50LlxuICAgKiBAcGFyYW0gez9Ob2RlfSBwYXJlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgdGFnIGZvciB0aGUgRWxlbWVudC5cbiAgICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IEEga2V5IHRvIGlkZW50aWZ5IHRoZSBFbGVtZW50LlxuICAgKiBAcGFyYW0gez9BcnJheTwqPj19IHN0YXRpY3MgQW4gYXJyYXkgb2YgYXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMgb2YgdGhlXG4gICAqICAgICBzdGF0aWMgYXR0cmlidXRlcyBmb3IgdGhlIEVsZW1lbnQuXG4gICAqIEByZXR1cm4geyFFbGVtZW50fVxuICAgKi9cbiAgdmFyIGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoZG9jLCBwYXJlbnQsIHRhZywga2V5LCBzdGF0aWNzKSB7XG4gICAgdmFyIG5hbWVzcGFjZSA9IGdldE5hbWVzcGFjZUZvclRhZyh0YWcsIHBhcmVudCk7XG4gICAgdmFyIGVsID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgZWwgPSBkb2MuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwgPSBkb2MuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIH1cblxuICAgIGluaXREYXRhKGVsLCB0YWcsIGtleSk7XG5cbiAgICBpZiAoc3RhdGljcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0aWNzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHVwZGF0ZUF0dHJpYnV0ZShlbCwgLyoqIEB0eXBlIHshc3RyaW5nfSovc3RhdGljc1tpXSwgc3RhdGljc1tpICsgMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFRleHQgTm9kZS5cbiAgICogQHBhcmFtIHtEb2N1bWVudH0gZG9jIFRoZSBkb2N1bWVudCB3aXRoIHdoaWNoIHRvIGNyZWF0ZSB0aGUgRWxlbWVudC5cbiAgICogQHJldHVybiB7IVRleHR9XG4gICAqL1xuICB2YXIgY3JlYXRlVGV4dCA9IGZ1bmN0aW9uIChkb2MpIHtcbiAgICB2YXIgbm9kZSA9IGRvYy5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgaW5pdERhdGEobm9kZSwgJyN0ZXh0JywgbnVsbCk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBtYXBwaW5nIHRoYXQgY2FuIGJlIHVzZWQgdG8gbG9vayB1cCBjaGlsZHJlbiB1c2luZyBhIGtleS5cbiAgICogQHBhcmFtIHs/Tm9kZX0gZWxcbiAgICogQHJldHVybiB7IU9iamVjdDxzdHJpbmcsICFFbGVtZW50Pn0gQSBtYXBwaW5nIG9mIGtleXMgdG8gdGhlIGNoaWxkcmVuIG9mIHRoZVxuICAgKiAgICAgRWxlbWVudC5cbiAgICovXG4gIHZhciBjcmVhdGVLZXlNYXAgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICB2YXIgbWFwID0gY3JlYXRlTWFwKCk7XG4gICAgdmFyIGNoaWxkID0gZWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIHZhciBrZXkgPSBnZXREYXRhKGNoaWxkKS5rZXk7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgbWFwW2tleV0gPSBjaGlsZDtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBtYXBwaW5nIG9mIGtleSB0byBjaGlsZCBub2RlIGZvciBhIGdpdmVuIEVsZW1lbnQsIGNyZWF0aW5nIGl0XG4gICAqIGlmIG5lY2Vzc2FyeS5cbiAgICogQHBhcmFtIHs/Tm9kZX0gZWxcbiAgICogQHJldHVybiB7IU9iamVjdDxzdHJpbmcsICFOb2RlPn0gQSBtYXBwaW5nIG9mIGtleXMgdG8gY2hpbGQgRWxlbWVudHNcbiAgICovXG4gIHZhciBnZXRLZXlNYXAgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICB2YXIgZGF0YSA9IGdldERhdGEoZWwpO1xuXG4gICAgaWYgKCFkYXRhLmtleU1hcCkge1xuICAgICAgZGF0YS5rZXlNYXAgPSBjcmVhdGVLZXlNYXAoZWwpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhLmtleU1hcDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgY2hpbGQgZnJvbSB0aGUgcGFyZW50IHdpdGggdGhlIGdpdmVuIGtleS5cbiAgICogQHBhcmFtIHs/Tm9kZX0gcGFyZW50XG4gICAqIEBwYXJhbSB7P3N0cmluZz19IGtleVxuICAgKiBAcmV0dXJuIHs/Tm9kZX0gVGhlIGNoaWxkIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGtleS5cbiAgICovXG4gIHZhciBnZXRDaGlsZCA9IGZ1bmN0aW9uIChwYXJlbnQsIGtleSkge1xuICAgIHJldHVybiBrZXkgPyBnZXRLZXlNYXAocGFyZW50KVtrZXldIDogbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGVsZW1lbnQgYXMgYmVpbmcgYSBjaGlsZC4gVGhlIHBhcmVudCB3aWxsIGtlZXAgdHJhY2sgb2YgdGhlXG4gICAqIGNoaWxkIHVzaW5nIHRoZSBrZXkuIFRoZSBjaGlsZCBjYW4gYmUgcmV0cmlldmVkIHVzaW5nIHRoZSBzYW1lIGtleSB1c2luZ1xuICAgKiBnZXRLZXlNYXAuIFRoZSBwcm92aWRlZCBrZXkgc2hvdWxkIGJlIHVuaXF1ZSB3aXRoaW4gdGhlIHBhcmVudCBFbGVtZW50LlxuICAgKiBAcGFyYW0gez9Ob2RlfSBwYXJlbnQgVGhlIHBhcmVudCBvZiBjaGlsZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBBIGtleSB0byBpZGVudGlmeSB0aGUgY2hpbGQgd2l0aC5cbiAgICogQHBhcmFtIHshTm9kZX0gY2hpbGQgVGhlIGNoaWxkIHRvIHJlZ2lzdGVyLlxuICAgKi9cbiAgdmFyIHJlZ2lzdGVyQ2hpbGQgPSBmdW5jdGlvbiAocGFyZW50LCBrZXksIGNoaWxkKSB7XG4gICAgZ2V0S2V5TWFwKHBhcmVudClba2V5XSA9IGNoaWxkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb3B5cmlnaHQgMjAxNSBUaGUgSW5jcmVtZW50YWwgRE9NIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAqXG4gICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAqXG4gICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICovXG5cbiAgLyoqIEBjb25zdCAqL1xuICB2YXIgbm90aWZpY2F0aW9ucyA9IHtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYWZ0ZXIgcGF0Y2ggaGFzIGNvbXBsZWF0ZWQgd2l0aCBhbnkgTm9kZXMgdGhhdCBoYXZlIGJlZW4gY3JlYXRlZFxuICAgICAqIGFuZCBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAqIEB0eXBlIHs/ZnVuY3Rpb24oQXJyYXk8IU5vZGU+KX1cbiAgICAgKi9cbiAgICBub2Rlc0NyZWF0ZWQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYWZ0ZXIgcGF0Y2ggaGFzIGNvbXBsZWF0ZWQgd2l0aCBhbnkgTm9kZXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZFxuICAgICAqIGZyb20gdGhlIERPTS5cbiAgICAgKiBOb3RlIGl0J3MgYW4gYXBwbGljYXRpb25zIHJlc3BvbnNpYmlsaXR5IHRvIGhhbmRsZSBhbnkgY2hpbGROb2Rlcy5cbiAgICAgKiBAdHlwZSB7P2Z1bmN0aW9uKEFycmF5PCFOb2RlPil9XG4gICAgICovXG4gICAgbm9kZXNEZWxldGVkOiBudWxsXG4gIH07XG5cbiAgLyoqXG4gICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBzdGF0ZSBvZiBhIHBhdGNoLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIENvbnRleHQoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUgeyhBcnJheTwhTm9kZT58dW5kZWZpbmVkKX1cbiAgICAgKi9cbiAgICB0aGlzLmNyZWF0ZWQgPSBub3RpZmljYXRpb25zLm5vZGVzQ3JlYXRlZCAmJiBbXTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHsoQXJyYXk8IU5vZGU+fHVuZGVmaW5lZCl9XG4gICAgICovXG4gICAgdGhpcy5kZWxldGVkID0gbm90aWZpY2F0aW9ucy5ub2Rlc0RlbGV0ZWQgJiYgW107XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKi9cbiAgQ29udGV4dC5wcm90b3R5cGUubWFya0NyZWF0ZWQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmICh0aGlzLmNyZWF0ZWQpIHtcbiAgICAgIHRoaXMuY3JlYXRlZC5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKi9cbiAgQ29udGV4dC5wcm90b3R5cGUubWFya0RlbGV0ZWQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHRoaXMuZGVsZXRlZC5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTm90aWZpZXMgYWJvdXQgbm9kZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZHVyaW5nIHRoZSBwYXRjaCBvcGVhcmF0aW9uLlxuICAgKi9cbiAgQ29udGV4dC5wcm90b3R5cGUubm90aWZ5Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5jcmVhdGVkICYmIHRoaXMuY3JlYXRlZC5sZW5ndGggPiAwKSB7XG4gICAgICBub3RpZmljYXRpb25zLm5vZGVzQ3JlYXRlZCh0aGlzLmNyZWF0ZWQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRlbGV0ZWQgJiYgdGhpcy5kZWxldGVkLmxlbmd0aCA+IDApIHtcbiAgICAgIG5vdGlmaWNhdGlvbnMubm9kZXNEZWxldGVkKHRoaXMuZGVsZXRlZCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAqIE1ha2VzIHN1cmUgdGhhdCBrZXllZCBFbGVtZW50IG1hdGNoZXMgdGhlIHRhZyBuYW1lIHByb3ZpZGVkLlxuICAqIEBwYXJhbSB7IXN0cmluZ30gbm9kZU5hbWUgVGhlIG5vZGVOYW1lIG9mIHRoZSBub2RlIHRoYXQgaXMgYmVpbmcgbWF0Y2hlZC5cbiAgKiBAcGFyYW0ge3N0cmluZz19IHRhZyBUaGUgdGFnIG5hbWUgb2YgdGhlIEVsZW1lbnQuXG4gICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IFRoZSBrZXkgb2YgdGhlIEVsZW1lbnQuXG4gICovXG4gIHZhciBhc3NlcnRLZXllZFRhZ01hdGNoZXMgPSBmdW5jdGlvbiAobm9kZU5hbWUsIHRhZywga2V5KSB7XG4gICAgaWYgKG5vZGVOYW1lICE9PSB0YWcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2FzIGV4cGVjdGluZyBub2RlIHdpdGgga2V5IFwiJyArIGtleSArICdcIiB0byBiZSBhICcgKyB0YWcgKyAnLCBub3QgYSAnICsgbm9kZU5hbWUgKyAnLicpO1xuICAgIH1cbiAgfTtcblxuICAvKiogQHR5cGUgez9Db250ZXh0fSAqL1xuICB2YXIgY29udGV4dCA9IG51bGw7XG5cbiAgLyoqIEB0eXBlIHs/Tm9kZX0gKi9cbiAgdmFyIGN1cnJlbnROb2RlID0gbnVsbDtcblxuICAvKiogQHR5cGUgez9Ob2RlfSAqL1xuICB2YXIgY3VycmVudFBhcmVudCA9IG51bGw7XG5cbiAgLyoqIEB0eXBlIHs/RWxlbWVudHw/RG9jdW1lbnRGcmFnbWVudH0gKi9cbiAgdmFyIHJvb3QgPSBudWxsO1xuXG4gIC8qKiBAdHlwZSB7P0RvY3VtZW50fSAqL1xuICB2YXIgZG9jID0gbnVsbDtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHBhdGNoZXIgZnVuY3Rpb24gdGhhdCBzZXRzIHVwIGFuZCByZXN0b3JlcyBhIHBhdGNoIGNvbnRleHQsXG4gICAqIHJ1bm5pbmcgdGhlIHJ1biBmdW5jdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBkYXRhLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCghRWxlbWVudHwhRG9jdW1lbnRGcmFnbWVudCksIWZ1bmN0aW9uKFQpLFQ9KX0gcnVuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKCghRWxlbWVudHwhRG9jdW1lbnRGcmFnbWVudCksIWZ1bmN0aW9uKFQpLFQ9KX1cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG4gIHZhciBwYXRjaEZhY3RvcnkgPSBmdW5jdGlvbiAocnVuKSB7XG4gICAgLyoqXG4gICAgICogVE9ETyhtb3opOiBUaGVzZSBhbm5vdGF0aW9ucyB3b24ndCBiZSBuZWNlc3Nhcnkgb25jZSB3ZSBzd2l0Y2ggdG8gQ2xvc3VyZVxuICAgICAqIENvbXBpbGVyJ3MgbmV3IHR5cGUgaW5mZXJlbmNlLiBSZW1vdmUgdGhlc2Ugb25jZSB0aGUgc3dpdGNoIGlzIGRvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyghRWxlbWVudHwhRG9jdW1lbnRGcmFnbWVudCl9IG5vZGVcbiAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihUKX0gZm5cbiAgICAgKiBAcGFyYW0ge1Q9fSBkYXRhXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKi9cbiAgICB2YXIgZiA9IGZ1bmN0aW9uIChub2RlLCBmbiwgZGF0YSkge1xuICAgICAgdmFyIHByZXZDb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHZhciBwcmV2Um9vdCA9IHJvb3Q7XG4gICAgICB2YXIgcHJldkRvYyA9IGRvYztcbiAgICAgIHZhciBwcmV2Q3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZTtcbiAgICAgIHZhciBwcmV2Q3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICB2YXIgcHJldmlvdXNJbkF0dHJpYnV0ZXMgPSBmYWxzZTtcbiAgICAgIHZhciBwcmV2aW91c0luU2tpcCA9IGZhbHNlO1xuXG4gICAgICBjb250ZXh0ID0gbmV3IENvbnRleHQoKTtcbiAgICAgIHJvb3QgPSBub2RlO1xuICAgICAgZG9jID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgICAgY3VycmVudFBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcblxuICAgICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gJ3Byb2R1Y3Rpb24nKSB7fVxuXG4gICAgICBydW4obm9kZSwgZm4sIGRhdGEpO1xuXG4gICAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSAncHJvZHVjdGlvbicpIHt9XG5cbiAgICAgIGNvbnRleHQubm90aWZ5Q2hhbmdlcygpO1xuXG4gICAgICBjb250ZXh0ID0gcHJldkNvbnRleHQ7XG4gICAgICByb290ID0gcHJldlJvb3Q7XG4gICAgICBkb2MgPSBwcmV2RG9jO1xuICAgICAgY3VycmVudE5vZGUgPSBwcmV2Q3VycmVudE5vZGU7XG4gICAgICBjdXJyZW50UGFyZW50ID0gcHJldkN1cnJlbnRQYXJlbnQ7XG4gICAgfTtcbiAgICByZXR1cm4gZjtcbiAgfTtcblxuICAvKipcbiAgICogUGF0Y2hlcyB0aGUgZG9jdW1lbnQgc3RhcnRpbmcgYXQgbm9kZSB3aXRoIHRoZSBwcm92aWRlZCBmdW5jdGlvbi4gVGhpc1xuICAgKiBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGR1cmluZyBhbiBleGlzdGluZyBwYXRjaCBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR8IURvY3VtZW50RnJhZ21lbnR9IG5vZGUgVGhlIEVsZW1lbnQgb3IgRG9jdW1lbnRcbiAgICogICAgIHRvIHBhdGNoLlxuICAgKiBAcGFyYW0geyFmdW5jdGlvbihUKX0gZm4gQSBmdW5jdGlvbiBjb250YWluaW5nIGVsZW1lbnRPcGVuL2VsZW1lbnRDbG9zZS9ldGMuXG4gICAqICAgICBjYWxscyB0aGF0IGRlc2NyaWJlIHRoZSBET00uXG4gICAqIEBwYXJhbSB7VD19IGRhdGEgQW4gYXJndW1lbnQgcGFzc2VkIHRvIGZuIHRvIHJlcHJlc2VudCBET00gc3RhdGUuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuICB2YXIgcGF0Y2hJbm5lciA9IHBhdGNoRmFjdG9yeShmdW5jdGlvbiAobm9kZSwgZm4sIGRhdGEpIHtcbiAgICBjdXJyZW50Tm9kZSA9IG5vZGU7XG5cbiAgICBlbnRlck5vZGUoKTtcbiAgICBmbihkYXRhKTtcbiAgICBleGl0Tm9kZSgpO1xuXG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gJ3Byb2R1Y3Rpb24nKSB7fVxuICB9KTtcblxuICAvKipcbiAgICogUGF0Y2hlcyBhbiBFbGVtZW50IHdpdGggdGhlIHRoZSBwcm92aWRlZCBmdW5jdGlvbi4gRXhhY3RseSBvbmUgdG9wIGxldmVsXG4gICAqIGVsZW1lbnQgY2FsbCBzaG91bGQgYmUgbWFkZSBjb3JyZXNwb25kaW5nIHRvIGBub2RlYC5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gbm9kZSBUaGUgRWxlbWVudCB3aGVyZSB0aGUgcGF0Y2ggc2hvdWxkIHN0YXJ0LlxuICAgKiBAcGFyYW0geyFmdW5jdGlvbihUKX0gZm4gQSBmdW5jdGlvbiBjb250YWluaW5nIGVsZW1lbnRPcGVuL2VsZW1lbnRDbG9zZS9ldGMuXG4gICAqICAgICBjYWxscyB0aGF0IGRlc2NyaWJlIHRoZSBET00uIFRoaXMgc2hvdWxkIGhhdmUgYXQgbW9zdCBvbmUgdG9wIGxldmVsXG4gICAqICAgICBlbGVtZW50IGNhbGwuXG4gICAqIEBwYXJhbSB7VD19IGRhdGEgQW4gYXJndW1lbnQgcGFzc2VkIHRvIGZuIHRvIHJlcHJlc2VudCBET00gc3RhdGUuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuICB2YXIgcGF0Y2hPdXRlciA9IHBhdGNoRmFjdG9yeShmdW5jdGlvbiAobm9kZSwgZm4sIGRhdGEpIHtcbiAgICBjdXJyZW50Tm9kZSA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICoveyBuZXh0U2libGluZzogbm9kZSB9O1xuXG4gICAgZm4oZGF0YSk7XG5cbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSAncHJvZHVjdGlvbicpIHt9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhlIGN1cnJlbnQgbm9kZSBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgbm9kZU5hbWUgYW5kXG4gICAqIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHs/c3RyaW5nfSBub2RlTmFtZSBUaGUgbm9kZU5hbWUgZm9yIHRoaXMgbm9kZS5cbiAgICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IEFuIG9wdGlvbmFsIGtleSB0aGF0IGlkZW50aWZpZXMgYSBub2RlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBub2RlIG1hdGNoZXMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHZhciBtYXRjaGVzID0gZnVuY3Rpb24gKG5vZGVOYW1lLCBrZXkpIHtcbiAgICB2YXIgZGF0YSA9IGdldERhdGEoY3VycmVudE5vZGUpO1xuXG4gICAgLy8gS2V5IGNoZWNrIGlzIGRvbmUgdXNpbmcgZG91YmxlIGVxdWFscyBhcyB3ZSB3YW50IHRvIHRyZWF0IGEgbnVsbCBrZXkgdGhlXG4gICAgLy8gc2FtZSBhcyB1bmRlZmluZWQuIFRoaXMgc2hvdWxkIGJlIG9rYXkgYXMgdGhlIG9ubHkgdmFsdWVzIGFsbG93ZWQgYXJlXG4gICAgLy8gc3RyaW5ncywgbnVsbCBhbmQgdW5kZWZpbmVkIHNvIHRoZSA9PSBzZW1hbnRpY3MgYXJlIG5vdCB0b28gd2VpcmQuXG4gICAgcmV0dXJuIG5vZGVOYW1lID09PSBkYXRhLm5vZGVOYW1lICYmIGtleSA9PSBkYXRhLmtleTtcbiAgfTtcblxuICAvKipcbiAgICogQWxpZ25zIHRoZSB2aXJ0dWFsIEVsZW1lbnQgZGVmaW5pdGlvbiB3aXRoIHRoZSBhY3R1YWwgRE9NLCBtb3ZpbmcgdGhlXG4gICAqIGNvcnJlc3BvbmRpbmcgRE9NIG5vZGUgdG8gdGhlIGNvcnJlY3QgbG9jYXRpb24gb3IgY3JlYXRpbmcgaXQgaWYgbmVjZXNzYXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgRm9yIGFuIEVsZW1lbnQsIHRoaXMgc2hvdWxkIGJlIGEgdmFsaWQgdGFnIHN0cmluZy5cbiAgICogICAgIEZvciBhIFRleHQsIHRoaXMgc2hvdWxkIGJlICN0ZXh0LlxuICAgKiBAcGFyYW0gez9zdHJpbmc9fSBrZXkgVGhlIGtleSB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZWxlbWVudC5cbiAgICogQHBhcmFtIHs/QXJyYXk8Kj49fSBzdGF0aWNzIEZvciBhbiBFbGVtZW50LCB0aGlzIHNob3VsZCBiZSBhbiBhcnJheSBvZlxuICAgKiAgICAgbmFtZS12YWx1ZSBwYWlycy5cbiAgICovXG4gIHZhciBhbGlnbldpdGhET00gPSBmdW5jdGlvbiAobm9kZU5hbWUsIGtleSwgc3RhdGljcykge1xuICAgIGlmIChjdXJyZW50Tm9kZSAmJiBtYXRjaGVzKG5vZGVOYW1lLCBrZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIG5vZGUgaGFzIG1vdmVkIHdpdGhpbiB0aGUgcGFyZW50LlxuICAgIGlmIChrZXkpIHtcbiAgICAgIG5vZGUgPSBnZXRDaGlsZChjdXJyZW50UGFyZW50LCBrZXkpO1xuICAgICAgaWYgKG5vZGUgJiYgJ3Byb2R1Y3Rpb24nICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0S2V5ZWRUYWdNYXRjaGVzKGdldERhdGEobm9kZSkubm9kZU5hbWUsIG5vZGVOYW1lLCBrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgbm9kZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgIGlmICghbm9kZSkge1xuICAgICAgaWYgKG5vZGVOYW1lID09PSAnI3RleHQnKSB7XG4gICAgICAgIG5vZGUgPSBjcmVhdGVUZXh0KGRvYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gY3JlYXRlRWxlbWVudChkb2MsIGN1cnJlbnRQYXJlbnQsIG5vZGVOYW1lLCBrZXksIHN0YXRpY3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHJlZ2lzdGVyQ2hpbGQoY3VycmVudFBhcmVudCwga2V5LCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tYXJrQ3JlYXRlZChub2RlKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbm9kZSBoYXMgYSBrZXksIHJlbW92ZSBpdCBmcm9tIHRoZSBET00gdG8gcHJldmVudCBhIGxhcmdlIG51bWJlclxuICAgIC8vIG9mIHJlLW9yZGVycyBpbiB0aGUgY2FzZSB0aGF0IGl0IG1vdmVkIGZhciBvciB3YXMgY29tcGxldGVseSByZW1vdmVkLlxuICAgIC8vIFNpbmNlIHdlIGhvbGQgb24gdG8gYSByZWZlcmVuY2UgdGhyb3VnaCB0aGUga2V5TWFwLCB3ZSBjYW4gYWx3YXlzIGFkZCBpdFxuICAgIC8vIGJhY2suXG4gICAgaWYgKGN1cnJlbnROb2RlICYmIGdldERhdGEoY3VycmVudE5vZGUpLmtleSkge1xuICAgICAgY3VycmVudFBhcmVudC5yZXBsYWNlQ2hpbGQobm9kZSwgY3VycmVudE5vZGUpO1xuICAgICAgZ2V0RGF0YShjdXJyZW50UGFyZW50KS5rZXlNYXBWYWxpZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50UGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBjdXJyZW50Tm9kZSk7XG4gICAgfVxuXG4gICAgY3VycmVudE5vZGUgPSBub2RlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhcnMgb3V0IGFueSB1bnZpc2l0ZWQgTm9kZXMsIGFzIHRoZSBjb3JyZXNwb25kaW5nIHZpcnR1YWwgZWxlbWVudFxuICAgKiBmdW5jdGlvbnMgd2VyZSBuZXZlciBjYWxsZWQgZm9yIHRoZW0uXG4gICAqL1xuICB2YXIgY2xlYXJVbnZpc2l0ZWRET00gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICAgIHZhciBkYXRhID0gZ2V0RGF0YShub2RlKTtcbiAgICB2YXIga2V5TWFwID0gZGF0YS5rZXlNYXA7XG4gICAgdmFyIGtleU1hcFZhbGlkID0gZGF0YS5rZXlNYXBWYWxpZDtcbiAgICB2YXIgY2hpbGQgPSBub2RlLmxhc3RDaGlsZDtcbiAgICB2YXIga2V5ID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGNoaWxkID09PSBjdXJyZW50Tm9kZSAmJiBrZXlNYXBWYWxpZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmF0dHJzW3N5bWJvbHMucGxhY2Vob2xkZXJdICYmIG5vZGUgIT09IHJvb3QpIHtcbiAgICAgIGlmICgncHJvZHVjdGlvbicgIT09ICdwcm9kdWN0aW9uJykge31cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IGN1cnJlbnROb2RlKSB7XG4gICAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgIGNvbnRleHQubWFya0RlbGV0ZWQoIC8qKiBAdHlwZSB7IU5vZGV9Ki9jaGlsZCk7XG5cbiAgICAgIGtleSA9IGdldERhdGEoY2hpbGQpLmtleTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVsZXRlIGtleU1hcFtrZXldO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBub2RlLmxhc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBDbGVhbiB0aGUga2V5TWFwLCByZW1vdmluZyBhbnkgdW51c3VlZCBrZXlzLlxuICAgIGlmICgha2V5TWFwVmFsaWQpIHtcbiAgICAgIGZvciAoa2V5IGluIGtleU1hcCkge1xuICAgICAgICBjaGlsZCA9IGtleU1hcFtrZXldO1xuICAgICAgICBpZiAoY2hpbGQucGFyZW50Tm9kZSAhPT0gbm9kZSkge1xuICAgICAgICAgIGNvbnRleHQubWFya0RlbGV0ZWQoY2hpbGQpO1xuICAgICAgICAgIGRlbGV0ZSBrZXlNYXBba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkYXRhLmtleU1hcFZhbGlkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoYW5nZXMgdG8gdGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBjdXJyZW50IG5vZGUuXG4gICAqL1xuICB2YXIgZW50ZXJOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIGN1cnJlbnRQYXJlbnQgPSBjdXJyZW50Tm9kZTtcbiAgICBjdXJyZW50Tm9kZSA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoYW5nZXMgdG8gdGhlIG5leHQgc2libGluZyBvZiB0aGUgY3VycmVudCBub2RlLlxuICAgKi9cbiAgdmFyIG5leHROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjdXJyZW50Tm9kZSkge1xuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0U2libGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50UGFyZW50LmZpcnN0Q2hpbGQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRvIHRoZSBwYXJlbnQgb2YgdGhlIGN1cnJlbnQgbm9kZSwgcmVtb3ZpbmcgYW55IHVudmlzaXRlZCBjaGlsZHJlbi5cbiAgICovXG4gIHZhciBleGl0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhclVudmlzaXRlZERPTSgpO1xuXG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50UGFyZW50O1xuICAgIGN1cnJlbnRQYXJlbnQgPSBjdXJyZW50UGFyZW50LnBhcmVudE5vZGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1ha2VzIHN1cmUgdGhhdCB0aGUgY3VycmVudCBub2RlIGlzIGFuIEVsZW1lbnQgd2l0aCBhIG1hdGNoaW5nIHRhZ05hbWUgYW5kXG4gICAqIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgZWxlbWVudCdzIHRhZy5cbiAgICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IFRoZSBrZXkgdXNlZCB0byBpZGVudGlmeSB0aGlzIGVsZW1lbnQuIFRoaXMgY2FuIGJlIGFuXG4gICAqICAgICBlbXB0eSBzdHJpbmcsIGJ1dCBwZXJmb3JtYW5jZSBtYXkgYmUgYmV0dGVyIGlmIGEgdW5pcXVlIHZhbHVlIGlzIHVzZWRcbiAgICogICAgIHdoZW4gaXRlcmF0aW5nIG92ZXIgYW4gYXJyYXkgb2YgaXRlbXMuXG4gICAqIEBwYXJhbSB7P0FycmF5PCo+PX0gc3RhdGljcyBBbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBvZiB0aGVcbiAgICogICAgIHN0YXRpYyBhdHRyaWJ1dGVzIGZvciB0aGUgRWxlbWVudC4gVGhlc2Ugd2lsbCBvbmx5IGJlIHNldCBvbmNlIHdoZW4gdGhlXG4gICAqICAgICBFbGVtZW50IGlzIGNyZWF0ZWQuXG4gICAqIEByZXR1cm4geyFFbGVtZW50fSBUaGUgY29ycmVzcG9uZGluZyBFbGVtZW50LlxuICAgKi9cbiAgdmFyIGNvcmVFbGVtZW50T3BlbiA9IGZ1bmN0aW9uICh0YWcsIGtleSwgc3RhdGljcykge1xuICAgIG5leHROb2RlKCk7XG4gICAgYWxpZ25XaXRoRE9NKHRhZywga2V5LCBzdGF0aWNzKTtcbiAgICBlbnRlck5vZGUoKTtcbiAgICByZXR1cm4gKC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovY3VycmVudFBhcmVudFxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgY3VycmVudGx5IG9wZW4gRWxlbWVudCwgcmVtb3ZpbmcgYW55IHVudmlzaXRlZCBjaGlsZHJlbiBpZlxuICAgKiBuZWNlc3NhcnkuXG4gICAqXG4gICAqIEByZXR1cm4geyFFbGVtZW50fSBUaGUgY29ycmVzcG9uZGluZyBFbGVtZW50LlxuICAgKi9cbiAgdmFyIGNvcmVFbGVtZW50Q2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gJ3Byb2R1Y3Rpb24nKSB7fVxuXG4gICAgZXhpdE5vZGUoKTtcbiAgICByZXR1cm4gKC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovY3VycmVudE5vZGVcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYWtlcyBzdXJlIHRoZSBjdXJyZW50IG5vZGUgaXMgYSBUZXh0IG5vZGUgYW5kIGNyZWF0ZXMgYSBUZXh0IG5vZGUgaWYgaXQgaXNcbiAgICogbm90LlxuICAgKlxuICAgKiBAcmV0dXJuIHshVGV4dH0gVGhlIGNvcnJlc3BvbmRpbmcgVGV4dCBOb2RlLlxuICAgKi9cbiAgdmFyIGNvcmVUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIG5leHROb2RlKCk7XG4gICAgYWxpZ25XaXRoRE9NKCcjdGV4dCcsIG51bGwsIG51bGwpO1xuICAgIHJldHVybiAoLyoqIEB0eXBlIHshVGV4dH0gKi9jdXJyZW50Tm9kZVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgRWxlbWVudCBiZWluZyBwYXRjaGVkLlxuICAgKiBAcmV0dXJuIHshRWxlbWVudH1cbiAgICovXG4gIHZhciBjdXJyZW50RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSAncHJvZHVjdGlvbicpIHt9XG4gICAgcmV0dXJuICgvKiogQHR5cGUgeyFFbGVtZW50fSAqL2N1cnJlbnRQYXJlbnRcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTa2lwcyB0aGUgY2hpbGRyZW4gaW4gYSBzdWJ0cmVlLCBhbGxvd2luZyBhbiBFbGVtZW50IHRvIGJlIGNsb3NlZCB3aXRob3V0XG4gICAqIGNsZWFyaW5nIG91dCB0aGUgY2hpbGRyZW4uXG4gICAqL1xuICB2YXIgc2tpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSAncHJvZHVjdGlvbicpIHt9XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50UGFyZW50Lmxhc3RDaGlsZDtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIG9mZnNldCBpbiB0aGUgdmlydHVhbCBlbGVtZW50IGRlY2xhcmF0aW9uIHdoZXJlIHRoZSBhdHRyaWJ1dGVzIGFyZVxuICAgKiBzcGVjaWZpZWQuXG4gICAqIEBjb25zdFxuICAgKi9cbiAgdmFyIEFUVFJJQlVURVNfT0ZGU0VUID0gMztcblxuICAvKipcbiAgICogQnVpbGRzIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBmb3IgdXNlIHdpdGggZWxlbWVudE9wZW5TdGFydCwgYXR0ciBhbmRcbiAgICogZWxlbWVudE9wZW5FbmQuXG4gICAqIEBjb25zdCB7QXJyYXk8Kj59XG4gICAqL1xuICB2YXIgYXJnc0J1aWxkZXIgPSBbXTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgZWxlbWVudCdzIHRhZy5cbiAgICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IFRoZSBrZXkgdXNlZCB0byBpZGVudGlmeSB0aGlzIGVsZW1lbnQuIFRoaXMgY2FuIGJlIGFuXG4gICAqICAgICBlbXB0eSBzdHJpbmcsIGJ1dCBwZXJmb3JtYW5jZSBtYXkgYmUgYmV0dGVyIGlmIGEgdW5pcXVlIHZhbHVlIGlzIHVzZWRcbiAgICogICAgIHdoZW4gaXRlcmF0aW5nIG92ZXIgYW4gYXJyYXkgb2YgaXRlbXMuXG4gICAqIEBwYXJhbSB7P0FycmF5PCo+PX0gc3RhdGljcyBBbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBvZiB0aGVcbiAgICogICAgIHN0YXRpYyBhdHRyaWJ1dGVzIGZvciB0aGUgRWxlbWVudC4gVGhlc2Ugd2lsbCBvbmx5IGJlIHNldCBvbmNlIHdoZW4gdGhlXG4gICAqICAgICBFbGVtZW50IGlzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7Li4uKn0gY29uc3RfYXJncyBBdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBvZiB0aGUgZHluYW1pYyBhdHRyaWJ1dGVzXG4gICAqICAgICBmb3IgdGhlIEVsZW1lbnQuXG4gICAqIEByZXR1cm4geyFFbGVtZW50fSBUaGUgY29ycmVzcG9uZGluZyBFbGVtZW50LlxuICAgKi9cbiAgdmFyIGVsZW1lbnRPcGVuID0gZnVuY3Rpb24gKHRhZywga2V5LCBzdGF0aWNzLCBjb25zdF9hcmdzKSB7XG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gJ3Byb2R1Y3Rpb24nKSB7fVxuXG4gICAgdmFyIG5vZGUgPSBjb3JlRWxlbWVudE9wZW4odGFnLCBrZXksIHN0YXRpY3MpO1xuICAgIHZhciBkYXRhID0gZ2V0RGF0YShub2RlKTtcblxuICAgIC8qXG4gICAgICogQ2hlY2tzIHRvIHNlZSBpZiBvbmUgb3IgbW9yZSBhdHRyaWJ1dGVzIGhhdmUgY2hhbmdlZCBmb3IgYSBnaXZlbiBFbGVtZW50LlxuICAgICAqIFdoZW4gbm8gYXR0cmlidXRlcyBoYXZlIGNoYW5nZWQsIHRoaXMgaXMgbXVjaCBmYXN0ZXIgdGhhbiBjaGVja2luZyBlYWNoXG4gICAgICogaW5kaXZpZHVhbCBhcmd1bWVudC4gV2hlbiBhdHRyaWJ1dGVzIGhhdmUgY2hhbmdlZCwgdGhlIG92ZXJoZWFkIG9mIHRoaXMgaXNcbiAgICAgKiBtaW5pbWFsLlxuICAgICAqL1xuICAgIHZhciBhdHRyc0FyciA9IGRhdGEuYXR0cnNBcnI7XG4gICAgdmFyIG5ld0F0dHJzID0gZGF0YS5uZXdBdHRycztcbiAgICB2YXIgYXR0cnNDaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIGkgPSBBVFRSSUJVVEVTX09GRlNFVDtcbiAgICB2YXIgaiA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMSwgaiArPSAxKSB7XG4gICAgICBpZiAoYXR0cnNBcnJbal0gIT09IGFyZ3VtZW50c1tpXSkge1xuICAgICAgICBhdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMSwgaiArPSAxKSB7XG4gICAgICBhdHRyc0FycltqXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBpZiAoaiA8IGF0dHJzQXJyLmxlbmd0aCkge1xuICAgICAgYXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIGF0dHJzQXJyLmxlbmd0aCA9IGo7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBBY3R1YWxseSBwZXJmb3JtIHRoZSBhdHRyaWJ1dGUgdXBkYXRlLlxuICAgICAqL1xuICAgIGlmIChhdHRyc0NoYW5nZWQpIHtcbiAgICAgIGZvciAoaSA9IEFUVFJJQlVURVNfT0ZGU0VUOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIG5ld0F0dHJzW2FyZ3VtZW50c1tpXV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfYXR0ciBpbiBuZXdBdHRycykge1xuICAgICAgICB1cGRhdGVBdHRyaWJ1dGUobm9kZSwgX2F0dHIsIG5ld0F0dHJzW19hdHRyXSk7XG4gICAgICAgIG5ld0F0dHJzW19hdHRyXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICAvKipcbiAgICogRGVjbGFyZXMgYSB2aXJ0dWFsIEVsZW1lbnQgYXQgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gdGhlIGRvY3VtZW50LiBUaGlzXG4gICAqIGNvcnJlc3BvbmRzIHRvIGFuIG9wZW5pbmcgdGFnIGFuZCBhIGVsZW1lbnRDbG9zZSB0YWcgaXMgcmVxdWlyZWQuIFRoaXMgaXNcbiAgICogbGlrZSBlbGVtZW50T3BlbiwgYnV0IHRoZSBhdHRyaWJ1dGVzIGFyZSBkZWZpbmVkIHVzaW5nIHRoZSBhdHRyIGZ1bmN0aW9uXG4gICAqIHJhdGhlciB0aGFuIGJlaW5nIHBhc3NlZCBhcyBhcmd1bWVudHMuIE11c3QgYmUgZm9sbGxvd2VkIGJ5IDAgb3IgbW9yZSBjYWxsc1xuICAgKiB0byBhdHRyLCB0aGVuIGEgY2FsbCB0byBlbGVtZW50T3BlbkVuZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgZWxlbWVudCdzIHRhZy5cbiAgICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IFRoZSBrZXkgdXNlZCB0byBpZGVudGlmeSB0aGlzIGVsZW1lbnQuIFRoaXMgY2FuIGJlIGFuXG4gICAqICAgICBlbXB0eSBzdHJpbmcsIGJ1dCBwZXJmb3JtYW5jZSBtYXkgYmUgYmV0dGVyIGlmIGEgdW5pcXVlIHZhbHVlIGlzIHVzZWRcbiAgICogICAgIHdoZW4gaXRlcmF0aW5nIG92ZXIgYW4gYXJyYXkgb2YgaXRlbXMuXG4gICAqIEBwYXJhbSB7P0FycmF5PCo+PX0gc3RhdGljcyBBbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBvZiB0aGVcbiAgICogICAgIHN0YXRpYyBhdHRyaWJ1dGVzIGZvciB0aGUgRWxlbWVudC4gVGhlc2Ugd2lsbCBvbmx5IGJlIHNldCBvbmNlIHdoZW4gdGhlXG4gICAqICAgICBFbGVtZW50IGlzIGNyZWF0ZWQuXG4gICAqL1xuICB2YXIgZWxlbWVudE9wZW5TdGFydCA9IGZ1bmN0aW9uICh0YWcsIGtleSwgc3RhdGljcykge1xuICAgIGlmICgncHJvZHVjdGlvbicgIT09ICdwcm9kdWN0aW9uJykge31cblxuICAgIGFyZ3NCdWlsZGVyWzBdID0gdGFnO1xuICAgIGFyZ3NCdWlsZGVyWzFdID0ga2V5O1xuICAgIGFyZ3NCdWlsZGVyWzJdID0gc3RhdGljcztcbiAgfTtcblxuICAvKioqXG4gICAqIERlZmluZXMgYSB2aXJ0dWFsIGF0dHJpYnV0ZSBhdCB0aGlzIHBvaW50IG9mIHRoZSBET00uIFRoaXMgaXMgb25seSB2YWxpZFxuICAgKiB3aGVuIGNhbGxlZCBiZXR3ZWVuIGVsZW1lbnRPcGVuU3RhcnQgYW5kIGVsZW1lbnRPcGVuRW5kLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICB2YXIgYXR0ciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICgncHJvZHVjdGlvbicgIT09ICdwcm9kdWN0aW9uJykge31cblxuICAgIGFyZ3NCdWlsZGVyLnB1c2gobmFtZSwgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbG9zZXMgYW4gb3BlbiB0YWcgc3RhcnRlZCB3aXRoIGVsZW1lbnRPcGVuU3RhcnQuXG4gICAqIEByZXR1cm4geyFFbGVtZW50fSBUaGUgY29ycmVzcG9uZGluZyBFbGVtZW50LlxuICAgKi9cbiAgdmFyIGVsZW1lbnRPcGVuRW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICgncHJvZHVjdGlvbicgIT09ICdwcm9kdWN0aW9uJykge31cblxuICAgIHZhciBub2RlID0gZWxlbWVudE9wZW4uYXBwbHkobnVsbCwgYXJnc0J1aWxkZXIpO1xuICAgIGFyZ3NCdWlsZGVyLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsb3NlcyBhbiBvcGVuIHZpcnR1YWwgRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgZWxlbWVudCdzIHRhZy5cbiAgICogQHJldHVybiB7IUVsZW1lbnR9IFRoZSBjb3JyZXNwb25kaW5nIEVsZW1lbnQuXG4gICAqL1xuICB2YXIgZWxlbWVudENsb3NlID0gZnVuY3Rpb24gKHRhZykge1xuICAgIGlmICgncHJvZHVjdGlvbicgIT09ICdwcm9kdWN0aW9uJykge31cblxuICAgIHZhciBub2RlID0gY29yZUVsZW1lbnRDbG9zZSgpO1xuXG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gJ3Byb2R1Y3Rpb24nKSB7fVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY2xhcmVzIGEgdmlydHVhbCBFbGVtZW50IGF0IHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIHRoZSBkb2N1bWVudCB0aGF0IGhhc1xuICAgKiBubyBjaGlsZHJlbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgZWxlbWVudCdzIHRhZy5cbiAgICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IFRoZSBrZXkgdXNlZCB0byBpZGVudGlmeSB0aGlzIGVsZW1lbnQuIFRoaXMgY2FuIGJlIGFuXG4gICAqICAgICBlbXB0eSBzdHJpbmcsIGJ1dCBwZXJmb3JtYW5jZSBtYXkgYmUgYmV0dGVyIGlmIGEgdW5pcXVlIHZhbHVlIGlzIHVzZWRcbiAgICogICAgIHdoZW4gaXRlcmF0aW5nIG92ZXIgYW4gYXJyYXkgb2YgaXRlbXMuXG4gICAqIEBwYXJhbSB7P0FycmF5PCo+PX0gc3RhdGljcyBBbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBvZiB0aGVcbiAgICogICAgIHN0YXRpYyBhdHRyaWJ1dGVzIGZvciB0aGUgRWxlbWVudC4gVGhlc2Ugd2lsbCBvbmx5IGJlIHNldCBvbmNlIHdoZW4gdGhlXG4gICAqICAgICBFbGVtZW50IGlzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7Li4uKn0gY29uc3RfYXJncyBBdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBvZiB0aGUgZHluYW1pYyBhdHRyaWJ1dGVzXG4gICAqICAgICBmb3IgdGhlIEVsZW1lbnQuXG4gICAqIEByZXR1cm4geyFFbGVtZW50fSBUaGUgY29ycmVzcG9uZGluZyBFbGVtZW50LlxuICAgKi9cbiAgdmFyIGVsZW1lbnRWb2lkID0gZnVuY3Rpb24gKHRhZywga2V5LCBzdGF0aWNzLCBjb25zdF9hcmdzKSB7XG4gICAgZWxlbWVudE9wZW4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZWxlbWVudENsb3NlKHRhZyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY2xhcmVzIGEgdmlydHVhbCBFbGVtZW50IGF0IHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIHRoZSBkb2N1bWVudCB0aGF0IGlzIGFcbiAgICogcGxhY2Vob2xkZXIgZWxlbWVudC4gQ2hpbGRyZW4gb2YgdGhpcyBFbGVtZW50IGNhbiBiZSBtYW51YWxseSBtYW5hZ2VkIGFuZFxuICAgKiB3aWxsIG5vdCBiZSBjbGVhcmVkIGJ5IHRoZSBsaWJyYXJ5LlxuICAgKlxuICAgKiBBIGtleSBtdXN0IGJlIHNwZWNpZmllZCB0byBtYWtlIHN1cmUgdGhhdCB0aGlzIG5vZGUgaXMgY29ycmVjdGx5IHByZXNlcnZlZFxuICAgKiBhY3Jvc3MgYWxsIGNvbmRpdGlvbmFscy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgZWxlbWVudCdzIHRhZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBlbGVtZW50LlxuICAgKiBAcGFyYW0gez9BcnJheTwqPj19IHN0YXRpY3MgQW4gYXJyYXkgb2YgYXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMgb2YgdGhlXG4gICAqICAgICBzdGF0aWMgYXR0cmlidXRlcyBmb3IgdGhlIEVsZW1lbnQuIFRoZXNlIHdpbGwgb25seSBiZSBzZXQgb25jZSB3aGVuIHRoZVxuICAgKiAgICAgRWxlbWVudCBpcyBjcmVhdGVkLlxuICAgKiBAcGFyYW0gey4uLip9IGNvbnN0X2FyZ3MgQXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMgb2YgdGhlIGR5bmFtaWMgYXR0cmlidXRlc1xuICAgKiAgICAgZm9yIHRoZSBFbGVtZW50LlxuICAgKiBAcmV0dXJuIHshRWxlbWVudH0gVGhlIGNvcnJlc3BvbmRpbmcgRWxlbWVudC5cbiAgICovXG4gIHZhciBlbGVtZW50UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAodGFnLCBrZXksIHN0YXRpY3MsIGNvbnN0X2FyZ3MpIHtcbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSAncHJvZHVjdGlvbicpIHt9XG5cbiAgICBlbGVtZW50T3Blbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIHNraXAoKTtcbiAgICByZXR1cm4gZWxlbWVudENsb3NlKHRhZyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY2xhcmVzIGEgdmlydHVhbCBUZXh0IGF0IHRoaXMgcG9pbnQgaW4gdGhlIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8Ym9vbGVhbn0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBUZXh0LlxuICAgKiBAcGFyYW0gey4uLihmdW5jdGlvbigoc3RyaW5nfG51bWJlcnxib29sZWFuKSk6c3RyaW5nKX0gY29uc3RfYXJnc1xuICAgKiAgICAgRnVuY3Rpb25zIHRvIGZvcm1hdCB0aGUgdmFsdWUgd2hpY2ggYXJlIGNhbGxlZCBvbmx5IHdoZW4gdGhlIHZhbHVlIGhhc1xuICAgKiAgICAgY2hhbmdlZC5cbiAgICogQHJldHVybiB7IVRleHR9IFRoZSBjb3JyZXNwb25kaW5nIHRleHQgbm9kZS5cbiAgICovXG4gIHZhciB0ZXh0ID0gZnVuY3Rpb24gKHZhbHVlLCBjb25zdF9hcmdzKSB7XG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gJ3Byb2R1Y3Rpb24nKSB7fVxuXG4gICAgdmFyIG5vZGUgPSBjb3JlVGV4dCgpO1xuICAgIHZhciBkYXRhID0gZ2V0RGF0YShub2RlKTtcblxuICAgIGlmIChkYXRhLnRleHQgIT09IHZhbHVlKSB7XG4gICAgICBkYXRhLnRleHQgPSAvKiogQHR5cGUge3N0cmluZ30gKi92YWx1ZTtcblxuICAgICAgdmFyIGZvcm1hdHRlZCA9IHZhbHVlO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogQ2FsbCB0aGUgZm9ybWF0dGVyIGZ1bmN0aW9uIGRpcmVjdGx5IHRvIHByZXZlbnQgbGVha2luZyBhcmd1bWVudHMuXG4gICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvaW5jcmVtZW50YWwtZG9tL3B1bGwvMjA0I2lzc3VlY29tbWVudC0xNzgyMjM1NzRcbiAgICAgICAgICovXG4gICAgICAgIHZhciBmbiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgZm9ybWF0dGVkID0gZm4oZm9ybWF0dGVkKTtcbiAgICAgIH1cblxuICAgICAgbm9kZS5kYXRhID0gZm9ybWF0dGVkO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIGV4cG9ydHMucGF0Y2ggPSBwYXRjaElubmVyO1xuICBleHBvcnRzLnBhdGNoSW5uZXIgPSBwYXRjaElubmVyO1xuICBleHBvcnRzLnBhdGNoT3V0ZXIgPSBwYXRjaE91dGVyO1xuICBleHBvcnRzLmN1cnJlbnRFbGVtZW50ID0gY3VycmVudEVsZW1lbnQ7XG4gIGV4cG9ydHMuc2tpcCA9IHNraXA7XG4gIGV4cG9ydHMuZWxlbWVudFZvaWQgPSBlbGVtZW50Vm9pZDtcbiAgZXhwb3J0cy5lbGVtZW50T3BlblN0YXJ0ID0gZWxlbWVudE9wZW5TdGFydDtcbiAgZXhwb3J0cy5lbGVtZW50T3BlbkVuZCA9IGVsZW1lbnRPcGVuRW5kO1xuICBleHBvcnRzLmVsZW1lbnRPcGVuID0gZWxlbWVudE9wZW47XG4gIGV4cG9ydHMuZWxlbWVudENsb3NlID0gZWxlbWVudENsb3NlO1xuICBleHBvcnRzLmVsZW1lbnRQbGFjZWhvbGRlciA9IGVsZW1lbnRQbGFjZWhvbGRlcjtcbiAgZXhwb3J0cy50ZXh0ID0gdGV4dDtcbiAgZXhwb3J0cy5hdHRyID0gYXR0cjtcbiAgZXhwb3J0cy5zeW1ib2xzID0gc3ltYm9scztcbiAgZXhwb3J0cy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgZXhwb3J0cy5hcHBseUF0dHIgPSBhcHBseUF0dHI7XG4gIGV4cG9ydHMuYXBwbHlQcm9wID0gYXBwbHlQcm9wO1xuICBleHBvcnRzLm5vdGlmaWNhdGlvbnMgPSBub3RpZmljYXRpb25zO1xuXG59KSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCAnLi9pRE9NSGVscGVycyc7XG5pbXBvcnQgSW5jcmVtZW50YWxEb21SZW5kZXJlciBmcm9tICdtZXRhbC1pbmNyZW1lbnRhbC1kb20nO1xuXG4vKipcbiAqIEFsbG93cyBjb21wb25lbnRzIHRvIHVzZSBKU1ggdGVtcGxhdGVzIHRvIHJlbmRlciB0aGVpciBjb250ZW50cy4gVXNhZ2VcbiAqIGV4YW1wbGU6XG4gKlxuICogY2xhc3MgTXlDb21wIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAqICAganN4KCkge1xuICogICAgIDxkaXYgY2xhc3M9XCJteS1jb21wXCI+SGVsbG8gV29ybGQ8L2Rpdj47XG4gKiAgIH1cbiAqIH1cbiAqIEpTWC5yZWdpc3RlcihNeUNvbXApO1xuICovXG5jbGFzcyBKU1ggZXh0ZW5kcyBJbmNyZW1lbnRhbERvbVJlbmRlcmVyIHtcblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihjb21wKSB7XG5cdFx0c3VwZXIoY29tcCk7XG5cdFx0dGhpcy5mbl8gPSBjb21wLnJlbmRlciAmJiBjb21wLnJlbmRlci5iaW5kKGNvbXApO1xuXHR9XG5cblx0LyoqXG5cdCAqIE92ZXJyaWRlcyB0aGUgb3JpZ2luYWwgbWV0aG9kIHNvIHRoZSBcImNoaWxkcmVuXCIgZnVuY3Rpb24gY2FuIGJlXG5cdCAqIGF1dG9tYXRpY2FsbHkgcmVuZGVyZWQgdGhyb3VnaCBqc3guXG5cdCAqIEBwYXJhbSB7IUFycmF5PCF7bmFtZTogc3RyaW5nLCBhcmdzOiAhQXJyYXl9Pn0gY2FsbHNcblx0ICogQHJldHVybiB7IWZ1bmN0aW9uKCl9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQG92ZXJyaWRlXG5cdCAqL1xuXHRidWlsZENoaWxkcmVuRm5fKGNhbGxzKSB7XG5cdFx0dmFyIGZuID0gc3VwZXIuYnVpbGRDaGlsZHJlbkZuXyhjYWxscyk7XG5cdFx0cmV0dXJuIGlET01IZWxwZXJzLmpzeFdyYXBwZXIoZm4pO1xuXHR9XG5cblx0LyoqXG5cdCAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBtZXRob2QgZnJvbSBgSW5jcmVtZW50YWxEb21SZW5kZXJlcmAgc28gdGhlXG5cdCAqIGNvbXBvbmVudCdzIEpTWCB0ZW1wbGF0ZSBjYW4gYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxuXHQgKiBAb3ZlcnJpZGVcblx0ICovXG5cdHJlbmRlckluY0RvbSgpIHtcblx0XHRpZiAodGhpcy5mbl8pIHtcblx0XHRcdHRoaXMuZm5fKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN1cGVyLnJlbmRlckluY0RvbSgpO1xuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBKU1g7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnbWV0YWwtY29tcG9uZW50JztcbmltcG9ydCBKU1ggZnJvbSAnLi9KU1gnO1xuXG5jbGFzcyBKU1hDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuXHQvKipcblx0ICogT3ZlcnJpZGVzIHRoZSBvcmlnaW5hbCBtZXRob2QgdG8gY3JlYXRlIGEgSlNYIHJlbmRlcmVyLlxuXHQgKiBAcmV0dXJuIHshSlNYfVxuXHQgKi9cblx0Y3JlYXRlUmVuZGVyZXIoKSB7XG5cdFx0cmV0dXJuIG5ldyBKU1godGhpcyk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSlNYQ29tcG9uZW50O1xuZXhwb3J0IHsgSlNYIH07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhlc2UgaGVscGVycyBhcmUgYWxsIGZyb20gXCJiYWJlbC1wbHVnaW4taW5jcmVtZW50YWwtZG9tXCIuIFNlZSBpdHMgUkVBRE1FXG4gKiBmaWxlIGZvciBtb3JlIGRldGFpbHM6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vanJpZGdld2VsbC9iYWJlbC1wbHVnaW4taW5jcmVtZW50YWwtZG9tI3J1bnRpbWVcbiAqL1xuXG53aW5kb3cuaURPTUhlbHBlcnMgPSB3aW5kb3cuaURPTUhlbHBlcnMgfHwge307XG5cbndpbmRvdy5pRE9NSGVscGVycy5hdHRyID0gZnVuY3Rpb24odmFsdWUsIGF0dHJOYW1lKSB7XG4gIEluY3JlbWVudGFsRE9NLmF0dHIoYXR0ck5hbWUsIHZhbHVlKTtcbn07XG5cbndpbmRvdy5pRE9NSGVscGVycy5mb3JPd24gPSBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdG9yKSB7XG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICBmb3IgKHZhciBwcm9wIGluIG9iamVjdCkge1xuICAgIGlmIChoYXNPd24uY2FsbChvYmplY3QsIHByb3ApKSB7XG4gICAgICBpdGVyYXRvcihvYmplY3RbcHJvcF0sIHByb3ApO1xuICAgIH1cbiAgfVxufTtcblxud2luZG93LmlET01IZWxwZXJzLmpzeFdyYXBwZXIgPSBmdW5jdGlvbihlbGVtZW50Q2xvc3VyZSwgYXJncykge1xuICB2YXIgd3JhcHBlciA9IGFyZ3MgPyBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZWxlbWVudENsb3N1cmUuYXBwbHkodGhpcywgYXJncyk7XG4gIH0gOiBlbGVtZW50Q2xvc3VyZTtcbiAgd3JhcHBlci5fX2pzeERPTVdyYXBwZXIgPSB0cnVlO1xuICByZXR1cm4gd3JhcHBlcjtcbn07XG5cbndpbmRvdy5pRE9NSGVscGVycy5yZW5kZXJBcmJpdHJhcnkgPSBmdW5jdGlvbihjaGlsZCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZDtcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInIHx8ICh0eXBlID09PSAnc3RyaW5nJyB8fCBjaGlsZCAmJiBjaGlsZCBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICBJbmNyZW1lbnRhbERPTS50ZXh0KGNoaWxkKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnZnVuY3Rpb24nICYmIGNoaWxkLl9fanN4RE9NV3JhcHBlcikge1xuICAgIGNoaWxkKCk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICBjaGlsZC5mb3JFYWNoKHdpbmRvdy5pRE9NSGVscGVycy5yZW5kZXJBcmJpdHJhcnkpO1xuICB9IGVsc2UgaWYgKFN0cmluZyhjaGlsZCkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgd2luZG93LmlET01IZWxwZXJzLmZvck93bihjaGlsZCwgd2luZG93LmlET01IZWxwZXJzLnJlbmRlckFyYml0cmFyeSk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHdpbmRvdy5pRE9NSGVscGVycztcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgRGlzcG9zYWJsZSB9IGZyb20gJ21ldGFsJztcblxuLyoqXG4gKiBBIGNhY2hlZCByZWZlcmVuY2UgdG8gdGhlIGNyZWF0ZSBmdW5jdGlvbi5cbiAqL1xudmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogQ2FzZSBpbnNlbnNpdGl2ZSBzdHJpbmcgTXVsdGltYXAgaW1wbGVtZW50YXRpb24uIEFsbG93cyBtdWx0aXBsZSB2YWx1ZXMgZm9yXG4gKiB0aGUgc2FtZSBrZXkgbmFtZS5cbiAqIEBleHRlbmRzIHtEaXNwb3NhYmxlfVxuICovXG5jbGFzcyBNdWx0aU1hcCBleHRlbmRzIERpc3Bvc2FibGUge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMua2V5cyA9IGNyZWF0ZShudWxsKTtcblx0XHR0aGlzLnZhbHVlcyA9IGNyZWF0ZShudWxsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHZhbHVlIHRvIGEga2V5IG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWVcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0YWRkKG5hbWUsIHZhbHVlKSB7XG5cdFx0dGhpcy5rZXlzW25hbWUudG9Mb3dlckNhc2UoKV0gPSBuYW1lO1xuXHRcdHRoaXMudmFsdWVzW25hbWUudG9Mb3dlckNhc2UoKV0gPSB0aGlzLnZhbHVlc1tuYW1lLnRvTG93ZXJDYXNlKCldIHx8IFtdO1xuXHRcdHRoaXMudmFsdWVzW25hbWUudG9Mb3dlckNhc2UoKV0ucHVzaCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIG1hcCBuYW1lcyBhbmQgdmFsdWVzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRjbGVhcigpIHtcblx0XHR0aGlzLmtleXMgPSBjcmVhdGUobnVsbCk7XG5cdFx0dGhpcy52YWx1ZXMgPSBjcmVhdGUobnVsbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIG1hcCBjb250YWlucyBhIHZhbHVlIHRvIHRoZSBrZXkgbmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0Y29udGFpbnMobmFtZSkge1xuXHRcdHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKCkgaW4gdGhpcy52YWx1ZXM7XG5cdH1cblxuXHQvKipcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG5cdGRpc3Bvc2VJbnRlcm5hbCgpIHtcblx0XHR0aGlzLnZhbHVlcyA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgZmlyc3QgYWRkZWQgdmFsdWUgZnJvbSBhIGtleSBuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRnZXQobmFtZSkge1xuXHRcdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlc1tuYW1lLnRvTG93ZXJDYXNlKCldO1xuXHRcdGlmICh2YWx1ZXMpIHtcblx0XHRcdHJldHVybiB2YWx1ZXNbMF07XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgYWxsIHZhbHVlcyBmcm9tIGEga2V5IG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEByZXR1cm4ge0FycmF5LjwqPn1cblx0ICovXG5cdGdldEFsbChuYW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzW25hbWUudG9Mb3dlckNhc2UoKV07XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBtYXAgaXMgZW1wdHksIGZhbHNlIG90aGVyd2lzZS5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGlzRW1wdHkoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2l6ZSgpID09PSAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgYXJyYXkgb2Yga2V5IG5hbWVzLlxuXHQgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cblx0ICovXG5cdG5hbWVzKCkge1xuXHRcdHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykubWFwKChrZXkpID0+IHRoaXMua2V5c1trZXldKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFsbCB2YWx1ZXMgZnJvbSBhIGtleSBuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRyZW1vdmUobmFtZSkge1xuXHRcdGRlbGV0ZSB0aGlzLmtleXNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcblx0XHRkZWxldGUgdGhpcy52YWx1ZXNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIGtleSBuYW1lLiBSZWxldmFudCB0byByZXBsYWNlIHRoZSBjdXJyZW50IHZhbHVlcyB3aXRoXG5cdCAqIGEgbmV3IG9uZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXQobmFtZSwgdmFsdWUpIHtcblx0XHR0aGlzLmtleXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IG5hbWU7XG5cdFx0dGhpcy52YWx1ZXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IFt2YWx1ZV07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgc2l6ZSBvZiB0aGUgbWFwIGtleSBuYW1lcy5cblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cblx0c2l6ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5uYW1lcygpLmxlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBwYXJzZWQgdmFsdWVzIGFzIGEgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZXMpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE11bHRpTWFwO1xuIiwiLyohXG4gKiBQcm9taXNlcyBwb2x5ZmlsbCBmcm9tIEdvb2dsZSdzIENsb3N1cmUgTGlicmFyeS5cbiAqXG4gKiAgICAgIENvcHlyaWdodCAyMDEzIFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBOT1RFKGVkdWFyZG8pOiBQcm9taXNlIHN1cHBvcnQgaXMgbm90IHJlYWR5IG9uIGFsbCBzdXBwb3J0ZWQgYnJvd3NlcnMsXG4gKiB0aGVyZWZvcmUgY29yZS5qcyBpcyB0ZW1wb3JhcmlseSB1c2luZyBHb29nbGUncyBwcm9taXNlcyBhcyBwb2x5ZmlsbC4gSXRcbiAqIHN1cHBvcnRzIGNhbmNlbGxhYmxlIHByb21pc2VzIGFuZCBoYXMgY2xlYW4gYW5kIGZhc3QgaW1wbGVtZW50YXRpb24uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IHsgYXN5bmMgfSBmcm9tICdtZXRhbCc7XG5cbi8qKlxuICogUHJvdmlkZXMgYSBtb3JlIHN0cmljdCBpbnRlcmZhY2UgZm9yIFRoZW5hYmxlcyBpbiB0ZXJtcyBvZlxuICogaHR0cDovL3Byb21pc2VzYXBsdXMuY29tIGZvciBpbnRlcm9wIHdpdGgge0BzZWUgQ2FuY2VsbGFibGVQcm9taXNlfS5cbiAqXG4gKiBAaW50ZXJmYWNlXG4gKiBAZXh0ZW5kcyB7SVRoZW5hYmxlLjxUWVBFPn1cbiAqIEB0ZW1wbGF0ZSBUWVBFXG4gKi9cbnZhciBUaGVuYWJsZSA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogQWRkcyBjYWxsYmFja3MgdGhhdCB3aWxsIG9wZXJhdGUgb24gdGhlIHJlc3VsdCBvZiB0aGUgVGhlbmFibGUsIHJldHVybmluZyBhXG4gKiBuZXcgY2hpbGQgUHJvbWlzZS5cbiAqXG4gKiBJZiB0aGUgVGhlbmFibGUgaXMgZnVsZmlsbGVkLCB0aGUge0Bjb2RlIG9uRnVsZmlsbGVkfSBjYWxsYmFjayB3aWxsIGJlXG4gKiBpbnZva2VkIHdpdGggdGhlIGZ1bGZpbGxtZW50IHZhbHVlIGFzIGFyZ3VtZW50LCBhbmQgdGhlIGNoaWxkIFByb21pc2Ugd2lsbFxuICogYmUgZnVsZmlsbGVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGJhY2suIElmIHRoZSBjYWxsYmFjayB0aHJvd3NcbiAqIGFuIGV4Y2VwdGlvbiwgdGhlIGNoaWxkIFByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSB0aHJvd24gdmFsdWVcbiAqIGluc3RlYWQuXG4gKlxuICogSWYgdGhlIFRoZW5hYmxlIGlzIHJlamVjdGVkLCB0aGUge0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZFxuICogd2l0aCB0aGUgcmVqZWN0aW9uIHJlYXNvbiBhcyBhcmd1bWVudCwgYW5kIHRoZSBjaGlsZCBQcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWRcbiAqIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGJhY2sgb3IgdGhyb3duIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7PyhmdW5jdGlvbih0aGlzOlRISVMsIFRZUEUpOlxuICogICAgICAgICAgICAgKFJFU1VMVHxJVGhlbmFibGUuPFJFU1VMVD58VGhlbmFibGUpKT19IG9wdF9vbkZ1bGZpbGxlZCBBXG4gKiAgICAgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWQgd2l0aCB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgaWYgdGhlIFByb21pc2VcbiAqICAgICBpcyBmdWxsZmlsbGVkLlxuICogQHBhcmFtIHs/KGZ1bmN0aW9uKCopOiAqKT19IG9wdF9vblJlamVjdGVkIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWRcbiAqICAgICB3aXRoIHRoZSByZWplY3Rpb24gcmVhc29uIGlmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLlxuICogQHBhcmFtIHtUSElTPX0gb3B0X2NvbnRleHQgQW4gb3B0aW9uYWwgY29udGV4dCBvYmplY3QgdGhhdCB3aWxsIGJlIHRoZVxuICogICAgIGV4ZWN1dGlvbiBjb250ZXh0IGZvciB0aGUgY2FsbGJhY2tzLiBCeSBkZWZhdWx0LCBmdW5jdGlvbnMgYXJlIGV4ZWN1dGVkXG4gKiAgICAgd2l0aCB0aGUgZGVmYXVsdCB0aGlzLlxuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZS48UkVTVUxUPn0gQSBuZXcgUHJvbWlzZSB0aGF0IHdpbGwgcmVjZWl2ZSB0aGVcbiAqICAgICByZXN1bHQgb2YgdGhlIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvbiBjYWxsYmFjay5cbiAqIEB0ZW1wbGF0ZSBSRVNVTFQsVEhJU1xuICovXG5UaGVuYWJsZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKCkge307XG5cblxuLyoqXG4gKiBBbiBleHBhbmRvIHByb3BlcnR5IHRvIGluZGljYXRlIHRoYXQgYW4gb2JqZWN0IGltcGxlbWVudHNcbiAqIHtAY29kZSBUaGVuYWJsZX0uXG4gKlxuICoge0BzZWUgYWRkSW1wbGVtZW50YXRpb259LlxuICpcbiAqIEBjb25zdFxuICovXG5UaGVuYWJsZS5JTVBMRU1FTlRFRF9CWV9QUk9QID0gJyRnb29nX1RoZW5hYmxlJztcblxuXG4vKipcbiAqIE1hcmtzIGEgZ2l2ZW4gY2xhc3MgKGNvbnN0cnVjdG9yKSBhcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBUaGVuYWJsZSwgc29cbiAqIHRoYXQgd2UgY2FuIHF1ZXJ5IHRoYXQgZmFjdCBhdCBydW50aW1lLiBUaGUgY2xhc3MgbXVzdCBoYXZlIGFscmVhZHlcbiAqIGltcGxlbWVudGVkIHRoZSBpbnRlcmZhY2UuXG4gKiBFeHBvcnRzIGEgJ3RoZW4nIG1ldGhvZCBvbiB0aGUgY29uc3RydWN0b3IgcHJvdG90eXBlLCBzbyB0aGF0IHRoZSBvYmplY3RzXG4gKiBhbHNvIGltcGxlbWVudCB0aGUgZXh0ZXJuIHtAc2VlIFRoZW5hYmxlfSBpbnRlcmZhY2UgZm9yIGludGVyb3Agd2l0aFxuICogb3RoZXIgUHJvbWlzZSBpbXBsZW1lbnRhdGlvbnMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpUaGVuYWJsZSwuLi5bP10pfSBjdG9yIFRoZSBjbGFzcyBjb25zdHJ1Y3Rvci4gVGhlXG4gKiAgICAgY29ycmVzcG9uZGluZyBjbGFzcyBtdXN0IGhhdmUgYWxyZWFkeSBpbXBsZW1lbnRlZCB0aGUgaW50ZXJmYWNlLlxuICovXG5UaGVuYWJsZS5hZGRJbXBsZW1lbnRhdGlvbiA9IGZ1bmN0aW9uKGN0b3IpIHtcbiAgY3Rvci5wcm90b3R5cGUudGhlbiA9IGN0b3IucHJvdG90eXBlLnRoZW47XG4gIGN0b3IucHJvdG90eXBlLiRnb29nX1RoZW5hYmxlID0gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBhIGdpdmVuIGluc3RhbmNlIGltcGxlbWVudHMge0Bjb2RlIFRoZW5hYmxlfS5cbiAqICAgICBUaGUgY2xhc3Mvc3VwZXJjbGFzcyBvZiB0aGUgaW5zdGFuY2UgbXVzdCBjYWxsIHtAY29kZSBhZGRJbXBsZW1lbnRhdGlvbn0uXG4gKi9cblRoZW5hYmxlLmlzSW1wbGVtZW50ZWRCeSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiAhIW9iamVjdC4kZ29vZ19UaGVuYWJsZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFByb3BlcnR5IGFjY2VzcyBzZWVtcyB0byBiZSBmb3JiaWRkZW4uXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5cbi8qKlxuICogTGlrZSBiaW5kKCksIGV4Y2VwdCB0aGF0IGEgJ3RoaXMgb2JqZWN0JyBpcyBub3QgcmVxdWlyZWQuIFVzZWZ1bCB3aGVuIHRoZVxuICogdGFyZ2V0IGZ1bmN0aW9uIGlzIGFscmVhZHkgYm91bmQuXG4gKlxuICogVXNhZ2U6XG4gKiB2YXIgZyA9IHBhcnRpYWwoZiwgYXJnMSwgYXJnMik7XG4gKiBnKGFyZzMsIGFyZzQpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEEgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5LlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0aGF0IGFyZSBwYXJ0aWFsbHkgYXBwbGllZCB0byBmbi5cbiAqIEByZXR1cm4geyFGdW5jdGlvbn0gQSBwYXJ0aWFsbHktYXBwbGllZCBmb3JtIG9mIHRoZSBmdW5jdGlvbiBiaW5kKCkgd2FzXG4gKiAgICAgaW52b2tlZCBhcyBhIG1ldGhvZCBvZi5cbiAqL1xudmFyIHBhcnRpYWwgPSBmdW5jdGlvbihmbikge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAvLyBDbG9uZSB0aGUgYXJyYXkgKHdpdGggc2xpY2UoKSkgYW5kIGFwcGVuZCBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgIC8vIHRvIHRoZSBleGlzdGluZyBhcmd1bWVudHMuXG4gICAgdmFyIG5ld0FyZ3MgPSBhcmdzLnNsaWNlKCk7XG4gICAgbmV3QXJncy5wdXNoLmFwcGx5KG5ld0FyZ3MsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICB9O1xufTtcblxuLyoqXG4gKiBQcm9taXNlcyBwcm92aWRlIGEgcmVzdWx0IHRoYXQgbWF5IGJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5LiBBIFByb21pc2UgbWF5XG4gKiBiZSByZXNvbHZlZCBieSBiZWluZyBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQgd2l0aCBhIHZhbHVlLCB3aGljaCB3aWxsIGJlIGtub3duXG4gKiBhcyB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgb3IgdGhlIHJlamVjdGlvbiByZWFzb24uIFdoZXRoZXIgZnVsZmlsbGVkIG9yXG4gKiByZWplY3RlZCwgdGhlIFByb21pc2UgcmVzdWx0IGlzIGltbXV0YWJsZSBvbmNlIGl0IGlzIHNldC5cbiAqXG4gKiBQcm9taXNlcyBtYXkgcmVwcmVzZW50IHJlc3VsdHMgb2YgYW55IHR5cGUsIGluY2x1ZGluZyB1bmRlZmluZWQuIFJlamVjdGlvblxuICogcmVhc29ucyBhcmUgdHlwaWNhbGx5IEVycm9ycywgYnV0IG1heSBhbHNvIGJlIG9mIGFueSB0eXBlLiBDbG9zdXJlIFByb21pc2VzXG4gKiBhbGxvdyBmb3Igb3B0aW9uYWwgdHlwZSBhbm5vdGF0aW9ucyB0aGF0IGVuZm9yY2UgdGhhdCBmdWxmaWxsbWVudCB2YWx1ZXMgYXJlXG4gKiBvZiB0aGUgYXBwcm9wcmlhdGUgdHlwZXMgYXQgY29tcGlsZSB0aW1lLlxuICpcbiAqIFRoZSByZXN1bHQgb2YgYSBQcm9taXNlIGlzIGFjY2Vzc2libGUgYnkgY2FsbGluZyB7QGNvZGUgdGhlbn0gYW5kIHJlZ2lzdGVyaW5nXG4gKiB7QGNvZGUgb25GdWxmaWxsZWR9IGFuZCB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2tzLiBPbmNlIHRoZSBQcm9taXNlXG4gKiByZXNvbHZlcywgdGhlIHJlbGV2YW50IGNhbGxiYWNrcyBhcmUgaW52b2tlZCB3aXRoIHRoZSBmdWxmaWxsbWVudCB2YWx1ZSBvclxuICogcmVqZWN0aW9uIHJlYXNvbiBhcyBhcmd1bWVudC4gQ2FsbGJhY2tzIGFyZSBhbHdheXMgaW52b2tlZCBpbiB0aGUgb3JkZXIgdGhleVxuICogd2VyZSByZWdpc3RlcmVkLCBldmVuIHdoZW4gYWRkaXRpb25hbCB7QGNvZGUgdGhlbn0gY2FsbHMgYXJlIG1hZGUgZnJvbSBpbnNpZGVcbiAqIGFub3RoZXIgY2FsbGJhY2suIEEgY2FsbGJhY2sgaXMgYWx3YXlzIHJ1biBhc3luY2hyb25vdXNseSBzb21ldGltZSBhZnRlciB0aGVcbiAqIHNjb3BlIGNvbnRhaW5pbmcgdGhlIHJlZ2lzdGVyaW5nIHtAY29kZSB0aGVufSBpbnZvY2F0aW9uIGhhcyByZXR1cm5lZC5cbiAqXG4gKiBJZiBhIFByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCBhbm90aGVyIFByb21pc2UsIHRoZSBmaXJzdCBQcm9taXNlIHdpbGwgYmxvY2tcbiAqIHVudGlsIHRoZSBzZWNvbmQgaXMgcmVzb2x2ZWQsIGFuZCB0aGVuIGFzc3VtZXMgdGhlIHNhbWUgcmVzdWx0IGFzIHRoZSBzZWNvbmRcbiAqIFByb21pc2UuIFRoaXMgYWxsb3dzIFByb21pc2VzIHRvIGRlcGVuZCBvbiB0aGUgcmVzdWx0cyBvZiBvdGhlciBQcm9taXNlcyxcbiAqIGxpbmtpbmcgdG9nZXRoZXIgbXVsdGlwbGUgYXN5bmNocm9ub3VzIG9wZXJhdGlvbnMuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBjb21wYXRpYmxlIHdpdGggdGhlIFByb21pc2VzL0ErIHNwZWNpZmljYXRpb24gYW5kXG4gKiBwYXNzZXMgdGhhdCBzcGVjaWZpY2F0aW9uJ3MgY29uZm9ybWFuY2UgdGVzdCBzdWl0ZS4gQSBDbG9zdXJlIFByb21pc2UgbWF5IGJlXG4gKiByZXNvbHZlZCB3aXRoIGEgUHJvbWlzZSBpbnN0YW5jZSAob3Igc3VmZmljaWVudGx5IGNvbXBhdGlibGUgUHJvbWlzZS1saWtlXG4gKiBvYmplY3QpIGNyZWF0ZWQgYnkgb3RoZXIgUHJvbWlzZSBpbXBsZW1lbnRhdGlvbnMuIEZyb20gdGhlIHNwZWNpZmljYXRpb24sXG4gKiBQcm9taXNlLWxpa2Ugb2JqZWN0cyBhcmUga25vd24gYXMgXCJUaGVuYWJsZXNcIi5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9wcm9taXNlc2FwbHVzLmNvbS9cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFxuICogICAgICAgICAgICAgdGhpczpSRVNPTFZFUl9DT05URVhULFxuICogICAgICAgICAgICAgZnVuY3Rpb24oKFRZUEV8SVRoZW5hYmxlLjxUWVBFPnxUaGVuYWJsZSkpLFxuICogICAgICAgICAgICAgZnVuY3Rpb24oKikpOiB2b2lkfSByZXNvbHZlclxuICogICAgIEluaXRpYWxpemF0aW9uIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCBpbW1lZGlhdGVseSB3aXRoIHtAY29kZSByZXNvbHZlfVxuICogICAgIGFuZCB7QGNvZGUgcmVqZWN0fSBmdW5jdGlvbnMgYXMgYXJndW1lbnRzLiBUaGUgUHJvbWlzZSBpcyByZXNvbHZlZCBvclxuICogICAgIHJlamVjdGVkIHdpdGggdGhlIGZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBlaXRoZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1JFU09MVkVSX0NPTlRFWFQ9fSBvcHRfY29udGV4dCBBbiBvcHRpb25hbCBjb250ZXh0IGZvciBleGVjdXRpbmcgdGhlXG4gKiAgICAgcmVzb2x2ZXIgZnVuY3Rpb24uIElmIHVuc3BlY2lmaWVkLCB0aGUgcmVzb2x2ZXIgZnVuY3Rpb24gd2lsbCBiZSBleGVjdXRlZFxuICogICAgIGluIHRoZSBkZWZhdWx0IHNjb3BlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAc3RydWN0XG4gKiBAZmluYWxcbiAqIEBpbXBsZW1lbnRzIHtUaGVuYWJsZS48VFlQRT59XG4gKiBAdGVtcGxhdGUgVFlQRSxSRVNPTFZFUl9DT05URVhUXG4gKi9cbnZhciBDYW5jZWxsYWJsZVByb21pc2UgPSBmdW5jdGlvbihyZXNvbHZlciwgb3B0X2NvbnRleHQpIHtcbiAgLyoqXG4gICAqIFRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGlzIFByb21pc2UuIEVpdGhlciBQRU5ESU5HLCBGVUxGSUxMRUQsIFJFSkVDVEVELCBvclxuICAgKiBCTE9DS0VELlxuICAgKiBAcHJpdmF0ZSB7Q2FuY2VsbGFibGVQcm9taXNlLlN0YXRlX31cbiAgICovXG4gIHRoaXMuc3RhdGVfID0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5QRU5ESU5HO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVzb2x2ZWQgcmVzdWx0IG9mIHRoZSBQcm9taXNlLiBJbW11dGFibGUgb25jZSBzZXQgd2l0aCBlaXRoZXIgYVxuICAgKiBmdWxmaWxsbWVudCB2YWx1ZSBvciByZWplY3Rpb24gcmVhc29uLlxuICAgKiBAcHJpdmF0ZSB7Kn1cbiAgICovXG4gIHRoaXMucmVzdWx0XyA9IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogRm9yIFByb21pc2VzIGNyZWF0ZWQgYnkgY2FsbGluZyB7QGNvZGUgdGhlbigpfSwgdGhlIG9yaWdpbmF0aW5nIHBhcmVudC5cbiAgICogQHByaXZhdGUge0NhbmNlbGxhYmxlUHJvbWlzZX1cbiAgICovXG4gIHRoaXMucGFyZW50XyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIHtAY29kZSBvbkZ1bGZpbGxlZH0gYW5kIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFja3MgYWRkZWQgdG9cbiAgICogdGhpcyBQcm9taXNlIGJ5IGNhbGxzIHRvIHtAY29kZSB0aGVuKCl9LlxuICAgKiBAcHJpdmF0ZSB7QXJyYXkuPENhbmNlbGxhYmxlUHJvbWlzZS5DYWxsYmFja0VudHJ5Xz59XG4gICAqL1xuICB0aGlzLmNhbGxiYWNrRW50cmllc18gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBQcm9taXNlIGlzIGluIHRoZSBxdWV1ZSBvZiBQcm9taXNlcyB0byBleGVjdXRlLlxuICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMuZXhlY3V0aW5nXyA9IGZhbHNlO1xuXG4gIGlmIChDYW5jZWxsYWJsZVByb21pc2UuVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWSA+IDApIHtcbiAgICAvKipcbiAgICAgKiBBIHRpbWVvdXQgSUQgdXNlZCB3aGVuIHRoZSB7QGNvZGUgVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWX0gaXMgZ3JlYXRlclxuICAgICAqIHRoYW4gMCBtaWxsaXNlY29uZHMuIFRoZSBJRCBpcyBzZXQgd2hlbiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgYW5kXG4gICAgICogY2xlYXJlZCBvbmx5IGlmIGFuIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFjayBpcyBpbnZva2VkIGZvciB0aGVcbiAgICAgKiBQcm9taXNlIChvciBvbmUgb2YgaXRzIGRlc2NlbmRhbnRzKSBiZWZvcmUgdGhlIGRlbGF5IGlzIGV4Y2VlZGVkLlxuICAgICAqXG4gICAgICogSWYgdGhlIHJlamVjdGlvbiBpcyBub3QgaGFuZGxlZCBiZWZvcmUgdGhlIHRpbWVvdXQgY29tcGxldGVzLCB0aGVcbiAgICAgKiByZWplY3Rpb24gcmVhc29uIGlzIHBhc3NlZCB0byB0aGUgdW5oYW5kbGVkIHJlamVjdGlvbiBoYW5kbGVyLlxuICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy51bmhhbmRsZWRSZWplY3Rpb25JZF8gPSAwO1xuICB9IGVsc2UgaWYgKENhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZID09PSAwKSB7XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUge0Bjb2RlIFVOSEFORExFRF9SRUpFQ1RJT05fREVMQVl9IGlzIHNldCB0byAwIG1pbGxpc2Vjb25kcywgYVxuICAgICAqIGJvb2xlYW4gdGhhdCBpcyBzZXQgaWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGFuZCByZXNldCB0byBmYWxzZSBpZiBhblxuICAgICAqIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFjayBpcyBpbnZva2VkIGZvciB0aGUgUHJvbWlzZSAob3Igb25lIG9mIGl0c1xuICAgICAqIGRlc2NlbmRhbnRzKS4gSWYgdGhlIHJlamVjdGlvbiBpcyBub3QgaGFuZGxlZCBiZWZvcmUgdGhlIG5leHQgdGltZXN0ZXAsXG4gICAgICogdGhlIHJlamVjdGlvbiByZWFzb24gaXMgcGFzc2VkIHRvIHRoZSB1bmhhbmRsZWQgcmVqZWN0aW9uIGhhbmRsZXIuXG4gICAgICogQHByaXZhdGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5oYWRVbmhhbmRsZWRSZWplY3Rpb25fID0gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXNvbHZlci5jYWxsKFxuICAgICAgb3B0X2NvbnRleHQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHNlbGYucmVzb2x2ZV8oQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5GVUxGSUxMRUQsIHZhbHVlKTtcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICBzZWxmLnJlc29sdmVfKENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQsIHJlYXNvbik7XG4gICAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMucmVzb2x2ZV8oQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5SRUpFQ1RFRCwgZSk7XG4gIH1cbn07XG5cbi8qKlxuICogVGhlIGRlbGF5IGluIG1pbGxpc2Vjb25kcyBiZWZvcmUgYSByZWplY3RlZCBQcm9taXNlJ3MgcmVhc29uIGlzIHBhc3NlZCB0b1xuICogdGhlIHJlamVjdGlvbiBoYW5kbGVyLiBCeSBkZWZhdWx0LCB0aGUgcmVqZWN0aW9uIGhhbmRsZXIgcmV0aHJvd3MgdGhlXG4gKiByZWplY3Rpb24gcmVhc29uIHNvIHRoYXQgaXQgYXBwZWFycyBpbiB0aGUgZGV2ZWxvcGVyIGNvbnNvbGUgb3JcbiAqIHtAY29kZSB3aW5kb3cub25lcnJvcn0gaGFuZGxlci5cbiAqIFJlamVjdGlvbnMgYXJlIHJldGhyb3duIGFzIHF1aWNrbHkgYXMgcG9zc2libGUgYnkgZGVmYXVsdC4gQSBuZWdhdGl2ZSB2YWx1ZVxuICogZGlzYWJsZXMgcmVqZWN0aW9uIGhhbmRsaW5nIGVudGlyZWx5LlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkgPSAwO1xuXG5cbi8qKlxuICogVGhlIHBvc3NpYmxlIGludGVybmFsIHN0YXRlcyBmb3IgYSBQcm9taXNlLiBUaGVzZSBzdGF0ZXMgYXJlIG5vdCBkaXJlY3RseVxuICogb2JzZXJ2YWJsZSB0byBleHRlcm5hbCBjYWxsZXJzLlxuICogQGVudW0ge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8gPSB7XG4gIC8qKiBUaGUgUHJvbWlzZSBpcyB3YWl0aW5nIGZvciByZXNvbHV0aW9uLiAqL1xuICBQRU5ESU5HOiAwLFxuXG4gIC8qKiBUaGUgUHJvbWlzZSBpcyBibG9ja2VkIHdhaXRpbmcgZm9yIHRoZSByZXN1bHQgb2YgYW5vdGhlciBUaGVuYWJsZS4gKi9cbiAgQkxPQ0tFRDogMSxcblxuICAvKiogVGhlIFByb21pc2UgaGFzIGJlZW4gcmVzb2x2ZWQgd2l0aCBhIGZ1bGZpbGxtZW50IHZhbHVlLiAqL1xuICBGVUxGSUxMRUQ6IDIsXG5cbiAgLyoqIFRoZSBQcm9taXNlIGhhcyBiZWVuIHJlc29sdmVkIHdpdGggYSByZWplY3Rpb24gcmVhc29uLiAqL1xuICBSRUpFQ1RFRDogM1xufTtcblxuXG4vKipcbiAqIFR5cGVkZWYgZm9yIGVudHJpZXMgaW4gdGhlIGNhbGxiYWNrIGNoYWluLiBFYWNoIGNhbGwgdG8ge0Bjb2RlIHRoZW59LFxuICoge0Bjb2RlIHRoZW5DYXRjaH0sIG9yIHtAY29kZSB0aGVuQWx3YXlzfSBjcmVhdGVzIGFuIGVudHJ5IGNvbnRhaW5pbmcgdGhlXG4gKiBmdW5jdGlvbnMgdGhhdCBtYXkgYmUgaW52b2tlZCBvbmNlIHRoZSBQcm9taXNlIGlzIHJlc29sdmVkLlxuICpcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGNoaWxkOiBDYW5jZWxsYWJsZVByb21pc2UsXG4gKiAgIG9uRnVsZmlsbGVkOiBmdW5jdGlvbigqKSxcbiAqICAgb25SZWplY3RlZDogZnVuY3Rpb24oKilcbiAqIH19XG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UuQ2FsbGJhY2tFbnRyeV8gPSBudWxsO1xuXG5cbi8qKlxuICogQHBhcmFtIHsoVFlQRXxUaGVuYWJsZS48VFlQRT58VGhlbmFibGUpPX0gb3B0X3ZhbHVlXG4gKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlLjxUWVBFPn0gQSBuZXcgUHJvbWlzZSB0aGF0IGlzIGltbWVkaWF0ZWx5IHJlc29sdmVkXG4gKiAgICAgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuXG4gKiBAdGVtcGxhdGUgVFlQRVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uKG9wdF92YWx1ZSkge1xuICByZXR1cm4gbmV3IENhbmNlbGxhYmxlUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKG9wdF92YWx1ZSk7XG4gICAgfSk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHsqPX0gb3B0X3JlYXNvblxuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX0gQSBuZXcgUHJvbWlzZSB0aGF0IGlzIGltbWVkaWF0ZWx5IHJlamVjdGVkIHdpdGggdGhlXG4gKiAgICAgZ2l2ZW4gcmVhc29uLlxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24ob3B0X3JlYXNvbikge1xuICByZXR1cm4gbmV3IENhbmNlbGxhYmxlUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlamVjdChvcHRfcmVhc29uKTtcbiAgICB9KTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0geyFBcnJheS48IShUaGVuYWJsZS48VFlQRT58VGhlbmFibGUpPn0gcHJvbWlzZXNcbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2UuPFRZUEU+fSBBIFByb21pc2UgdGhhdCByZWNlaXZlcyB0aGUgcmVzdWx0IG9mIHRoZVxuICogICAgIGZpcnN0IFByb21pc2UgKG9yIFByb21pc2UtbGlrZSkgaW5wdXQgdG8gY29tcGxldGUuXG4gKiBAdGVtcGxhdGUgVFlQRVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucmFjZSA9IGZ1bmN0aW9uKHByb21pc2VzKSB7XG4gIHJldHVybiBuZXcgQ2FuY2VsbGFibGVQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgaWYgKCFwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIHByb21pc2U7IChwcm9taXNlID0gcHJvbWlzZXNbaV0pOyBpKyspIHtcbiAgICAgICAgcHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHshQXJyYXkuPCEoVGhlbmFibGUuPFRZUEU+fFRoZW5hYmxlKT59IHByb21pc2VzXG4gKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlLjwhQXJyYXkuPFRZUEU+Pn0gQSBQcm9taXNlIHRoYXQgcmVjZWl2ZXMgYSBsaXN0IG9mXG4gKiAgICAgZXZlcnkgZnVsZmlsbGVkIHZhbHVlIG9uY2UgZXZlcnkgaW5wdXQgUHJvbWlzZSAob3IgUHJvbWlzZS1saWtlKSBpc1xuICogICAgIHN1Y2Nlc3NmdWxseSBmdWxmaWxsZWQsIG9yIGlzIHJlamVjdGVkIGJ5IHRoZSBmaXJzdCByZWplY3Rpb24gcmVzdWx0LlxuICogQHRlbXBsYXRlIFRZUEVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLmFsbCA9IGZ1bmN0aW9uKHByb21pc2VzKSB7XG4gIHJldHVybiBuZXcgQ2FuY2VsbGFibGVQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHRvRnVsZmlsbCA9IHByb21pc2VzLmxlbmd0aDtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgICAgaWYgKCF0b0Z1bGZpbGwpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBvbkZ1bGZpbGwgPSBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgdG9GdWxmaWxsLS07XG4gICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRvRnVsZmlsbCA9PT0gMCkge1xuICAgICAgICAgIHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIG9uUmVqZWN0ID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIHByb21pc2U7IChwcm9taXNlID0gcHJvbWlzZXNbaV0pOyBpKyspIHtcbiAgICAgICAgcHJvbWlzZS50aGVuKHBhcnRpYWwob25GdWxmaWxsLCBpKSwgb25SZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7IUFycmF5LjwhKFRoZW5hYmxlLjxUWVBFPnxUaGVuYWJsZSk+fSBwcm9taXNlc1xuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZS48VFlQRT59IEEgUHJvbWlzZSB0aGF0IHJlY2VpdmVzIHRoZSB2YWx1ZSBvZlxuICogICAgIHRoZSBmaXJzdCBpbnB1dCB0byBiZSBmdWxmaWxsZWQsIG9yIGlzIHJlamVjdGVkIHdpdGggYSBsaXN0IG9mIGV2ZXJ5XG4gKiAgICAgcmVqZWN0aW9uIHJlYXNvbiBpZiBhbGwgaW5wdXRzIGFyZSByZWplY3RlZC5cbiAqIEB0ZW1wbGF0ZSBUWVBFXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5maXJzdEZ1bGZpbGxlZCA9IGZ1bmN0aW9uKHByb21pc2VzKSB7XG4gIHJldHVybiBuZXcgQ2FuY2VsbGFibGVQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHRvUmVqZWN0ID0gcHJvbWlzZXMubGVuZ3RoO1xuICAgICAgdmFyIHJlYXNvbnMgPSBbXTtcblxuICAgICAgaWYgKCF0b1JlamVjdCkge1xuICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9uRnVsZmlsbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgfTtcblxuICAgICAgdmFyIG9uUmVqZWN0ID0gZnVuY3Rpb24oaW5kZXgsIHJlYXNvbikge1xuICAgICAgICB0b1JlamVjdC0tO1xuICAgICAgICByZWFzb25zW2luZGV4XSA9IHJlYXNvbjtcbiAgICAgICAgaWYgKHRvUmVqZWN0ID09PSAwKSB7XG4gICAgICAgICAgcmVqZWN0KHJlYXNvbnMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgcHJvbWlzZTsgKHByb21pc2UgPSBwcm9taXNlc1tpXSk7IGkrKykge1xuICAgICAgICBwcm9taXNlLnRoZW4ob25GdWxmaWxsLCBwYXJ0aWFsKG9uUmVqZWN0LCBpKSk7XG4gICAgICB9XG4gICAgfSk7XG59O1xuXG5cbi8qKlxuICogQWRkcyBjYWxsYmFja3MgdGhhdCB3aWxsIG9wZXJhdGUgb24gdGhlIHJlc3VsdCBvZiB0aGUgUHJvbWlzZSwgcmV0dXJuaW5nIGFcbiAqIG5ldyBjaGlsZCBQcm9taXNlLlxuICpcbiAqIElmIHRoZSBQcm9taXNlIGlzIGZ1bGZpbGxlZCwgdGhlIHtAY29kZSBvbkZ1bGZpbGxlZH0gY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkXG4gKiB3aXRoIHRoZSBmdWxmaWxsbWVudCB2YWx1ZSBhcyBhcmd1bWVudCwgYW5kIHRoZSBjaGlsZCBQcm9taXNlIHdpbGwgYmVcbiAqIGZ1bGZpbGxlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNhbGxiYWNrLiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzIGFuXG4gKiBleGNlcHRpb24sIHRoZSBjaGlsZCBQcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgdGhyb3duIHZhbHVlIGluc3RlYWQuXG4gKlxuICogSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIHRoZSB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkXG4gKiB3aXRoIHRoZSByZWplY3Rpb24gcmVhc29uIGFzIGFyZ3VtZW50LCBhbmQgdGhlIGNoaWxkIFByb21pc2Ugd2lsbCBiZSByZWplY3RlZFxuICogd2l0aCB0aGUgcmV0dXJuIHZhbHVlIChvciB0aHJvd24gdmFsdWUpIG9mIHRoZSBjYWxsYmFjay5cbiAqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ob3B0X29uRnVsZmlsbGVkLCBvcHRfb25SZWplY3RlZCwgb3B0X2NvbnRleHQpIHtcbiAgcmV0dXJuIHRoaXMuYWRkQ2hpbGRQcm9taXNlXyhcbiAgICBjb3JlLmlzRnVuY3Rpb24ob3B0X29uRnVsZmlsbGVkKSA/IG9wdF9vbkZ1bGZpbGxlZCA6IG51bGwsXG4gICAgY29yZS5pc0Z1bmN0aW9uKG9wdF9vblJlamVjdGVkKSA/IG9wdF9vblJlamVjdGVkIDogbnVsbCxcbiAgICBvcHRfY29udGV4dCk7XG59O1xuVGhlbmFibGUuYWRkSW1wbGVtZW50YXRpb24oQ2FuY2VsbGFibGVQcm9taXNlKTtcblxuXG4vKipcbiAqIEFkZHMgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aGV0aGVyIHRoZSBQcm9taXNlIGlzIGZ1bGZpbGxlZCBvclxuICogcmVqZWN0ZWQuIFRoZSBjYWxsYmFjayByZWNlaXZlcyBubyBhcmd1bWVudCwgYW5kIG5vIG5ldyBjaGlsZCBQcm9taXNlIGlzXG4gKiBjcmVhdGVkLiBUaGlzIGlzIHVzZWZ1bCBmb3IgZW5zdXJpbmcgdGhhdCBjbGVhbnVwIHRha2VzIHBsYWNlIGFmdGVyIGNlcnRhaW5cbiAqIGFzeW5jaHJvbm91cyBvcGVyYXRpb25zLiBDYWxsYmFja3MgYWRkZWQgd2l0aCB7QGNvZGUgdGhlbkFsd2F5c30gd2lsbCBiZVxuICogZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgd2l0aCBvdGhlciBjYWxscyB0byB7QGNvZGUgdGhlbn0sXG4gKiB7QGNvZGUgdGhlbkFsd2F5c30sIG9yIHtAY29kZSB0aGVuQ2F0Y2h9LlxuICpcbiAqIFNpbmNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSBuZXcgY2hpbGQgUHJvbWlzZSwgY2FuY2VsbGF0aW9uIHByb3BhZ2F0aW9uIGlzXG4gKiBub3QgcHJldmVudGVkIGJ5IGFkZGluZyBjYWxsYmFja3Mgd2l0aCB7QGNvZGUgdGhlbkFsd2F5c30uIEEgUHJvbWlzZSB0aGF0IGhhc1xuICogYSBjbGVhbnVwIGhhbmRsZXIgYWRkZWQgd2l0aCB7QGNvZGUgdGhlbkFsd2F5c30gd2lsbCBiZSBjYW5jZWxlZCBpZiBhbGwgb2ZcbiAqIGl0cyBjaGlsZHJlbiBjcmVhdGVkIGJ5IHtAY29kZSB0aGVufSAob3Ige0Bjb2RlIHRoZW5DYXRjaH0pIGFyZSBjYW5jZWxlZC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6VEhJUyk6IHZvaWR9IG9uUmVzb2x2ZWQgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZFxuICogICAgIHdoZW4gdGhlIFByb21pc2UgaXMgcmVzb2x2ZWQuXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfY29udGV4dCBBbiBvcHRpb25hbCBjb250ZXh0IG9iamVjdCB0aGF0IHdpbGwgYmUgdGhlXG4gKiAgICAgZXhlY3V0aW9uIGNvbnRleHQgZm9yIHRoZSBjYWxsYmFja3MuIEJ5IGRlZmF1bHQsIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWRcbiAqICAgICBpbiB0aGUgZ2xvYmFsIHNjb3BlLlxuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZS48VFlQRT59IFRoaXMgUHJvbWlzZSwgZm9yIGNoYWluaW5nIGFkZGl0aW9uYWwgY2FsbHMuXG4gKiBAdGVtcGxhdGUgVEhJU1xuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnRoZW5BbHdheXMgPSBmdW5jdGlvbihvblJlc29sdmVkLCBvcHRfY29udGV4dCkge1xuICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgdG8gb25SZXNvbHZlZC5cbiAgICAgIG9uUmVzb2x2ZWQuY2FsbChvcHRfY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBDYW5jZWxsYWJsZVByb21pc2UuaGFuZGxlUmVqZWN0aW9uXy5jYWxsKG51bGwsIGVycik7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuYWRkQ2FsbGJhY2tFbnRyeV8oe1xuICAgIGNoaWxkOiBudWxsLFxuICAgIG9uUmVqZWN0ZWQ6IGNhbGxiYWNrLFxuICAgIG9uRnVsZmlsbGVkOiBjYWxsYmFja1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogQWRkcyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIG9ubHkgaWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXNcbiAqIGlzIGVxdWl2YWxlbnQgdG8ge0Bjb2RlIHRoZW4obnVsbCwgb25SZWplY3RlZCl9LlxuICpcbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKHRoaXM6VEhJUywgKik6ICp9IG9uUmVqZWN0ZWQgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmVcbiAqICAgICBpbnZva2VkIHdpdGggdGhlIHJlamVjdGlvbiByZWFzb24gaWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQuXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfY29udGV4dCBBbiBvcHRpb25hbCBjb250ZXh0IG9iamVjdCB0aGF0IHdpbGwgYmUgdGhlXG4gKiAgICAgZXhlY3V0aW9uIGNvbnRleHQgZm9yIHRoZSBjYWxsYmFja3MuIEJ5IGRlZmF1bHQsIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWRcbiAqICAgICBpbiB0aGUgZ2xvYmFsIHNjb3BlLlxuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX0gQSBuZXcgUHJvbWlzZSB0aGF0IHdpbGwgcmVjZWl2ZSB0aGUgcmVzdWx0IG9mIHRoZVxuICogICAgIGNhbGxiYWNrLlxuICogQHRlbXBsYXRlIFRISVNcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS50aGVuQ2F0Y2ggPSBmdW5jdGlvbihvblJlamVjdGVkLCBvcHRfY29udGV4dCkge1xuICByZXR1cm4gdGhpcy5hZGRDaGlsZFByb21pc2VfKG51bGwsIG9uUmVqZWN0ZWQsIG9wdF9jb250ZXh0KTtcbn07XG5cbi8qKlxuICogQWxpYXMgb2Yge0BsaW5rIENhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudGhlbkNhdGNofVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmNhdGNoID0gQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS50aGVuQ2F0Y2g7XG5cblxuLyoqXG4gKiBDYW5jZWxzIHRoZSBQcm9taXNlIGlmIGl0IGlzIHN0aWxsIHBlbmRpbmcgYnkgcmVqZWN0aW5nIGl0IHdpdGggYSBjYW5jZWxcbiAqIEVycm9yLiBObyBhY3Rpb24gaXMgcGVyZm9ybWVkIGlmIHRoZSBQcm9taXNlIGlzIGFscmVhZHkgcmVzb2x2ZWQuXG4gKlxuICogQWxsIGNoaWxkIFByb21pc2VzIG9mIHRoZSBjYW5jZWxlZCBQcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICogY2FuY2VsIGVycm9yLCBhcyB3aXRoIG5vcm1hbCBQcm9taXNlIHJlamVjdGlvbi4gSWYgdGhlIFByb21pc2UgdG8gYmUgY2FuY2VsZWRcbiAqIGlzIHRoZSBvbmx5IGNoaWxkIG9mIGEgcGVuZGluZyBQcm9taXNlLCB0aGUgcGFyZW50IFByb21pc2Ugd2lsbCBhbHNvIGJlXG4gKiBjYW5jZWxlZC4gQ2FuY2VsbGF0aW9uIG1heSBwcm9wYWdhdGUgdXB3YXJkIHRocm91Z2ggbXVsdGlwbGUgZ2VuZXJhdGlvbnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWVzc2FnZSBBbiBvcHRpb25hbCBkZWJ1Z2dpbmcgbWVzc2FnZSBmb3IgZGVzY3JpYmluZyB0aGVcbiAqICAgICBjYW5jZWxsYXRpb24gcmVhc29uLlxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uKG9wdF9tZXNzYWdlKSB7XG4gIGlmICh0aGlzLnN0YXRlXyA9PT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5QRU5ESU5HKSB7XG4gICAgYXN5bmMucnVuKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVyciA9IG5ldyBDYW5jZWxsYWJsZVByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3Iob3B0X21lc3NhZ2UpO1xuICAgICAgZXJyLklTX0NBTkNFTExBVElPTl9FUlJPUiA9IHRydWU7XG4gICAgICB0aGlzLmNhbmNlbEludGVybmFsXyhlcnIpO1xuICAgIH0sIHRoaXMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ2FuY2VscyB0aGlzIFByb21pc2Ugd2l0aCB0aGUgZ2l2ZW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHshRXJyb3J9IGVyciBUaGUgY2FuY2VsbGF0aW9uIGVycm9yLlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5jYW5jZWxJbnRlcm5hbF8gPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKHRoaXMuc3RhdGVfID09PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlBFTkRJTkcpIHtcbiAgICBpZiAodGhpcy5wYXJlbnRfKSB7XG4gICAgICAvLyBDYW5jZWwgdGhlIFByb21pc2UgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBwYXJlbnQncyBjaGlsZCBsaXN0LlxuICAgICAgdGhpcy5wYXJlbnRfLmNhbmNlbENoaWxkXyh0aGlzLCBlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc29sdmVfKENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQsIGVycik7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogQ2FuY2VscyBhIGNoaWxkIFByb21pc2UgZnJvbSB0aGUgbGlzdCBvZiBjYWxsYmFjayBlbnRyaWVzLiBJZiB0aGUgUHJvbWlzZSBoYXNcbiAqIG5vdCBhbHJlYWR5IGJlZW4gcmVzb2x2ZWQsIHJlamVjdCBpdCB3aXRoIGEgY2FuY2VsIGVycm9yLiBJZiB0aGVyZSBhcmUgbm9cbiAqIG90aGVyIGNoaWxkcmVuIGluIHRoZSBsaXN0IG9mIGNhbGxiYWNrIGVudHJpZXMsIHByb3BhZ2F0ZSB0aGUgY2FuY2VsbGF0aW9uXG4gKiBieSBjYW5jZWxpbmcgdGhpcyBQcm9taXNlIGFzIHdlbGwuXG4gKlxuICogQHBhcmFtIHshQ2FuY2VsbGFibGVQcm9taXNlfSBjaGlsZFByb21pc2UgVGhlIFByb21pc2UgdG8gY2FuY2VsLlxuICogQHBhcmFtIHshRXJyb3J9IGVyciBUaGUgY2FuY2VsIGVycm9yIHRvIHVzZSBmb3IgcmVqZWN0aW5nIHRoZSBQcm9taXNlLlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5jYW5jZWxDaGlsZF8gPSBmdW5jdGlvbihjaGlsZFByb21pc2UsIGVycikge1xuICBpZiAoIXRoaXMuY2FsbGJhY2tFbnRyaWVzXykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2hpbGRDb3VudCA9IDA7XG4gIHZhciBjaGlsZEluZGV4ID0gLTE7XG5cbiAgLy8gRmluZCB0aGUgY2FsbGJhY2sgZW50cnkgZm9yIHRoZSBjaGlsZFByb21pc2UsIGFuZCBjb3VudCB3aGV0aGVyIHRoZXJlIGFyZVxuICAvLyBhZGRpdGlvbmFsIGNoaWxkIFByb21pc2VzLlxuICBmb3IgKHZhciBpID0gMCwgZW50cnk7IChlbnRyeSA9IHRoaXMuY2FsbGJhY2tFbnRyaWVzX1tpXSk7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGVudHJ5LmNoaWxkO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgY2hpbGRDb3VudCsrO1xuICAgICAgaWYgKGNoaWxkID09PSBjaGlsZFByb21pc2UpIHtcbiAgICAgICAgY2hpbGRJbmRleCA9IGk7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGRJbmRleCA+PSAwICYmIGNoaWxkQ291bnQgPiAxKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBjaGlsZCBQcm9taXNlIHdhcyB0aGUgb25seSBjaGlsZCwgY2FuY2VsIHRoaXMgUHJvbWlzZSBhcyB3ZWxsLlxuICAvLyBPdGhlcndpc2UsIHJlamVjdCBvbmx5IHRoZSBjaGlsZCBQcm9taXNlIHdpdGggdGhlIGNhbmNlbCBlcnJvci5cbiAgaWYgKGNoaWxkSW5kZXggPj0gMCkge1xuICAgIGlmICh0aGlzLnN0YXRlXyA9PT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5QRU5ESU5HICYmIGNoaWxkQ291bnQgPT09IDEpIHtcbiAgICAgIHRoaXMuY2FuY2VsSW50ZXJuYWxfKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjYWxsYmFja0VudHJ5ID0gdGhpcy5jYWxsYmFja0VudHJpZXNfLnNwbGljZShjaGlsZEluZGV4LCAxKVswXTtcbiAgICAgIHRoaXMuZXhlY3V0ZUNhbGxiYWNrXyhcbiAgICAgICAgY2FsbGJhY2tFbnRyeSwgQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5SRUpFQ1RFRCwgZXJyKTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBBZGRzIGEgY2FsbGJhY2sgZW50cnkgdG8gdGhlIGN1cnJlbnQgUHJvbWlzZSwgYW5kIHNjaGVkdWxlcyBjYWxsYmFja1xuICogZXhlY3V0aW9uIGlmIHRoZSBQcm9taXNlIGhhcyBhbHJlYWR5IGJlZW4gcmVzb2x2ZWQuXG4gKlxuICogQHBhcmFtIHtDYW5jZWxsYWJsZVByb21pc2UuQ2FsbGJhY2tFbnRyeV99IGNhbGxiYWNrRW50cnkgUmVjb3JkIGNvbnRhaW5pbmdcbiAqICAgICB7QGNvZGUgb25GdWxmaWxsZWR9IGFuZCB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2tzIHRvIGV4ZWN1dGUgYWZ0ZXJcbiAqICAgICB0aGUgUHJvbWlzZSBpcyByZXNvbHZlZC5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUuYWRkQ2FsbGJhY2tFbnRyeV8gPSBmdW5jdGlvbihjYWxsYmFja0VudHJ5KSB7XG4gIGlmICgoIXRoaXMuY2FsbGJhY2tFbnRyaWVzXyB8fCAhdGhpcy5jYWxsYmFja0VudHJpZXNfLmxlbmd0aCkgJiZcbiAgICAodGhpcy5zdGF0ZV8gPT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uRlVMRklMTEVEIHx8XG4gICAgdGhpcy5zdGF0ZV8gPT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQpKSB7XG4gICAgdGhpcy5zY2hlZHVsZUNhbGxiYWNrc18oKTtcbiAgfVxuICBpZiAoIXRoaXMuY2FsbGJhY2tFbnRyaWVzXykge1xuICAgIHRoaXMuY2FsbGJhY2tFbnRyaWVzXyA9IFtdO1xuICB9XG4gIHRoaXMuY2FsbGJhY2tFbnRyaWVzXy5wdXNoKGNhbGxiYWNrRW50cnkpO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBjaGlsZCBQcm9taXNlIGFuZCBhZGRzIGl0IHRvIHRoZSBjYWxsYmFjayBlbnRyeSBsaXN0LiBUaGUgcmVzdWx0IG9mXG4gKiB0aGUgY2hpbGQgUHJvbWlzZSBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBzdGF0ZSBvZiB0aGUgcGFyZW50IFByb21pc2UgYW5kIHRoZVxuICogcmVzdWx0IG9mIHRoZSB7QGNvZGUgb25GdWxmaWxsZWR9IG9yIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFja3MgYXNcbiAqIHNwZWNpZmllZCBpbiB0aGUgUHJvbWlzZSByZXNvbHV0aW9uIHByb2NlZHVyZS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9wcm9taXNlc2FwbHVzLmNvbS8jdGhlX19tZXRob2RcbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbih0aGlzOlRISVMsIFRZUEUpOlxuICogICAgICAgICAgKFJFU1VMVHxDYW5jZWxsYWJsZVByb21pc2UuPFJFU1VMVD58VGhlbmFibGUpfSBvbkZ1bGZpbGxlZCBBIGNhbGxiYWNrIHRoYXRcbiAqICAgICB3aWxsIGJlIGludm9rZWQgaWYgdGhlIFByb21pc2UgaXMgZnVsbGZpbGxlZCwgb3IgbnVsbC5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9uKHRoaXM6VEhJUywgKik6ICp9IG9uUmVqZWN0ZWQgQSBjYWxsYmFjayB0aGF0IHdpbGwgYmVcbiAqICAgICBpbnZva2VkIGlmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBvciBudWxsLlxuICogQHBhcmFtIHtUSElTPX0gb3B0X2NvbnRleHQgQW4gb3B0aW9uYWwgZXhlY3V0aW9uIGNvbnRleHQgZm9yIHRoZSBjYWxsYmFja3MuXG4gKiAgICAgaW4gdGhlIGRlZmF1bHQgY2FsbGluZyBjb250ZXh0LlxuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX0gVGhlIGNoaWxkIFByb21pc2UuXG4gKiBAdGVtcGxhdGUgUkVTVUxULFRISVNcbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUuYWRkQ2hpbGRQcm9taXNlXyA9IGZ1bmN0aW9uKFxub25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9wdF9jb250ZXh0KSB7XG5cbiAgdmFyIGNhbGxiYWNrRW50cnkgPSB7XG4gICAgY2hpbGQ6IG51bGwsXG4gICAgb25GdWxmaWxsZWQ6IG51bGwsXG4gICAgb25SZWplY3RlZDogbnVsbFxuICB9O1xuXG4gIGNhbGxiYWNrRW50cnkuY2hpbGQgPSBuZXcgQ2FuY2VsbGFibGVQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIC8vIEludm9rZSBvbkZ1bGZpbGxlZCwgb3IgcmVzb2x2ZSB3aXRoIHRoZSBwYXJlbnQncyB2YWx1ZSBpZiBhYnNlbnQuXG4gICAgY2FsbGJhY2tFbnRyeS5vbkZ1bGZpbGxlZCA9IG9uRnVsZmlsbGVkID8gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBvbkZ1bGZpbGxlZC5jYWxsKG9wdF9jb250ZXh0LCB2YWx1ZSk7XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9IDogcmVzb2x2ZTtcblxuICAgIC8vIEludm9rZSBvblJlamVjdGVkLCBvciByZWplY3Qgd2l0aCB0aGUgcGFyZW50J3MgcmVhc29uIGlmIGFic2VudC5cbiAgICBjYWxsYmFja0VudHJ5Lm9uUmVqZWN0ZWQgPSBvblJlamVjdGVkID8gZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gb25SZWplY3RlZC5jYWxsKG9wdF9jb250ZXh0LCByZWFzb24pO1xuICAgICAgICBpZiAoIWNvcmUuaXNEZWYocmVzdWx0KSAmJiByZWFzb24uSVNfQ0FOQ0VMTEFUSU9OX0VSUk9SKSB7XG4gICAgICAgICAgLy8gUHJvcGFnYXRlIGNhbmNlbGxhdGlvbiB0byBjaGlsZHJlbiBpZiBubyBvdGhlciByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSA6IHJlamVjdDtcbiAgfSk7XG5cbiAgY2FsbGJhY2tFbnRyeS5jaGlsZC5wYXJlbnRfID0gdGhpcztcbiAgdGhpcy5hZGRDYWxsYmFja0VudHJ5XyhcbiAgICAvKiogQHR5cGUge0NhbmNlbGxhYmxlUHJvbWlzZS5DYWxsYmFja0VudHJ5X30gKi8gKGNhbGxiYWNrRW50cnkpKTtcbiAgcmV0dXJuIGNhbGxiYWNrRW50cnkuY2hpbGQ7XG59O1xuXG5cbi8qKlxuICogVW5ibG9ja3MgdGhlIFByb21pc2UgYW5kIGZ1bGZpbGxzIGl0IHdpdGggdGhlIGdpdmVuIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7VFlQRX0gdmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudW5ibG9ja0FuZEZ1bGZpbGxfID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHRoaXMuc3RhdGVfICE9PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkJMT0NLRUQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbmNlbGxhYmxlUHJvbWlzZSBpcyBub3QgYmxvY2tlZC4nKTtcbiAgfVxuICB0aGlzLnN0YXRlXyA9IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUEVORElORztcbiAgdGhpcy5yZXNvbHZlXyhDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkZVTEZJTExFRCwgdmFsdWUpO1xufTtcblxuXG4vKipcbiAqIFVuYmxvY2tzIHRoZSBQcm9taXNlIGFuZCByZWplY3RzIGl0IHdpdGggdGhlIGdpdmVuIHJlamVjdGlvbiByZWFzb24uXG4gKlxuICogQHBhcmFtIHsqfSByZWFzb25cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudW5ibG9ja0FuZFJlamVjdF8gPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgaWYgKHRoaXMuc3RhdGVfICE9PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkJMT0NLRUQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbmNlbGxhYmxlUHJvbWlzZSBpcyBub3QgYmxvY2tlZC4nKTtcbiAgfVxuICB0aGlzLnN0YXRlXyA9IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUEVORElORztcbiAgdGhpcy5yZXNvbHZlXyhDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVELCByZWFzb24pO1xufTtcblxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIHJlc29sdmUgYSBQcm9taXNlIHdpdGggYSBnaXZlbiByZXNvbHV0aW9uIHN0YXRlIGFuZCB2YWx1ZS4gVGhpc1xuICogaXMgYSBuby1vcCBpZiB0aGUgZ2l2ZW4gUHJvbWlzZSBoYXMgYWxyZWFkeSBiZWVuIHJlc29sdmVkLlxuICpcbiAqIElmIHRoZSBnaXZlbiByZXN1bHQgaXMgYSBUaGVuYWJsZSAoc3VjaCBhcyBhbm90aGVyIFByb21pc2UpLCB0aGUgUHJvbWlzZSB3aWxsXG4gKiBiZSByZXNvbHZlZCB3aXRoIHRoZSBzYW1lIHN0YXRlIGFuZCByZXN1bHQgYXMgdGhlIFRoZW5hYmxlIG9uY2UgaXQgaXMgaXRzZWxmXG4gKiByZXNvbHZlZC5cbiAqXG4gKiBJZiB0aGUgZ2l2ZW4gcmVzdWx0IGlzIG5vdCBhIFRoZW5hYmxlLCB0aGUgUHJvbWlzZSB3aWxsIGJlIGZ1bGZpbGxlZCBvclxuICogcmVqZWN0ZWQgd2l0aCB0aGF0IHJlc3VsdCBiYXNlZCBvbiB0aGUgZ2l2ZW4gc3RhdGUuXG4gKlxuICogQHNlZSBodHRwOi8vcHJvbWlzZXNhcGx1cy5jb20vI3RoZV9wcm9taXNlX3Jlc29sdXRpb25fcHJvY2VkdXJlXG4gKlxuICogQHBhcmFtIHtDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVffSBzdGF0ZVxuICogQHBhcmFtIHsqfSB4IFRoZSByZXN1bHQgdG8gYXBwbHkgdG8gdGhlIFByb21pc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnJlc29sdmVfID0gZnVuY3Rpb24oc3RhdGUsIHgpIHtcbiAgaWYgKHRoaXMuc3RhdGVfICE9PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcyA9PT0geCkge1xuICAgIHN0YXRlID0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5SRUpFQ1RFRDtcbiAgICB4ID0gbmV3IFR5cGVFcnJvcignQ2FuY2VsbGFibGVQcm9taXNlIGNhbm5vdCByZXNvbHZlIHRvIGl0c2VsZicpO1xuXG4gIH0gZWxzZSBpZiAoVGhlbmFibGUuaXNJbXBsZW1lbnRlZEJ5KHgpKSB7XG4gICAgeCA9IC8qKiBAdHlwZSB7IVRoZW5hYmxlfSAqLyAoeCk7XG4gICAgdGhpcy5zdGF0ZV8gPSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkJMT0NLRUQ7XG4gICAgeC50aGVuKHRoaXMudW5ibG9ja0FuZEZ1bGZpbGxfLCB0aGlzLnVuYmxvY2tBbmRSZWplY3RfLCB0aGlzKTtcbiAgICByZXR1cm47XG5cbiAgfSBlbHNlIGlmIChjb3JlLmlzT2JqZWN0KHgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB0aGVuID0geC50aGVuO1xuICAgICAgaWYgKGNvcmUuaXNGdW5jdGlvbih0aGVuKSkge1xuICAgICAgICB0aGlzLnRyeVRoZW5fKHgsIHRoZW4pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc3RhdGUgPSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVEO1xuICAgICAgeCA9IGU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5yZXN1bHRfID0geDtcbiAgdGhpcy5zdGF0ZV8gPSBzdGF0ZTtcbiAgdGhpcy5zY2hlZHVsZUNhbGxiYWNrc18oKTtcblxuICBpZiAoc3RhdGUgPT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUkVKRUNURUQgJiYgIXguSVNfQ0FOQ0VMTEFUSU9OX0VSUk9SKSB7XG4gICAgQ2FuY2VsbGFibGVQcm9taXNlLmFkZFVuaGFuZGxlZFJlamVjdGlvbl8odGhpcywgeCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBjYWxsIHRoZSB7QGNvZGUgdGhlbn0gbWV0aG9kIG9uIGFuIG9iamVjdCBpbiB0aGUgaG9wZXMgdGhhdCBpdCBpc1xuICogYSBQcm9taXNlLWNvbXBhdGlibGUgaW5zdGFuY2UuIFRoaXMgYWxsb3dzIGludGVyb3BlcmF0aW9uIGJldHdlZW4gZGlmZmVyZW50XG4gKiBQcm9taXNlIGltcGxlbWVudGF0aW9ucywgaG93ZXZlciBhIG5vbi1jb21wbGlhbnQgb2JqZWN0IG1heSBjYXVzZSBhIFByb21pc2VcbiAqIHRvIGhhbmcgaW5kZWZpbml0ZWx5LiBJZiB0aGUge0Bjb2RlIHRoZW59IG1ldGhvZCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB0aGVcbiAqIGRlcGVuZGVudCBQcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgdGhyb3duIHZhbHVlLlxuICpcbiAqIEBzZWUgaHR0cDovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03MFxuICpcbiAqIEBwYXJhbSB7VGhlbmFibGV9IHRoZW5hYmxlIEFuIG9iamVjdCB3aXRoIGEge0Bjb2RlIHRoZW59IG1ldGhvZCB0aGF0IG1heSBiZVxuICogICAgIGNvbXBhdGlibGUgd2l0aCB0aGUgUHJvbWlzZS9BKyBzcGVjaWZpY2F0aW9uLlxuICogQHBhcmFtIHshRnVuY3Rpb259IHRoZW4gVGhlIHtAY29kZSB0aGVufSBtZXRob2Qgb2YgdGhlIFRoZW5hYmxlIG9iamVjdC5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudHJ5VGhlbl8gPSBmdW5jdGlvbih0aGVuYWJsZSwgdGhlbikge1xuICB0aGlzLnN0YXRlXyA9IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uQkxPQ0tFRDtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG5cbiAgdmFyIHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgcHJvbWlzZS51bmJsb2NrQW5kRnVsZmlsbF8odmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmVqZWN0ID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBwcm9taXNlLnVuYmxvY2tBbmRSZWplY3RfKHJlYXNvbik7XG4gICAgfVxuICB9O1xuXG4gIHRyeSB7XG4gICAgdGhlbi5jYWxsKHRoZW5hYmxlLCByZXNvbHZlLCByZWplY3QpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVqZWN0KGUpO1xuICB9XG59O1xuXG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHBlbmRpbmcgY2FsbGJhY2tzIG9mIGEgcmVzb2x2ZWQgUHJvbWlzZSBhZnRlciBhIHRpbWVvdXQuXG4gKlxuICogU2VjdGlvbiAyLjIuNCBvZiB0aGUgUHJvbWlzZXMvQSsgc3BlY2lmaWNhdGlvbiByZXF1aXJlcyB0aGF0IFByb21pc2VcbiAqIGNhbGxiYWNrcyBtdXN0IG9ubHkgYmUgaW52b2tlZCBmcm9tIGEgY2FsbCBzdGFjayB0aGF0IG9ubHkgY29udGFpbnMgUHJvbWlzZVxuICogaW1wbGVtZW50YXRpb24gY29kZSwgd2hpY2ggd2UgYWNjb21wbGlzaCBieSBpbnZva2luZyBjYWxsYmFjayBleGVjdXRpb24gYWZ0ZXJcbiAqIGEgdGltZW91dC4gSWYge0Bjb2RlIHN0YXJ0RXhlY3V0aW9uX30gaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGZvciB0aGUgc2FtZVxuICogUHJvbWlzZSwgdGhlIGNhbGxiYWNrIGNoYWluIHdpbGwgYmUgZXZhbHVhdGVkIG9ubHkgb25jZS4gQWRkaXRpb25hbCBjYWxsYmFja3NcbiAqIG1heSBiZSBhZGRlZCBkdXJpbmcgdGhlIGV2YWx1YXRpb24gcGhhc2UsIGFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lXG4gKiBldmVudCBsb29wLlxuICpcbiAqIEFsbCBQcm9taXNlcyBhZGRlZCB0byB0aGUgd2FpdGluZyBsaXN0IGR1cmluZyB0aGUgc2FtZSBicm93c2VyIGV2ZW50IGxvb3BcbiAqIHdpbGwgYmUgZXhlY3V0ZWQgaW4gb25lIGJhdGNoIHRvIGF2b2lkIHVzaW5nIGEgc2VwYXJhdGUgdGltZW91dCBwZXIgUHJvbWlzZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnNjaGVkdWxlQ2FsbGJhY2tzXyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuZXhlY3V0aW5nXykge1xuICAgIHRoaXMuZXhlY3V0aW5nXyA9IHRydWU7XG4gICAgYXN5bmMucnVuKHRoaXMuZXhlY3V0ZUNhbGxiYWNrc18sIHRoaXMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogRXhlY3V0ZXMgYWxsIHBlbmRpbmcgY2FsbGJhY2tzIGZvciB0aGlzIFByb21pc2UuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5leGVjdXRlQ2FsbGJhY2tzXyA9IGZ1bmN0aW9uKCkge1xuICB3aGlsZSAodGhpcy5jYWxsYmFja0VudHJpZXNfICYmIHRoaXMuY2FsbGJhY2tFbnRyaWVzXy5sZW5ndGgpIHtcbiAgICB2YXIgZW50cmllcyA9IHRoaXMuY2FsbGJhY2tFbnRyaWVzXztcbiAgICB0aGlzLmNhbGxiYWNrRW50cmllc18gPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5leGVjdXRlQ2FsbGJhY2tfKGVudHJpZXNbaV0sIHRoaXMuc3RhdGVfLCB0aGlzLnJlc3VsdF8pO1xuICAgIH1cbiAgfVxuICB0aGlzLmV4ZWN1dGluZ18gPSBmYWxzZTtcbn07XG5cblxuLyoqXG4gKiBFeGVjdXRlcyBhIHBlbmRpbmcgY2FsbGJhY2sgZm9yIHRoaXMgUHJvbWlzZS4gSW52b2tlcyBhbiB7QGNvZGUgb25GdWxmaWxsZWR9XG4gKiBvciB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2sgYmFzZWQgb24gdGhlIHJlc29sdmVkIHN0YXRlIG9mIHRoZSBQcm9taXNlLlxuICpcbiAqIEBwYXJhbSB7IUNhbmNlbGxhYmxlUHJvbWlzZS5DYWxsYmFja0VudHJ5X30gY2FsbGJhY2tFbnRyeSBBbiBlbnRyeSBjb250YWluaW5nIHRoZVxuICogICAgIG9uRnVsZmlsbGVkIGFuZC9vciBvblJlamVjdGVkIGNhbGxiYWNrcyBmb3IgdGhpcyBzdGVwLlxuICogQHBhcmFtIHtDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVffSBzdGF0ZSBUaGUgcmVzb2x1dGlvbiBzdGF0dXMgb2YgdGhlIFByb21pc2UsXG4gKiAgICAgZWl0aGVyIEZVTEZJTExFRCBvciBSRUpFQ1RFRC5cbiAqIEBwYXJhbSB7Kn0gcmVzdWx0IFRoZSByZXNvbHZlZCByZXN1bHQgb2YgdGhlIFByb21pc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmV4ZWN1dGVDYWxsYmFja18gPSBmdW5jdGlvbihcbmNhbGxiYWNrRW50cnksIHN0YXRlLCByZXN1bHQpIHtcbiAgaWYgKHN0YXRlID09PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLkZVTEZJTExFRCkge1xuICAgIGNhbGxiYWNrRW50cnkub25GdWxmaWxsZWQocmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlbW92ZVVuaGFuZGxlZFJlamVjdGlvbl8oKTtcbiAgICBjYWxsYmFja0VudHJ5Lm9uUmVqZWN0ZWQocmVzdWx0KTtcbiAgfVxufTtcblxuXG4vKipcbiAqIE1hcmtzIHRoaXMgcmVqZWN0ZWQgUHJvbWlzZSBhcyBoYXZpbmcgYmVpbmcgaGFuZGxlZC4gQWxzbyBtYXJrcyBhbnkgcGFyZW50XG4gKiBQcm9taXNlcyBpbiB0aGUgcmVqZWN0ZWQgc3RhdGUgYXMgaGFuZGxlZC4gVGhlIHJlamVjdGlvbiBoYW5kbGVyIHdpbGwgbm9cbiAqIGxvbmdlciBiZSBpbnZva2VkIGZvciB0aGlzIFByb21pc2UgKGlmIGl0IGhhcyBub3QgYmVlbiBjYWxsZWQgYWxyZWFkeSkuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5yZW1vdmVVbmhhbmRsZWRSZWplY3Rpb25fID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwO1xuICBpZiAoQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkgPiAwKSB7XG4gICAgZm9yIChwID0gdGhpczsgcCAmJiBwLnVuaGFuZGxlZFJlamVjdGlvbklkXzsgcCA9IHAucGFyZW50Xykge1xuICAgICAgY2xlYXJUaW1lb3V0KHAudW5oYW5kbGVkUmVqZWN0aW9uSWRfKTtcbiAgICAgIHAudW5oYW5kbGVkUmVqZWN0aW9uSWRfID0gMDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkgPT09IDApIHtcbiAgICBmb3IgKHAgPSB0aGlzOyBwICYmIHAuaGFkVW5oYW5kbGVkUmVqZWN0aW9uXzsgcCA9IHAucGFyZW50Xykge1xuICAgICAgcC5oYWRVbmhhbmRsZWRSZWplY3Rpb25fID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogTWFya3MgdGhpcyByZWplY3RlZCBQcm9taXNlIGFzIHVuaGFuZGxlZC4gSWYgbm8ge0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrXG4gKiBpcyBjYWxsZWQgZm9yIHRoaXMgUHJvbWlzZSBiZWZvcmUgdGhlIHtAY29kZSBVTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZfVxuICogZXhwaXJlcywgdGhlIHJlYXNvbiB3aWxsIGJlIHBhc3NlZCB0byB0aGUgdW5oYW5kbGVkIHJlamVjdGlvbiBoYW5kbGVyLiBUaGVcbiAqIGhhbmRsZXIgdHlwaWNhbGx5IHJldGhyb3dzIHRoZSByZWplY3Rpb24gcmVhc29uIHNvIHRoYXQgaXQgYmVjb21lcyB2aXNpYmxlIGluXG4gKiB0aGUgZGV2ZWxvcGVyIGNvbnNvbGUuXG4gKlxuICogQHBhcmFtIHshQ2FuY2VsbGFibGVQcm9taXNlfSBwcm9taXNlIFRoZSByZWplY3RlZCBQcm9taXNlLlxuICogQHBhcmFtIHsqfSByZWFzb24gVGhlIFByb21pc2UgcmVqZWN0aW9uIHJlYXNvbi5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5hZGRVbmhhbmRsZWRSZWplY3Rpb25fID0gZnVuY3Rpb24ocHJvbWlzZSwgcmVhc29uKSB7XG4gIGlmIChDYW5jZWxsYWJsZVByb21pc2UuVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWSA+IDApIHtcbiAgICBwcm9taXNlLnVuaGFuZGxlZFJlamVjdGlvbklkXyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBDYW5jZWxsYWJsZVByb21pc2UuaGFuZGxlUmVqZWN0aW9uXy5jYWxsKG51bGwsIHJlYXNvbik7XG4gICAgfSwgQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkpO1xuXG4gIH0gZWxzZSBpZiAoQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkgPT09IDApIHtcbiAgICBwcm9taXNlLmhhZFVuaGFuZGxlZFJlamVjdGlvbl8gPSB0cnVlO1xuICAgIGFzeW5jLnJ1bihmdW5jdGlvbigpIHtcbiAgICAgIGlmIChwcm9taXNlLmhhZFVuaGFuZGxlZFJlamVjdGlvbl8pIHtcbiAgICAgICAgQ2FuY2VsbGFibGVQcm9taXNlLmhhbmRsZVJlamVjdGlvbl8uY2FsbChudWxsLCByZWFzb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5cbi8qKlxuICogQSBtZXRob2QgdGhhdCBpcyBpbnZva2VkIHdpdGggdGhlIHJlamVjdGlvbiByZWFzb25zIGZvciBQcm9taXNlcyB0aGF0IGFyZVxuICogcmVqZWN0ZWQgYnV0IGhhdmUgbm8ge0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrcyByZWdpc3RlcmVkIHlldC5cbiAqIEB0eXBlIHtmdW5jdGlvbigqKX1cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5oYW5kbGVSZWplY3Rpb25fID0gYXN5bmMudGhyb3dFeGNlcHRpb247XG5cblxuLyoqXG4gKiBTZXRzIGEgaGFuZGxlciB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggcmVhc29ucyBmcm9tIHVuaGFuZGxlZCByZWplY3RlZFxuICogUHJvbWlzZXMuIElmIHRoZSByZWplY3RlZCBQcm9taXNlIChvciBvbmUgb2YgaXRzIGRlc2NlbmRhbnRzKSBoYXMgYW5cbiAqIHtAY29kZSBvblJlamVjdGVkfSBjYWxsYmFjayByZWdpc3RlcmVkLCB0aGUgcmVqZWN0aW9uIHdpbGwgYmUgY29uc2lkZXJlZFxuICogaGFuZGxlZCwgYW5kIHRoZSByZWplY3Rpb24gaGFuZGxlciB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gKlxuICogQnkgZGVmYXVsdCwgdW5oYW5kbGVkIHJlamVjdGlvbnMgYXJlIHJldGhyb3duIHNvIHRoYXQgdGhlIGVycm9yIG1heSBiZVxuICogY2FwdHVyZWQgYnkgdGhlIGRldmVsb3BlciBjb25zb2xlIG9yIGEge0Bjb2RlIHdpbmRvdy5vbmVycm9yfSBoYW5kbGVyLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKil9IGhhbmRsZXIgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggcmVhc29ucyBmcm9tXG4gKiAgICAgcmVqZWN0ZWQgUHJvbWlzZXMuIERlZmF1bHRzIHRvIHtAY29kZSBhc3luYy50aHJvd0V4Y2VwdGlvbn0uXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5zZXRVbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVyID0gZnVuY3Rpb24oaGFuZGxlcikge1xuICBDYW5jZWxsYWJsZVByb21pc2UuaGFuZGxlUmVqZWN0aW9uXyA9IGhhbmRsZXI7XG59O1xuXG5cblxuLyoqXG4gKiBFcnJvciB1c2VkIGFzIGEgcmVqZWN0aW9uIHJlYXNvbiBmb3IgY2FuY2VsZWQgUHJvbWlzZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWVzc2FnZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7RXJyb3J9XG4gKiBAZmluYWxcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG9wdF9tZXNzYWdlKSB7XG4gICAgIHN1cGVyKG9wdF9tZXNzYWdlKTtcblxuICAgICBpZiAob3B0X21lc3NhZ2UpIHtcbiAgICAgICB0aGlzLm1lc3NhZ2UgPSBvcHRfbWVzc2FnZTtcbiAgICAgfVxuICAgfVxufTtcblxuLyoqIEBvdmVycmlkZSAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yLnByb3RvdHlwZS5uYW1lID0gJ2NhbmNlbCc7XG5cbmV4cG9ydCB7Q2FuY2VsbGFibGVQcm9taXNlfTtcbmV4cG9ydCBkZWZhdWx0IENhbmNlbGxhYmxlUHJvbWlzZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSwgb2JqZWN0IH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IENhbmNlbGxhYmxlUHJvbWlzZSBmcm9tICdtZXRhbC1wcm9taXNlJztcbmltcG9ydCB7IENvbXBvbmVudCwgQ29tcG9uZW50UmVnaXN0cnkgfSBmcm9tICdtZXRhbC1jb21wb25lbnQnO1xuaW1wb3J0IEFwcCBmcm9tICdzZW5uYSc7XG5pbXBvcnQgUm91dGUgZnJvbSAnc2VubmEvc3JjL3JvdXRlL1JvdXRlJztcbmltcG9ydCBSZXF1ZXN0U2NyZWVuIGZyb20gJ3Nlbm5hL3NyYy9zY3JlZW4vUmVxdWVzdFNjcmVlbic7XG5pbXBvcnQgU295IGZyb20gJ21ldGFsLXNveSc7XG5cbmltcG9ydCB0ZW1wbGF0ZXMgZnJvbSAnLi9Sb3V0ZXIuc295JztcblxuLyoqXG4gKiBSb3V0ZXIgY2xhc3MgcmVzcG9uc2libGUgZm9yIHJvdXRpbmcgbGlua3MgdG8gY29tcG9uZW50cy5cbiAqL1xuY2xhc3MgUm91dGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgYFJvdXRlcmAgaW5zdGFuY2Ugd2l0aG91dCByZW5kZXJpbmcgaXRzIHBsYWNlaG9sZGVyIGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG5cdCAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjb21wb25lbnRcblx0ICogQHBhcmFtIHtPYmplY3R8ZnVuY3Rpb24oKX0gaW5pdGlhbFN0YXRlXG5cdCAqIEByZXR1cm4geyFSb3V0ZXJ9XG5cdCAqL1xuXHRzdGF0aWMgcm91dGUocGF0aCwgY29tcG9uZW50LCBpbml0aWFsU3RhdGUsIGluY2x1ZGVDdXJyZW50VXJsKSB7XG5cdFx0cmV0dXJuIG5ldyBSb3V0ZXIoe1xuXHRcdFx0cGF0aCxcblx0XHRcdGNvbXBvbmVudCxcblx0XHRcdGluaXRpYWxTdGF0ZSxcblx0XHRcdGluY2x1ZGVDdXJyZW50VXJsXG5cdFx0fSwgZmFsc2UpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNpbmdsZXRvbiB0byBpbml0aWFsaXplcyBhbmQgcmV0cmlldmUgU2VubmEuanMgYXBwbGljYXRpb24uXG5cdCAqIEByZXR1cm4ge0FwcH1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIHJvdXRlcigpIHtcblx0XHRpZiAoIVJvdXRlci5yb3V0ZXJJbnN0YW5jZSkge1xuXHRcdFx0Um91dGVyLnJvdXRlckluc3RhbmNlID0gbmV3IEFwcCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gUm91dGVyLnJvdXRlckluc3RhbmNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBpbnN0YW5jZSBvZiByb3V0ZXIgaXMgYmVpbmcgcm91dGVkIHRvIHRoZSBzYW1lIGFjdGl2ZVxuXHQgKiBjb21wb25lbnQuXG5cdCAqIEBwYXJhbSB7Um91dGVyfSByb3V0ZXJcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdHN0YXRpYyBpc1JvdXRpbmdUb1NhbWVBY3RpdmVDb21wb25lbnQocm91dGVyKSB7XG5cdFx0cmV0dXJuIFJvdXRlci5hY3RpdmVDb21wb25lbnQgaW5zdGFuY2VvZiByb3V0ZXIucmVzb2x2ZUNvbXBvbmVudENvbnN0cnVjdG9yKCk7XG5cdH1cblxuXHQvKipcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG5cdGNyZWF0ZWQoKSB7XG5cdFx0dGhpcy5yb3V0ZSA9IG5ldyBSb3V0ZSh0aGlzLnBhdGgsICgpID0+IG5ldyBSb3V0ZXIuZGVmYXVsdFNjcmVlbih0aGlzKSk7XG5cdFx0dGhpcy5yb3V0ZS5yb3V0ZXIgPSB0aGlzO1xuXHRcdFJvdXRlci5yb3V0ZXIoKS5hZGRSb3V0ZXModGhpcy5yb3V0ZSk7XG5cdH1cblxuXHQvKipcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG5cdGRpc3Bvc2VJbnRlcm5hbCgpIHtcblx0XHRSb3V0ZXIucm91dGVyKCkucmVtb3ZlUm91dGUodGhpcy5yb3V0ZSk7XG5cdFx0c3VwZXIuZGlzcG9zZUludGVybmFsKCk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBjb21wb25lbnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2NvbmZpZ1xuXHQgKiBAcGFyYW0ge0VsZW1lbnQ9fSBvcHRfY29udGFpbmVyXG5cdCAqIEByZXR1cm4ge0NvbXBvbmVudH1cblx0ICovXG5cdGNyZWF0ZUNvbXBvbmVudChvcHRfY29uZmlnLCBvcHRfY29udGFpbmVyKSB7XG5cdFx0cmV0dXJuIG5ldyAodGhpcy5yZXNvbHZlQ29tcG9uZW50Q29uc3RydWN0b3IoKSkob3B0X2NvbmZpZywgb3B0X2NvbnRhaW5lcik7XG5cdH1cblxuXHQvKipcblx0ICogUmVzb2x2ZXMgY29tcG9uZW50IGNvbnN0cnVjdG9yIGZyb20gY2xhc3MgbmFtZSBvciByZWZlcmVuY2UuXG5cdCAqIEByZXR1cm4ge0NvbXBvbmVudH1cblx0ICovXG5cdHJlc29sdmVDb21wb25lbnRDb25zdHJ1Y3RvcigpIHtcblx0XHR2YXIgY29tcG9uZW50Q29uc3RydWN0b3IgPSB0aGlzLmNvbXBvbmVudDtcblx0XHRpZiAoY29yZS5pc1N0cmluZyhjb21wb25lbnRDb25zdHJ1Y3RvcikpIHtcblx0XHRcdGNvbXBvbmVudENvbnN0cnVjdG9yID0gQ29tcG9uZW50UmVnaXN0cnkuZ2V0Q29uc3RydWN0b3IoY29tcG9uZW50Q29uc3RydWN0b3IpO1xuXHRcdH1cblx0XHRyZXR1cm4gY29tcG9uZW50Q29uc3RydWN0b3I7XG5cdH1cblxufVxuU295LnJlZ2lzdGVyKFJvdXRlciwgdGVtcGxhdGVzKTtcblxuXG4vKipcbiAqIFJvdXRlciBzdGF0ZSBkZWZpbml0aW9uLlxuICogQHR5cGUgeyFPYmplY3R9XG4gKiBAc3RhdGljXG4gKi9cblJvdXRlci5TVEFURSA9IHtcblx0LyoqXG5cdCAqIElmIHNldCB0byB0cnVlIG5hdmlnYXRpb24gd2lsbCBjYWNoZSBjb21wb25lbnQgc3RhdGUgZGVmZXJyZWQgcmVzdWx0cy5cblx0ICogQHR5cGUge2Jvb2xlYW59XG5cdCAqIEBkZWZhdWx0IHRydWVcblx0ICovXG5cdGNhY2hlYWJsZToge1xuXHRcdHZhbGlkYXRvcjogY29yZS5pc0Jvb2xlYW4sXG5cdFx0dmFsdWU6IHRydWVcblx0fSxcblxuXHQvKipcblx0ICogTWV0YWwgY29tcG9uZW50IHRvIHJlbmRlciB3aGVuIHBhdGggaXMgYWNjZXNzZWQuXG5cdCAqIEB0eXBlIHtDb21wb25lbnR9XG5cdCAqL1xuXHRjb21wb25lbnQ6IHtcblx0fSxcblxuXHQvKipcblx0ICogRGVmaW5lcyB0aGUgbm9kZSB0aGF0IHRoZSBjb21wb25lbnQgd2lsbCBiZSByZW5kZXJlZCBhdC5cblx0ICogQHR5cGUgeyFzdHJpbmd8RWxlbWVudH1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Y29udGFpbmVyOiB7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEZsYWcgaW5kaWNhdGluZyBpZiB0aGUgY3VycmVudCB1cmwgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSBjb21wb25lbnQnc1xuXHQgKiBzdGF0ZS5cblx0ICovXG5cdGluY2x1ZGVDdXJyZW50VXJsOiB7XG5cdFx0dmFsdWU6IGZhbHNlXG5cdH0sXG5cblx0LyoqXG5cdCAqIEhvbGRzIHRoZSBsb2FkIGluaXRpYWwgc3RhdGUgdmFsdWUsIGZ1bmN0aW9uIG9yIGRlZmVycmVkIGZ1bmN0aW9uIHRoYXRcblx0ICogcmVzb2x2ZXMgdGhlIGNvbXBvbmVudCBjb25maWd1cmF0aW9ucy5cblx0ICogQHR5cGUgez9PYmplY3R8ZnVuY3Rpb24oP3N0cmluZz0pPX1cblx0ICovXG5cdGluaXRpYWxTdGF0ZToge1xuXHRcdHNldHRlcjogKHZhbCkgPT4gdmFsID8gKGNvcmUuaXNGdW5jdGlvbih2YWwpID8gdmFsIDogKCkgPT4gdmFsKSA6IG51bGxcblx0fSxcblxuXHQvKipcblx0ICogRGVmaW5lcyB0aGUgcGF0aCB3aGljaCB3aWxsIHRyaWdnZXIgdGhlIHJvdXRlIGhhbmRsZXIgcmVzcG9uc2libGUgZm9yXG5cdCAqIHJlbmRlcmluZyB0aGUgbWV0YWwgY29tcG9uZW50LlxuXHQgKiBAdHlwZSB7IXN0cmluZ3xSZWdFeHB8RnVuY3Rpb259XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHBhdGg6IHtcblx0fSxcblxuXHQvKipcblx0ICogSWYgc2V0IHRvIHRydWUgYWN0aXZlIGNvbXBvbmVudCB3aWxsIGJlIHVzZWQgd2hlbiByb3V0aW5nIHRvIHNhbWVcblx0ICogY29tcG9uZW50IHR5cGUuXG5cdCAqIEB0eXBlIHtib29sZWFufVxuXHQgKiBAZGVmYXVsdCB0cnVlXG5cdCAqL1xuXHRyZXVzZUFjdGl2ZUNvbXBvbmVudDoge1xuXHRcdHZhbGlkYXRvcjogY29yZS5pc0Jvb2xlYW4sXG5cdFx0dmFsdWU6IHRydWVcblx0fVxufTtcblxuLyoqXG4gKiBIb2xkcyB0aGUgYWN0aXZlIGNvbXBvbmVudC5cbiAqIEB0eXBlIHtDb21wb25lbnR9XG4gKiBAc3RhdGljXG4gKi9cblJvdXRlci5hY3RpdmVDb21wb25lbnQgPSBudWxsO1xuXG4vKipcbiAqIEhvbGRzIHRoZSBhY3RpdmUgcmVuZGVyIHN0YXRlLlxuICogQHR5cGUgeyp9XG4gKiBAc3RhdGljXG4gKi9cblJvdXRlci5hY3RpdmVTdGF0ZSA9IG51bGw7XG5cbmNsYXNzIENvbXBvbmVudFNjcmVlbiBleHRlbmRzIFJlcXVlc3RTY3JlZW4ge1xuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0Y29uc3RydWN0b3Iocm91dGVyKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdGlmICghcm91dGVyKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1JvdXRlciBub3Qgc3BlY2lmaWVkIGZvciBjb21wb25lbnQgc2NyZWVuLicpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJvdXRlciByZXNwb25zaWJsZSBmb3IgdGhlIHNjcmVlbi5cblx0XHQgKiBAdHlwZSB7Um91dGVyfVxuXHRcdCAqL1xuXHRcdHRoaXMucm91dGVyID0gcm91dGVyO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRldmFsdWF0ZVNjcmlwdHMoKSB7fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0ZXZhbHVhdGVTdHlsZXMoKSB7fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0ZmxpcCgpIHtcblx0XHR2YXIgcm91dGVyID0gdGhpcy5yb3V0ZXI7XG5cdFx0dmFyIHJlZGlyZWN0Um91dGVyID0gdGhpcy5tYXliZUZpbmRSZWRpcmVjdFJvdXRlcigpO1xuXHRcdGlmIChyZWRpcmVjdFJvdXRlcikge1xuXHRcdFx0cm91dGVyID0gcmVkaXJlY3RSb3V0ZXI7XG5cdFx0fVxuXG5cdFx0Um91dGVyLmFjdGl2ZVN0YXRlID0gdGhpcy5tYXliZVBhcnNlTGFzdExvYWRlZFN0YXRlQXNKc29uKCk7XG5cdFx0aWYgKHJvdXRlci5pbmNsdWRlQ3VycmVudFVybCkge1xuXHRcdFx0Um91dGVyLmFjdGl2ZVN0YXRlID0gb2JqZWN0Lm1peGluKHt9LCBSb3V0ZXIuYWN0aXZlU3RhdGUsIHtcblx0XHRcdFx0Y3VycmVudFVybDogcm91dGVyLnBhdGhcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnJvdXRlci5yZXVzZUFjdGl2ZUNvbXBvbmVudCAmJiBSb3V0ZXIuaXNSb3V0aW5nVG9TYW1lQWN0aXZlQ29tcG9uZW50KHJvdXRlcikpIHtcblx0XHRcdFJvdXRlci5hY3RpdmVDb21wb25lbnQuc2V0U3RhdGUoUm91dGVyLmFjdGl2ZVN0YXRlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKFJvdXRlci5hY3RpdmVDb21wb25lbnQpIHtcblx0XHRcdFx0Um91dGVyLmFjdGl2ZUNvbXBvbmVudC5kaXNwb3NlKCk7XG5cdFx0XHR9XG5cdFx0XHRSb3V0ZXIuYWN0aXZlQ29tcG9uZW50ID0gcm91dGVyLmNyZWF0ZUNvbXBvbmVudChSb3V0ZXIuYWN0aXZlU3RhdGUsIHJvdXRlci5jb250YWluZXIpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0bG9hZChwYXRoKSB7XG5cdFx0dGhpcy5zZXRDYWNoZWFibGUodGhpcy5yb3V0ZXIuY2FjaGVhYmxlKTtcblx0XHR2YXIgZGVmZXJyZWQgPSBDYW5jZWxsYWJsZVByb21pc2UucmVzb2x2ZSgpO1xuXHRcdGlmIChjb3JlLmlzTnVsbCh0aGlzLnJvdXRlci5pbml0aWFsU3RhdGUpKSB7XG5cdFx0XHRkZWZlcnJlZCA9IGRlZmVycmVkLnRoZW4oKCkgPT4gc3VwZXIubG9hZChwYXRoKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlZmVycmVkID0gZGVmZXJyZWQudGhlbigoKSA9PiB0aGlzLnJvdXRlci5pbml0aWFsU3RhdGUocGF0aCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gZGVmZXJyZWQudGhlbigobG9hZGVkU3RhdGUpID0+IHtcblx0XHRcdHRoaXMucm91dGVyLmxhc3RQYXRoID0gcGF0aDtcblx0XHRcdHRoaXMucm91dGVyLmxhc3RMb2FkZWRTdGF0ZSA9IGxvYWRlZFN0YXRlO1xuXHRcdFx0cmV0dXJuIGxvYWRlZFN0YXRlO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNvbWUgcmVzcG9uc2VzIG1hZGUgYnkgc3VwZXJjbGFzcyBwZXJmb3JtcyBhIDMwMiByZWRpcmVjdCB3aGljaCB3aWxsIGJlXG5cdCAqIHJlZmxlY3RlZCBpbnRvIHRoZSBicm93c2VyIGhpc3RvcnkgcGF0aC4gV2hlbiByZWRpcmVjdGVkLCBtYWtlIHN1cmUgdG9cblx0ICogcmVuZGVyIHRoZSBiZXN0IGNvbXBvbmVudCBtYXRjaCB0byBuZXcgcGF0aC4gSWYgbm90IGZvdW5kIGFueSwgaXQgd2lsbFxuXHQgKiB1c2UgY3VycmVudCByb3V0ZXIgY29tcG9uZW50LlxuXHQgKiBAcmV0dXJuIHtSb3V0ZXJ9XG5cdCAqL1xuXHRtYXliZUZpbmRSZWRpcmVjdFJvdXRlcigpIHtcblx0XHR2YXIgcmVkaXJlY3RQYXRoID0gdGhpcy5iZWZvcmVVcGRhdGVIaXN0b3J5UGF0aCh0aGlzLnJvdXRlci5sYXN0UGF0aCk7XG5cdFx0aWYgKHJlZGlyZWN0UGF0aCAhPT0gdGhpcy5yb3V0ZXIubGFzdFBhdGgpIHtcblx0XHRcdHZhciByZWRpcmVjdFJvdXRlID0gUm91dGVyLnJvdXRlcigpLmZpbmRSb3V0ZShyZWRpcmVjdFBhdGgpO1xuXHRcdFx0aWYgKHJlZGlyZWN0Um91dGUpIHtcblx0XHRcdFx0cmV0dXJuIHJlZGlyZWN0Um91dGUucm91dGVyO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBNYXliZSBwYXJzZXMgbGFzdCBzdGF0ZSBhcyBKc29uLCBpZiBub3QgYWJsZSB0byBwYXJzZSBhbiBvYmplY3QgaXNcblx0ICogcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4ge29iamVjdH1cblx0ICovXG5cdG1heWJlUGFyc2VMYXN0TG9hZGVkU3RhdGVBc0pzb24oKSB7XG5cdFx0dmFyIHN0YXRlID0gdGhpcy5yb3V0ZXIubGFzdExvYWRlZFN0YXRlO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gSlNPTi5wYXJzZShzdGF0ZSk7XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRyZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwoc3RhdGUpID8gc3RhdGUgOiB7fTtcblx0XHR9XG5cdH1cblxufVxuXG4vKipcbiAqIERlZmF1bHQgc2NyZWVuIHVzZWQgZm9yIGhhbmRsaW5nIGNvbXBvbmVudHMuXG4gKiBAdHlwZSB7Q29tcG9uZW50U2NyZWVufVxuICovXG5Sb3V0ZXIuZGVmYXVsdFNjcmVlbiA9IENvbXBvbmVudFNjcmVlbjtcblxuZXhwb3J0IGRlZmF1bHQgUm91dGVyO1xuIiwiLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICdtZXRhbC1jb21wb25lbnQvc3JjL0NvbXBvbmVudCc7XG5pbXBvcnQgU295IGZyb20gJ21ldGFsLXNveS9zcmMvU295JztcbnZhciB0ZW1wbGF0ZXM7XG5nb29nLmxvYWRNb2R1bGUoZnVuY3Rpb24oZXhwb3J0cykge1xuXG4vLyBUaGlzIGZpbGUgd2FzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGZyb20gUm91dGVyLnNveS5cbi8vIFBsZWFzZSBkb24ndCBlZGl0IHRoaXMgZmlsZSBieSBoYW5kLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGVtcGxhdGVzIGluIG5hbWVzcGFjZSBSb3V0ZXIuXG4gKiBAcHVibGljXG4gKi9cblxuZ29vZy5tb2R1bGUoJ1JvdXRlci5pbmNyZW1lbnRhbGRvbScpO1xuXG4vKiogQHN1cHByZXNzIHtleHRyYVJlcXVpcmV9ICovXG52YXIgc295ID0gZ29vZy5yZXF1aXJlKCdzb3knKTtcbi8qKiBAc3VwcHJlc3Mge2V4dHJhUmVxdWlyZX0gKi9cbnZhciBzb3lkYXRhID0gZ29vZy5yZXF1aXJlKCdzb3lkYXRhJyk7XG4vKiogQHN1cHByZXNzIHtleHRyYVJlcXVpcmV9ICovXG5nb29nLnJlcXVpcmUoJ2dvb2cuaTE4bi5iaWRpJyk7XG4vKiogQHN1cHByZXNzIHtleHRyYVJlcXVpcmV9ICovXG5nb29nLnJlcXVpcmUoJ2dvb2cuYXNzZXJ0cycpO1xudmFyIEluY3JlbWVudGFsRG9tID0gZ29vZy5yZXF1aXJlKCdpbmNyZW1lbnRhbGRvbScpO1xudmFyIGllX29wZW4gPSBJbmNyZW1lbnRhbERvbS5lbGVtZW50T3BlbjtcbnZhciBpZV9jbG9zZSA9IEluY3JlbWVudGFsRG9tLmVsZW1lbnRDbG9zZTtcbnZhciBpZV92b2lkID0gSW5jcmVtZW50YWxEb20uZWxlbWVudFZvaWQ7XG52YXIgaWVfb3Blbl9zdGFydCA9IEluY3JlbWVudGFsRG9tLmVsZW1lbnRPcGVuU3RhcnQ7XG52YXIgaWVfb3Blbl9lbmQgPSBJbmNyZW1lbnRhbERvbS5lbGVtZW50T3BlbkVuZDtcbnZhciBpdGV4dCA9IEluY3JlbWVudGFsRG9tLnRleHQ7XG52YXIgaWF0dHIgPSBJbmNyZW1lbnRhbERvbS5hdHRyO1xuXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCAqPj19IG9wdF9kYXRhXG4gKiBAcGFyYW0geyhudWxsfHVuZGVmaW5lZCk9fSBvcHRfaWdub3JlZFxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCAqPj19IG9wdF9pakRhdGFcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9XG4gKi9cbmZ1bmN0aW9uICRyZW5kZXIob3B0X2RhdGEsIG9wdF9pZ25vcmVkLCBvcHRfaWpEYXRhKSB7XG4gIG9wdF9kYXRhID0gb3B0X2RhdGEgfHwge307XG4gIGllX3ZvaWQoJ2xpbmsnLCBudWxsLCBudWxsLFxuICAgICAgJ2lkJywgb3B0X2RhdGEuaWQsXG4gICAgICAncmVsJywgJ21ldGFsLXJvdXRlJyk7XG59XG5leHBvcnRzLnJlbmRlciA9ICRyZW5kZXI7XG5pZiAoZ29vZy5ERUJVRykge1xuICAkcmVuZGVyLnNveVRlbXBsYXRlTmFtZSA9ICdSb3V0ZXIucmVuZGVyJztcbn1cblxuZXhwb3J0cy5yZW5kZXIucGFyYW1zID0gW1wiaWRcIl07XG5leHBvcnRzLnJlbmRlci50eXBlcyA9IHtcImlkXCI6XCJhbnlcIn07XG50ZW1wbGF0ZXMgPSBleHBvcnRzO1xucmV0dXJuIGV4cG9ydHM7XG5cbn0pO1xuXG5jbGFzcyBSb3V0ZXIgZXh0ZW5kcyBDb21wb25lbnQge31cblNveS5yZWdpc3RlcihSb3V0ZXIsIHRlbXBsYXRlcyk7XG5leHBvcnQgZGVmYXVsdCB0ZW1wbGF0ZXM7XG5leHBvcnQgeyBSb3V0ZXIsIHRlbXBsYXRlcyB9O1xuLyoganNoaW50IGlnbm9yZTplbmQgKi9cbiIsImltcG9ydCAnbWV0YWwtaW5jcmVtZW50YWwtZG9tJztcblxuKGZ1bmN0aW9uKCkge1xudGhpcy5DTE9TVVJFX05PX0RFUFMgPSB0cnVlO1xudGhpcy5nb29nID0gdGhpcy5nb29nIHx8IHt9O1xuXG4vLyBDb3B5cmlnaHQgMjAwNiBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEJvb3RzdHJhcCBmb3IgdGhlIEdvb2dsZSBKUyBMaWJyYXJ5IChDbG9zdXJlKS5cbiAqXG4gKiBJbiB1bmNvbXBpbGVkIG1vZGUgYmFzZS5qcyB3aWxsIHdyaXRlIG91dCBDbG9zdXJlJ3MgZGVwcyBmaWxlLCB1bmxlc3MgdGhlXG4gKiBnbG9iYWwgPGNvZGU+Q0xPU1VSRV9OT19ERVBTPC9jb2RlPiBpcyBzZXQgdG8gdHJ1ZS4gIFRoaXMgYWxsb3dzIHByb2plY3RzIHRvXG4gKiBpbmNsdWRlIHRoZWlyIG93biBkZXBzIGZpbGUocykgZnJvbSBkaWZmZXJlbnQgbG9jYXRpb25zLlxuICpcbiAqIEBhdXRob3IgYXJ2QGdvb2dsZS5jb20gKEVyaWsgQXJ2aWRzc29uKVxuICpcbiAqIEBwcm92aWRlR29vZ1xuICovXG5cblxuLyoqXG4gKiBAZGVmaW5lIHtib29sZWFufSBPdmVycmlkZGVuIHRvIHRydWUgYnkgdGhlIGNvbXBpbGVyIHdoZW5cbiAqICAgICAtLXByb2Nlc3NfY2xvc3VyZV9wcmltaXRpdmVzIGlzIHNwZWNpZmllZC5cbiAqL1xudmFyIENPTVBJTEVEID0gZmFsc2U7XG5cblxuLyoqXG4gKiBCYXNlIG5hbWVzcGFjZSBmb3IgdGhlIENsb3N1cmUgbGlicmFyeS4gIENoZWNrcyB0byBzZWUgZ29vZyBpcyBhbHJlYWR5XG4gKiBkZWZpbmVkIGluIHRoZSBjdXJyZW50IHNjb3BlIGJlZm9yZSBhc3NpZ25pbmcgdG8gcHJldmVudCBjbG9iYmVyaW5nIGlmXG4gKiBiYXNlLmpzIGlzIGxvYWRlZCBtb3JlIHRoYW4gb25jZS5cbiAqXG4gKiBAY29uc3RcbiAqL1xudmFyIGdvb2cgPSB0aGlzLmdvb2cgfHwge307XG5cblxuLyoqXG4gKiBSZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBjb250ZXh0LiAgSW4gbW9zdCBjYXNlcyB0aGlzIHdpbGwgYmUgJ3dpbmRvdycuXG4gKi9cbmdvb2cuZ2xvYmFsID0gdGhpcztcblxuXG4vKipcbiAqIEEgaG9vayBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmaW5lIHZhbHVlcyBpbiB1bmNvbXBpbGVkIG1vZGUuXG4gKlxuICogSW4gdW5jb21waWxlZCBtb2RlLCB7QGNvZGUgQ0xPU1VSRV9VTkNPTVBJTEVEX0RFRklORVN9IG1heSBiZSBkZWZpbmVkIGJlZm9yZVxuICogbG9hZGluZyBiYXNlLmpzLiAgSWYgYSBrZXkgaXMgZGVmaW5lZCBpbiB7QGNvZGUgQ0xPU1VSRV9VTkNPTVBJTEVEX0RFRklORVN9LFxuICoge0Bjb2RlIGdvb2cuZGVmaW5lfSB3aWxsIHVzZSB0aGUgdmFsdWUgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCB2YWx1ZS4gIFRoaXNcbiAqIGFsbG93cyBmbGFncyB0byBiZSBvdmVyd3JpdHRlbiB3aXRob3V0IGNvbXBpbGF0aW9uICh0aGlzIGlzIG5vcm1hbGx5XG4gKiBhY2NvbXBsaXNoZWQgd2l0aCB0aGUgY29tcGlsZXIncyBcImRlZmluZVwiIGZsYWcpLlxuICpcbiAqIEV4YW1wbGU6XG4gKiA8cHJlPlxuICogICB2YXIgQ0xPU1VSRV9VTkNPTVBJTEVEX0RFRklORVMgPSB7J2dvb2cuREVCVUcnOiBmYWxzZX07XG4gKiA8L3ByZT5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgKHN0cmluZ3xudW1iZXJ8Ym9vbGVhbik+fHVuZGVmaW5lZH1cbiAqL1xuZ29vZy5nbG9iYWwuQ0xPU1VSRV9VTkNPTVBJTEVEX0RFRklORVM7XG5cblxuLyoqXG4gKiBBIGhvb2sgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmluZSB2YWx1ZXMgaW4gdW5jb21waWxlZCBvciBjb21waWxlZCBtb2RlLFxuICogbGlrZSBDTE9TVVJFX1VOQ09NUElMRURfREVGSU5FUyBidXQgZWZmZWN0aXZlIGluIGNvbXBpbGVkIGNvZGUuICBJblxuICogdW5jb21waWxlZCBjb2RlIENMT1NVUkVfVU5DT01QSUxFRF9ERUZJTkVTIHRha2VzIHByZWNlZGVuY2UuXG4gKlxuICogQWxzbyB1bmxpa2UgQ0xPU1VSRV9VTkNPTVBJTEVEX0RFRklORVMgdGhlIHZhbHVlcyBtdXN0IGJlIG51bWJlciwgYm9vbGVhbiBvclxuICogc3RyaW5nIGxpdGVyYWxzIG9yIHRoZSBjb21waWxlciB3aWxsIGVtaXQgYW4gZXJyb3IuXG4gKlxuICogV2hpbGUgYW55IEBkZWZpbmUgdmFsdWUgbWF5IGJlIHNldCwgb25seSB0aG9zZSBzZXQgd2l0aCBnb29nLmRlZmluZSB3aWxsIGJlXG4gKiBlZmZlY3RpdmUgZm9yIHVuY29tcGlsZWQgY29kZS5cbiAqXG4gKiBFeGFtcGxlOlxuICogPHByZT5cbiAqICAgdmFyIENMT1NVUkVfREVGSU5FUyA9IHsnZ29vZy5ERUJVRyc6IGZhbHNlfSA7XG4gKiA8L3ByZT5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgKHN0cmluZ3xudW1iZXJ8Ym9vbGVhbik+fHVuZGVmaW5lZH1cbiAqL1xuZ29vZy5nbG9iYWwuQ0xPU1VSRV9ERUZJTkVTO1xuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgbm90IHVuZGVmaW5lZC5cbiAqIFdBUk5JTkc6IERvIG5vdCB1c2UgdGhpcyB0byB0ZXN0IGlmIGFuIG9iamVjdCBoYXMgYSBwcm9wZXJ0eS4gVXNlIHRoZSBpblxuICogb3BlcmF0b3IgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBkZWZpbmVkLlxuICovXG5nb29nLmlzRGVmID0gZnVuY3Rpb24odmFsKSB7XG4gIC8vIHZvaWQgMCBhbHdheXMgZXZhbHVhdGVzIHRvIHVuZGVmaW5lZCBhbmQgaGVuY2Ugd2UgZG8gbm90IG5lZWQgdG8gZGVwZW5kIG9uXG4gIC8vIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBnbG9iYWwgdmFyaWFibGUgbmFtZWQgJ3VuZGVmaW5lZCcuXG4gIHJldHVybiB2YWwgIT09IHZvaWQgMDtcbn07XG5cblxuLyoqXG4gKiBCdWlsZHMgYW4gb2JqZWN0IHN0cnVjdHVyZSBmb3IgdGhlIHByb3ZpZGVkIG5hbWVzcGFjZSBwYXRoLCBlbnN1cmluZyB0aGF0XG4gKiBuYW1lcyB0aGF0IGFscmVhZHkgZXhpc3QgYXJlIG5vdCBvdmVyd3JpdHRlbi4gRm9yIGV4YW1wbGU6XG4gKiBcImEuYi5jXCIgLT4gYSA9IHt9O2EuYj17fTthLmIuYz17fTtcbiAqIFVzZWQgYnkgZ29vZy5wcm92aWRlIGFuZCBnb29nLmV4cG9ydFN5bWJvbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIG9iamVjdCB0aGF0IHRoaXMgZmlsZSBkZWZpbmVzLlxuICogQHBhcmFtIHsqPX0gb3B0X29iamVjdCB0aGUgb2JqZWN0IHRvIGV4cG9zZSBhdCB0aGUgZW5kIG9mIHRoZSBwYXRoLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfb2JqZWN0VG9FeHBvcnRUbyBUaGUgb2JqZWN0IHRvIGFkZCB0aGUgcGF0aCB0bzsgZGVmYXVsdFxuICogICAgIGlzIHxnb29nLmdsb2JhbHwuXG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmV4cG9ydFBhdGhfID0gZnVuY3Rpb24obmFtZSwgb3B0X29iamVjdCwgb3B0X29iamVjdFRvRXhwb3J0VG8pIHtcbiAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuICB2YXIgY3VyID0gb3B0X29iamVjdFRvRXhwb3J0VG8gfHwgZ29vZy5nbG9iYWw7XG5cbiAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgZXhoaWJpdHMgc3RyYW5nZSBiZWhhdmlvciB3aGVuIHRocm93aW5nIGVycm9ycyBmcm9tXG4gIC8vIG1ldGhvZHMgZXh0ZXJuZWQgaW4gdGhpcyBtYW5uZXIuICBTZWUgdGhlIHRlc3RFeHBvcnRTeW1ib2xFeGNlcHRpb25zIGluXG4gIC8vIGJhc2VfdGVzdC5odG1sIGZvciBhbiBleGFtcGxlLlxuICBpZiAoIShwYXJ0c1swXSBpbiBjdXIpICYmIGN1ci5leGVjU2NyaXB0KSB7XG4gICAgY3VyLmV4ZWNTY3JpcHQoJ3ZhciAnICsgcGFydHNbMF0pO1xuICB9XG5cbiAgLy8gQ2VydGFpbiBicm93c2VycyBjYW5ub3QgcGFyc2UgY29kZSBpbiB0aGUgZm9ybSBmb3IoKGEgaW4gYik7IGM7KTtcbiAgLy8gVGhpcyBwYXR0ZXJuIGlzIHByb2R1Y2VkIGJ5IHRoZSBKU0NvbXBpbGVyIHdoZW4gaXQgY29sbGFwc2VzIHRoZVxuICAvLyBzdGF0ZW1lbnQgYWJvdmUgaW50byB0aGUgY29uZGl0aW9uYWwgbG9vcCBiZWxvdy4gVG8gcHJldmVudCB0aGlzIGZyb21cbiAgLy8gaGFwcGVuaW5nLCB1c2UgYSBmb3ItbG9vcCBhbmQgcmVzZXJ2ZSB0aGUgaW5pdCBsb2dpYyBhcyBiZWxvdy5cblxuICAvLyBQYXJlbnRoZXNlcyBhZGRlZCB0byBlbGltaW5hdGUgc3RyaWN0IEpTIHdhcm5pbmcgaW4gRmlyZWZveC5cbiAgZm9yICh2YXIgcGFydDsgcGFydHMubGVuZ3RoICYmIChwYXJ0ID0gcGFydHMuc2hpZnQoKSk7KSB7XG4gICAgaWYgKCFwYXJ0cy5sZW5ndGggJiYgZ29vZy5pc0RlZihvcHRfb2JqZWN0KSkge1xuICAgICAgLy8gbGFzdCBwYXJ0IGFuZCB3ZSBoYXZlIGFuIG9iamVjdDsgdXNlIGl0XG4gICAgICBjdXJbcGFydF0gPSBvcHRfb2JqZWN0O1xuICAgIH0gZWxzZSBpZiAoY3VyW3BhcnRdKSB7XG4gICAgICBjdXIgPSBjdXJbcGFydF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1ciA9IGN1cltwYXJ0XSA9IHt9O1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIERlZmluZXMgYSBuYW1lZCB2YWx1ZS4gSW4gdW5jb21waWxlZCBtb2RlLCB0aGUgdmFsdWUgaXMgcmV0cmlldmVkIGZyb21cbiAqIENMT1NVUkVfREVGSU5FUyBvciBDTE9TVVJFX1VOQ09NUElMRURfREVGSU5FUyBpZiB0aGUgb2JqZWN0IGlzIGRlZmluZWQgYW5kXG4gKiBoYXMgdGhlIHByb3BlcnR5IHNwZWNpZmllZCwgYW5kIG90aGVyd2lzZSB1c2VkIHRoZSBkZWZpbmVkIGRlZmF1bHRWYWx1ZS5cbiAqIFdoZW4gY29tcGlsZWQgdGhlIGRlZmF1bHQgY2FuIGJlIG92ZXJyaWRkZW4gdXNpbmcgdGhlIGNvbXBpbGVyXG4gKiBvcHRpb25zIG9yIHRoZSB2YWx1ZSBzZXQgaW4gdGhlIENMT1NVUkVfREVGSU5FUyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGRpc3Rpbmd1aXNoZWQgbmFtZSB0byBwcm92aWRlLlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfGJvb2xlYW59IGRlZmF1bHRWYWx1ZVxuICovXG5nb29nLmRlZmluZSA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIGlmICghQ09NUElMRUQpIHtcbiAgICBpZiAoZ29vZy5nbG9iYWwuQ0xPU1VSRV9VTkNPTVBJTEVEX0RFRklORVMgJiZcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFxuICAgICAgICAgICAgZ29vZy5nbG9iYWwuQ0xPU1VSRV9VTkNPTVBJTEVEX0RFRklORVMsIG5hbWUpKSB7XG4gICAgICB2YWx1ZSA9IGdvb2cuZ2xvYmFsLkNMT1NVUkVfVU5DT01QSUxFRF9ERUZJTkVTW25hbWVdO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGdvb2cuZ2xvYmFsLkNMT1NVUkVfREVGSU5FUyAmJlxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG4gICAgICAgICAgICBnb29nLmdsb2JhbC5DTE9TVVJFX0RFRklORVMsIG5hbWUpKSB7XG4gICAgICB2YWx1ZSA9IGdvb2cuZ2xvYmFsLkNMT1NVUkVfREVGSU5FU1tuYW1lXTtcbiAgICB9XG4gIH1cbiAgZ29vZy5leHBvcnRQYXRoXyhuYW1lLCB2YWx1ZSk7XG59O1xuXG5cbi8qKlxuICogQGRlZmluZSB7Ym9vbGVhbn0gREVCVUcgaXMgcHJvdmlkZWQgYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IGRlYnVnZ2luZyBjb2RlXG4gKiB0aGF0IHNob3VsZCBub3QgYmUgaW5jbHVkZWQgaW4gYSBwcm9kdWN0aW9uIGpzX2JpbmFyeSBjYW4gYmUgZWFzaWx5IHN0cmlwcGVkXG4gKiBieSBzcGVjaWZ5aW5nIC0tZGVmaW5lIGdvb2cuREVCVUc9ZmFsc2UgdG8gdGhlIEpTQ29tcGlsZXIuIEZvciBleGFtcGxlLCBtb3N0XG4gKiB0b1N0cmluZygpIG1ldGhvZHMgc2hvdWxkIGJlIGRlY2xhcmVkIGluc2lkZSBhbiBcImlmIChnb29nLkRFQlVHKVwiIGNvbmRpdGlvbmFsXG4gKiBiZWNhdXNlIHRoZXkgYXJlIGdlbmVyYWxseSB1c2VkIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgYW5kIGl0IGlzIGRpZmZpY3VsdFxuICogZm9yIHRoZSBKU0NvbXBpbGVyIHRvIHN0YXRpY2FsbHkgZGV0ZXJtaW5lIHdoZXRoZXIgdGhleSBhcmUgdXNlZC5cbiAqL1xuZ29vZy5kZWZpbmUoJ2dvb2cuREVCVUcnLCB0cnVlKTtcblxuXG4vKipcbiAqIEBkZWZpbmUge3N0cmluZ30gTE9DQUxFIGRlZmluZXMgdGhlIGxvY2FsZSBiZWluZyB1c2VkIGZvciBjb21waWxhdGlvbi4gSXQgaXNcbiAqIHVzZWQgdG8gc2VsZWN0IGxvY2FsZSBzcGVjaWZpYyBkYXRhIHRvIGJlIGNvbXBpbGVkIGluIGpzIGJpbmFyeS4gQlVJTEQgcnVsZVxuICogY2FuIHNwZWNpZnkgdGhpcyB2YWx1ZSBieSBcIi0tZGVmaW5lIGdvb2cuTE9DQUxFPTxsb2NhbGVfbmFtZT5cIiBhcyBKU0NvbXBpbGVyXG4gKiBvcHRpb24uXG4gKlxuICogVGFrZSBpbnRvIGFjY291bnQgdGhhdCB0aGUgbG9jYWxlIGNvZGUgZm9ybWF0IGlzIGltcG9ydGFudC4gWW91IHNob3VsZCB1c2VcbiAqIHRoZSBjYW5vbmljYWwgVW5pY29kZSBmb3JtYXQgd2l0aCBoeXBoZW4gYXMgYSBkZWxpbWl0ZXIuIExhbmd1YWdlIG11c3QgYmVcbiAqIGxvd2VyY2FzZSwgTGFuZ3VhZ2UgU2NyaXB0IC0gQ2FwaXRhbGl6ZWQsIFJlZ2lvbiAtIFVQUEVSQ0FTRS5cbiAqIFRoZXJlIGFyZSBmZXcgZXhhbXBsZXM6IHB0LUJSLCBlbiwgZW4tVVMsIHNyLUxhdGluLUJPLCB6aC1IYW5zLUNOLlxuICpcbiAqIFNlZSBtb3JlIGluZm8gYWJvdXQgbG9jYWxlIGNvZGVzIGhlcmU6XG4gKiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS8jVW5pY29kZV9MYW5ndWFnZV9hbmRfTG9jYWxlX0lkZW50aWZpZXJzXG4gKlxuICogRm9yIGxhbmd1YWdlIGNvZGVzIHlvdSBzaG91bGQgdXNlIHZhbHVlcyBkZWZpbmVkIGJ5IElTTyA2OTMtMS4gU2VlIGl0IGhlcmVcbiAqIGh0dHA6Ly93d3cudzMub3JnL1dBSS9FUi9JRy9lcnQvaXNvNjM5Lmh0bS4gVGhlcmUgaXMgb25seSBvbmUgZXhjZXB0aW9uIGZyb21cbiAqIHRoaXMgcnVsZTogdGhlIEhlYnJldyBsYW5ndWFnZS4gRm9yIGxlZ2FjeSByZWFzb25zIHRoZSBvbGQgY29kZSAoaXcpIHNob3VsZFxuICogYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBuZXcgY29kZSAoaGUpLCBzZWUgaHR0cDovL3dpa2kvTWFpbi9JSUlTeW5vbnltcy5cbiAqL1xuZ29vZy5kZWZpbmUoJ2dvb2cuTE9DQUxFJywgJ2VuJyk7ICAvLyBkZWZhdWx0IHRvIGVuXG5cblxuLyoqXG4gKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoaXMgY29kZSBpcyBydW5uaW5nIG9uIHRydXN0ZWQgc2l0ZXMuXG4gKlxuICogT24gdW50cnVzdGVkIHNpdGVzLCBzZXZlcmFsIG5hdGl2ZSBmdW5jdGlvbnMgY2FuIGJlIGRlZmluZWQgb3Igb3ZlcnJpZGRlbiBieVxuICogZXh0ZXJuYWwgbGlicmFyaWVzIGxpa2UgUHJvdG90eXBlLCBEYXRlanMsIGFuZCBKUXVlcnkgYW5kIHNldHRpbmcgdGhpcyBmbGFnXG4gKiB0byBmYWxzZSBmb3JjZXMgY2xvc3VyZSB0byB1c2UgaXRzIG93biBpbXBsZW1lbnRhdGlvbnMgd2hlbiBwb3NzaWJsZS5cbiAqXG4gKiBJZiB5b3VyIEphdmFTY3JpcHQgY2FuIGJlIGxvYWRlZCBieSBhIHRoaXJkIHBhcnR5IHNpdGUgYW5kIHlvdSBhcmUgd2FyeSBhYm91dFxuICogcmVseWluZyBvbiBub24tc3RhbmRhcmQgaW1wbGVtZW50YXRpb25zLCBzcGVjaWZ5XG4gKiBcIi0tZGVmaW5lIGdvb2cuVFJVU1RFRF9TSVRFPWZhbHNlXCIgdG8gdGhlIEpTQ29tcGlsZXIuXG4gKi9cbmdvb2cuZGVmaW5lKCdnb29nLlRSVVNURURfU0lURScsIHRydWUpO1xuXG5cbi8qKlxuICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciBhIHByb2plY3QgaXMgZXhwZWN0ZWQgdG8gYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZS5cbiAqXG4gKiBUaGlzIGRlZmluZSBjYW4gYmUgdXNlZCB0byB0cmlnZ2VyIGFsdGVybmF0ZSBpbXBsZW1lbnRhdGlvbnMgY29tcGF0aWJsZSB3aXRoXG4gKiBydW5uaW5nIGluIEVjbWFTY3JpcHQgU3RyaWN0IG1vZGUgb3Igd2FybiBhYm91dCB1bmF2YWlsYWJsZSBmdW5jdGlvbmFsaXR5LlxuICogQHNlZSBodHRwczovL2dvby5nbC9nNUVvSElcbiAqXG4gKi9cbmdvb2cuZGVmaW5lKCdnb29nLlNUUklDVF9NT0RFX0NPTVBBVElCTEUnLCBmYWxzZSk7XG5cblxuLyoqXG4gKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIGNvZGUgdGhhdCBjYWxscyB7QGxpbmsgZ29vZy5zZXRUZXN0T25seX0gc2hvdWxkXG4gKiAgICAgYmUgZGlzYWxsb3dlZCBpbiB0aGUgY29tcGlsYXRpb24gdW5pdC5cbiAqL1xuZ29vZy5kZWZpbmUoJ2dvb2cuRElTQUxMT1dfVEVTVF9PTkxZX0NPREUnLCBDT01QSUxFRCAmJiAhZ29vZy5ERUJVRyk7XG5cblxuLyoqXG4gKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRvIHVzZSBhIENocm9tZSBhcHAgQ1NQLWNvbXBsaWFudCBtZXRob2QgZm9yXG4gKiAgICAgbG9hZGluZyBzY3JpcHRzIHZpYSBnb29nLnJlcXVpcmUuIEBzZWUgYXBwZW5kU2NyaXB0U3JjTm9kZV8uXG4gKi9cbmdvb2cuZGVmaW5lKCdnb29nLkVOQUJMRV9DSFJPTUVfQVBQX1NBRkVfU0NSSVBUX0xPQURJTkcnLCBmYWxzZSk7XG5cblxuLyoqXG4gKiBEZWZpbmVzIGEgbmFtZXNwYWNlIGluIENsb3N1cmUuXG4gKlxuICogQSBuYW1lc3BhY2UgbWF5IG9ubHkgYmUgZGVmaW5lZCBvbmNlIGluIGEgY29kZWJhc2UuIEl0IG1heSBiZSBkZWZpbmVkIHVzaW5nXG4gKiBnb29nLnByb3ZpZGUoKSBvciBnb29nLm1vZHVsZSgpLlxuICpcbiAqIFRoZSBwcmVzZW5jZSBvZiBvbmUgb3IgbW9yZSBnb29nLnByb3ZpZGUoKSBjYWxscyBpbiBhIGZpbGUgaW5kaWNhdGVzXG4gKiB0aGF0IHRoZSBmaWxlIGRlZmluZXMgdGhlIGdpdmVuIG9iamVjdHMvbmFtZXNwYWNlcy5cbiAqIFByb3ZpZGVkIHN5bWJvbHMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuXG4gKlxuICogSW4gYWRkaXRpb24sIGdvb2cucHJvdmlkZSgpIGNyZWF0ZXMgdGhlIG9iamVjdCBzdHVicyBmb3IgYSBuYW1lc3BhY2VcbiAqIChmb3IgZXhhbXBsZSwgZ29vZy5wcm92aWRlKFwiZ29vZy5mb28uYmFyXCIpIHdpbGwgY3JlYXRlIHRoZSBvYmplY3RcbiAqIGdvb2cuZm9vLmJhciBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0KS5cbiAqXG4gKiBCdWlsZCB0b29scyBhbHNvIHNjYW4gZm9yIHByb3ZpZGUvcmVxdWlyZS9tb2R1bGUgc3RhdGVtZW50c1xuICogdG8gZGlzY2VybiBkZXBlbmRlbmNpZXMsIGJ1aWxkIGRlcGVuZGVuY3kgZmlsZXMgKHNlZSBkZXBzLmpzKSwgZXRjLlxuICpcbiAqIEBzZWUgZ29vZy5yZXF1aXJlXG4gKiBAc2VlIGdvb2cubW9kdWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lc3BhY2UgcHJvdmlkZWQgYnkgdGhpcyBmaWxlIGluIHRoZSBmb3JtXG4gKiAgICAgXCJnb29nLnBhY2thZ2UucGFydFwiLlxuICovXG5nb29nLnByb3ZpZGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICghQ09NUElMRUQpIHtcbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgc2FtZSBuYW1lc3BhY2UgaXNuJ3QgcHJvdmlkZWQgdHdpY2UuXG4gICAgLy8gQSBnb29nLm1vZHVsZS9nb29nLnByb3ZpZGUgbWFwcyBhIGdvb2cucmVxdWlyZSB0byBhIHNwZWNpZmljIGZpbGVcbiAgICBpZiAoZ29vZy5pc1Byb3ZpZGVkXyhuYW1lKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ05hbWVzcGFjZSBcIicgKyBuYW1lICsgJ1wiIGFscmVhZHkgZGVjbGFyZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgZ29vZy5jb25zdHJ1Y3ROYW1lc3BhY2VfKG5hbWUpO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWVzcGFjZSBwcm92aWRlZCBieSB0aGlzIGZpbGUgaW4gdGhlIGZvcm1cbiAqICAgICBcImdvb2cucGFja2FnZS5wYXJ0XCIuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9vYmogVGhlIG9iamVjdCB0byBlbWJlZCBpbiB0aGUgbmFtZXNwYWNlLlxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5jb25zdHJ1Y3ROYW1lc3BhY2VfID0gZnVuY3Rpb24obmFtZSwgb3B0X29iaikge1xuICBpZiAoIUNPTVBJTEVEKSB7XG4gICAgZGVsZXRlIGdvb2cuaW1wbGljaXROYW1lc3BhY2VzX1tuYW1lXTtcblxuICAgIHZhciBuYW1lc3BhY2UgPSBuYW1lO1xuICAgIHdoaWxlICgobmFtZXNwYWNlID0gbmFtZXNwYWNlLnN1YnN0cmluZygwLCBuYW1lc3BhY2UubGFzdEluZGV4T2YoJy4nKSkpKSB7XG4gICAgICBpZiAoZ29vZy5nZXRPYmplY3RCeU5hbWUobmFtZXNwYWNlKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGdvb2cuaW1wbGljaXROYW1lc3BhY2VzX1tuYW1lc3BhY2VdID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBnb29nLmV4cG9ydFBhdGhfKG5hbWUsIG9wdF9vYmopO1xufTtcblxuXG4vKipcbiAqIE1vZHVsZSBpZGVudGlmaWVyIHZhbGlkYXRpb24gcmVnZXhwLlxuICogTm90ZTogVGhpcyBpcyBhIGNvbnNlcnZhdGl2ZSBjaGVjaywgaXQgaXMgdmVyeSBwb3NzaWJsZSB0byBiZSBtb3JlIGxlbmllbnQsXG4gKiAgIHRoZSBwcmltYXJ5IGV4Y2x1c2lvbiBoZXJlIGlzIFwiL1wiIGFuZCBcIlxcXCIgYW5kIGEgbGVhZGluZyBcIi5cIiwgdGhlc2VcbiAqICAgcmVzdHJpY3Rpb25zIGFyZSBpbnRlbmRlZCB0byBsZWF2ZSB0aGUgZG9vciBvcGVuIGZvciB1c2luZyBnb29nLnJlcXVpcmVcbiAqICAgd2l0aCByZWxhdGl2ZSBmaWxlIHBhdGhzIHJhdGhlciB0aGFuIG1vZHVsZSBpZGVudGlmaWVycy5cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cuVkFMSURfTU9EVUxFX1JFXyA9IC9eW2EtekEtWl8kXVthLXpBLVowLTkuXyRdKiQvO1xuXG5cbi8qKlxuICogRGVmaW5lcyBhIG1vZHVsZSBpbiBDbG9zdXJlLlxuICpcbiAqIE1hcmtzIHRoYXQgdGhpcyBmaWxlIG11c3QgYmUgbG9hZGVkIGFzIGEgbW9kdWxlIGFuZCBjbGFpbXMgdGhlIG5hbWVzcGFjZS5cbiAqXG4gKiBBIG5hbWVzcGFjZSBtYXkgb25seSBiZSBkZWZpbmVkIG9uY2UgaW4gYSBjb2RlYmFzZS4gSXQgbWF5IGJlIGRlZmluZWQgdXNpbmdcbiAqIGdvb2cucHJvdmlkZSgpIG9yIGdvb2cubW9kdWxlKCkuXG4gKlxuICogZ29vZy5tb2R1bGUoKSBoYXMgdGhyZWUgcmVxdWlyZW1lbnRzOlxuICogLSBnb29nLm1vZHVsZSBtYXkgbm90IGJlIHVzZWQgaW4gdGhlIHNhbWUgZmlsZSBhcyBnb29nLnByb3ZpZGUuXG4gKiAtIGdvb2cubW9kdWxlIG11c3QgYmUgdGhlIGZpcnN0IHN0YXRlbWVudCBpbiB0aGUgZmlsZS5cbiAqIC0gb25seSBvbmUgZ29vZy5tb2R1bGUgaXMgYWxsb3dlZCBwZXIgZmlsZS5cbiAqXG4gKiBXaGVuIGEgZ29vZy5tb2R1bGUgYW5ub3RhdGVkIGZpbGUgaXMgbG9hZGVkLCBpdCBpcyBlbmNsb3NlZCBpblxuICogYSBzdHJpY3QgZnVuY3Rpb24gY2xvc3VyZS4gVGhpcyBtZWFucyB0aGF0OlxuICogLSBhbnkgdmFyaWFibGVzIGRlY2xhcmVkIGluIGEgZ29vZy5tb2R1bGUgZmlsZSBhcmUgcHJpdmF0ZSB0byB0aGUgZmlsZVxuICogKG5vdCBnbG9iYWwpLCB0aG91Z2ggdGhlIGNvbXBpbGVyIGlzIGV4cGVjdGVkIHRvIGlubGluZSB0aGUgbW9kdWxlLlxuICogLSBUaGUgY29kZSBtdXN0IG9iZXkgYWxsIHRoZSBydWxlcyBvZiBcInN0cmljdFwiIEphdmFTY3JpcHQuXG4gKiAtIHRoZSBmaWxlIHdpbGwgYmUgbWFya2VkIGFzIFwidXNlIHN0cmljdFwiXG4gKlxuICogTk9URTogdW5saWtlIGdvb2cucHJvdmlkZSwgZ29vZy5tb2R1bGUgZG9lcyBub3QgZGVjbGFyZSBhbnkgc3ltYm9scyBieVxuICogaXRzZWxmLiBJZiBkZWNsYXJlZCBzeW1ib2xzIGFyZSBkZXNpcmVkLCB1c2VcbiAqIGdvb2cubW9kdWxlLmRlY2xhcmVMZWdhY3lOYW1lc3BhY2UoKS5cbiAqXG4gKlxuICogU2VlIHRoZSBwdWJsaWMgZ29vZy5tb2R1bGUgcHJvcG9zYWw6IGh0dHA6Ly9nb28uZ2wvVmExaGluXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZXNwYWNlIHByb3ZpZGVkIGJ5IHRoaXMgZmlsZSBpbiB0aGUgZm9ybVxuICogICAgIFwiZ29vZy5wYWNrYWdlLnBhcnRcIiwgaXMgZXhwZWN0ZWQgYnV0IG5vdCByZXF1aXJlZC5cbiAqL1xuZ29vZy5tb2R1bGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICghZ29vZy5pc1N0cmluZyhuYW1lKSB8fCAhbmFtZSB8fFxuICAgICAgbmFtZS5zZWFyY2goZ29vZy5WQUxJRF9NT0RVTEVfUkVfKSA9PSAtMSkge1xuICAgIHRocm93IEVycm9yKCdJbnZhbGlkIG1vZHVsZSBpZGVudGlmaWVyJyk7XG4gIH1cbiAgaWYgKCFnb29nLmlzSW5Nb2R1bGVMb2FkZXJfKCkpIHtcbiAgICB0aHJvdyBFcnJvcignTW9kdWxlICcgKyBuYW1lICsgJyBoYXMgYmVlbiBsb2FkZWQgaW5jb3JyZWN0bHkuJyk7XG4gIH1cbiAgaWYgKGdvb2cubW9kdWxlTG9hZGVyU3RhdGVfLm1vZHVsZU5hbWUpIHtcbiAgICB0aHJvdyBFcnJvcignZ29vZy5tb2R1bGUgbWF5IG9ubHkgYmUgY2FsbGVkIG9uY2UgcGVyIG1vZHVsZS4nKTtcbiAgfVxuXG4gIC8vIFN0b3JlIHRoZSBtb2R1bGUgbmFtZSBmb3IgdGhlIGxvYWRlci5cbiAgZ29vZy5tb2R1bGVMb2FkZXJTdGF0ZV8ubW9kdWxlTmFtZSA9IG5hbWU7XG4gIGlmICghQ09NUElMRUQpIHtcbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgc2FtZSBuYW1lc3BhY2UgaXNuJ3QgcHJvdmlkZWQgdHdpY2UuXG4gICAgLy8gQSBnb29nLm1vZHVsZS9nb29nLnByb3ZpZGUgbWFwcyBhIGdvb2cucmVxdWlyZSB0byBhIHNwZWNpZmljIGZpbGVcbiAgICBpZiAoZ29vZy5pc1Byb3ZpZGVkXyhuYW1lKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ05hbWVzcGFjZSBcIicgKyBuYW1lICsgJ1wiIGFscmVhZHkgZGVjbGFyZWQuJyk7XG4gICAgfVxuICAgIGRlbGV0ZSBnb29nLmltcGxpY2l0TmFtZXNwYWNlc19bbmFtZV07XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbW9kdWxlIGlkZW50aWZpZXIuXG4gKiBAcmV0dXJuIHs/fSBUaGUgbW9kdWxlIGV4cG9ydHMgZm9yIGFuIGFscmVhZHkgbG9hZGVkIG1vZHVsZSBvciBudWxsLlxuICpcbiAqIE5vdGU6IFRoaXMgaXMgbm90IGFuIGFsdGVybmF0aXZlIHRvIGdvb2cucmVxdWlyZSwgaXQgZG9lcyBub3RcbiAqIGluZGljYXRlIGEgaGFyZCBkZXBlbmRlbmN5LCBpbnN0ZWFkIGl0IGlzIHVzZWQgdG8gaW5kaWNhdGVcbiAqIGFuIG9wdGlvbmFsIGRlcGVuZGVuY3kgb3IgdG8gYWNjZXNzIHRoZSBleHBvcnRzIG9mIGEgbW9kdWxlXG4gKiB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkLlxuICogQHN1cHByZXNzIHttaXNzaW5nUHJvdmlkZX1cbiAqL1xuZ29vZy5tb2R1bGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gZ29vZy5tb2R1bGUuZ2V0SW50ZXJuYWxfKG5hbWUpO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBtb2R1bGUgaWRlbnRpZmllci5cbiAqIEByZXR1cm4gez99IFRoZSBtb2R1bGUgZXhwb3J0cyBmb3IgYW4gYWxyZWFkeSBsb2FkZWQgbW9kdWxlIG9yIG51bGwuXG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLm1vZHVsZS5nZXRJbnRlcm5hbF8gPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICghQ09NUElMRUQpIHtcbiAgICBpZiAoZ29vZy5pc1Byb3ZpZGVkXyhuYW1lKSkge1xuICAgICAgLy8gZ29vZy5yZXF1aXJlIG9ubHkgcmV0dXJuIGEgdmFsdWUgd2l0aC1pbiBnb29nLm1vZHVsZSBmaWxlcy5cbiAgICAgIHJldHVybiBuYW1lIGluIGdvb2cubG9hZGVkTW9kdWxlc18gPyBnb29nLmxvYWRlZE1vZHVsZXNfW25hbWVdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnb29nLmdldE9iamVjdEJ5TmFtZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogQHByaXZhdGUgez97bW9kdWxlTmFtZTogKHN0cmluZ3x1bmRlZmluZWQpLCBkZWNsYXJlTGVnYWN5TmFtZXNwYWNlOmJvb2xlYW59fVxuICovXG5nb29nLm1vZHVsZUxvYWRlclN0YXRlXyA9IG51bGw7XG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBhIGdvb2cubW9kdWxlIGlzIGN1cnJlbnRseSBiZWluZyBpbml0aWFsaXplZC5cbiAqL1xuZ29vZy5pc0luTW9kdWxlTG9hZGVyXyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZ29vZy5tb2R1bGVMb2FkZXJTdGF0ZV8gIT0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBQcm92aWRlIHRoZSBtb2R1bGUncyBleHBvcnRzIGFzIGEgZ2xvYmFsbHkgYWNjZXNzaWJsZSBvYmplY3QgdW5kZXIgdGhlXG4gKiBtb2R1bGUncyBkZWNsYXJlZCBuYW1lLiAgVGhpcyBpcyBpbnRlbmRlZCB0byBlYXNlIG1pZ3JhdGlvbiB0byBnb29nLm1vZHVsZVxuICogZm9yIGZpbGVzIHRoYXQgaGF2ZSBleGlzdGluZyB1c2FnZXMuXG4gKiBAc3VwcHJlc3Mge21pc3NpbmdQcm92aWRlfVxuICovXG5nb29nLm1vZHVsZS5kZWNsYXJlTGVnYWN5TmFtZXNwYWNlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghQ09NUElMRUQgJiYgIWdvb2cuaXNJbk1vZHVsZUxvYWRlcl8oKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2dvb2cubW9kdWxlLmRlY2xhcmVMZWdhY3lOYW1lc3BhY2UgbXVzdCBiZSBjYWxsZWQgZnJvbSAnICtcbiAgICAgICAgJ3dpdGhpbiBhIGdvb2cubW9kdWxlJyk7XG4gIH1cbiAgaWYgKCFDT01QSUxFRCAmJiAhZ29vZy5tb2R1bGVMb2FkZXJTdGF0ZV8ubW9kdWxlTmFtZSkge1xuICAgIHRocm93IEVycm9yKFxuICAgICAgICAnZ29vZy5tb2R1bGUgbXVzdCBiZSBjYWxsZWQgcHJpb3IgdG8gJyArXG4gICAgICAgICdnb29nLm1vZHVsZS5kZWNsYXJlTGVnYWN5TmFtZXNwYWNlLicpO1xuICB9XG4gIGdvb2cubW9kdWxlTG9hZGVyU3RhdGVfLmRlY2xhcmVMZWdhY3lOYW1lc3BhY2UgPSB0cnVlO1xufTtcblxuXG4vKipcbiAqIE1hcmtzIHRoYXQgdGhlIGN1cnJlbnQgZmlsZSBzaG91bGQgb25seSBiZSB1c2VkIGZvciB0ZXN0aW5nLCBhbmQgbmV2ZXIgZm9yXG4gKiBsaXZlIGNvZGUgaW4gcHJvZHVjdGlvbi5cbiAqXG4gKiBJbiB0aGUgY2FzZSBvZiB1bml0IHRlc3RzLCB0aGUgbWVzc2FnZSBtYXkgb3B0aW9uYWxseSBiZSBhbiBleGFjdCBuYW1lc3BhY2VcbiAqIGZvciB0aGUgdGVzdCAoZS5nLiAnZ29vZy5zdHJpbmdUZXN0JykuIFRoZSBsaW50ZXIgd2lsbCB0aGVuIGlnbm9yZSB0aGUgZXh0cmFcbiAqIHByb3ZpZGUgKGlmIG5vdCBleHBsaWNpdGx5IGRlZmluZWQgaW4gdGhlIGNvZGUpLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2UgT3B0aW9uYWwgbWVzc2FnZSB0byBhZGQgdG8gdGhlIGVycm9yIHRoYXQnc1xuICogICAgIHJhaXNlZCB3aGVuIHVzZWQgaW4gcHJvZHVjdGlvbiBjb2RlLlxuICovXG5nb29nLnNldFRlc3RPbmx5ID0gZnVuY3Rpb24ob3B0X21lc3NhZ2UpIHtcbiAgaWYgKGdvb2cuRElTQUxMT1dfVEVTVF9PTkxZX0NPREUpIHtcbiAgICBvcHRfbWVzc2FnZSA9IG9wdF9tZXNzYWdlIHx8ICcnO1xuICAgIHRocm93IEVycm9yKFxuICAgICAgICAnSW1wb3J0aW5nIHRlc3Qtb25seSBjb2RlIGludG8gbm9uLWRlYnVnIGVudmlyb25tZW50JyArXG4gICAgICAgIChvcHRfbWVzc2FnZSA/ICc6ICcgKyBvcHRfbWVzc2FnZSA6ICcuJykpO1xuICB9XG59O1xuXG5pZiAoIUNPTVBJTEVEKSB7XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gbmFtZSBoYXMgYmVlbiBnb29nLnByb3ZpZGVkLiBUaGlzIHdpbGwgcmV0dXJuIGZhbHNlIGZvclxuICAgKiBuYW1lcyB0aGF0IGFyZSBhdmFpbGFibGUgb25seSBhcyBpbXBsaWNpdCBuYW1lc3BhY2VzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBvYmplY3QgdG8gbG9vayBmb3IuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIG5hbWUgaGFzIGJlZW4gcHJvdmlkZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmlzUHJvdmlkZWRfID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiAobmFtZSBpbiBnb29nLmxvYWRlZE1vZHVsZXNfKSB8fFxuICAgICAgICAoIWdvb2cuaW1wbGljaXROYW1lc3BhY2VzX1tuYW1lXSAmJlxuICAgICAgICAgZ29vZy5pc0RlZkFuZE5vdE51bGwoZ29vZy5nZXRPYmplY3RCeU5hbWUobmFtZSkpKTtcbiAgfTtcblxuICAvKipcbiAgICogTmFtZXNwYWNlcyBpbXBsaWNpdGx5IGRlZmluZWQgYnkgZ29vZy5wcm92aWRlLiBGb3IgZXhhbXBsZSxcbiAgICogZ29vZy5wcm92aWRlKCdnb29nLmV2ZW50cy5FdmVudCcpIGltcGxpY2l0bHkgZGVjbGFyZXMgdGhhdCAnZ29vZycgYW5kXG4gICAqICdnb29nLmV2ZW50cycgbXVzdCBiZSBuYW1lc3BhY2VzLlxuICAgKlxuICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIChib29sZWFufHVuZGVmaW5lZCk+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pbXBsaWNpdE5hbWVzcGFjZXNfID0geydnb29nLm1vZHVsZSc6IHRydWV9O1xuXG4gIC8vIE5PVEU6IFdlIGFkZCBnb29nLm1vZHVsZSBhcyBhbiBpbXBsaWNpdCBuYW1lc3BhY2UgYXMgZ29vZy5tb2R1bGUgaXMgZGVmaW5lZFxuICAvLyBoZXJlIGFuZCBiZWNhdXNlIHRoZSBleGlzdGluZyBtb2R1bGUgcGFja2FnZSBoYXMgbm90IGJlZW4gbW92ZWQgeWV0IG91dCBvZlxuICAvLyB0aGUgZ29vZy5tb2R1bGUgbmFtZXNwYWNlLiBUaGlzIHNhdGlzaWZpZXMgYm90aCB0aGUgZGVidWcgbG9hZGVyIGFuZFxuICAvLyBhaGVhZC1vZi10aW1lIGRlcGVuZGVuY3kgbWFuYWdlbWVudC5cbn1cblxuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IGJhc2VkIG9uIGl0cyBmdWxseSBxdWFsaWZpZWQgZXh0ZXJuYWwgbmFtZS4gIFRoZSBvYmplY3RcbiAqIGlzIG5vdCBmb3VuZCBpZiBudWxsIG9yIHVuZGVmaW5lZC4gIElmIHlvdSBhcmUgdXNpbmcgYSBjb21waWxhdGlvbiBwYXNzIHRoYXRcbiAqIHJlbmFtZXMgcHJvcGVydHkgbmFtZXMgYmV3YXJlIHRoYXQgdXNpbmcgdGhpcyBmdW5jdGlvbiB3aWxsIG5vdCBmaW5kIHJlbmFtZWRcbiAqIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfb2JqIFRoZSBvYmplY3Qgd2l0aGluIHdoaWNoIHRvIGxvb2s7IGRlZmF1bHQgaXNcbiAqICAgICB8Z29vZy5nbG9iYWx8LlxuICogQHJldHVybiB7P30gVGhlIHZhbHVlIChvYmplY3Qgb3IgcHJpbWl0aXZlKSBvciwgaWYgbm90IGZvdW5kLCBudWxsLlxuICovXG5nb29nLmdldE9iamVjdEJ5TmFtZSA9IGZ1bmN0aW9uKG5hbWUsIG9wdF9vYmopIHtcbiAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuICB2YXIgY3VyID0gb3B0X29iaiB8fCBnb29nLmdsb2JhbDtcbiAgZm9yICh2YXIgcGFydDsgcGFydCA9IHBhcnRzLnNoaWZ0KCk7KSB7XG4gICAgaWYgKGdvb2cuaXNEZWZBbmROb3ROdWxsKGN1cltwYXJ0XSkpIHtcbiAgICAgIGN1ciA9IGN1cltwYXJ0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBjdXI7XG59O1xuXG5cbi8qKlxuICogR2xvYmFsaXplcyBhIHdob2xlIG5hbWVzcGFjZSwgc3VjaCBhcyBnb29nIG9yIGdvb2cubGFuZy5cbiAqXG4gKiBAcGFyYW0geyFPYmplY3R9IG9iaiBUaGUgbmFtZXNwYWNlIHRvIGdsb2JhbGl6ZS5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2dsb2JhbCBUaGUgb2JqZWN0IHRvIGFkZCB0aGUgcHJvcGVydGllcyB0by5cbiAqIEBkZXByZWNhdGVkIFByb3BlcnRpZXMgbWF5IGJlIGV4cGxpY2l0bHkgZXhwb3J0ZWQgdG8gdGhlIGdsb2JhbCBzY29wZSwgYnV0XG4gKiAgICAgdGhpcyBzaG91bGQgbm8gbG9uZ2VyIGJlIGRvbmUgaW4gYnVsay5cbiAqL1xuZ29vZy5nbG9iYWxpemUgPSBmdW5jdGlvbihvYmosIG9wdF9nbG9iYWwpIHtcbiAgdmFyIGdsb2JhbCA9IG9wdF9nbG9iYWwgfHwgZ29vZy5nbG9iYWw7XG4gIGZvciAodmFyIHggaW4gb2JqKSB7XG4gICAgZ2xvYmFsW3hdID0gb2JqW3hdO1xuICB9XG59O1xuXG5cbi8qKlxuICogQWRkcyBhIGRlcGVuZGVuY3kgZnJvbSBhIGZpbGUgdG8gdGhlIGZpbGVzIGl0IHJlcXVpcmVzLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbFBhdGggVGhlIHBhdGggdG8gdGhlIGpzIGZpbGUuXG4gKiBAcGFyYW0geyFBcnJheTxzdHJpbmc+fSBwcm92aWRlcyBBbiBhcnJheSBvZiBzdHJpbmdzIHdpdGhcbiAqICAgICB0aGUgbmFtZXMgb2YgdGhlIG9iamVjdHMgdGhpcyBmaWxlIHByb3ZpZGVzLlxuICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0gcmVxdWlyZXMgQW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoXG4gKiAgICAgdGhlIG5hbWVzIG9mIHRoZSBvYmplY3RzIHRoaXMgZmlsZSByZXF1aXJlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbnwhT2JqZWN0PHN0cmluZz49fSBvcHRfbG9hZEZsYWdzIFBhcmFtZXRlcnMgaW5kaWNhdGluZ1xuICogICAgIGhvdyB0aGUgZmlsZSBtdXN0IGJlIGxvYWRlZC4gIFRoZSBib29sZWFuICd0cnVlJyBpcyBlcXVpdmFsZW50XG4gKiAgICAgdG8geydtb2R1bGUnOiAnZ29vZyd9IGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eS4gIFZhbGlkIHByb3BlcnRpZXNcbiAqICAgICBhbmQgdmFsdWVzIGluY2x1ZGUgeydtb2R1bGUnOiAnZ29vZyd9IGFuZCB7J2xhbmcnOiAnZXM2J30uXG4gKi9cbmdvb2cuYWRkRGVwZW5kZW5jeSA9IGZ1bmN0aW9uKHJlbFBhdGgsIHByb3ZpZGVzLCByZXF1aXJlcywgb3B0X2xvYWRGbGFncykge1xuICBpZiAoZ29vZy5ERVBFTkRFTkNJRVNfRU5BQkxFRCkge1xuICAgIHZhciBwcm92aWRlLCByZXF1aXJlO1xuICAgIHZhciBwYXRoID0gcmVsUGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gICAgdmFyIGRlcHMgPSBnb29nLmRlcGVuZGVuY2llc187XG4gICAgaWYgKCFvcHRfbG9hZEZsYWdzIHx8IHR5cGVvZiBvcHRfbG9hZEZsYWdzID09PSAnYm9vbGVhbicpIHtcbiAgICAgIG9wdF9sb2FkRmxhZ3MgPSBvcHRfbG9hZEZsYWdzID8geydtb2R1bGUnOiAnZ29vZyd9IDoge307XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBwcm92aWRlID0gcHJvdmlkZXNbaV07IGkrKykge1xuICAgICAgZGVwcy5uYW1lVG9QYXRoW3Byb3ZpZGVdID0gcGF0aDtcbiAgICAgIGRlcHMucGF0aElzTW9kdWxlW3BhdGhdID0gb3B0X2xvYWRGbGFnc1snbW9kdWxlJ10gPT0gJ2dvb2cnO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgcmVxdWlyZSA9IHJlcXVpcmVzW2pdOyBqKyspIHtcbiAgICAgIGlmICghKHBhdGggaW4gZGVwcy5yZXF1aXJlcykpIHtcbiAgICAgICAgZGVwcy5yZXF1aXJlc1twYXRoXSA9IHt9O1xuICAgICAgfVxuICAgICAgZGVwcy5yZXF1aXJlc1twYXRoXVtyZXF1aXJlXSA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5cblxuXG4vLyBOT1RFKG5uYXplKTogVGhlIGRlYnVnIERPTSBsb2FkZXIgd2FzIGluY2x1ZGVkIGluIGJhc2UuanMgYXMgYW4gb3JpZ2luYWwgd2F5XG4vLyB0byBkbyBcImRlYnVnLW1vZGVcIiBkZXZlbG9wbWVudC4gIFRoZSBkZXBlbmRlbmN5IHN5c3RlbSBjYW4gc29tZXRpbWVzIGJlXG4vLyBjb25mdXNpbmcsIGFzIGNhbiB0aGUgZGVidWcgRE9NIGxvYWRlcidzIGFzeW5jaHJvbm91cyBuYXR1cmUuXG4vL1xuLy8gV2l0aCB0aGUgRE9NIGxvYWRlciwgYSBjYWxsIHRvIGdvb2cucmVxdWlyZSgpIGlzIG5vdCBibG9ja2luZyAtLSB0aGUgc2NyaXB0XG4vLyB3aWxsIG5vdCBsb2FkIHVudGlsIHNvbWUgcG9pbnQgYWZ0ZXIgdGhlIGN1cnJlbnQgc2NyaXB0LiAgSWYgYSBuYW1lc3BhY2UgaXNcbi8vIG5lZWRlZCBhdCBydW50aW1lLCBpdCBuZWVkcyB0byBiZSBkZWZpbmVkIGluIGEgcHJldmlvdXMgc2NyaXB0LCBvciBsb2FkZWQgdmlhXG4vLyByZXF1aXJlKCkgd2l0aCBpdHMgcmVnaXN0ZXJlZCBkZXBlbmRlbmNpZXMuXG4vL1xuLy8gVXNlci1kZWZpbmVkIG5hbWVzcGFjZXMgbWF5IG5lZWQgdGhlaXIgb3duIGRlcHMgZmlsZS4gRm9yIGEgcmVmZXJlbmNlIG9uXG4vLyBjcmVhdGluZyBhIGRlcHMgZmlsZSwgc2VlOlxuLy8gRXh0ZXJuYWxseTogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vY2xvc3VyZS9saWJyYXJ5L2RvY3MvZGVwc3dyaXRlclxuLy9cbi8vIEJlY2F1c2Ugb2YgbGVnYWN5IGNsaWVudHMsIHRoZSBET00gbG9hZGVyIGNhbid0IGJlIGVhc2lseSByZW1vdmVkIGZyb21cbi8vIGJhc2UuanMuICBXb3JrIGlzIGJlaW5nIGRvbmUgdG8gbWFrZSBpdCBkaXNhYmxlYWJsZSBvciByZXBsYWNlYWJsZSBmb3Jcbi8vIGRpZmZlcmVudCBlbnZpcm9ubWVudHMgKERPTS1sZXNzIEphdmFTY3JpcHQgaW50ZXJwcmV0ZXJzIGxpa2UgUmhpbm8gb3IgVjgsXG4vLyBmb3IgZXhhbXBsZSkuIFNlZSBib290c3RyYXAvIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG5cbi8qKlxuICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0byBlbmFibGUgdGhlIGRlYnVnIGxvYWRlci5cbiAqXG4gKiBJZiBlbmFibGVkLCBhIGNhbGwgdG8gZ29vZy5yZXF1aXJlKCkgd2lsbCBhdHRlbXB0IHRvIGxvYWQgdGhlIG5hbWVzcGFjZSBieVxuICogYXBwZW5kaW5nIGEgc2NyaXB0IHRhZyB0byB0aGUgRE9NIChpZiB0aGUgbmFtZXNwYWNlIGhhcyBiZWVuIHJlZ2lzdGVyZWQpLlxuICpcbiAqIElmIGRpc2FibGVkLCBnb29nLnJlcXVpcmUoKSB3aWxsIHNpbXBseSBhc3NlcnQgdGhhdCB0aGUgbmFtZXNwYWNlIGhhcyBiZWVuXG4gKiBwcm92aWRlZCAoYW5kIGRlcGVuZCBvbiB0aGUgZmFjdCB0aGF0IHNvbWUgb3V0c2lkZSB0b29sIGNvcnJlY3RseSBvcmRlcmVkXG4gKiB0aGUgc2NyaXB0KS5cbiAqL1xuZ29vZy5kZWZpbmUoJ2dvb2cuRU5BQkxFX0RFQlVHX0xPQURFUicsIHRydWUpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1zZ1xuICogQHByaXZhdGVcbiAqL1xuZ29vZy5sb2dUb0NvbnNvbGVfID0gZnVuY3Rpb24obXNnKSB7XG4gIGlmIChnb29nLmdsb2JhbC5jb25zb2xlKSB7XG4gICAgZ29vZy5nbG9iYWwuY29uc29sZVsnZXJyb3InXShtc2cpO1xuICB9XG59O1xuXG5cbi8qKlxuICogSW1wbGVtZW50cyBhIHN5c3RlbSBmb3IgdGhlIGR5bmFtaWMgcmVzb2x1dGlvbiBvZiBkZXBlbmRlbmNpZXMgdGhhdCB3b3JrcyBpblxuICogcGFyYWxsZWwgd2l0aCB0aGUgQlVJTEQgc3lzdGVtLiBOb3RlIHRoYXQgYWxsIGNhbGxzIHRvIGdvb2cucmVxdWlyZSB3aWxsIGJlXG4gKiBzdHJpcHBlZCBieSB0aGUgSlNDb21waWxlciB3aGVuIHRoZSAtLXByb2Nlc3NfY2xvc3VyZV9wcmltaXRpdmVzIG9wdGlvbiBpc1xuICogdXNlZC5cbiAqIEBzZWUgZ29vZy5wcm92aWRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lc3BhY2UgdG8gaW5jbHVkZSAoYXMgd2FzIGdpdmVuIGluIGdvb2cucHJvdmlkZSgpKSBpblxuICogICAgIHRoZSBmb3JtIFwiZ29vZy5wYWNrYWdlLnBhcnRcIi5cbiAqIEByZXR1cm4gez99IElmIGNhbGxlZCB3aXRoaW4gYSBnb29nLm1vZHVsZSBmaWxlLCB0aGUgYXNzb2NpYXRlZCBuYW1lc3BhY2Ugb3JcbiAqICAgICBtb2R1bGUgb3RoZXJ3aXNlIG51bGwuXG4gKi9cbmdvb2cucmVxdWlyZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgLy8gSWYgdGhlIG9iamVjdCBhbHJlYWR5IGV4aXN0cyB3ZSBkbyBub3QgbmVlZCBkbyBkbyBhbnl0aGluZy5cbiAgaWYgKCFDT01QSUxFRCkge1xuICAgIGlmIChnb29nLkVOQUJMRV9ERUJVR19MT0FERVIgJiYgZ29vZy5JU19PTERfSUVfKSB7XG4gICAgICBnb29nLm1heWJlUHJvY2Vzc0RlZmVycmVkRGVwXyhuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoZ29vZy5pc1Byb3ZpZGVkXyhuYW1lKSkge1xuICAgICAgaWYgKGdvb2cuaXNJbk1vZHVsZUxvYWRlcl8oKSkge1xuICAgICAgICByZXR1cm4gZ29vZy5tb2R1bGUuZ2V0SW50ZXJuYWxfKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGdvb2cuRU5BQkxFX0RFQlVHX0xPQURFUikge1xuICAgICAgdmFyIHBhdGggPSBnb29nLmdldFBhdGhGcm9tRGVwc18obmFtZSk7XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICBnb29nLndyaXRlU2NyaXB0c18ocGF0aCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBlcnJvck1lc3NhZ2UgPSAnZ29vZy5yZXF1aXJlIGNvdWxkIG5vdCBmaW5kOiAnICsgbmFtZTtcbiAgICBnb29nLmxvZ1RvQ29uc29sZV8oZXJyb3JNZXNzYWdlKTtcblxuICAgIHRocm93IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBQYXRoIGZvciBpbmNsdWRlZCBzY3JpcHRzLlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZ29vZy5iYXNlUGF0aCA9ICcnO1xuXG5cbi8qKlxuICogQSBob29rIGZvciBvdmVycmlkaW5nIHRoZSBiYXNlIHBhdGguXG4gKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuZ29vZy5nbG9iYWwuQ0xPU1VSRV9CQVNFX1BBVEg7XG5cblxuLyoqXG4gKiBXaGV0aGVyIHRvIHdyaXRlIG91dCBDbG9zdXJlJ3MgZGVwcyBmaWxlLiBCeSBkZWZhdWx0LCB0aGUgZGVwcyBhcmUgd3JpdHRlbi5cbiAqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xuZ29vZy5nbG9iYWwuQ0xPU1VSRV9OT19ERVBTO1xuXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0byBpbXBvcnQgYSBzaW5nbGUgc2NyaXB0LiBUaGlzIGlzIG1lYW50IHRvIGJlIG92ZXJyaWRkZW4gd2hlblxuICogQ2xvc3VyZSBpcyBiZWluZyBydW4gaW4gbm9uLUhUTUwgY29udGV4dHMsIHN1Y2ggYXMgd2ViIHdvcmtlcnMuIEl0J3MgZGVmaW5lZFxuICogaW4gdGhlIGdsb2JhbCBzY29wZSBzbyB0aGF0IGl0IGNhbiBiZSBzZXQgYmVmb3JlIGJhc2UuanMgaXMgbG9hZGVkLCB3aGljaFxuICogYWxsb3dzIGRlcHMuanMgdG8gYmUgaW1wb3J0ZWQgcHJvcGVybHkuXG4gKlxuICogVGhlIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgc2NyaXB0IHNvdXJjZSwgd2hpY2ggaXMgYSByZWxhdGl2ZSBVUkkuIEl0IHNob3VsZFxuICogcmV0dXJuIHRydWUgaWYgdGhlIHNjcmlwdCB3YXMgaW1wb3J0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEB0eXBlIHsoZnVuY3Rpb24oc3RyaW5nKTogYm9vbGVhbil8dW5kZWZpbmVkfVxuICovXG5nb29nLmdsb2JhbC5DTE9TVVJFX0lNUE9SVF9TQ1JJUFQ7XG5cblxuLyoqXG4gKiBOdWxsIGZ1bmN0aW9uIHVzZWQgZm9yIGRlZmF1bHQgdmFsdWVzIG9mIGNhbGxiYWNrcywgZXRjLlxuICogQHJldHVybiB7dm9pZH0gTm90aGluZy5cbiAqL1xuZ29vZy5udWxsRnVuY3Rpb24gPSBmdW5jdGlvbigpIHt9O1xuXG5cbi8qKlxuICogV2hlbiBkZWZpbmluZyBhIGNsYXNzIEZvbyB3aXRoIGFuIGFic3RyYWN0IG1ldGhvZCBiYXIoKSwgeW91IGNhbiBkbzpcbiAqIEZvby5wcm90b3R5cGUuYmFyID0gZ29vZy5hYnN0cmFjdE1ldGhvZFxuICpcbiAqIE5vdyBpZiBhIHN1YmNsYXNzIG9mIEZvbyBmYWlscyB0byBvdmVycmlkZSBiYXIoKSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd25cbiAqIHdoZW4gYmFyKCkgaXMgaW52b2tlZC5cbiAqXG4gKiBOb3RlOiBUaGlzIGRvZXMgbm90IHRha2UgdGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIG92ZXJyaWRlIGFzIGFuIGFyZ3VtZW50XG4gKiBiZWNhdXNlIHRoYXQgd291bGQgbWFrZSBpdCBtb3JlIGRpZmZpY3VsdCB0byBvYmZ1c2NhdGUgb3VyIEphdmFTY3JpcHQgY29kZS5cbiAqXG4gKiBAdHlwZSB7IUZ1bmN0aW9ufVxuICogQHRocm93cyB7RXJyb3J9IHdoZW4gaW52b2tlZCB0byBpbmRpY2F0ZSB0aGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuICovXG5nb29nLmFic3RyYWN0TWV0aG9kID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IEVycm9yKCd1bmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZCcpO1xufTtcblxuXG4vKipcbiAqIEFkZHMgYSB7QGNvZGUgZ2V0SW5zdGFuY2V9IHN0YXRpYyBtZXRob2QgdGhhdCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZVxuICogaW5zdGFuY2Ugb2JqZWN0LlxuICogQHBhcmFtIHshRnVuY3Rpb259IGN0b3IgVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgY2xhc3MgdG8gYWRkIHRoZSBzdGF0aWNcbiAqICAgICBtZXRob2QgdG8uXG4gKi9cbmdvb2cuYWRkU2luZ2xldG9uR2V0dGVyID0gZnVuY3Rpb24oY3Rvcikge1xuICBjdG9yLmdldEluc3RhbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGN0b3IuaW5zdGFuY2VfKSB7XG4gICAgICByZXR1cm4gY3Rvci5pbnN0YW5jZV87XG4gICAgfVxuICAgIGlmIChnb29nLkRFQlVHKSB7XG4gICAgICAvLyBOT1RFOiBKU0NvbXBpbGVyIGNhbid0IG9wdGltaXplIGF3YXkgQXJyYXkjcHVzaC5cbiAgICAgIGdvb2cuaW5zdGFudGlhdGVkU2luZ2xldG9uc19bZ29vZy5pbnN0YW50aWF0ZWRTaW5nbGV0b25zXy5sZW5ndGhdID0gY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuIGN0b3IuaW5zdGFuY2VfID0gbmV3IGN0b3I7XG4gIH07XG59O1xuXG5cbi8qKlxuICogQWxsIHNpbmdsZXRvbiBjbGFzc2VzIHRoYXQgaGF2ZSBiZWVuIGluc3RhbnRpYXRlZCwgZm9yIHRlc3RpbmcuIERvbid0IHJlYWRcbiAqIGl0IGRpcmVjdGx5LCB1c2UgdGhlIHtAY29kZSBnb29nLnRlc3Rpbmcuc2luZ2xldG9ufSBtb2R1bGUuIFRoZSBjb21waWxlclxuICogcmVtb3ZlcyB0aGlzIHZhcmlhYmxlIGlmIHVudXNlZC5cbiAqIEB0eXBlIHshQXJyYXk8IUZ1bmN0aW9uPn1cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cuaW5zdGFudGlhdGVkU2luZ2xldG9uc18gPSBbXTtcblxuXG4vKipcbiAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdG8gbG9hZCBnb29nLm1vZHVsZXMgdXNpbmcge0Bjb2RlIGV2YWx9IHdoZW4gdXNpbmdcbiAqIHRoZSBkZWJ1ZyBsb2FkZXIuICBUaGlzIHByb3ZpZGVzIGEgYmV0dGVyIGRlYnVnZ2luZyBleHBlcmllbmNlIGFzIHRoZVxuICogc291cmNlIGlzIHVubW9kaWZpZWQgYW5kIGNhbiBiZSBlZGl0ZWQgdXNpbmcgQ2hyb21lIFdvcmtzcGFjZXMgb3Igc2ltaWxhci5cbiAqIEhvd2V2ZXIgaW4gc29tZSBlbnZpcm9ubWVudHMgdGhlIHVzZSBvZiB7QGNvZGUgZXZhbH0gaXMgYmFubmVkXG4gKiBzbyB3ZSBwcm92aWRlIGFuIGFsdGVybmF0aXZlLlxuICovXG5nb29nLmRlZmluZSgnZ29vZy5MT0FEX01PRFVMRV9VU0lOR19FVkFMJywgdHJ1ZSk7XG5cblxuLyoqXG4gKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoZSBleHBvcnRzIG9mIGdvb2cubW9kdWxlcyBzaG91bGQgYmUgc2VhbGVkIHdoZW5cbiAqIHBvc3NpYmxlLlxuICovXG5nb29nLmRlZmluZSgnZ29vZy5TRUFMX01PRFVMRV9FWFBPUlRTJywgZ29vZy5ERUJVRyk7XG5cblxuLyoqXG4gKiBUaGUgcmVnaXN0cnkgb2YgaW5pdGlhbGl6ZWQgbW9kdWxlczpcbiAqIHRoZSBtb2R1bGUgaWRlbnRpZmllciB0byBtb2R1bGUgZXhwb3J0cyBtYXAuXG4gKiBAcHJpdmF0ZSBAY29uc3QgeyFPYmplY3Q8c3RyaW5nLCA/Pn1cbiAqL1xuZ29vZy5sb2FkZWRNb2R1bGVzXyA9IHt9O1xuXG5cbi8qKlxuICogVHJ1ZSBpZiBnb29nLmRlcGVuZGVuY2llc18gaXMgYXZhaWxhYmxlLlxuICogQGNvbnN0IHtib29sZWFufVxuICovXG5nb29nLkRFUEVOREVOQ0lFU19FTkFCTEVEID0gIUNPTVBJTEVEICYmIGdvb2cuRU5BQkxFX0RFQlVHX0xPQURFUjtcblxuXG5pZiAoZ29vZy5ERVBFTkRFTkNJRVNfRU5BQkxFRCkge1xuICAvKipcbiAgICogVGhpcyBvYmplY3QgaXMgdXNlZCB0byBrZWVwIHRyYWNrIG9mIGRlcGVuZGVuY2llcyBhbmQgb3RoZXIgZGF0YSB0aGF0IGlzXG4gICAqIHVzZWQgZm9yIGxvYWRpbmcgc2NyaXB0cy5cbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge3tcbiAgICogICBwYXRoSXNNb2R1bGU6ICFPYmplY3Q8c3RyaW5nLCBib29sZWFuPixcbiAgICogICBuYW1lVG9QYXRoOiAhT2JqZWN0PHN0cmluZywgc3RyaW5nPixcbiAgICogICByZXF1aXJlczogIU9iamVjdDxzdHJpbmcsICFPYmplY3Q8c3RyaW5nLCBib29sZWFuPj4sXG4gICAqICAgdmlzaXRlZDogIU9iamVjdDxzdHJpbmcsIGJvb2xlYW4+LFxuICAgKiAgIHdyaXR0ZW46ICFPYmplY3Q8c3RyaW5nLCBib29sZWFuPixcbiAgICogICBkZWZlcnJlZDogIU9iamVjdDxzdHJpbmcsIHN0cmluZz5cbiAgICogfX1cbiAgICovXG4gIGdvb2cuZGVwZW5kZW5jaWVzXyA9IHtcbiAgICBwYXRoSXNNb2R1bGU6IHt9LCAgLy8gMSB0byAxXG5cbiAgICBuYW1lVG9QYXRoOiB7fSwgIC8vIDEgdG8gMVxuXG4gICAgcmVxdWlyZXM6IHt9LCAgLy8gMSB0byBtYW55XG5cbiAgICAvLyBVc2VkIHdoZW4gcmVzb2x2aW5nIGRlcGVuZGVuY2llcyB0byBwcmV2ZW50IHVzIGZyb20gdmlzaXRpbmcgZmlsZSB0d2ljZS5cbiAgICB2aXNpdGVkOiB7fSxcblxuICAgIHdyaXR0ZW46IHt9LCAgLy8gVXNlZCB0byBrZWVwIHRyYWNrIG9mIHNjcmlwdCBmaWxlcyB3ZSBoYXZlIHdyaXR0ZW4uXG5cbiAgICBkZWZlcnJlZDoge30gIC8vIFVzZWQgdG8gdHJhY2sgZGVmZXJyZWQgbW9kdWxlIGV2YWx1YXRpb25zIGluIG9sZCBJRXNcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBUcmllcyB0byBkZXRlY3Qgd2hldGhlciBpcyBpbiB0aGUgY29udGV4dCBvZiBhbiBIVE1MIGRvY3VtZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGl0IGxvb2tzIGxpa2UgSFRNTCBkb2N1bWVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuaW5IdG1sRG9jdW1lbnRfID0gZnVuY3Rpb24oKSB7XG4gICAgLyoqIEB0eXBlIHtEb2N1bWVudH0gKi9cbiAgICB2YXIgZG9jID0gZ29vZy5nbG9iYWwuZG9jdW1lbnQ7XG4gICAgcmV0dXJuIGRvYyAhPSBudWxsICYmICd3cml0ZScgaW4gZG9jOyAgLy8gWFVMRG9jdW1lbnQgbWlzc2VzIHdyaXRlLlxuICB9O1xuXG5cbiAgLyoqXG4gICAqIFRyaWVzIHRvIGRldGVjdCB0aGUgYmFzZSBwYXRoIG9mIGJhc2UuanMgc2NyaXB0IHRoYXQgYm9vdHN0cmFwcyBDbG9zdXJlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5maW5kQmFzZVBhdGhfID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGdvb2cuaXNEZWYoZ29vZy5nbG9iYWwuQ0xPU1VSRV9CQVNFX1BBVEgpKSB7XG4gICAgICBnb29nLmJhc2VQYXRoID0gZ29vZy5nbG9iYWwuQ0xPU1VSRV9CQVNFX1BBVEg7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICghZ29vZy5pbkh0bWxEb2N1bWVudF8oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKiogQHR5cGUge0RvY3VtZW50fSAqL1xuICAgIHZhciBkb2MgPSBnb29nLmdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgc2NyaXB0cyA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnU0NSSVBUJyk7XG4gICAgLy8gU2VhcmNoIGJhY2t3YXJkcyBzaW5jZSB0aGUgY3VycmVudCBzY3JpcHQgaXMgaW4gYWxtb3N0IGFsbCBjYXNlcyB0aGUgb25lXG4gICAgLy8gdGhhdCBoYXMgYmFzZS5qcy5cbiAgICBmb3IgKHZhciBpID0gc2NyaXB0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIHNjcmlwdCA9IC8qKiBAdHlwZSB7IUhUTUxTY3JpcHRFbGVtZW50fSAqLyAoc2NyaXB0c1tpXSk7XG4gICAgICB2YXIgc3JjID0gc2NyaXB0LnNyYztcbiAgICAgIHZhciBxbWFyayA9IHNyYy5sYXN0SW5kZXhPZignPycpO1xuICAgICAgdmFyIGwgPSBxbWFyayA9PSAtMSA/IHNyYy5sZW5ndGggOiBxbWFyaztcbiAgICAgIGlmIChzcmMuc3Vic3RyKGwgLSA3LCA3KSA9PSAnYmFzZS5qcycpIHtcbiAgICAgICAgZ29vZy5iYXNlUGF0aCA9IHNyYy5zdWJzdHIoMCwgbCAtIDcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEltcG9ydHMgYSBzY3JpcHQgaWYsIGFuZCBvbmx5IGlmLCB0aGF0IHNjcmlwdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIGltcG9ydGVkLlxuICAgKiAoTXVzdCBiZSBjYWxsZWQgYXQgZXhlY3V0aW9uIHRpbWUpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgU2NyaXB0IHNvdXJjZS5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfc291cmNlVGV4dCBUaGUgb3B0aW9uYWxseSBzb3VyY2UgdGV4dCB0byBldmFsdWF0ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pbXBvcnRTY3JpcHRfID0gZnVuY3Rpb24oc3JjLCBvcHRfc291cmNlVGV4dCkge1xuICAgIHZhciBpbXBvcnRTY3JpcHQgPVxuICAgICAgICBnb29nLmdsb2JhbC5DTE9TVVJFX0lNUE9SVF9TQ1JJUFQgfHwgZ29vZy53cml0ZVNjcmlwdFRhZ187XG4gICAgaWYgKGltcG9ydFNjcmlwdChzcmMsIG9wdF9zb3VyY2VUZXh0KSkge1xuICAgICAgZ29vZy5kZXBlbmRlbmNpZXNfLndyaXR0ZW5bc3JjXSA9IHRydWU7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqIEBjb25zdCBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgZ29vZy5JU19PTERfSUVfID1cbiAgICAgICEhKCFnb29nLmdsb2JhbC5hdG9iICYmIGdvb2cuZ2xvYmFsLmRvY3VtZW50ICYmIGdvb2cuZ2xvYmFsLmRvY3VtZW50LmFsbCk7XG5cblxuICAvKipcbiAgICogR2l2ZW4gYSBVUkwgaW5pdGlhdGUgcmV0cmlldmFsIGFuZCBleGVjdXRpb24gb2YgdGhlIG1vZHVsZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNyYyBTY3JpcHQgc291cmNlIFVSTC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuaW1wb3J0TW9kdWxlXyA9IGZ1bmN0aW9uKHNyYykge1xuICAgIC8vIEluIGFuIGF0dGVtcHQgdG8ga2VlcCBicm93c2VycyBmcm9tIHRpbWluZyBvdXQgbG9hZGluZyBzY3JpcHRzIHVzaW5nXG4gICAgLy8gc3luY2hyb25vdXMgWEhScywgcHV0IGVhY2ggbG9hZCBpbiBpdHMgb3duIHNjcmlwdCBibG9jay5cbiAgICB2YXIgYm9vdHN0cmFwID0gJ2dvb2cucmV0cmlldmVBbmRFeGVjTW9kdWxlXyhcIicgKyBzcmMgKyAnXCIpOyc7XG5cbiAgICBpZiAoZ29vZy5pbXBvcnRTY3JpcHRfKCcnLCBib290c3RyYXApKSB7XG4gICAgICBnb29nLmRlcGVuZGVuY2llc18ud3JpdHRlbltzcmNdID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cblxuICAvKiogQHByaXZhdGUgeyFBcnJheTxzdHJpbmc+fSAqL1xuICBnb29nLnF1ZXVlZE1vZHVsZXNfID0gW107XG5cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFwcHJvcHJpYXRlIG1vZHVsZSB0ZXh0LiBTdWl0YWJsZSB0byBpbnNlcnQgaW50b1xuICAgKiBhIHNjcmlwdCB0YWcgKHRoYXQgaXMgdW5lc2NhcGVkKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNyY1VybFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2NyaXB0VGV4dFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLndyYXBNb2R1bGVfID0gZnVuY3Rpb24oc3JjVXJsLCBzY3JpcHRUZXh0KSB7XG4gICAgaWYgKCFnb29nLkxPQURfTU9EVUxFX1VTSU5HX0VWQUwgfHwgIWdvb2cuaXNEZWYoZ29vZy5nbG9iYWwuSlNPTikpIHtcbiAgICAgIHJldHVybiAnJyArXG4gICAgICAgICAgJ2dvb2cubG9hZE1vZHVsZShmdW5jdGlvbihleHBvcnRzKSB7JyArXG4gICAgICAgICAgJ1widXNlIHN0cmljdFwiOycgKyBzY3JpcHRUZXh0ICtcbiAgICAgICAgICAnXFxuJyArICAvLyB0ZXJtaW5hdGUgYW55IHRyYWlsaW5nIHNpbmdsZSBsaW5lIGNvbW1lbnQuXG4gICAgICAgICAgJztyZXR1cm4gZXhwb3J0cycgK1xuICAgICAgICAgICd9KTsnICtcbiAgICAgICAgICAnXFxuLy8jIHNvdXJjZVVSTD0nICsgc3JjVXJsICsgJ1xcbic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnJyArXG4gICAgICAgICAgJ2dvb2cubG9hZE1vZHVsZSgnICtcbiAgICAgICAgICBnb29nLmdsb2JhbC5KU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgc2NyaXB0VGV4dCArICdcXG4vLyMgc291cmNlVVJMPScgKyBzcmNVcmwgKyAnXFxuJykgK1xuICAgICAgICAgICcpOyc7XG4gICAgfVxuICB9O1xuXG4gIC8vIE9uIElFOSBhbmQgZWFybGllciwgaXQgaXMgbmVjZXNzYXJ5IHRvIGhhbmRsZVxuICAvLyBkZWZlcnJlZCBtb2R1bGUgbG9hZHMuIEluIGxhdGVyIGJyb3dzZXJzLCB0aGVcbiAgLy8gY29kZSB0byBiZSBldmFsdWF0ZWQgaXMgc2ltcGx5IGluc2VydGVkIGFzIGEgc2NyaXB0XG4gIC8vIGJsb2NrIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBUbyBldmFsIGRlZmVycmVkXG4gIC8vIGNvZGUgYXQgdGhlIHJpZ2h0IHRpbWUsIHdlIHBpZ2d5IGJhY2sgb24gZ29vZy5yZXF1aXJlIHRvIGNhbGxcbiAgLy8gZ29vZy5tYXliZVByb2Nlc3NEZWZlcnJlZERlcF8uXG4gIC8vXG4gIC8vIFRoZSBnb29nLnJlcXVpcmVzIGFyZSB1c2VkIGJvdGggdG8gYm9vdHN0cmFwXG4gIC8vIHRoZSBsb2FkaW5nIHByb2Nlc3MgKHdoZW4gbm8gZGVwcyBhcmUgYXZhaWxhYmxlKSBhbmRcbiAgLy8gZGVjbGFyZSB0aGF0IHRoZXkgc2hvdWxkIGJlIGF2YWlsYWJsZS5cbiAgLy9cbiAgLy8gSGVyZSB3ZSBldmFsIHRoZSBzb3VyY2VzLCBpZiBhbGwgdGhlIGRlcHMgYXJlIGF2YWlsYWJsZVxuICAvLyBlaXRoZXIgYWxyZWFkeSBldmFsJ2Qgb3IgZ29vZy5yZXF1aXJlJ2QuICBUaGlzIHdpbGxcbiAgLy8gYmUgdGhlIGNhc2Ugd2hlbiBhbGwgdGhlIGRlcGVuZGVuY2llcyBoYXZlIGFscmVhZHlcbiAgLy8gYmVlbiBsb2FkZWQsIGFuZCB0aGUgZGVwZW5kZW50IG1vZHVsZSBpcyBsb2FkZWQuXG4gIC8vXG4gIC8vIEJ1dCB0aGlzIGFsb25lIGlzbid0IHN1ZmZpY2llbnQgYmVjYXVzZSBpdCBpcyBhbHNvXG4gIC8vIG5lY2Vzc2FyeSB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlcmUgaXMgbm8gcm9vdFxuICAvLyB0aGF0IGlzIG5vdCBkZWZlcnJlZC4gIEZvciB0aGF0IHRoZXJlIHdlIHJlZ2lzdGVyIGZvciBhbiBldmVudFxuICAvLyBhbmQgdHJpZ2dlciBnb29nLmxvYWRRdWV1ZWRNb2R1bGVzXyBoYW5kbGUgYW55IHJlbWFpbmluZyBkZWZlcnJlZFxuICAvLyBldmFsdWF0aW9ucy5cblxuICAvKipcbiAgICogSGFuZGxlIGFueSByZW1haW5pbmcgZGVmZXJyZWQgZ29vZy5tb2R1bGUgZXZhbHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmxvYWRRdWV1ZWRNb2R1bGVzXyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb3VudCA9IGdvb2cucXVldWVkTW9kdWxlc18ubGVuZ3RoO1xuICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgIHZhciBxdWV1ZSA9IGdvb2cucXVldWVkTW9kdWxlc187XG4gICAgICBnb29nLnF1ZXVlZE1vZHVsZXNfID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHBhdGggPSBxdWV1ZVtpXTtcbiAgICAgICAgZ29vZy5tYXliZVByb2Nlc3NEZWZlcnJlZFBhdGhfKHBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBFdmFsIHRoZSBuYW1lZCBtb2R1bGUgaWYgaXRzIGRlcGVuZGVuY2llcyBhcmVcbiAgICogYXZhaWxhYmxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbW9kdWxlIHRvIGxvYWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLm1heWJlUHJvY2Vzc0RlZmVycmVkRGVwXyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoZ29vZy5pc0RlZmVycmVkTW9kdWxlXyhuYW1lKSAmJiBnb29nLmFsbERlcHNBcmVBdmFpbGFibGVfKG5hbWUpKSB7XG4gICAgICB2YXIgcGF0aCA9IGdvb2cuZ2V0UGF0aEZyb21EZXBzXyhuYW1lKTtcbiAgICAgIGdvb2cubWF5YmVQcm9jZXNzRGVmZXJyZWRQYXRoXyhnb29nLmJhc2VQYXRoICsgcGF0aCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbW9kdWxlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBuYW1lIHJlcHJlc2VudHMgYVxuICAgKiAgICAgbW9kdWxlIHdob3NlIGV2YWx1YXRpb24gaGFzIGJlZW4gZGVmZXJyZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmlzRGVmZXJyZWRNb2R1bGVfID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBwYXRoID0gZ29vZy5nZXRQYXRoRnJvbURlcHNfKG5hbWUpO1xuICAgIGlmIChwYXRoICYmIGdvb2cuZGVwZW5kZW5jaWVzXy5wYXRoSXNNb2R1bGVbcGF0aF0pIHtcbiAgICAgIHZhciBhYnNwYXRoID0gZ29vZy5iYXNlUGF0aCArIHBhdGg7XG4gICAgICByZXR1cm4gKGFic3BhdGgpIGluIGdvb2cuZGVwZW5kZW5jaWVzXy5kZWZlcnJlZDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbW9kdWxlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBuYW1lIHJlcHJlc2VudHMgYVxuICAgKiAgICAgbW9kdWxlIHdob3NlIGRlY2xhcmVkIGRlcGVuZGVuY2llcyBoYXZlIGFsbCBiZWVuIGxvYWRlZFxuICAgKiAgICAgKGV2YWwnZCBvciBhIGRlZmVycmVkIG1vZHVsZSBsb2FkKVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5hbGxEZXBzQXJlQXZhaWxhYmxlXyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgcGF0aCA9IGdvb2cuZ2V0UGF0aEZyb21EZXBzXyhuYW1lKTtcbiAgICBpZiAocGF0aCAmJiAocGF0aCBpbiBnb29nLmRlcGVuZGVuY2llc18ucmVxdWlyZXMpKSB7XG4gICAgICBmb3IgKHZhciByZXF1aXJlTmFtZSBpbiBnb29nLmRlcGVuZGVuY2llc18ucmVxdWlyZXNbcGF0aF0pIHtcbiAgICAgICAgaWYgKCFnb29nLmlzUHJvdmlkZWRfKHJlcXVpcmVOYW1lKSAmJlxuICAgICAgICAgICAgIWdvb2cuaXNEZWZlcnJlZE1vZHVsZV8ocmVxdWlyZU5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhYnNwYXRoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLm1heWJlUHJvY2Vzc0RlZmVycmVkUGF0aF8gPSBmdW5jdGlvbihhYnNwYXRoKSB7XG4gICAgaWYgKGFic3BhdGggaW4gZ29vZy5kZXBlbmRlbmNpZXNfLmRlZmVycmVkKSB7XG4gICAgICB2YXIgc3JjID0gZ29vZy5kZXBlbmRlbmNpZXNfLmRlZmVycmVkW2Fic3BhdGhdO1xuICAgICAgZGVsZXRlIGdvb2cuZGVwZW5kZW5jaWVzXy5kZWZlcnJlZFthYnNwYXRoXTtcbiAgICAgIGdvb2cuZ2xvYmFsRXZhbChzcmMpO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBMb2FkIGEgZ29vZy5tb2R1bGUgZnJvbSB0aGUgcHJvdmlkZWQgVVJMLiAgVGhpcyBpcyBub3QgYSBnZW5lcmFsIHB1cnBvc2VcbiAgICogY29kZSBsb2FkZXIgYW5kIGRvZXMgbm90IHN1cHBvcnQgbGF0ZSBsb2FkaW5nIGNvZGUsIHRoYXQgaXMgaXQgc2hvdWxkIG9ubHlcbiAgICogYmUgdXNlZCBkdXJpbmcgcGFnZSBsb2FkLiBUaGlzIG1ldGhvZCBleGlzdHMgdG8gc3VwcG9ydCB1bml0IHRlc3RzIGFuZFxuICAgKiBcImRlYnVnXCIgbG9hZGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBoYXZlIGluc2VydGVkIHNjcmlwdCB0YWdzLiBVbmRlciB0aGVcbiAgICogaG9vZCB0aGlzIG5lZWRzIHRvIHVzZSBhIHN5bmNocm9ub3VzIFhIUiBhbmQgaXMgbm90IHJlY29tbWVuZWRlZCBmb3JcbiAgICogcHJvZHVjdGlvbiBjb2RlLlxuICAgKlxuICAgKiBUaGUgbW9kdWxlJ3MgZ29vZy5yZXF1aXJlcyBtdXN0IGhhdmUgYWxyZWFkeSBiZWVuIHNhdGlzaWZpZWQ7IGFuIGV4Y2VwdGlvblxuICAgKiB3aWxsIGJlIHRocm93biBpZiB0aGlzIGlzIG5vdCB0aGUgY2FzZS4gVGhpcyBhc3N1bXB0aW9uIGlzIHRoYXQgbm9cbiAgICogXCJkZXBzLmpzXCIgZmlsZSBleGlzdHMsIHNvIHRoZXJlIGlzIG5vIHdheSB0byBkaXNjb3ZlciBhbmQgbG9jYXRlIHRoZVxuICAgKiBtb2R1bGUtdG8tYmUtbG9hZGVkJ3MgZGVwZW5kZW5jaWVzIGFuZCBubyBhdHRlbXB0IGlzIG1hZGUgdG8gZG8gc28uXG4gICAqXG4gICAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIG9uZSBhdHRlbXB0IHRvIGxvYWQgYSBtb2R1bGUuICBJZlxuICAgKiBcImdvb2cubG9hZE1vZHVsZUZyb21VcmxcIiBpcyBjYWxsZWQgZm9yIGFuIGFscmVhZHkgbG9hZGVkIG1vZHVsZSwgYW5cbiAgICogZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3cuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCBmcm9tIHdoaWNoIHRvIGF0dGVtcHQgdG8gbG9hZCB0aGUgZ29vZy5tb2R1bGUuXG4gICAqL1xuICBnb29nLmxvYWRNb2R1bGVGcm9tVXJsID0gZnVuY3Rpb24odXJsKSB7XG4gICAgLy8gQmVjYXVzZSB0aGlzIGV4ZWN1dGVzIHN5bmNocm9ub3VzbHksIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55IGFkZGl0aW9uYWxcbiAgICAvLyBib29ra2VlcGluZy4gV2hlbiBcImdvb2cubG9hZE1vZHVsZVwiIHRoZSBuYW1lc3BhY2Ugd2lsbCBiZSBtYXJrZWQgYXNcbiAgICAvLyBoYXZpbmcgYmVlbiBwcm92aWRlZCB3aGljaCBpcyBzdWZmaWNpZW50LlxuICAgIGdvb2cucmV0cmlldmVBbmRFeGVjTW9kdWxlXyh1cmwpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oPyk6P3xzdHJpbmd9IG1vZHVsZURlZiBUaGUgbW9kdWxlIGRlZmluaXRpb24uXG4gICAqL1xuICBnb29nLmxvYWRNb2R1bGUgPSBmdW5jdGlvbihtb2R1bGVEZWYpIHtcbiAgICAvLyBOT1RFOiB3ZSBhbGxvdyBmdW5jdGlvbiBkZWZpbml0aW9ucyB0byBiZSBlaXRoZXIgaW4gdGhlIGZyb21cbiAgICAvLyBvZiBhIHN0cmluZyB0byBldmFsICh3aGljaCBrZWVwcyB0aGUgb3JpZ2luYWwgc291cmNlIGludGFjdCkgb3JcbiAgICAvLyBpbiBhIGV2YWwgZm9yYmlkZGVuIGVudmlyb25tZW50IChDU1ApIHdlIGFsbG93IGEgZnVuY3Rpb24gZGVmaW5pdGlvblxuICAgIC8vIHdoaWNoIGluIGl0cyBib2R5IG11c3QgY2FsbCB7QGNvZGUgZ29vZy5tb2R1bGV9LCBhbmQgcmV0dXJuIHRoZSBleHBvcnRzXG4gICAgLy8gb2YgdGhlIG1vZHVsZS5cbiAgICB2YXIgcHJldmlvdXNTdGF0ZSA9IGdvb2cubW9kdWxlTG9hZGVyU3RhdGVfO1xuICAgIHRyeSB7XG4gICAgICBnb29nLm1vZHVsZUxvYWRlclN0YXRlXyA9IHtcbiAgICAgICAgbW9kdWxlTmFtZTogdW5kZWZpbmVkLFxuICAgICAgICBkZWNsYXJlTGVnYWN5TmFtZXNwYWNlOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHZhciBleHBvcnRzO1xuICAgICAgaWYgKGdvb2cuaXNGdW5jdGlvbihtb2R1bGVEZWYpKSB7XG4gICAgICAgIGV4cG9ydHMgPSBtb2R1bGVEZWYuY2FsbChnb29nLmdsb2JhbCwge30pO1xuICAgICAgfSBlbHNlIGlmIChnb29nLmlzU3RyaW5nKG1vZHVsZURlZikpIHtcbiAgICAgICAgZXhwb3J0cyA9IGdvb2cubG9hZE1vZHVsZUZyb21Tb3VyY2VfLmNhbGwoZ29vZy5nbG9iYWwsIG1vZHVsZURlZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBtb2R1bGUgZGVmaW5pdGlvbicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbW9kdWxlTmFtZSA9IGdvb2cubW9kdWxlTG9hZGVyU3RhdGVfLm1vZHVsZU5hbWU7XG4gICAgICBpZiAoIWdvb2cuaXNTdHJpbmcobW9kdWxlTmFtZSkgfHwgIW1vZHVsZU5hbWUpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgbW9kdWxlIG5hbWUgXFxcIicgKyBtb2R1bGVOYW1lICsgJ1xcXCInKTtcbiAgICAgIH1cblxuICAgICAgLy8gRG9uJ3Qgc2VhbCBsZWdhY3kgbmFtZXNwYWNlcyBhcyB0aGV5IG1heSBiZSB1c2VzIGFzIGEgcGFyZW50IG9mXG4gICAgICAvLyBhbm90aGVyIG5hbWVzcGFjZVxuICAgICAgaWYgKGdvb2cubW9kdWxlTG9hZGVyU3RhdGVfLmRlY2xhcmVMZWdhY3lOYW1lc3BhY2UpIHtcbiAgICAgICAgZ29vZy5jb25zdHJ1Y3ROYW1lc3BhY2VfKG1vZHVsZU5hbWUsIGV4cG9ydHMpO1xuICAgICAgfSBlbHNlIGlmIChnb29nLlNFQUxfTU9EVUxFX0VYUE9SVFMgJiYgT2JqZWN0LnNlYWwpIHtcbiAgICAgICAgT2JqZWN0LnNlYWwoZXhwb3J0cyk7XG4gICAgICB9XG5cbiAgICAgIGdvb2cubG9hZGVkTW9kdWxlc19bbW9kdWxlTmFtZV0gPSBleHBvcnRzO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBnb29nLm1vZHVsZUxvYWRlclN0YXRlXyA9IHByZXZpb3VzU3RhdGU7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlIEBjb25zdCB7ZnVuY3Rpb24oc3RyaW5nKTo/fVxuICAgKlxuICAgKiBUaGUgbmV3IHR5cGUgaW5mZXJlbmNlIHdhcm5zIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBoYXMgbm8gZm9ybWFsXG4gICAqIHBhcmFtZXRlcnMsIGJ1dCBpdHMganNkb2Mgc2F5cyB0aGF0IGl0IHRha2VzIG9uZSBhcmd1bWVudC5cbiAgICogKFRoZSBhcmd1bWVudCBpcyB1c2VkIHZpYSBhcmd1bWVudHNbMF0sIGJ1dCBOVEkgZG9lcyBub3QgZGV0ZWN0IHRoaXMuKVxuICAgKiBAc3VwcHJlc3Mge25ld0NoZWNrVHlwZXN9XG4gICAqL1xuICBnb29nLmxvYWRNb2R1bGVGcm9tU291cmNlXyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIE5PVEU6IHdlIGF2b2lkIGRlY2xhcmluZyBwYXJhbWV0ZXJzIG9yIGxvY2FsIHZhcmlhYmxlcyBoZXJlIHRvIGF2b2lkXG4gICAgLy8gbWFza2luZyBnbG9iYWxzIG9yIGxlYWtpbmcgdmFsdWVzIGludG8gdGhlIG1vZHVsZSBkZWZpbml0aW9uLlxuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgZXhwb3J0cyA9IHt9O1xuICAgIGV2YWwoYXJndW1lbnRzWzBdKTtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBXcml0ZXMgYSBuZXcgc2NyaXB0IHBvaW50aW5nIHRvIHtAY29kZSBzcmN9IGRpcmVjdGx5IGludG8gdGhlIERPTS5cbiAgICpcbiAgICogTk9URTogVGhpcyBtZXRob2QgaXMgbm90IENTUC1jb21wbGlhbnQuIEBzZWUgZ29vZy5hcHBlbmRTY3JpcHRTcmNOb2RlXyBmb3JcbiAgICogdGhlIGZhbGxiYWNrIG1lY2hhbmlzbS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNyYyBUaGUgc2NyaXB0IFVSTC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cud3JpdGVTY3JpcHRTcmNOb2RlXyA9IGZ1bmN0aW9uKHNyYykge1xuICAgIGdvb2cuZ2xvYmFsLmRvY3VtZW50LndyaXRlKFxuICAgICAgICAnPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwiJyArIHNyYyArICdcIj48LycgK1xuICAgICAgICAnc2NyaXB0PicpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgYSBuZXcgc2NyaXB0IG5vZGUgdG8gdGhlIERPTSB1c2luZyBhIENTUC1jb21wbGlhbnQgbWVjaGFuaXNtLiBUaGlzXG4gICAqIG1ldGhvZCBleGlzdHMgYXMgYSBmYWxsYmFjayBmb3IgZG9jdW1lbnQud3JpdGUgKHdoaWNoIGlzIG5vdCBhbGxvd2VkIGluIGFcbiAgICogc3RyaWN0IENTUCBjb250ZXh0LCBlLmcuLCBDaHJvbWUgYXBwcykuXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG5vdCBhbmFsb2dvdXMgdG8gdXNpbmcgZG9jdW1lbnQud3JpdGUgdG8gaW5zZXJ0IGFcbiAgICogPHNjcmlwdD4gdGFnOyBzcGVjaWZpY2FsbHksIHRoZSB1c2VyIGFnZW50IHdpbGwgZXhlY3V0ZSBhIHNjcmlwdCBhZGRlZCBieVxuICAgKiBkb2N1bWVudC53cml0ZSBpbW1lZGlhdGVseSBhZnRlciB0aGUgY3VycmVudCBzY3JpcHQgYmxvY2sgZmluaXNoZXNcbiAgICogZXhlY3V0aW5nLCB3aGVyZWFzIHRoZSBET00tYXBwZW5kZWQgc2NyaXB0IG5vZGUgd2lsbCBub3QgYmUgZXhlY3V0ZWQgdW50aWxcbiAgICogdGhlIGVudGlyZSBkb2N1bWVudCBpcyBwYXJzZWQgYW5kIGV4ZWN1dGVkLiBUaGF0IGlzIHRvIHNheSwgdGhpcyBzY3JpcHQgaXNcbiAgICogYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGUgc2NyaXB0IGV4ZWN1dGlvbiBxdWV1ZS5cbiAgICpcbiAgICogVGhlIHBhZ2UgbXVzdCBub3QgYXR0ZW1wdCB0byBjYWxsIGdvb2cucmVxdWlyZWQgZW50aXRpZXMgdW50aWwgYWZ0ZXIgdGhlXG4gICAqIGRvY3VtZW50IGhhcyBsb2FkZWQsIGUuZy4sIGluIG9yIGFmdGVyIHRoZSB3aW5kb3cub25sb2FkIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFRoZSBzY3JpcHQgVVJMLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5hcHBlbmRTY3JpcHRTcmNOb2RlXyA9IGZ1bmN0aW9uKHNyYykge1xuICAgIC8qKiBAdHlwZSB7RG9jdW1lbnR9ICovXG4gICAgdmFyIGRvYyA9IGdvb2cuZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciBzY3JpcHRFbCA9XG4gICAgICAgIC8qKiBAdHlwZSB7SFRNTFNjcmlwdEVsZW1lbnR9ICovIChkb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpO1xuICAgIHNjcmlwdEVsLnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICBzY3JpcHRFbC5zcmMgPSBzcmM7XG4gICAgc2NyaXB0RWwuZGVmZXIgPSBmYWxzZTtcbiAgICBzY3JpcHRFbC5hc3luYyA9IGZhbHNlO1xuICAgIGRvYy5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdEVsKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgaW1wb3J0IGZ1bmN0aW9uLiBXcml0ZXMgYSBzY3JpcHQgdGFnIHRvXG4gICAqIGltcG9ydCB0aGUgc2NyaXB0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFRoZSBzY3JpcHQgdXJsLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9zb3VyY2VUZXh0IFRoZSBvcHRpb25hbGx5IHNvdXJjZSB0ZXh0IHRvIGV2YWx1YXRlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNjcmlwdCB3YXMgaW1wb3J0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cud3JpdGVTY3JpcHRUYWdfID0gZnVuY3Rpb24oc3JjLCBvcHRfc291cmNlVGV4dCkge1xuICAgIGlmIChnb29nLmluSHRtbERvY3VtZW50XygpKSB7XG4gICAgICAvKiogQHR5cGUgeyFIVE1MRG9jdW1lbnR9ICovXG4gICAgICB2YXIgZG9jID0gZ29vZy5nbG9iYWwuZG9jdW1lbnQ7XG5cbiAgICAgIC8vIElmIHRoZSB1c2VyIHRyaWVzIHRvIHJlcXVpcmUgYSBuZXcgc3ltYm9sIGFmdGVyIGRvY3VtZW50IGxvYWQsXG4gICAgICAvLyBzb21ldGhpbmcgaGFzIGdvbmUgdGVycmlibHkgd3JvbmcuIERvaW5nIGEgZG9jdW1lbnQud3JpdGUgd291bGRcbiAgICAgIC8vIHdpcGUgb3V0IHRoZSBwYWdlLiBUaGlzIGRvZXMgbm90IGFwcGx5IHRvIHRoZSBDU1AtY29tcGxpYW50IG1ldGhvZFxuICAgICAgLy8gb2Ygd3JpdGluZyBzY3JpcHQgdGFncy5cbiAgICAgIGlmICghZ29vZy5FTkFCTEVfQ0hST01FX0FQUF9TQUZFX1NDUklQVF9MT0FESU5HICYmXG4gICAgICAgICAgZG9jLnJlYWR5U3RhdGUgPT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAvLyBDZXJ0YWluIHRlc3QgZnJhbWV3b3JrcyBsb2FkIGJhc2UuanMgbXVsdGlwbGUgdGltZXMsIHdoaWNoIHRyaWVzXG4gICAgICAgIC8vIHRvIHdyaXRlIGRlcHMuanMgZWFjaCB0aW1lLiBJZiB0aGF0IGhhcHBlbnMsIGp1c3QgZmFpbCBzaWxlbnRseS5cbiAgICAgICAgLy8gVGhlc2UgZnJhbWV3b3JrcyB3aXBlIHRoZSBwYWdlIGJldHdlZW4gZWFjaCBsb2FkIG9mIGJhc2UuanMsIHNvIHRoaXNcbiAgICAgICAgLy8gaXMgT0suXG4gICAgICAgIHZhciBpc0RlcHMgPSAvXFxiZGVwcy5qcyQvLnRlc3Qoc3JjKTtcbiAgICAgICAgaWYgKGlzRGVwcykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignQ2Fubm90IHdyaXRlIFwiJyArIHNyYyArICdcIiBhZnRlciBkb2N1bWVudCBsb2FkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGlzT2xkSUUgPSBnb29nLklTX09MRF9JRV87XG5cbiAgICAgIGlmIChvcHRfc291cmNlVGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghaXNPbGRJRSkge1xuICAgICAgICAgIGlmIChnb29nLkVOQUJMRV9DSFJPTUVfQVBQX1NBRkVfU0NSSVBUX0xPQURJTkcpIHtcbiAgICAgICAgICAgIGdvb2cuYXBwZW5kU2NyaXB0U3JjTm9kZV8oc3JjKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ29vZy53cml0ZVNjcmlwdFNyY05vZGVfKHNyYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdGF0ZSA9IFwiIG9ucmVhZHlzdGF0ZWNoYW5nZT0nZ29vZy5vblNjcmlwdExvYWRfKHRoaXMsIFwiICtcbiAgICAgICAgICAgICAgKytnb29nLmxhc3ROb25Nb2R1bGVTY3JpcHRJbmRleF8gKyBcIiknIFwiO1xuICAgICAgICAgIGRvYy53cml0ZShcbiAgICAgICAgICAgICAgJzxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIicgKyBzcmMgKyAnXCInICsgc3RhdGUgK1xuICAgICAgICAgICAgICAnPjwvJyArXG4gICAgICAgICAgICAgICdzY3JpcHQ+Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvYy53cml0ZShcbiAgICAgICAgICAgICc8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIj4nICsgb3B0X3NvdXJjZVRleHQgKyAnPC8nICtcbiAgICAgICAgICAgICdzY3JpcHQ+Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICBnb29nLmxhc3ROb25Nb2R1bGVTY3JpcHRJbmRleF8gPSAwO1xuXG5cbiAgLyoqXG4gICAqIEEgcmVhZHlzdGF0ZWNoYW5nZSBoYW5kbGVyIGZvciBsZWdhY3kgSUVcbiAgICogQHBhcmFtIHshSFRNTFNjcmlwdEVsZW1lbnR9IHNjcmlwdFxuICAgKiBAcGFyYW0ge251bWJlcn0gc2NyaXB0SW5kZXhcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cub25TY3JpcHRMb2FkXyA9IGZ1bmN0aW9uKHNjcmlwdCwgc2NyaXB0SW5kZXgpIHtcbiAgICAvLyBmb3Igbm93IGxvYWQgdGhlIG1vZHVsZXMgd2hlbiB3ZSByZWFjaCB0aGUgbGFzdCBzY3JpcHQsXG4gICAgLy8gbGF0ZXIgYWxsb3cgbW9yZSBpbnRlci1taW5nbGluZy5cbiAgICBpZiAoc2NyaXB0LnJlYWR5U3RhdGUgPT0gJ2NvbXBsZXRlJyAmJlxuICAgICAgICBnb29nLmxhc3ROb25Nb2R1bGVTY3JpcHRJbmRleF8gPT0gc2NyaXB0SW5kZXgpIHtcbiAgICAgIGdvb2cubG9hZFF1ZXVlZE1vZHVsZXNfKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyBkZXBlbmRlbmNpZXMgYmFzZWQgb24gdGhlIGRlcGVuZGVuY2llcyBhZGRlZCB1c2luZyBhZGREZXBlbmRlbmN5XG4gICAqIGFuZCBjYWxscyBpbXBvcnRTY3JpcHRfIGluIHRoZSBjb3JyZWN0IG9yZGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFRvTG9hZCBUaGUgcGF0aCBmcm9tIHdoaWNoIHRvIHN0YXJ0IGRpc2NvdmVyaW5nXG4gICAqICAgICBkZXBlbmRlbmNpZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLndyaXRlU2NyaXB0c18gPSBmdW5jdGlvbihwYXRoVG9Mb2FkKSB7XG4gICAgLyoqIEB0eXBlIHshQXJyYXk8c3RyaW5nPn0gVGhlIHNjcmlwdHMgd2UgbmVlZCB0byB3cml0ZSB0aGlzIHRpbWUuICovXG4gICAgdmFyIHNjcmlwdHMgPSBbXTtcbiAgICB2YXIgc2VlblNjcmlwdCA9IHt9O1xuICAgIHZhciBkZXBzID0gZ29vZy5kZXBlbmRlbmNpZXNfO1xuXG4gICAgLyoqIEBwYXJhbSB7c3RyaW5nfSBwYXRoICovXG4gICAgZnVuY3Rpb24gdmlzaXROb2RlKHBhdGgpIHtcbiAgICAgIGlmIChwYXRoIGluIGRlcHMud3JpdHRlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSB2aXNpdGVkIHRoaXMgb25lLiBXZSBjYW4gZ2V0IGhlcmUgaWYgd2UgaGF2ZSBjeWNsaWNcbiAgICAgIC8vIGRlcGVuZGVuY2llcy5cbiAgICAgIGlmIChwYXRoIGluIGRlcHMudmlzaXRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRlcHMudmlzaXRlZFtwYXRoXSA9IHRydWU7XG5cbiAgICAgIGlmIChwYXRoIGluIGRlcHMucmVxdWlyZXMpIHtcbiAgICAgICAgZm9yICh2YXIgcmVxdWlyZU5hbWUgaW4gZGVwcy5yZXF1aXJlc1twYXRoXSkge1xuICAgICAgICAgIC8vIElmIHRoZSByZXF1aXJlZCBuYW1lIGlzIGRlZmluZWQsIHdlIGFzc3VtZSB0aGF0IGl0IHdhcyBhbHJlYWR5XG4gICAgICAgICAgLy8gYm9vdHN0cmFwcGVkIGJ5IG90aGVyIG1lYW5zLlxuICAgICAgICAgIGlmICghZ29vZy5pc1Byb3ZpZGVkXyhyZXF1aXJlTmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChyZXF1aXJlTmFtZSBpbiBkZXBzLm5hbWVUb1BhdGgpIHtcbiAgICAgICAgICAgICAgdmlzaXROb2RlKGRlcHMubmFtZVRvUGF0aFtyZXF1aXJlTmFtZV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1VuZGVmaW5lZCBuYW1lVG9QYXRoIGZvciAnICsgcmVxdWlyZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIShwYXRoIGluIHNlZW5TY3JpcHQpKSB7XG4gICAgICAgIHNlZW5TY3JpcHRbcGF0aF0gPSB0cnVlO1xuICAgICAgICBzY3JpcHRzLnB1c2gocGF0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmlzaXROb2RlKHBhdGhUb0xvYWQpO1xuXG4gICAgLy8gcmVjb3JkIHRoYXQgd2UgYXJlIGdvaW5nIHRvIGxvYWQgYWxsIHRoZXNlIHNjcmlwdHMuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGF0aCA9IHNjcmlwdHNbaV07XG4gICAgICBnb29nLmRlcGVuZGVuY2llc18ud3JpdHRlbltwYXRoXSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gSWYgYSBtb2R1bGUgaXMgbG9hZGVkIHN5bmNocm9ub3VzbHkgdGhlbiB3ZSBuZWVkIHRvXG4gICAgLy8gY2xlYXIgdGhlIGN1cnJlbnQgaW5Nb2R1bGVMb2FkZXIgdmFsdWUsIGFuZCByZXN0b3JlIGl0IHdoZW4gd2UgYXJlXG4gICAgLy8gZG9uZSBsb2FkaW5nIHRoZSBjdXJyZW50IFwicmVxdWlyZXNcIi5cbiAgICB2YXIgbW9kdWxlU3RhdGUgPSBnb29nLm1vZHVsZUxvYWRlclN0YXRlXztcbiAgICBnb29nLm1vZHVsZUxvYWRlclN0YXRlXyA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXRoID0gc2NyaXB0c1tpXTtcbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIGlmICghZGVwcy5wYXRoSXNNb2R1bGVbcGF0aF0pIHtcbiAgICAgICAgICBnb29nLmltcG9ydFNjcmlwdF8oZ29vZy5iYXNlUGF0aCArIHBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdvb2cuaW1wb3J0TW9kdWxlXyhnb29nLmJhc2VQYXRoICsgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdvb2cubW9kdWxlTG9hZGVyU3RhdGVfID0gbW9kdWxlU3RhdGU7XG4gICAgICAgIHRocm93IEVycm9yKCdVbmRlZmluZWQgc2NyaXB0IGlucHV0Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVzdG9yZSB0aGUgY3VycmVudCBcIm1vZHVsZSBsb2FkaW5nIHN0YXRlXCJcbiAgICBnb29nLm1vZHVsZUxvYWRlclN0YXRlXyA9IG1vZHVsZVN0YXRlO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIExvb2tzIGF0IHRoZSBkZXBlbmRlbmN5IHJ1bGVzIGFuZCB0cmllcyB0byBkZXRlcm1pbmUgdGhlIHNjcmlwdCBmaWxlIHRoYXRcbiAgICogZnVsZmlsbHMgYSBwYXJ0aWN1bGFyIHJ1bGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBydWxlIEluIHRoZSBmb3JtIGdvb2cubmFtZXNwYWNlLkNsYXNzIG9yIHByb2plY3Quc2NyaXB0LlxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBVcmwgY29ycmVzcG9uZGluZyB0byB0aGUgcnVsZSwgb3IgbnVsbC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuZ2V0UGF0aEZyb21EZXBzXyA9IGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICBpZiAocnVsZSBpbiBnb29nLmRlcGVuZGVuY2llc18ubmFtZVRvUGF0aCkge1xuICAgICAgcmV0dXJuIGdvb2cuZGVwZW5kZW5jaWVzXy5uYW1lVG9QYXRoW3J1bGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgZ29vZy5maW5kQmFzZVBhdGhfKCk7XG5cbiAgLy8gQWxsb3cgcHJvamVjdHMgdG8gbWFuYWdlIHRoZSBkZXBzIGZpbGVzIHRoZW1zZWx2ZXMuXG4gIGlmICghZ29vZy5nbG9iYWwuQ0xPU1VSRV9OT19ERVBTKSB7XG4gICAgZ29vZy5pbXBvcnRTY3JpcHRfKGdvb2cuYmFzZVBhdGggKyAnZGVwcy5qcycpO1xuICB9XG59XG5cblxuLyoqXG4gKiBOb3JtYWxpemUgYSBmaWxlIHBhdGggYnkgcmVtb3ZpbmcgcmVkdW5kYW50IFwiLi5cIiBhbmQgZXh0cmFuZW91cyBcIi5cIiBmaWxlXG4gKiBwYXRoIGNvbXBvbmVudHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5ub3JtYWxpemVQYXRoXyA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGNvbXBvbmVudHMgPSBwYXRoLnNwbGl0KCcvJyk7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGkgPCBjb21wb25lbnRzLmxlbmd0aCkge1xuICAgIGlmIChjb21wb25lbnRzW2ldID09ICcuJykge1xuICAgICAgY29tcG9uZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgaSAmJiBjb21wb25lbnRzW2ldID09ICcuLicgJiYgY29tcG9uZW50c1tpIC0gMV0gJiZcbiAgICAgICAgY29tcG9uZW50c1tpIC0gMV0gIT0gJy4uJykge1xuICAgICAgY29tcG9uZW50cy5zcGxpY2UoLS1pLCAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcG9uZW50cy5qb2luKCcvJyk7XG59O1xuXG5cbi8qKlxuICogTG9hZHMgZmlsZSBieSBzeW5jaHJvbm91cyBYSFIuIFNob3VsZCBub3QgYmUgdXNlZCBpbiBwcm9kdWN0aW9uIGVudmlyb25tZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgU291cmNlIFVSTC5cbiAqIEByZXR1cm4ge3N0cmluZ30gRmlsZSBjb250ZW50cy5cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cubG9hZEZpbGVTeW5jXyA9IGZ1bmN0aW9uKHNyYykge1xuICBpZiAoZ29vZy5nbG9iYWwuQ0xPU1VSRV9MT0FEX0ZJTEVfU1lOQykge1xuICAgIHJldHVybiBnb29nLmdsb2JhbC5DTE9TVVJFX0xPQURfRklMRV9TWU5DKHNyYyk7XG4gIH0gZWxzZSB7XG4gICAgLyoqIEB0eXBlIHtYTUxIdHRwUmVxdWVzdH0gKi9cbiAgICB2YXIgeGhyID0gbmV3IGdvb2cuZ2xvYmFsWydYTUxIdHRwUmVxdWVzdCddKCk7XG4gICAgeGhyLm9wZW4oJ2dldCcsIHNyYywgZmFsc2UpO1xuICAgIHhoci5zZW5kKCk7XG4gICAgcmV0dXJuIHhoci5yZXNwb25zZVRleHQ7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZXRyaWV2ZSBhbmQgZXhlY3V0ZSBhIG1vZHVsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgU2NyaXB0IHNvdXJjZSBVUkwuXG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLnJldHJpZXZlQW5kRXhlY01vZHVsZV8gPSBmdW5jdGlvbihzcmMpIHtcbiAgaWYgKCFDT01QSUxFRCkge1xuICAgIC8vIFRoZSBmdWxsIGJ1dCBub24tY2Fub25pY2FsaXplZCBVUkwgZm9yIGxhdGVyIHVzZS5cbiAgICB2YXIgb3JpZ2luYWxQYXRoID0gc3JjO1xuICAgIC8vIENhbm9uaWNhbGl6ZSB0aGUgcGF0aCwgcmVtb3ZpbmcgYW55IC8uLyBvciAvLi4vIHNpbmNlIENocm9tZSdzIGRlYnVnZ2luZ1xuICAgIC8vIGNvbnNvbGUgZG9lc24ndCBhdXRvLWNhbm9uaWNhbGl6ZSBYSFIgbG9hZHMgYXMgaXQgZG9lcyA8c2NyaXB0PiBzcmNzLlxuICAgIHNyYyA9IGdvb2cubm9ybWFsaXplUGF0aF8oc3JjKTtcblxuICAgIHZhciBpbXBvcnRTY3JpcHQgPVxuICAgICAgICBnb29nLmdsb2JhbC5DTE9TVVJFX0lNUE9SVF9TQ1JJUFQgfHwgZ29vZy53cml0ZVNjcmlwdFRhZ187XG5cbiAgICB2YXIgc2NyaXB0VGV4dCA9IGdvb2cubG9hZEZpbGVTeW5jXyhzcmMpO1xuXG4gICAgaWYgKHNjcmlwdFRleHQgIT0gbnVsbCkge1xuICAgICAgdmFyIGV4ZWNNb2R1bGVTY3JpcHQgPSBnb29nLndyYXBNb2R1bGVfKHNyYywgc2NyaXB0VGV4dCk7XG4gICAgICB2YXIgaXNPbGRJRSA9IGdvb2cuSVNfT0xEX0lFXztcbiAgICAgIGlmIChpc09sZElFKSB7XG4gICAgICAgIGdvb2cuZGVwZW5kZW5jaWVzXy5kZWZlcnJlZFtvcmlnaW5hbFBhdGhdID0gZXhlY01vZHVsZVNjcmlwdDtcbiAgICAgICAgZ29vZy5xdWV1ZWRNb2R1bGVzXy5wdXNoKG9yaWdpbmFsUGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbXBvcnRTY3JpcHQoc3JjLCBleGVjTW9kdWxlU2NyaXB0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb2FkIG9mICcgKyBzcmMgKyAnZmFpbGVkJyk7XG4gICAgfVxuICB9XG59O1xuXG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMYW5ndWFnZSBFbmhhbmNlbWVudHNcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuLyoqXG4gKiBUaGlzIGlzIGEgXCJmaXhlZFwiIHZlcnNpb24gb2YgdGhlIHR5cGVvZiBvcGVyYXRvci4gIEl0IGRpZmZlcnMgZnJvbSB0aGUgdHlwZW9mXG4gKiBvcGVyYXRvciBpbiBzdWNoIGEgd2F5IHRoYXQgbnVsbCByZXR1cm5zICdudWxsJyBhbmQgYXJyYXlzIHJldHVybiAnYXJyYXknLlxuICogQHBhcmFtIHs/fSB2YWx1ZSBUaGUgdmFsdWUgdG8gZ2V0IHRoZSB0eXBlIG9mLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgdHlwZS5cbiAqL1xuZ29vZy50eXBlT2YgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgcyA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHMgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIC8vIENoZWNrIHRoZXNlIGZpcnN0LCBzbyB3ZSBjYW4gYXZvaWQgY2FsbGluZyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIGlmXG4gICAgICAvLyBwb3NzaWJsZS5cbiAgICAgIC8vXG4gICAgICAvLyBJRSBpbXByb3Blcmx5IG1hcnNoYWxzIHR5cGVvZiBhY3Jvc3MgZXhlY3V0aW9uIGNvbnRleHRzLCBidXQgYVxuICAgICAgLy8gY3Jvc3MtY29udGV4dCBvYmplY3Qgd2lsbCBzdGlsbCByZXR1cm4gZmFsc2UgZm9yIFwiaW5zdGFuY2VvZiBPYmplY3RcIi5cbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICByZXR1cm4gcztcbiAgICAgIH1cblxuICAgICAgLy8gSEFDSzogSW4gb3JkZXIgdG8gdXNlIGFuIE9iamVjdCBwcm90b3R5cGUgbWV0aG9kIG9uIHRoZSBhcmJpdHJhcnlcbiAgICAgIC8vICAgdmFsdWUsIHRoZSBjb21waWxlciByZXF1aXJlcyB0aGUgdmFsdWUgYmUgY2FzdCB0byB0eXBlIE9iamVjdCxcbiAgICAgIC8vICAgZXZlbiB0aG91Z2ggdGhlIEVDTUEgc3BlYyBleHBsaWNpdGx5IGFsbG93cyBpdC5cbiAgICAgIHZhciBjbGFzc05hbWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoXG4gICAgICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAodmFsdWUpKTtcbiAgICAgIC8vIEluIEZpcmVmb3ggMy42LCBhdHRlbXB0aW5nIHRvIGFjY2VzcyBpZnJhbWUgd2luZG93IG9iamVjdHMnIGxlbmd0aFxuICAgICAgLy8gcHJvcGVydHkgdGhyb3dzIGFuIE5TX0VSUk9SX0ZBSUxVUkUsIHNvIHdlIG5lZWQgdG8gc3BlY2lhbC1jYXNlIGl0XG4gICAgICAvLyBoZXJlLlxuICAgICAgaWYgKGNsYXNzTmFtZSA9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGNhbm5vdCBhbHdheXMgdXNlIGNvbnN0cnVjdG9yID09IEFycmF5IG9yIGluc3RhbmNlb2YgQXJyYXkgYmVjYXVzZVxuICAgICAgLy8gZGlmZmVyZW50IGZyYW1lcyBoYXZlIGRpZmZlcmVudCBBcnJheSBvYmplY3RzLiBJbiBJRTYsIGlmIHRoZSBpZnJhbWVcbiAgICAgIC8vIHdoZXJlIHRoZSBhcnJheSB3YXMgY3JlYXRlZCBpcyBkZXN0cm95ZWQsIHRoZSBhcnJheSBsb3NlcyBpdHNcbiAgICAgIC8vIHByb3RvdHlwZS4gVGhlbiBkZXJlZmVyZW5jaW5nIHZhbC5zcGxpY2UgaGVyZSB0aHJvd3MgYW4gZXhjZXB0aW9uLCBzb1xuICAgICAgLy8gd2UgY2FuJ3QgdXNlIGdvb2cuaXNGdW5jdGlvbi4gQ2FsbGluZyB0eXBlb2YgZGlyZWN0bHkgcmV0dXJucyAndW5rbm93bidcbiAgICAgIC8vIHNvIHRoYXQgd2lsbCB3b3JrLiBJbiB0aGlzIGNhc2UsIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gZmFsc2UgYW5kXG4gICAgICAvLyBtb3N0IGFycmF5IGZ1bmN0aW9ucyB3aWxsIHN0aWxsIHdvcmsgYmVjYXVzZSB0aGUgYXJyYXkgaXMgc3RpbGxcbiAgICAgIC8vIGFycmF5LWxpa2UgKHN1cHBvcnRzIGxlbmd0aCBhbmQgW10pIGV2ZW4gdGhvdWdoIGl0IGhhcyBsb3N0IGl0c1xuICAgICAgLy8gcHJvdG90eXBlLlxuICAgICAgLy8gTWFyayBNaWxsZXIgbm90aWNlZCB0aGF0IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAgIC8vIGFsbG93cyBhY2Nlc3MgdG8gdGhlIHVuZm9yZ2VhYmxlIFtbQ2xhc3NdXSBwcm9wZXJ0eS5cbiAgICAgIC8vICAxNS4yLjQuMiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nICggKVxuICAgICAgLy8gIFdoZW4gdGhlIHRvU3RyaW5nIG1ldGhvZCBpcyBjYWxsZWQsIHRoZSBmb2xsb3dpbmcgc3RlcHMgYXJlIHRha2VuOlxuICAgICAgLy8gICAgICAxLiBHZXQgdGhlIFtbQ2xhc3NdXSBwcm9wZXJ0eSBvZiB0aGlzIG9iamVjdC5cbiAgICAgIC8vICAgICAgMi4gQ29tcHV0ZSBhIHN0cmluZyB2YWx1ZSBieSBjb25jYXRlbmF0aW5nIHRoZSB0aHJlZSBzdHJpbmdzXG4gICAgICAvLyAgICAgICAgIFwiW29iamVjdCBcIiwgUmVzdWx0KDEpLCBhbmQgXCJdXCIuXG4gICAgICAvLyAgICAgIDMuIFJldHVybiBSZXN1bHQoMikuXG4gICAgICAvLyBhbmQgdGhpcyBiZWhhdmlvciBzdXJ2aXZlcyB0aGUgZGVzdHJ1Y3Rpb24gb2YgdGhlIGV4ZWN1dGlvbiBjb250ZXh0LlxuICAgICAgaWYgKChjbGFzc05hbWUgPT0gJ1tvYmplY3QgQXJyYXldJyB8fFxuICAgICAgICAgICAvLyBJbiBJRSBhbGwgbm9uIHZhbHVlIHR5cGVzIGFyZSB3cmFwcGVkIGFzIG9iamVjdHMgYWNyb3NzIHdpbmRvd1xuICAgICAgICAgICAvLyBib3VuZGFyaWVzIChub3QgaWZyYW1lIHRob3VnaCkgc28gd2UgaGF2ZSB0byBkbyBvYmplY3QgZGV0ZWN0aW9uXG4gICAgICAgICAgIC8vIGZvciB0aGlzIGVkZ2UgY2FzZS5cbiAgICAgICAgICAgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlLnNwbGljZSAhPSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlLnByb3BlcnR5SXNFbnVtZXJhYmxlICE9ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAhdmFsdWUucHJvcGVydHlJc0VudW1lcmFibGUoJ3NwbGljZScpXG5cbiAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICB9XG4gICAgICAvLyBIQUNLOiBUaGVyZSBpcyBzdGlsbCBhbiBhcnJheSBjYXNlIHRoYXQgZmFpbHMuXG4gICAgICAvLyAgICAgZnVuY3Rpb24gQXJyYXlJbXBvc3RvcigpIHt9XG4gICAgICAvLyAgICAgQXJyYXlJbXBvc3Rvci5wcm90b3R5cGUgPSBbXTtcbiAgICAgIC8vICAgICB2YXIgaW1wb3N0b3IgPSBuZXcgQXJyYXlJbXBvc3RvcjtcbiAgICAgIC8vIHRoaXMgY2FuIGJlIGZpeGVkIGJ5IGdldHRpbmcgcmlkIG9mIHRoZSBmYXN0IHBhdGhcbiAgICAgIC8vICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSBhbmQgc29sZWx5IHJlbHlpbmcgb25cbiAgICAgIC8vICh2YWx1ZSAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLnZhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKVxuICAgICAgLy8gYnV0IHRoYXQgd291bGQgcmVxdWlyZSBtYW55IG1vcmUgZnVuY3Rpb24gY2FsbHMgYW5kIGlzIG5vdCB3YXJyYW50ZWRcbiAgICAgIC8vIHVubGVzcyBjbG9zdXJlIGNvZGUgaXMgcmVjZWl2aW5nIG9iamVjdHMgZnJvbSB1bnRydXN0ZWQgc291cmNlcy5cblxuICAgICAgLy8gSUUgaW4gY3Jvc3Mtd2luZG93IGNhbGxzIGRvZXMgbm90IGNvcnJlY3RseSBtYXJzaGFsIHRoZSBmdW5jdGlvbiB0eXBlXG4gICAgICAvLyAoaXQgYXBwZWFycyBqdXN0IGFzIGFuIG9iamVjdCkgc28gd2UgY2Fubm90IHVzZSBqdXN0IHR5cGVvZiB2YWwgPT1cbiAgICAgIC8vICdmdW5jdGlvbicuIEhvd2V2ZXIsIGlmIHRoZSBvYmplY3QgaGFzIGEgY2FsbCBwcm9wZXJ0eSwgaXQgaXMgYVxuICAgICAgLy8gZnVuY3Rpb24uXG4gICAgICBpZiAoKGNsYXNzTmFtZSA9PSAnW29iamVjdCBGdW5jdGlvbl0nIHx8XG4gICAgICAgICAgIHR5cGVvZiB2YWx1ZS5jYWxsICE9ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUucHJvcGVydHlJc0VudW1lcmFibGUgIT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICF2YWx1ZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgnY2FsbCcpKSkge1xuICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uJztcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cblxuICB9IGVsc2UgaWYgKHMgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuY2FsbCA9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEluIFNhZmFyaSB0eXBlb2Ygbm9kZUxpc3QgcmV0dXJucyAnZnVuY3Rpb24nLCBhbmQgb24gRmlyZWZveCB0eXBlb2ZcbiAgICAvLyBiZWhhdmVzIHNpbWlsYXJseSBmb3IgSFRNTHtBcHBsZXQsRW1iZWQsT2JqZWN0fSwgRWxlbWVudHMgYW5kIFJlZ0V4cHMuIFdlXG4gICAgLy8gd291bGQgbGlrZSB0byByZXR1cm4gb2JqZWN0IGZvciB0aG9zZSBhbmQgd2UgY2FuIGRldGVjdCBhbiBpbnZhbGlkXG4gICAgLy8gZnVuY3Rpb24gYnkgbWFraW5nIHN1cmUgdGhhdCB0aGUgZnVuY3Rpb24gb2JqZWN0IGhhcyBhIGNhbGwgbWV0aG9kLlxuICAgIHJldHVybiAnb2JqZWN0JztcbiAgfVxuICByZXR1cm4gcztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBudWxsLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgbnVsbC5cbiAqL1xuZ29vZy5pc051bGwgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PT0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBkZWZpbmVkIGFuZCBub3QgbnVsbC5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGRlZmluZWQgYW5kIG5vdCBudWxsLlxuICovXG5nb29nLmlzRGVmQW5kTm90TnVsbCA9IGZ1bmN0aW9uKHZhbCkge1xuICAvLyBOb3RlIHRoYXQgdW5kZWZpbmVkID09IG51bGwuXG4gIHJldHVybiB2YWwgIT0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBhcnJheS5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGFuIGFycmF5LlxuICovXG5nb29nLmlzQXJyYXkgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIGdvb2cudHlwZU9mKHZhbCkgPT0gJ2FycmF5Jztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBsb29rcyBsaWtlIGFuIGFycmF5LiBUbyBxdWFsaWZ5IGFzIGFycmF5IGxpa2VcbiAqIHRoZSB2YWx1ZSBuZWVkcyB0byBiZSBlaXRoZXIgYSBOb2RlTGlzdCBvciBhbiBvYmplY3Qgd2l0aCBhIE51bWJlciBsZW5ndGhcbiAqIHByb3BlcnR5LiBBcyBhIHNwZWNpYWwgY2FzZSwgYSBmdW5jdGlvbiB2YWx1ZSBpcyBub3QgYXJyYXkgbGlrZSwgYmVjYXVzZSBpdHNcbiAqIGxlbmd0aCBwcm9wZXJ0eSBpcyBmaXhlZCB0byBjb3JyZXNwb25kIHRvIHRoZSBudW1iZXIgb2YgZXhwZWN0ZWQgYXJndW1lbnRzLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYW4gYXJyYXkuXG4gKi9cbmdvb2cuaXNBcnJheUxpa2UgPSBmdW5jdGlvbih2YWwpIHtcbiAgdmFyIHR5cGUgPSBnb29nLnR5cGVPZih2YWwpO1xuICAvLyBXZSBkbyBub3QgdXNlIGdvb2cuaXNPYmplY3QgaGVyZSBpbiBvcmRlciB0byBleGNsdWRlIGZ1bmN0aW9uIHZhbHVlcy5cbiAgcmV0dXJuIHR5cGUgPT0gJ2FycmF5JyB8fCB0eXBlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwubGVuZ3RoID09ICdudW1iZXInO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGxvb2tzIGxpa2UgYSBEYXRlLiBUbyBxdWFsaWZ5IGFzIERhdGUtbGlrZSB0aGVcbiAqIHZhbHVlIG5lZWRzIHRvIGJlIGFuIG9iamVjdCBhbmQgaGF2ZSBhIGdldEZ1bGxZZWFyKCkgZnVuY3Rpb24uXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIGxpa2UgYSBEYXRlLlxuICovXG5nb29nLmlzRGF0ZUxpa2UgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIGdvb2cuaXNPYmplY3QodmFsKSAmJiB0eXBlb2YgdmFsLmdldEZ1bGxZZWFyID09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIHN0cmluZy5cbiAqL1xuZ29vZy5pc1N0cmluZyA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PSAnc3RyaW5nJztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGJvb2xlYW4uXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBib29sZWFuLlxuICovXG5nb29nLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PSAnYm9vbGVhbic7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIG51bWJlci5cbiAqL1xuZ29vZy5pc051bWJlciA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PSAnbnVtYmVyJztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYSBmdW5jdGlvbi5cbiAqL1xuZ29vZy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiBnb29nLnR5cGVPZih2YWwpID09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gb2JqZWN0LiAgVGhpcyBpbmNsdWRlcyBhcnJheXMgYW5kXG4gKiBmdW5jdGlvbnMuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhbiBvYmplY3QuXG4gKi9cbmdvb2cuaXNPYmplY3QgPSBmdW5jdGlvbih2YWwpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICByZXR1cm4gdHlwZSA9PSAnb2JqZWN0JyAmJiB2YWwgIT0gbnVsbCB8fCB0eXBlID09ICdmdW5jdGlvbic7XG4gIC8vIHJldHVybiBPYmplY3QodmFsKSA9PT0gdmFsIGFsc28gd29ya3MsIGJ1dCBpcyBzbG93ZXIsIGVzcGVjaWFsbHkgaWYgdmFsIGlzXG4gIC8vIG5vdCBhbiBvYmplY3QuXG59O1xuXG5cbi8qKlxuICogR2V0cyBhIHVuaXF1ZSBJRCBmb3IgYW4gb2JqZWN0LiBUaGlzIG11dGF0ZXMgdGhlIG9iamVjdCBzbyB0aGF0IGZ1cnRoZXIgY2FsbHNcbiAqIHdpdGggdGhlIHNhbWUgb2JqZWN0IGFzIGEgcGFyYW1ldGVyIHJldHVybnMgdGhlIHNhbWUgdmFsdWUuIFRoZSB1bmlxdWUgSUQgaXNcbiAqIGd1YXJhbnRlZWQgdG8gYmUgdW5pcXVlIGFjcm9zcyB0aGUgY3VycmVudCBzZXNzaW9uIGFtb25nc3Qgb2JqZWN0cyB0aGF0IGFyZVxuICogcGFzc2VkIGludG8ge0Bjb2RlIGdldFVpZH0uIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBJRCBpcyB1bmlxdWUgb3JcbiAqIGNvbnNpc3RlbnQgYWNyb3NzIHNlc3Npb25zLiBJdCBpcyB1bnNhZmUgdG8gZ2VuZXJhdGUgdW5pcXVlIElEIGZvciBmdW5jdGlvblxuICogcHJvdG90eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gZ2V0IHRoZSB1bmlxdWUgSUQgZm9yLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgdW5pcXVlIElEIGZvciB0aGUgb2JqZWN0LlxuICovXG5nb29nLmdldFVpZCA9IGZ1bmN0aW9uKG9iaikge1xuICAvLyBUT0RPKGFydik6IE1ha2UgdGhlIHR5cGUgc3RyaWN0ZXIsIGRvIG5vdCBhY2NlcHQgbnVsbC5cblxuICAvLyBJbiBPcGVyYSB3aW5kb3cuaGFzT3duUHJvcGVydHkgZXhpc3RzIGJ1dCBhbHdheXMgcmV0dXJucyBmYWxzZSBzbyB3ZSBhdm9pZFxuICAvLyB1c2luZyBpdC4gQXMgYSBjb25zZXF1ZW5jZSB0aGUgdW5pcXVlIElEIGdlbmVyYXRlZCBmb3IgQmFzZUNsYXNzLnByb3RvdHlwZVxuICAvLyBhbmQgU3ViQ2xhc3MucHJvdG90eXBlIHdpbGwgYmUgdGhlIHNhbWUuXG4gIHJldHVybiBvYmpbZ29vZy5VSURfUFJPUEVSVFlfXSB8fFxuICAgICAgKG9ialtnb29nLlVJRF9QUk9QRVJUWV9dID0gKytnb29nLnVpZENvdW50ZXJfKTtcbn07XG5cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYWxyZWFkeSBhc3NpZ25lZCBhIHVuaXF1ZSBJRC5cbiAqXG4gKiBUaGlzIGRvZXMgbm90IG1vZGlmeSB0aGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZXJlIGlzIGFuIGFzc2lnbmVkIHVuaXF1ZSBpZCBmb3IgdGhlIG9iamVjdC5cbiAqL1xuZ29vZy5oYXNVaWQgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuICEhb2JqW2dvb2cuVUlEX1BST1BFUlRZX107XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgdW5pcXVlIElEIGZyb20gYW4gb2JqZWN0LiBUaGlzIGlzIHVzZWZ1bCBpZiB0aGUgb2JqZWN0IHdhc1xuICogcHJldmlvdXNseSBtdXRhdGVkIHVzaW5nIHtAY29kZSBnb29nLmdldFVpZH0gaW4gd2hpY2ggY2FzZSB0aGUgbXV0YXRpb24gaXNcbiAqIHVuZG9uZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byByZW1vdmUgdGhlIHVuaXF1ZSBJRCBmaWVsZCBmcm9tLlxuICovXG5nb29nLnJlbW92ZVVpZCA9IGZ1bmN0aW9uKG9iaikge1xuICAvLyBUT0RPKGFydik6IE1ha2UgdGhlIHR5cGUgc3RyaWN0ZXIsIGRvIG5vdCBhY2NlcHQgbnVsbC5cblxuICAvLyBJbiBJRSwgRE9NIG5vZGVzIGFyZSBub3QgaW5zdGFuY2VzIG9mIE9iamVjdCBhbmQgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHdlXG4gIC8vIHRyeSB0byBkZWxldGUuICBJbnN0ZWFkIHdlIHRyeSB0byB1c2UgcmVtb3ZlQXR0cmlidXRlLlxuICBpZiAob2JqICE9PSBudWxsICYmICdyZW1vdmVBdHRyaWJ1dGUnIGluIG9iaikge1xuICAgIG9iai5yZW1vdmVBdHRyaWJ1dGUoZ29vZy5VSURfUFJPUEVSVFlfKTtcbiAgfVxuICAvKiogQHByZXNlcnZlVHJ5ICovXG4gIHRyeSB7XG4gICAgZGVsZXRlIG9ialtnb29nLlVJRF9QUk9QRVJUWV9dO1xuICB9IGNhdGNoIChleCkge1xuICB9XG59O1xuXG5cbi8qKlxuICogTmFtZSBmb3IgdW5pcXVlIElEIHByb3BlcnR5LiBJbml0aWFsaXplZCBpbiBhIHdheSB0byBoZWxwIGF2b2lkIGNvbGxpc2lvbnNcbiAqIHdpdGggb3RoZXIgY2xvc3VyZSBKYXZhU2NyaXB0IG9uIHRoZSBzYW1lIHBhZ2UuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5VSURfUFJPUEVSVFlfID0gJ2Nsb3N1cmVfdWlkXycgKyAoKE1hdGgucmFuZG9tKCkgKiAxZTkpID4+PiAwKTtcblxuXG4vKipcbiAqIENvdW50ZXIgZm9yIFVJRC5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLnVpZENvdW50ZXJfID0gMDtcblxuXG4vKipcbiAqIEFkZHMgYSBoYXNoIGNvZGUgZmllbGQgdG8gYW4gb2JqZWN0LiBUaGUgaGFzaCBjb2RlIGlzIHVuaXF1ZSBmb3IgdGhlXG4gKiBnaXZlbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gZ2V0IHRoZSBoYXNoIGNvZGUgZm9yLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaGFzaCBjb2RlIGZvciB0aGUgb2JqZWN0LlxuICogQGRlcHJlY2F0ZWQgVXNlIGdvb2cuZ2V0VWlkIGluc3RlYWQuXG4gKi9cbmdvb2cuZ2V0SGFzaENvZGUgPSBnb29nLmdldFVpZDtcblxuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGhhc2ggY29kZSBmaWVsZCBmcm9tIGFuIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byByZW1vdmUgdGhlIGZpZWxkIGZyb20uXG4gKiBAZGVwcmVjYXRlZCBVc2UgZ29vZy5yZW1vdmVVaWQgaW5zdGVhZC5cbiAqL1xuZ29vZy5yZW1vdmVIYXNoQ29kZSA9IGdvb2cucmVtb3ZlVWlkO1xuXG5cbi8qKlxuICogQ2xvbmVzIGEgdmFsdWUuIFRoZSBpbnB1dCBtYXkgYmUgYW4gT2JqZWN0LCBBcnJheSwgb3IgYmFzaWMgdHlwZS4gT2JqZWN0cyBhbmRcbiAqIGFycmF5cyB3aWxsIGJlIGNsb25lZCByZWN1cnNpdmVseS5cbiAqXG4gKiBXQVJOSU5HUzpcbiAqIDxjb2RlPmdvb2cuY2xvbmVPYmplY3Q8L2NvZGU+IGRvZXMgbm90IGRldGVjdCByZWZlcmVuY2UgbG9vcHMuIE9iamVjdHMgdGhhdFxuICogcmVmZXIgdG8gdGhlbXNlbHZlcyB3aWxsIGNhdXNlIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAqXG4gKiA8Y29kZT5nb29nLmNsb25lT2JqZWN0PC9jb2RlPiBpcyB1bmF3YXJlIG9mIHVuaXF1ZSBpZGVudGlmaWVycywgYW5kIGNvcGllc1xuICogVUlEcyBjcmVhdGVkIGJ5IDxjb2RlPmdldFVpZDwvY29kZT4gaW50byBjbG9uZWQgcmVzdWx0cy5cbiAqXG4gKiBAcGFyYW0geyp9IG9iaiBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcmV0dXJuIHsqfSBBIGNsb25lIG9mIHRoZSBpbnB1dCB2YWx1ZS5cbiAqIEBkZXByZWNhdGVkIGdvb2cuY2xvbmVPYmplY3QgaXMgdW5zYWZlLiBQcmVmZXIgdGhlIGdvb2cub2JqZWN0IG1ldGhvZHMuXG4gKi9cbmdvb2cuY2xvbmVPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHR5cGUgPSBnb29nLnR5cGVPZihvYmopO1xuICBpZiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdhcnJheScpIHtcbiAgICBpZiAob2JqLmNsb25lKSB7XG4gICAgICByZXR1cm4gb2JqLmNsb25lKCk7XG4gICAgfVxuICAgIHZhciBjbG9uZSA9IHR5cGUgPT0gJ2FycmF5JyA/IFtdIDoge307XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgY2xvbmVba2V5XSA9IGdvb2cuY2xvbmVPYmplY3Qob2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vKipcbiAqIEEgbmF0aXZlIGltcGxlbWVudGF0aW9uIG9mIGdvb2cuYmluZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEEgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5LlxuICogQHBhcmFtIHtPYmplY3R8dW5kZWZpbmVkfSBzZWxmT2JqIFNwZWNpZmllcyB0aGUgb2JqZWN0IHdoaWNoIHRoaXMgc2hvdWxkXG4gKiAgICAgcG9pbnQgdG8gd2hlbiB0aGUgZnVuY3Rpb24gaXMgcnVuLlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0aGF0IGFyZSBwYXJ0aWFsbHkgYXBwbGllZCB0byB0aGVcbiAqICAgICBmdW5jdGlvbi5cbiAqIEByZXR1cm4geyFGdW5jdGlvbn0gQSBwYXJ0aWFsbHktYXBwbGllZCBmb3JtIG9mIHRoZSBmdW5jdGlvbiBiaW5kKCkgd2FzXG4gKiAgICAgaW52b2tlZCBhcyBhIG1ldGhvZCBvZi5cbiAqIEBwcml2YXRlXG4gKiBAc3VwcHJlc3Mge2RlcHJlY2F0ZWR9IFRoZSBjb21waWxlciB0aGlua3MgdGhhdCBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBpc1xuICogICAgIGRlcHJlY2F0ZWQgYmVjYXVzZSBzb21lIHBlb3BsZSBoYXZlIGRlY2xhcmVkIGEgcHVyZS1KUyB2ZXJzaW9uLlxuICogICAgIE9ubHkgdGhlIHB1cmUtSlMgdmVyc2lvbiBpcyB0cnVseSBkZXByZWNhdGVkLlxuICovXG5nb29nLmJpbmROYXRpdmVfID0gZnVuY3Rpb24oZm4sIHNlbGZPYmosIHZhcl9hcmdzKSB7XG4gIHJldHVybiAvKiogQHR5cGUgeyFGdW5jdGlvbn0gKi8gKGZuLmNhbGwuYXBwbHkoZm4uYmluZCwgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogQSBwdXJlLUpTIGltcGxlbWVudGF0aW9uIG9mIGdvb2cuYmluZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEEgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5LlxuICogQHBhcmFtIHtPYmplY3R8dW5kZWZpbmVkfSBzZWxmT2JqIFNwZWNpZmllcyB0aGUgb2JqZWN0IHdoaWNoIHRoaXMgc2hvdWxkXG4gKiAgICAgcG9pbnQgdG8gd2hlbiB0aGUgZnVuY3Rpb24gaXMgcnVuLlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0aGF0IGFyZSBwYXJ0aWFsbHkgYXBwbGllZCB0byB0aGVcbiAqICAgICBmdW5jdGlvbi5cbiAqIEByZXR1cm4geyFGdW5jdGlvbn0gQSBwYXJ0aWFsbHktYXBwbGllZCBmb3JtIG9mIHRoZSBmdW5jdGlvbiBiaW5kKCkgd2FzXG4gKiAgICAgaW52b2tlZCBhcyBhIG1ldGhvZCBvZi5cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cuYmluZEpzXyA9IGZ1bmN0aW9uKGZuLCBzZWxmT2JqLCB2YXJfYXJncykge1xuICBpZiAoIWZuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gIH1cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICB2YXIgYm91bmRBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBQcmVwZW5kIHRoZSBib3VuZCBhcmd1bWVudHMgdG8gdGhlIGN1cnJlbnQgYXJndW1lbnRzLlxuICAgICAgdmFyIG5ld0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkobmV3QXJncywgYm91bmRBcmdzKTtcbiAgICAgIHJldHVybiBmbi5hcHBseShzZWxmT2JqLCBuZXdBcmdzKTtcbiAgICB9O1xuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gZm4uYXBwbHkoc2VsZk9iaiwgYXJndW1lbnRzKTsgfTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFBhcnRpYWxseSBhcHBsaWVzIHRoaXMgZnVuY3Rpb24gdG8gYSBwYXJ0aWN1bGFyICd0aGlzIG9iamVjdCcgYW5kIHplcm8gb3JcbiAqIG1vcmUgYXJndW1lbnRzLiBUaGUgcmVzdWx0IGlzIGEgbmV3IGZ1bmN0aW9uIHdpdGggc29tZSBhcmd1bWVudHMgb2YgdGhlIGZpcnN0XG4gKiBmdW5jdGlvbiBwcmUtZmlsbGVkIGFuZCB0aGUgdmFsdWUgb2YgdGhpcyAncHJlLXNwZWNpZmllZCcuXG4gKlxuICogUmVtYWluaW5nIGFyZ3VtZW50cyBzcGVjaWZpZWQgYXQgY2FsbC10aW1lIGFyZSBhcHBlbmRlZCB0byB0aGUgcHJlLXNwZWNpZmllZFxuICogb25lcy5cbiAqXG4gKiBBbHNvIHNlZToge0BsaW5rICNwYXJ0aWFsfS5cbiAqXG4gKiBVc2FnZTpcbiAqIDxwcmU+dmFyIGJhck1ldGhCb3VuZCA9IGdvb2cuYmluZChteUZ1bmN0aW9uLCBteU9iaiwgJ2FyZzEnLCAnYXJnMicpO1xuICogYmFyTWV0aEJvdW5kKCdhcmczJywgJ2FyZzQnKTs8L3ByZT5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbih0aGlzOlQsIC4uLil9IGZuIEEgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5LlxuICogQHBhcmFtIHtUfSBzZWxmT2JqIFNwZWNpZmllcyB0aGUgb2JqZWN0IHdoaWNoIHRoaXMgc2hvdWxkIHBvaW50IHRvIHdoZW4gdGhlXG4gKiAgICAgZnVuY3Rpb24gaXMgcnVuLlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0aGF0IGFyZSBwYXJ0aWFsbHkgYXBwbGllZCB0byB0aGVcbiAqICAgICBmdW5jdGlvbi5cbiAqIEByZXR1cm4geyFGdW5jdGlvbn0gQSBwYXJ0aWFsbHktYXBwbGllZCBmb3JtIG9mIHRoZSBmdW5jdGlvbiBnb29nLmJpbmQoKSB3YXNcbiAqICAgICBpbnZva2VkIGFzIGEgbWV0aG9kIG9mLlxuICogQHRlbXBsYXRlIFRcbiAqIEBzdXBwcmVzcyB7ZGVwcmVjYXRlZH0gU2VlIGFib3ZlLlxuICovXG5nb29nLmJpbmQgPSBmdW5jdGlvbihmbiwgc2VsZk9iaiwgdmFyX2FyZ3MpIHtcbiAgLy8gVE9ETyhuaWNrc2FudG9zKTogbmFycm93IHRoZSB0eXBlIHNpZ25hdHVyZS5cbiAgaWYgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kICYmXG4gICAgICAvLyBOT1RFKG5pY2tzYW50b3MpOiBTb21lYm9keSBwdWxsZWQgYmFzZS5qcyBpbnRvIHRoZSBkZWZhdWx0IENocm9tZVxuICAgICAgLy8gZXh0ZW5zaW9uIGVudmlyb25tZW50LiBUaGlzIG1lYW5zIHRoYXQgZm9yIENocm9tZSBleHRlbnNpb25zLCB0aGV5IGdldFxuICAgICAgLy8gdGhlIGltcGxlbWVudGF0aW9uIG9mIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHRoYXQgY2FsbHMgZ29vZy5iaW5kXG4gICAgICAvLyBpbnN0ZWFkIG9mIHRoZSBuYXRpdmUgb25lLiBFdmVuIHdvcnNlLCB3ZSBkb24ndCB3YW50IHRvIGludHJvZHVjZSBhXG4gICAgICAvLyBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW4gZ29vZy5iaW5kIGFuZCBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCwgc29cbiAgICAgIC8vIHdlIGhhdmUgdG8gaGFjayB0aGlzIHRvIG1ha2Ugc3VyZSBpdCB3b3JrcyBjb3JyZWN0bHkuXG4gICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC50b1N0cmluZygpLmluZGV4T2YoJ25hdGl2ZSBjb2RlJykgIT0gLTEpIHtcbiAgICBnb29nLmJpbmQgPSBnb29nLmJpbmROYXRpdmVfO1xuICB9IGVsc2Uge1xuICAgIGdvb2cuYmluZCA9IGdvb2cuYmluZEpzXztcbiAgfVxuICByZXR1cm4gZ29vZy5iaW5kLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbi8qKlxuICogTGlrZSBnb29nLmJpbmQoKSwgZXhjZXB0IHRoYXQgYSAndGhpcyBvYmplY3QnIGlzIG5vdCByZXF1aXJlZC4gVXNlZnVsIHdoZW5cbiAqIHRoZSB0YXJnZXQgZnVuY3Rpb24gaXMgYWxyZWFkeSBib3VuZC5cbiAqXG4gKiBVc2FnZTpcbiAqIHZhciBnID0gZ29vZy5wYXJ0aWFsKGYsIGFyZzEsIGFyZzIpO1xuICogZyhhcmczLCBhcmc0KTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBBIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseS5cbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgQWRkaXRpb25hbCBhcmd1bWVudHMgdGhhdCBhcmUgcGFydGlhbGx5IGFwcGxpZWQgdG8gZm4uXG4gKiBAcmV0dXJuIHshRnVuY3Rpb259IEEgcGFydGlhbGx5LWFwcGxpZWQgZm9ybSBvZiB0aGUgZnVuY3Rpb24gZ29vZy5wYXJ0aWFsKClcbiAqICAgICB3YXMgaW52b2tlZCBhcyBhIG1ldGhvZCBvZi5cbiAqL1xuZ29vZy5wYXJ0aWFsID0gZnVuY3Rpb24oZm4sIHZhcl9hcmdzKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIC8vIENsb25lIHRoZSBhcnJheSAod2l0aCBzbGljZSgpKSBhbmQgYXBwZW5kIGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgLy8gdG8gdGhlIGV4aXN0aW5nIGFyZ3VtZW50cy5cbiAgICB2YXIgbmV3QXJncyA9IGFyZ3Muc2xpY2UoKTtcbiAgICBuZXdBcmdzLnB1c2guYXBwbHkobmV3QXJncywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgbmV3QXJncyk7XG4gIH07XG59O1xuXG5cbi8qKlxuICogQ29waWVzIGFsbCB0aGUgbWVtYmVycyBvZiBhIHNvdXJjZSBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LiBUaGlzIG1ldGhvZFxuICogZG9lcyBub3Qgd29yayBvbiBhbGwgYnJvd3NlcnMgZm9yIGFsbCBvYmplY3RzIHRoYXQgY29udGFpbiBrZXlzIHN1Y2ggYXNcbiAqIHRvU3RyaW5nIG9yIGhhc093blByb3BlcnR5LiBVc2UgZ29vZy5vYmplY3QuZXh0ZW5kIGZvciB0aGlzIHB1cnBvc2UuXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRhcmdldC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgU291cmNlLlxuICovXG5nb29nLm1peGluID0gZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UpIHtcbiAgZm9yICh2YXIgeCBpbiBzb3VyY2UpIHtcbiAgICB0YXJnZXRbeF0gPSBzb3VyY2VbeF07XG4gIH1cblxuICAvLyBGb3IgSUU3IG9yIGxvd2VyLCB0aGUgZm9yLWluLWxvb3AgZG9lcyBub3QgY29udGFpbiBhbnkgcHJvcGVydGllcyB0aGF0IGFyZVxuICAvLyBub3QgZW51bWVyYWJsZSBvbiB0aGUgcHJvdG90eXBlIG9iamVjdCAoZm9yIGV4YW1wbGUsIGlzUHJvdG90eXBlT2YgZnJvbVxuICAvLyBPYmplY3QucHJvdG90eXBlKSBidXQgYWxzbyBpdCB3aWxsIG5vdCBpbmNsdWRlICdyZXBsYWNlJyBvbiBvYmplY3RzIHRoYXRcbiAgLy8gZXh0ZW5kIFN0cmluZyBhbmQgY2hhbmdlICdyZXBsYWNlJyAobm90IHRoYXQgaXQgaXMgY29tbW9uIGZvciBhbnlvbmUgdG9cbiAgLy8gZXh0ZW5kIGFueXRoaW5nIGV4Y2VwdCBPYmplY3QpLlxufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW50ZWdlciB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHNcbiAqICAgICBiZXR3ZWVuIG1pZG5pZ2h0LCBKYW51YXJ5IDEsIDE5NzAgYW5kIHRoZSBjdXJyZW50IHRpbWUuXG4gKi9cbmdvb2cubm93ID0gKGdvb2cuVFJVU1RFRF9TSVRFICYmIERhdGUubm93KSB8fCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgLy8gVW5hcnkgcGx1cyBvcGVyYXRvciBjb252ZXJ0cyBpdHMgb3BlcmFuZCB0byBhIG51bWJlciB3aGljaCBpblxuICAgICAgICAgICAgIC8vIHRoZSBjYXNlIG9mXG4gICAgICAgICAgICAgLy8gYSBkYXRlIGlzIGRvbmUgYnkgY2FsbGluZyBnZXRUaW1lKCkuXG4gICAgICAgICAgICAgcmV0dXJuICtuZXcgRGF0ZSgpO1xuICAgICAgICAgICB9KTtcblxuXG4vKipcbiAqIEV2YWxzIEphdmFTY3JpcHQgaW4gdGhlIGdsb2JhbCBzY29wZS4gIEluIElFIHRoaXMgdXNlcyBleGVjU2NyaXB0LCBvdGhlclxuICogYnJvd3NlcnMgdXNlIGdvb2cuZ2xvYmFsLmV2YWwuIElmIGdvb2cuZ2xvYmFsLmV2YWwgZG9lcyBub3QgZXZhbHVhdGUgaW4gdGhlXG4gKiBnbG9iYWwgc2NvcGUgKGZvciBleGFtcGxlLCBpbiBTYWZhcmkpLCBhcHBlbmRzIGEgc2NyaXB0IHRhZyBpbnN0ZWFkLlxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBuZWl0aGVyIGV4ZWNTY3JpcHQgb3IgZXZhbCBpcyBkZWZpbmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHNjcmlwdCBKYXZhU2NyaXB0IHN0cmluZy5cbiAqL1xuZ29vZy5nbG9iYWxFdmFsID0gZnVuY3Rpb24oc2NyaXB0KSB7XG4gIGlmIChnb29nLmdsb2JhbC5leGVjU2NyaXB0KSB7XG4gICAgZ29vZy5nbG9iYWwuZXhlY1NjcmlwdChzY3JpcHQsICdKYXZhU2NyaXB0Jyk7XG4gIH0gZWxzZSBpZiAoZ29vZy5nbG9iYWwuZXZhbCkge1xuICAgIC8vIFRlc3QgdG8gc2VlIGlmIGV2YWwgd29ya3NcbiAgICBpZiAoZ29vZy5ldmFsV29ya3NGb3JHbG9iYWxzXyA9PSBudWxsKSB7XG4gICAgICBnb29nLmdsb2JhbC5ldmFsKCd2YXIgX2V2YWxUZXN0XyA9IDE7Jyk7XG4gICAgICBpZiAodHlwZW9mIGdvb2cuZ2xvYmFsWydfZXZhbFRlc3RfJ10gIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkZWxldGUgZ29vZy5nbG9iYWxbJ19ldmFsVGVzdF8nXTtcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7XG4gICAgICAgICAgLy8gTWljcm9zb2Z0IGVkZ2UgZmFpbHMgdGhlIGRlbGV0aW9uIGFib3ZlIGluIHN0cmljdCBtb2RlLlxuICAgICAgICB9XG4gICAgICAgIGdvb2cuZXZhbFdvcmtzRm9yR2xvYmFsc18gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ29vZy5ldmFsV29ya3NGb3JHbG9iYWxzXyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChnb29nLmV2YWxXb3Jrc0Zvckdsb2JhbHNfKSB7XG4gICAgICBnb29nLmdsb2JhbC5ldmFsKHNjcmlwdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7RG9jdW1lbnR9ICovXG4gICAgICB2YXIgZG9jID0gZ29vZy5nbG9iYWwuZG9jdW1lbnQ7XG4gICAgICB2YXIgc2NyaXB0RWx0ID1cbiAgICAgICAgICAvKiogQHR5cGUgeyFIVE1MU2NyaXB0RWxlbWVudH0gKi8gKGRvYy5jcmVhdGVFbGVtZW50KCdTQ1JJUFQnKSk7XG4gICAgICBzY3JpcHRFbHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgc2NyaXB0RWx0LmRlZmVyID0gZmFsc2U7XG4gICAgICAvLyBOb3RlKHVzZXIpOiBjYW4ndCB1c2UgLmlubmVySFRNTCBzaW5jZSBcInQoJzx0ZXN0PicpXCIgd2lsbCBmYWlsIGFuZFxuICAgICAgLy8gLnRleHQgZG9lc24ndCB3b3JrIGluIFNhZmFyaSAyLiAgVGhlcmVmb3JlIHdlIGFwcGVuZCBhIHRleHQgbm9kZS5cbiAgICAgIHNjcmlwdEVsdC5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoc2NyaXB0KSk7XG4gICAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChzY3JpcHRFbHQpO1xuICAgICAgZG9jLmJvZHkucmVtb3ZlQ2hpbGQoc2NyaXB0RWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoJ2dvb2cuZ2xvYmFsRXZhbCBub3QgYXZhaWxhYmxlJyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBJbmRpY2F0ZXMgd2hldGhlciBvciBub3Qgd2UgY2FuIGNhbGwgJ2V2YWwnIGRpcmVjdGx5IHRvIGV2YWwgY29kZSBpbiB0aGVcbiAqIGdsb2JhbCBzY29wZS4gU2V0IHRvIGEgQm9vbGVhbiBieSB0aGUgZmlyc3QgY2FsbCB0byBnb29nLmdsb2JhbEV2YWwgKHdoaWNoXG4gKiBlbXBpcmljYWxseSB0ZXN0cyB3aGV0aGVyIGV2YWwgd29ya3MgZm9yIGdsb2JhbHMpLiBAc2VlIGdvb2cuZ2xvYmFsRXZhbFxuICogQHR5cGUgez9ib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5ldmFsV29ya3NGb3JHbG9iYWxzXyA9IG51bGw7XG5cblxuLyoqXG4gKiBPcHRpb25hbCBtYXAgb2YgQ1NTIGNsYXNzIG5hbWVzIHRvIG9iZnVzY2F0ZWQgbmFtZXMgdXNlZCB3aXRoXG4gKiBnb29nLmdldENzc05hbWUoKS5cbiAqIEBwcml2YXRlIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPnx1bmRlZmluZWR9XG4gKiBAc2VlIGdvb2cuc2V0Q3NzTmFtZU1hcHBpbmdcbiAqL1xuZ29vZy5jc3NOYW1lTWFwcGluZ187XG5cblxuLyoqXG4gKiBPcHRpb25hbCBvYmZ1c2NhdGlvbiBzdHlsZSBmb3IgQ1NTIGNsYXNzIG5hbWVzLiBTaG91bGQgYmUgc2V0IHRvIGVpdGhlclxuICogJ0JZX1dIT0xFJyBvciAnQllfUEFSVCcgaWYgZGVmaW5lZC5cbiAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICogQHByaXZhdGVcbiAqIEBzZWUgZ29vZy5zZXRDc3NOYW1lTWFwcGluZ1xuICovXG5nb29nLmNzc05hbWVNYXBwaW5nU3R5bGVfO1xuXG5cbi8qKlxuICogSGFuZGxlcyBzdHJpbmdzIHRoYXQgYXJlIGludGVuZGVkIHRvIGJlIHVzZWQgYXMgQ1NTIGNsYXNzIG5hbWVzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd29ya3MgaW4gdGFuZGVtIHdpdGggQHNlZSBnb29nLnNldENzc05hbWVNYXBwaW5nLlxuICpcbiAqIFdpdGhvdXQgYW55IG1hcHBpbmcgc2V0LCB0aGUgYXJndW1lbnRzIGFyZSBzaW1wbGUgam9pbmVkIHdpdGggYSBoeXBoZW4gYW5kXG4gKiBwYXNzZWQgdGhyb3VnaCB1bmFsdGVyZWQuXG4gKlxuICogV2hlbiB0aGVyZSBpcyBhIG1hcHBpbmcsIHRoZXJlIGFyZSB0d28gcG9zc2libGUgc3R5bGVzIGluIHdoaWNoIHRoZXNlXG4gKiBtYXBwaW5ncyBhcmUgdXNlZC4gSW4gdGhlIEJZX1BBUlQgc3R5bGUsIGVhY2ggcGFydCAoaS5lLiBpbiBiZXR3ZWVuIGh5cGhlbnMpXG4gKiBvZiB0aGUgcGFzc2VkIGluIGNzcyBuYW1lIGlzIHJld3JpdHRlbiBhY2NvcmRpbmcgdG8gdGhlIG1hcC4gSW4gdGhlIEJZX1dIT0xFXG4gKiBzdHlsZSwgdGhlIGZ1bGwgY3NzIG5hbWUgaXMgbG9va2VkIHVwIGluIHRoZSBtYXAgZGlyZWN0bHkuIElmIGEgcmV3cml0ZSBpc1xuICogbm90IHNwZWNpZmllZCBieSB0aGUgbWFwLCB0aGUgY29tcGlsZXIgd2lsbCBvdXRwdXQgYSB3YXJuaW5nLlxuICpcbiAqIFdoZW4gdGhlIG1hcHBpbmcgaXMgcGFzc2VkIHRvIHRoZSBjb21waWxlciwgaXQgd2lsbCByZXBsYWNlIGNhbGxzIHRvXG4gKiBnb29nLmdldENzc05hbWUgd2l0aCB0aGUgc3RyaW5ncyBmcm9tIHRoZSBtYXBwaW5nLCBlLmcuXG4gKiAgICAgdmFyIHggPSBnb29nLmdldENzc05hbWUoJ2ZvbycpO1xuICogICAgIHZhciB5ID0gZ29vZy5nZXRDc3NOYW1lKHRoaXMuYmFzZUNsYXNzLCAnYWN0aXZlJyk7XG4gKiAgYmVjb21lczpcbiAqICAgICB2YXIgeCA9ICdmb28nO1xuICogICAgIHZhciB5ID0gdGhpcy5iYXNlQ2xhc3MgKyAnLWFjdGl2ZSc7XG4gKlxuICogSWYgb25lIGFyZ3VtZW50IGlzIHBhc3NlZCBpdCB3aWxsIGJlIHByb2Nlc3NlZCwgaWYgdHdvIGFyZSBwYXNzZWQgb25seSB0aGVcbiAqIG1vZGlmaWVyIHdpbGwgYmUgcHJvY2Vzc2VkLCBhcyBpdCBpcyBhc3N1bWVkIHRoZSBmaXJzdCBhcmd1bWVudCB3YXMgZ2VuZXJhdGVkXG4gKiBhcyBhIHJlc3VsdCBvZiBjYWxsaW5nIGdvb2cuZ2V0Q3NzTmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIFRoZSBjbGFzcyBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbW9kaWZpZXIgQSBtb2RpZmllciB0byBiZSBhcHBlbmRlZCB0byB0aGUgY2xhc3MgbmFtZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNsYXNzIG5hbWUgb3IgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIGNsYXNzIG5hbWUgYW5kXG4gKiAgICAgdGhlIG1vZGlmaWVyLlxuICovXG5nb29nLmdldENzc05hbWUgPSBmdW5jdGlvbihjbGFzc05hbWUsIG9wdF9tb2RpZmllcikge1xuICB2YXIgZ2V0TWFwcGluZyA9IGZ1bmN0aW9uKGNzc05hbWUpIHtcbiAgICByZXR1cm4gZ29vZy5jc3NOYW1lTWFwcGluZ19bY3NzTmFtZV0gfHwgY3NzTmFtZTtcbiAgfTtcblxuICB2YXIgcmVuYW1lQnlQYXJ0cyA9IGZ1bmN0aW9uKGNzc05hbWUpIHtcbiAgICAvLyBSZW1hcCBhbGwgdGhlIHBhcnRzIGluZGl2aWR1YWxseS5cbiAgICB2YXIgcGFydHMgPSBjc3NOYW1lLnNwbGl0KCctJyk7XG4gICAgdmFyIG1hcHBlZCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1hcHBlZC5wdXNoKGdldE1hcHBpbmcocGFydHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcHBlZC5qb2luKCctJyk7XG4gIH07XG5cbiAgdmFyIHJlbmFtZTtcbiAgaWYgKGdvb2cuY3NzTmFtZU1hcHBpbmdfKSB7XG4gICAgcmVuYW1lID1cbiAgICAgICAgZ29vZy5jc3NOYW1lTWFwcGluZ1N0eWxlXyA9PSAnQllfV0hPTEUnID8gZ2V0TWFwcGluZyA6IHJlbmFtZUJ5UGFydHM7XG4gIH0gZWxzZSB7XG4gICAgcmVuYW1lID0gZnVuY3Rpb24oYSkgeyByZXR1cm4gYTsgfTtcbiAgfVxuXG4gIGlmIChvcHRfbW9kaWZpZXIpIHtcbiAgICByZXR1cm4gY2xhc3NOYW1lICsgJy0nICsgcmVuYW1lKG9wdF9tb2RpZmllcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlbmFtZShjbGFzc05hbWUpO1xuICB9XG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIHRvIGNoZWNrIHdoZW4gcmV0dXJuaW5nIGEgdmFsdWUgZnJvbSBnb29nLmdldENzc05hbWUoKS4gRXhhbXBsZTpcbiAqIDxwcmU+XG4gKiBnb29nLnNldENzc05hbWVNYXBwaW5nKHtcbiAqICAgXCJnb29nXCI6IFwiYVwiLFxuICogICBcImRpc2FibGVkXCI6IFwiYlwiLFxuICogfSk7XG4gKlxuICogdmFyIHggPSBnb29nLmdldENzc05hbWUoJ2dvb2cnKTtcbiAqIC8vIFRoZSBmb2xsb3dpbmcgZXZhbHVhdGVzIHRvOiBcImEgYS1iXCIuXG4gKiBnb29nLmdldENzc05hbWUoJ2dvb2cnKSArICcgJyArIGdvb2cuZ2V0Q3NzTmFtZSh4LCAnZGlzYWJsZWQnKVxuICogPC9wcmU+XG4gKiBXaGVuIGRlY2xhcmVkIGFzIGEgbWFwIG9mIHN0cmluZyBsaXRlcmFscyB0byBzdHJpbmcgbGl0ZXJhbHMsIHRoZSBKU0NvbXBpbGVyXG4gKiB3aWxsIHJlcGxhY2UgYWxsIGNhbGxzIHRvIGdvb2cuZ2V0Q3NzTmFtZSgpIHVzaW5nIHRoZSBzdXBwbGllZCBtYXAgaWYgdGhlXG4gKiAtLXByb2Nlc3NfY2xvc3VyZV9wcmltaXRpdmVzIGZsYWcgaXMgc2V0LlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gbWFwcGluZyBBIG1hcCBvZiBzdHJpbmdzIHRvIHN0cmluZ3Mgd2hlcmUga2V5cyBhcmUgcG9zc2libGVcbiAqICAgICBhcmd1bWVudHMgdG8gZ29vZy5nZXRDc3NOYW1lKCkgYW5kIHZhbHVlcyBhcmUgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzXG4gKiAgICAgdGhhdCBzaG91bGQgYmUgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9zdHlsZSBUaGUgc3R5bGUgb2YgY3NzIG5hbWUgbWFwcGluZy4gVGhlcmUgYXJlIHR3byB2YWxpZFxuICogICAgIG9wdGlvbnM6ICdCWV9QQVJUJywgYW5kICdCWV9XSE9MRScuXG4gKiBAc2VlIGdvb2cuZ2V0Q3NzTmFtZSBmb3IgYSBkZXNjcmlwdGlvbi5cbiAqL1xuZ29vZy5zZXRDc3NOYW1lTWFwcGluZyA9IGZ1bmN0aW9uKG1hcHBpbmcsIG9wdF9zdHlsZSkge1xuICBnb29nLmNzc05hbWVNYXBwaW5nXyA9IG1hcHBpbmc7XG4gIGdvb2cuY3NzTmFtZU1hcHBpbmdTdHlsZV8gPSBvcHRfc3R5bGU7XG59O1xuXG5cbi8qKlxuICogVG8gdXNlIENTUyByZW5hbWluZyBpbiBjb21waWxlZCBtb2RlLCBvbmUgb2YgdGhlIGlucHV0IGZpbGVzIHNob3VsZCBoYXZlIGFcbiAqIGNhbGwgdG8gZ29vZy5zZXRDc3NOYW1lTWFwcGluZygpIHdpdGggYW4gb2JqZWN0IGxpdGVyYWwgdGhhdCB0aGUgSlNDb21waWxlclxuICogY2FuIGV4dHJhY3QgYW5kIHVzZSB0byByZXBsYWNlIGFsbCBjYWxscyB0byBnb29nLmdldENzc05hbWUoKS4gSW4gdW5jb21waWxlZFxuICogbW9kZSwgSmF2YVNjcmlwdCBjb2RlIHNob3VsZCBiZSBsb2FkZWQgYmVmb3JlIHRoaXMgYmFzZS5qcyBmaWxlIHRoYXQgZGVjbGFyZXNcbiAqIGEgZ2xvYmFsIHZhcmlhYmxlLCBDTE9TVVJFX0NTU19OQU1FX01BUFBJTkcsIHdoaWNoIGlzIHVzZWQgYmVsb3cuIFRoaXMgaXNcbiAqIHRvIGVuc3VyZSB0aGF0IHRoZSBtYXBwaW5nIGlzIGxvYWRlZCBiZWZvcmUgYW55IGNhbGxzIHRvIGdvb2cuZ2V0Q3NzTmFtZSgpXG4gKiBhcmUgbWFkZSBpbiB1bmNvbXBpbGVkIG1vZGUuXG4gKlxuICogQSBob29rIGZvciBvdmVycmlkaW5nIHRoZSBDU1MgbmFtZSBtYXBwaW5nLlxuICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fHVuZGVmaW5lZH1cbiAqL1xuZ29vZy5nbG9iYWwuQ0xPU1VSRV9DU1NfTkFNRV9NQVBQSU5HO1xuXG5cbmlmICghQ09NUElMRUQgJiYgZ29vZy5nbG9iYWwuQ0xPU1VSRV9DU1NfTkFNRV9NQVBQSU5HKSB7XG4gIC8vIFRoaXMgZG9lcyBub3QgY2FsbCBnb29nLnNldENzc05hbWVNYXBwaW5nKCkgYmVjYXVzZSB0aGUgSlNDb21waWxlclxuICAvLyByZXF1aXJlcyB0aGF0IGdvb2cuc2V0Q3NzTmFtZU1hcHBpbmcoKSBiZSBjYWxsZWQgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC5cbiAgZ29vZy5jc3NOYW1lTWFwcGluZ18gPSBnb29nLmdsb2JhbC5DTE9TVVJFX0NTU19OQU1FX01BUFBJTkc7XG59XG5cblxuLyoqXG4gKiBHZXRzIGEgbG9jYWxpemVkIG1lc3NhZ2UuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhIGNvbXBpbGVyIHByaW1pdGl2ZS4gSWYgeW91IGdpdmUgdGhlIGNvbXBpbGVyIGEgbG9jYWxpemVkXG4gKiBtZXNzYWdlIGJ1bmRsZSwgaXQgd2lsbCByZXBsYWNlIHRoZSBzdHJpbmcgYXQgY29tcGlsZS10aW1lIHdpdGggYSBsb2NhbGl6ZWRcbiAqIHZlcnNpb24sIGFuZCBleHBhbmQgZ29vZy5nZXRNc2cgY2FsbCB0byBhIGNvbmNhdGVuYXRlZCBzdHJpbmcuXG4gKlxuICogTWVzc2FnZXMgbXVzdCBiZSBpbml0aWFsaXplZCBpbiB0aGUgZm9ybTpcbiAqIDxjb2RlPlxuICogdmFyIE1TR19OQU1FID0gZ29vZy5nZXRNc2coJ0hlbGxvIHskcGxhY2Vob2xkZXJ9JywgeydwbGFjZWhvbGRlcic6ICd3b3JsZCd9KTtcbiAqIDwvY29kZT5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRyYW5zbGF0YWJsZSBzdHJpbmcsIHBsYWNlcyBob2xkZXJzIGluIHRoZSBmb3JtIHskZm9vfS5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPj19IG9wdF92YWx1ZXMgTWFwcyBwbGFjZSBob2xkZXIgbmFtZSB0byB2YWx1ZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gbWVzc2FnZSB3aXRoIHBsYWNlaG9sZGVycyBmaWxsZWQuXG4gKi9cbmdvb2cuZ2V0TXNnID0gZnVuY3Rpb24oc3RyLCBvcHRfdmFsdWVzKSB7XG4gIGlmIChvcHRfdmFsdWVzKSB7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoL1xce1xcJChbXn1dKyl9L2csIGZ1bmN0aW9uKG1hdGNoLCBrZXkpIHtcbiAgICAgIHJldHVybiAob3B0X3ZhbHVlcyAhPSBudWxsICYmIGtleSBpbiBvcHRfdmFsdWVzKSA/IG9wdF92YWx1ZXNba2V5XSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vKipcbiAqIEdldHMgYSBsb2NhbGl6ZWQgbWVzc2FnZS4gSWYgdGhlIG1lc3NhZ2UgZG9lcyBub3QgaGF2ZSBhIHRyYW5zbGF0aW9uLCBnaXZlcyBhXG4gKiBmYWxsYmFjayBtZXNzYWdlLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gaW50cm9kdWNpbmcgYSBuZXcgbWVzc2FnZSB0aGF0IGhhcyBub3QgeWV0IGJlZW5cbiAqIHRyYW5zbGF0ZWQgaW50byBhbGwgbGFuZ3VhZ2VzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSBjb21waWxlciBwcmltaXRpdmUuIE11c3QgYmUgdXNlZCBpbiB0aGUgZm9ybTpcbiAqIDxjb2RlPnZhciB4ID0gZ29vZy5nZXRNc2dXaXRoRmFsbGJhY2soTVNHX0EsIE1TR19CKTs8L2NvZGU+XG4gKiB3aGVyZSBNU0dfQSBhbmQgTVNHX0Igd2VyZSBpbml0aWFsaXplZCB3aXRoIGdvb2cuZ2V0TXNnLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhIFRoZSBwcmVmZXJyZWQgbWVzc2FnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBiIFRoZSBmYWxsYmFjayBtZXNzYWdlLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgYmVzdCB0cmFuc2xhdGVkIG1lc3NhZ2UuXG4gKi9cbmdvb2cuZ2V0TXNnV2l0aEZhbGxiYWNrID0gZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYTtcbn07XG5cblxuLyoqXG4gKiBFeHBvc2VzIGFuIHVub2JmdXNjYXRlZCBnbG9iYWwgbmFtZXNwYWNlIHBhdGggZm9yIHRoZSBnaXZlbiBvYmplY3QuXG4gKiBOb3RlIHRoYXQgZmllbGRzIG9mIHRoZSBleHBvcnRlZCBvYmplY3QgKndpbGwqIGJlIG9iZnVzY2F0ZWQsIHVubGVzcyB0aGV5IGFyZVxuICogZXhwb3J0ZWQgaW4gdHVybiB2aWEgdGhpcyBmdW5jdGlvbiBvciBnb29nLmV4cG9ydFByb3BlcnR5LlxuICpcbiAqIEFsc28gaGFuZHkgZm9yIG1ha2luZyBwdWJsaWMgaXRlbXMgdGhhdCBhcmUgZGVmaW5lZCBpbiBhbm9ueW1vdXMgY2xvc3VyZXMuXG4gKlxuICogZXguIGdvb2cuZXhwb3J0U3ltYm9sKCdwdWJsaWMucGF0aC5Gb28nLCBGb28pO1xuICpcbiAqIGV4LiBnb29nLmV4cG9ydFN5bWJvbCgncHVibGljLnBhdGguRm9vLnN0YXRpY0Z1bmN0aW9uJywgRm9vLnN0YXRpY0Z1bmN0aW9uKTtcbiAqICAgICBwdWJsaWMucGF0aC5Gb28uc3RhdGljRnVuY3Rpb24oKTtcbiAqXG4gKiBleC4gZ29vZy5leHBvcnRTeW1ib2woJ3B1YmxpYy5wYXRoLkZvby5wcm90b3R5cGUubXlNZXRob2QnLFxuICogICAgICAgICAgICAgICAgICAgICAgIEZvby5wcm90b3R5cGUubXlNZXRob2QpO1xuICogICAgIG5ldyBwdWJsaWMucGF0aC5Gb28oKS5teU1ldGhvZCgpO1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNQYXRoIFVub2JmdXNjYXRlZCBuYW1lIHRvIGV4cG9ydC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IE9iamVjdCB0aGUgbmFtZSBzaG91bGQgcG9pbnQgdG8uXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9vYmplY3RUb0V4cG9ydFRvIFRoZSBvYmplY3QgdG8gYWRkIHRoZSBwYXRoIHRvOyBkZWZhdWx0XG4gKiAgICAgaXMgZ29vZy5nbG9iYWwuXG4gKi9cbmdvb2cuZXhwb3J0U3ltYm9sID0gZnVuY3Rpb24ocHVibGljUGF0aCwgb2JqZWN0LCBvcHRfb2JqZWN0VG9FeHBvcnRUbykge1xuICBnb29nLmV4cG9ydFBhdGhfKHB1YmxpY1BhdGgsIG9iamVjdCwgb3B0X29iamVjdFRvRXhwb3J0VG8pO1xufTtcblxuXG4vKipcbiAqIEV4cG9ydHMgYSBwcm9wZXJ0eSB1bm9iZnVzY2F0ZWQgaW50byB0aGUgb2JqZWN0J3MgbmFtZXNwYWNlLlxuICogZXguIGdvb2cuZXhwb3J0UHJvcGVydHkoRm9vLCAnc3RhdGljRnVuY3Rpb24nLCBGb28uc3RhdGljRnVuY3Rpb24pO1xuICogZXguIGdvb2cuZXhwb3J0UHJvcGVydHkoRm9vLnByb3RvdHlwZSwgJ215TWV0aG9kJywgRm9vLnByb3RvdHlwZS5teU1ldGhvZCk7XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB3aG9zZSBzdGF0aWMgcHJvcGVydHkgaXMgYmVpbmcgZXhwb3J0ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljTmFtZSBVbm9iZnVzY2F0ZWQgbmFtZSB0byBleHBvcnQuXG4gKiBAcGFyYW0geyp9IHN5bWJvbCBPYmplY3QgdGhlIG5hbWUgc2hvdWxkIHBvaW50IHRvLlxuICovXG5nb29nLmV4cG9ydFByb3BlcnR5ID0gZnVuY3Rpb24ob2JqZWN0LCBwdWJsaWNOYW1lLCBzeW1ib2wpIHtcbiAgb2JqZWN0W3B1YmxpY05hbWVdID0gc3ltYm9sO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBVc2FnZTpcbiAqIDxwcmU+XG4gKiBmdW5jdGlvbiBQYXJlbnRDbGFzcyhhLCBiKSB7IH1cbiAqIFBhcmVudENsYXNzLnByb3RvdHlwZS5mb28gPSBmdW5jdGlvbihhKSB7IH07XG4gKlxuICogZnVuY3Rpb24gQ2hpbGRDbGFzcyhhLCBiLCBjKSB7XG4gKiAgIENoaWxkQ2xhc3MuYmFzZSh0aGlzLCAnY29uc3RydWN0b3InLCBhLCBiKTtcbiAqIH1cbiAqIGdvb2cuaW5oZXJpdHMoQ2hpbGRDbGFzcywgUGFyZW50Q2xhc3MpO1xuICpcbiAqIHZhciBjaGlsZCA9IG5ldyBDaGlsZENsYXNzKCdhJywgJ2InLCAnc2VlJyk7XG4gKiBjaGlsZC5mb28oKTsgLy8gVGhpcyB3b3Jrcy5cbiAqIDwvcHJlPlxuICpcbiAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjaGlsZEN0b3IgQ2hpbGQgY2xhc3MuXG4gKiBAcGFyYW0geyFGdW5jdGlvbn0gcGFyZW50Q3RvciBQYXJlbnQgY2xhc3MuXG4gKi9cbmdvb2cuaW5oZXJpdHMgPSBmdW5jdGlvbihjaGlsZEN0b3IsIHBhcmVudEN0b3IpIHtcbiAgLyoqIEBjb25zdHJ1Y3RvciAqL1xuICBmdW5jdGlvbiB0ZW1wQ3RvcigpIHt9XG4gIHRlbXBDdG9yLnByb3RvdHlwZSA9IHBhcmVudEN0b3IucHJvdG90eXBlO1xuICBjaGlsZEN0b3Iuc3VwZXJDbGFzc18gPSBwYXJlbnRDdG9yLnByb3RvdHlwZTtcbiAgY2hpbGRDdG9yLnByb3RvdHlwZSA9IG5ldyB0ZW1wQ3RvcigpO1xuICAvKiogQG92ZXJyaWRlICovXG4gIGNoaWxkQ3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjaGlsZEN0b3I7XG5cbiAgLyoqXG4gICAqIENhbGxzIHN1cGVyY2xhc3MgY29uc3RydWN0b3IvbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgYXZhaWxhYmxlIGlmIHlvdSB1c2UgZ29vZy5pbmhlcml0cyB0b1xuICAgKiBleHByZXNzIGluaGVyaXRhbmNlIHJlbGF0aW9uc2hpcHMgYmV0d2VlbiBjbGFzc2VzLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGdvb2cuYmFzZSBhbmQgZm9yIHN1cGVyQ2xhc3NfXG4gICAqIHByb3BlcnR5IGRlZmluZWQgaW4gY2hpbGRDdG9yLlxuICAgKlxuICAgKiBAcGFyYW0geyFPYmplY3R9IG1lIFNob3VsZCBhbHdheXMgYmUgXCJ0aGlzXCIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBtZXRob2QgbmFtZSB0byBjYWxsLiBDYWxsaW5nXG4gICAqICAgICBzdXBlcmNsYXNzIGNvbnN0cnVjdG9yIGNhbiBiZSBkb25lIHdpdGggdGhlIHNwZWNpYWwgc3RyaW5nXG4gICAqICAgICAnY29uc3RydWN0b3InLlxuICAgKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byBzdXBlcmNsYXNzXG4gICAqICAgICBtZXRob2QvY29uc3RydWN0b3IuXG4gICAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHN1cGVyY2xhc3MgbWV0aG9kL2NvbnN0cnVjdG9yLlxuICAgKi9cbiAgY2hpbGRDdG9yLmJhc2UgPSBmdW5jdGlvbihtZSwgbWV0aG9kTmFtZSwgdmFyX2FyZ3MpIHtcbiAgICAvLyBDb3B5aW5nIHVzaW5nIGxvb3AgdG8gYXZvaWQgZGVvcCBkdWUgdG8gcGFzc2luZyBhcmd1bWVudHMgb2JqZWN0IHRvXG4gICAgLy8gZnVuY3Rpb24uIFRoaXMgaXMgZmFzdGVyIGluIG1hbnkgSlMgZW5naW5lcyBhcyBvZiBsYXRlIDIwMTQuXG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDIpO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAyXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudEN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdLmFwcGx5KG1lLCBhcmdzKTtcbiAgfTtcbn07XG5cblxuLyoqXG4gKiBDYWxsIHVwIHRvIHRoZSBzdXBlcmNsYXNzLlxuICpcbiAqIElmIHRoaXMgaXMgY2FsbGVkIGZyb20gYSBjb25zdHJ1Y3RvciwgdGhlbiB0aGlzIGNhbGxzIHRoZSBzdXBlcmNsYXNzXG4gKiBjb25zdHJ1Y3RvciB3aXRoIGFyZ3VtZW50cyAxLU4uXG4gKlxuICogSWYgdGhpcyBpcyBjYWxsZWQgZnJvbSBhIHByb3RvdHlwZSBtZXRob2QsIHRoZW4geW91IG11c3QgcGFzcyB0aGUgbmFtZSBvZiB0aGVcbiAqIG1ldGhvZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIHRoaXMgZnVuY3Rpb24uIElmIHlvdSBkbyBub3QsIHlvdSB3aWxsIGdldCBhXG4gKiBydW50aW1lIGVycm9yLiBUaGlzIGNhbGxzIHRoZSBzdXBlcmNsYXNzJyBtZXRob2Qgd2l0aCBhcmd1bWVudHMgMi1OLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gb25seSB3b3JrcyBpZiB5b3UgdXNlIGdvb2cuaW5oZXJpdHMgdG8gZXhwcmVzcyBpbmhlcml0YW5jZVxuICogcmVsYXRpb25zaGlwcyBiZXR3ZWVuIHlvdXIgY2xhc3Nlcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGEgY29tcGlsZXIgcHJpbWl0aXZlLiBBdCBjb21waWxlLXRpbWUsIHRoZSBjb21waWxlciB3aWxsIGRvXG4gKiBtYWNybyBleHBhbnNpb24gdG8gcmVtb3ZlIGEgbG90IG9mIHRoZSBleHRyYSBvdmVyaGVhZCB0aGF0IHRoaXMgZnVuY3Rpb25cbiAqIGludHJvZHVjZXMuIFRoZSBjb21waWxlciB3aWxsIGFsc28gZW5mb3JjZSBhIGxvdCBvZiB0aGUgYXNzdW1wdGlvbnMgdGhhdCB0aGlzXG4gKiBmdW5jdGlvbiBtYWtlcywgYW5kIHRyZWF0IGl0IGFzIGEgY29tcGlsZXIgZXJyb3IgaWYgeW91IGJyZWFrIHRoZW0uXG4gKlxuICogQHBhcmFtIHshT2JqZWN0fSBtZSBTaG91bGQgYWx3YXlzIGJlIFwidGhpc1wiLlxuICogQHBhcmFtIHsqPX0gb3B0X21ldGhvZE5hbWUgVGhlIG1ldGhvZCBuYW1lIGlmIGNhbGxpbmcgYSBzdXBlciBtZXRob2QuXG4gKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSByZXN0IG9mIHRoZSBhcmd1bWVudHMuXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBzdXBlcmNsYXNzIG1ldGhvZC5cbiAqIEBzdXBwcmVzcyB7ZXM1U3RyaWN0fSBUaGlzIG1ldGhvZCBjYW4gbm90IGJlIHVzZWQgaW4gc3RyaWN0IG1vZGUsIGJ1dFxuICogICAgIGFsbCBDbG9zdXJlIExpYnJhcnkgY29uc3VtZXJzIG11c3QgZGVwZW5kIG9uIHRoaXMgZmlsZS5cbiAqL1xuZ29vZy5iYXNlID0gZnVuY3Rpb24obWUsIG9wdF9tZXRob2ROYW1lLCB2YXJfYXJncykge1xuICB2YXIgY2FsbGVyID0gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXI7XG5cbiAgaWYgKGdvb2cuU1RSSUNUX01PREVfQ09NUEFUSUJMRSB8fCAoZ29vZy5ERUJVRyAmJiAhY2FsbGVyKSkge1xuICAgIHRocm93IEVycm9yKFxuICAgICAgICAnYXJndW1lbnRzLmNhbGxlciBub3QgZGVmaW5lZC4gIGdvb2cuYmFzZSgpIGNhbm5vdCBiZSB1c2VkICcgK1xuICAgICAgICAnd2l0aCBzdHJpY3QgbW9kZSBjb2RlLiBTZWUgJyArXG4gICAgICAgICdodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtQycpO1xuICB9XG5cbiAgaWYgKGNhbGxlci5zdXBlckNsYXNzXykge1xuICAgIC8vIENvcHlpbmcgdXNpbmcgbG9vcCB0byBhdm9pZCBkZW9wIGR1ZSB0byBwYXNzaW5nIGFyZ3VtZW50cyBvYmplY3QgdG9cbiAgICAvLyBmdW5jdGlvbi4gVGhpcyBpcyBmYXN0ZXIgaW4gbWFueSBKUyBlbmdpbmVzIGFzIG9mIGxhdGUgMjAxNC5cbiAgICB2YXIgY3RvckFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjdG9yQXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgYSBjb25zdHJ1Y3Rvci4gQ2FsbCB0aGUgc3VwZXJjbGFzcyBjb25zdHJ1Y3Rvci5cbiAgICByZXR1cm4gY2FsbGVyLnN1cGVyQ2xhc3NfLmNvbnN0cnVjdG9yLmFwcGx5KG1lLCBjdG9yQXJncyk7XG4gIH1cblxuICAvLyBDb3B5aW5nIHVzaW5nIGxvb3AgdG8gYXZvaWQgZGVvcCBkdWUgdG8gcGFzc2luZyBhcmd1bWVudHMgb2JqZWN0IHRvXG4gIC8vIGZ1bmN0aW9uLiBUaGlzIGlzIGZhc3RlciBpbiBtYW55IEpTIGVuZ2luZXMgYXMgb2YgbGF0ZSAyMDE0LlxuICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMik7XG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJnc1tpIC0gMl0gPSBhcmd1bWVudHNbaV07XG4gIH1cbiAgdmFyIGZvdW5kQ2FsbGVyID0gZmFsc2U7XG4gIGZvciAodmFyIGN0b3IgPSBtZS5jb25zdHJ1Y3RvcjsgY3RvcjtcbiAgICAgICBjdG9yID0gY3Rvci5zdXBlckNsYXNzXyAmJiBjdG9yLnN1cGVyQ2xhc3NfLmNvbnN0cnVjdG9yKSB7XG4gICAgaWYgKGN0b3IucHJvdG90eXBlW29wdF9tZXRob2ROYW1lXSA9PT0gY2FsbGVyKSB7XG4gICAgICBmb3VuZENhbGxlciA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChmb3VuZENhbGxlcikge1xuICAgICAgcmV0dXJuIGN0b3IucHJvdG90eXBlW29wdF9tZXRob2ROYW1lXS5hcHBseShtZSwgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2UgZGlkIG5vdCBmaW5kIHRoZSBjYWxsZXIgaW4gdGhlIHByb3RvdHlwZSBjaGFpbiwgdGhlbiBvbmUgb2YgdHdvXG4gIC8vIHRoaW5ncyBoYXBwZW5lZDpcbiAgLy8gMSkgVGhlIGNhbGxlciBpcyBhbiBpbnN0YW5jZSBtZXRob2QuXG4gIC8vIDIpIFRoaXMgbWV0aG9kIHdhcyBub3QgY2FsbGVkIGJ5IHRoZSByaWdodCBjYWxsZXIuXG4gIGlmIChtZVtvcHRfbWV0aG9kTmFtZV0gPT09IGNhbGxlcikge1xuICAgIHJldHVybiBtZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGVbb3B0X21ldGhvZE5hbWVdLmFwcGx5KG1lLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgJ2dvb2cuYmFzZSBjYWxsZWQgZnJvbSBhIG1ldGhvZCBvZiBvbmUgbmFtZSAnICtcbiAgICAgICAgJ3RvIGEgbWV0aG9kIG9mIGEgZGlmZmVyZW50IG5hbWUnKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEFsbG93IGZvciBhbGlhc2luZyB3aXRoaW4gc2NvcGUgZnVuY3Rpb25zLiAgVGhpcyBmdW5jdGlvbiBleGlzdHMgZm9yXG4gKiB1bmNvbXBpbGVkIGNvZGUgLSBpbiBjb21waWxlZCBjb2RlIHRoZSBjYWxscyB3aWxsIGJlIGlubGluZWQgYW5kIHRoZSBhbGlhc2VzXG4gKiBhcHBsaWVkLiAgSW4gdW5jb21waWxlZCBjb2RlIHRoZSBmdW5jdGlvbiBpcyBzaW1wbHkgcnVuIHNpbmNlIHRoZSBhbGlhc2VzIGFzXG4gKiB3cml0dGVuIGFyZSB2YWxpZCBKYXZhU2NyaXB0LlxuICpcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGZuIEZ1bmN0aW9uIHRvIGNhbGwuICBUaGlzIGZ1bmN0aW9uIGNhbiBjb250YWluIGFsaWFzZXNcbiAqICAgICB0byBuYW1lc3BhY2VzIChlLmcuIFwidmFyIGRvbSA9IGdvb2cuZG9tXCIpIG9yIGNsYXNzZXNcbiAqICAgICAoZS5nLiBcInZhciBUaW1lciA9IGdvb2cuVGltZXJcIikuXG4gKi9cbmdvb2cuc2NvcGUgPSBmdW5jdGlvbihmbikge1xuICBmbi5jYWxsKGdvb2cuZ2xvYmFsKTtcbn07XG5cblxuLypcbiAqIFRvIHN1cHBvcnQgdW5jb21waWxlZCwgc3RyaWN0IG1vZGUgYnVuZGxlcyB0aGF0IHVzZSBldmFsIHRvIGRpdmlkZSBzb3VyY2VcbiAqIGxpa2Ugc286XG4gKiAgICBldmFsKCdzb21lU291cmNlOy8vIyBzb3VyY2VVcmwgc291cmNlZmlsZS5qcycpO1xuICogV2UgbmVlZCB0byBleHBvcnQgdGhlIGdsb2JhbGx5IGRlZmluZWQgc3ltYm9scyBcImdvb2dcIiBhbmQgXCJDT01QSUxFRFwiLlxuICogRXhwb3J0aW5nIFwiZ29vZ1wiIGJyZWFrcyB0aGUgY29tcGlsZXIgb3B0aW1pemF0aW9ucywgc28gd2UgcmVxdWlyZWQgdGhhdFxuICogYmUgZGVmaW5lZCBleHRlcm5hbGx5LlxuICogTk9URTogV2UgZG9uJ3QgdXNlIGdvb2cuZXhwb3J0U3ltYm9sIGhlcmUgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIHRyaWdnZXJcbiAqIGV4dGVybiBnZW5lcmF0aW9uIHdoZW4gdGhhdCBjb21waWxlciBvcHRpb24gaXMgZW5hYmxlZC5cbiAqL1xuaWYgKCFDT01QSUxFRCkge1xuICBnb29nLmdsb2JhbFsnQ09NUElMRUQnXSA9IENPTVBJTEVEO1xufVxuXG5nb29nLnN0cmluZyA9IHt9O1xuXG5cbi8qKlxuICogRG9lcyBzaW1wbGUgcHl0aG9uLXN0eWxlIHN0cmluZyBzdWJzdGl0dXRpb24uXG4gKiBzdWJzKFwiZm9vJXMgaG90JXNcIiwgXCJiYXJcIiwgXCJkb2dcIikgYmVjb21lcyBcImZvb2JhciBob3Rkb2dcIi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyBjb250YWluaW5nIHRoZSBwYXR0ZXJuLlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBUaGUgaXRlbXMgdG8gc3Vic3RpdHV0ZSBpbnRvIHRoZSBwYXR0ZXJuLlxuICogQHJldHVybiB7c3RyaW5nfSBBIGNvcHkgb2Yge0Bjb2RlIHN0cn0gaW4gd2hpY2ggZWFjaCBvY2N1cnJlbmNlIG9mXG4gKiAgICAge0Bjb2RlICVzfSBoYXMgYmVlbiByZXBsYWNlZCBhbiBhcmd1bWVudCBmcm9tIHtAY29kZSB2YXJfYXJnc30uXG4gKi9cbmdvb2cuc3RyaW5nLnN1YnMgPSBmdW5jdGlvbihzdHIsIHZhcl9hcmdzKSB7XG4gIHZhciBzcGxpdFBhcnRzID0gc3RyLnNwbGl0KCclcycpO1xuICB2YXIgcmV0dXJuU3RyaW5nID0gJyc7XG5cbiAgdmFyIHN1YnNBcmd1bWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc3Vic0FyZ3VtZW50cy5sZW5ndGggJiZcbiAgICAgICAgIC8vIFJlcGxhY2UgdXAgdG8gdGhlIGxhc3Qgc3BsaXQgcGFydC4gV2UgYXJlIGluc2VydGluZyBpbiB0aGVcbiAgICAgICAgIC8vIHBvc2l0aW9ucyBiZXR3ZWVuIHNwbGl0IHBhcnRzLlxuICAgICAgICAgc3BsaXRQYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuU3RyaW5nICs9IHNwbGl0UGFydHMuc2hpZnQoKSArIHN1YnNBcmd1bWVudHMuc2hpZnQoKTtcbiAgfVxuXG4gIHJldHVybiByZXR1cm5TdHJpbmcgKyBzcGxpdFBhcnRzLmpvaW4oJyVzJyk7ICAvLyBKb2luIHVudXNlZCAnJXMnXG59O1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgYW4gYW1wZXJzYW5kLCBmb3IgdXNlIGluIGVzY2FwaW5nLlxuICogQGNvbnN0IHshUmVnRXhwfVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5zdHJpbmcuQU1QX1JFXyA9IC8mL2c7XG5cblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGEgbGVzcyB0aGFuIHNpZ24sIGZvciB1c2UgaW4gZXNjYXBpbmcuXG4gKiBAY29uc3QgeyFSZWdFeHB9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLnN0cmluZy5MVF9SRV8gPSAvPC9nO1xuXG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBhIGdyZWF0ZXIgdGhhbiBzaWduLCBmb3IgdXNlIGluIGVzY2FwaW5nLlxuICogQGNvbnN0IHshUmVnRXhwfVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5zdHJpbmcuR1RfUkVfID0gLz4vZztcblxuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgYSBkb3VibGUgcXVvdGUsIGZvciB1c2UgaW4gZXNjYXBpbmcuXG4gKiBAY29uc3QgeyFSZWdFeHB9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLnN0cmluZy5RVU9UX1JFXyA9IC9cIi9nO1xuXG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBhIHNpbmdsZSBxdW90ZSwgZm9yIHVzZSBpbiBlc2NhcGluZy5cbiAqIEBjb25zdCB7IVJlZ0V4cH1cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cuc3RyaW5nLlNJTkdMRV9RVU9URV9SRV8gPSAvJy9nO1xuXG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBudWxsIGNoYXJhY3RlciwgZm9yIHVzZSBpbiBlc2NhcGluZy5cbiAqIEBjb25zdCB7IVJlZ0V4cH1cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cuc3RyaW5nLk5VTExfUkVfID0gL1xceDAwL2c7XG5cblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGEgbG93ZXJjYXNlIGxldHRlciBcImVcIiwgZm9yIHVzZSBpbiBlc2NhcGluZy5cbiAqIEBjb25zdCB7IVJlZ0V4cH1cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cuc3RyaW5nLkVfUkVfID0gL2UvZztcblxuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgYW55IGNoYXJhY3RlciB0aGF0IG5lZWRzIHRvIGJlIGVzY2FwZWQuXG4gKiBAY29uc3QgeyFSZWdFeHB9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLnN0cmluZy5BTExfUkVfID1cbiAgICAoZ29vZy5zdHJpbmcuREVURUNUX0RPVUJMRV9FU0NBUElORyA/IC9bXFx4MDAmPD5cIidlXS8gOiAvW1xceDAwJjw+XCInXS8pO1xuXG4vKipcbiAqIEVzY2FwZXMgZG91YmxlIHF1b3RlICdcIicgYW5kIHNpbmdsZSBxdW90ZSAnXFwnJyBjaGFyYWN0ZXJzIGluIGFkZGl0aW9uIHRvXG4gKiAnJicsICc8JywgYW5kICc+JyBzbyB0aGF0IGEgc3RyaW5nIGNhbiBiZSBpbmNsdWRlZCBpbiBhbiBIVE1MIHRhZyBhdHRyaWJ1dGVcbiAqIHZhbHVlIHdpdGhpbiBkb3VibGUgb3Igc2luZ2xlIHF1b3Rlcy5cbiAqXG4gKiBJdCBzaG91bGQgYmUgbm90ZWQgdGhhdCA+IGRvZXNuJ3QgbmVlZCB0byBiZSBlc2NhcGVkIGZvciB0aGUgSFRNTCBvciBYTUwgdG9cbiAqIGJlIHZhbGlkLCBidXQgaXQgaGFzIGJlZW4gZGVjaWRlZCB0byBlc2NhcGUgaXQgZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXJcbiAqIGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKiBXaXRoIGdvb2cuc3RyaW5nLkRFVEVDVF9ET1VCTEVfRVNDQVBJTkcsIHRoaXMgZnVuY3Rpb24gZXNjYXBlcyBhbHNvIHRoZVxuICogbG93ZXJjYXNlIGxldHRlciBcImVcIi5cbiAqXG4gKiBOT1RFKHVzZXIpOlxuICogSHRtbEVzY2FwZSBpcyBvZnRlbiBjYWxsZWQgZHVyaW5nIHRoZSBnZW5lcmF0aW9uIG9mIGxhcmdlIGJsb2NrcyBvZiBIVE1MLlxuICogVXNpbmcgc3RhdGljcyBmb3IgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgYW5kIHN0cmluZ3MgaXMgYW4gb3B0aW1pemF0aW9uXG4gKiB0aGF0IGNhbiBtb3JlIHRoYW4gaGFsZiB0aGUgYW1vdW50IG9mIHRpbWUgSUUgc3BlbmRzIGluIHRoaXMgZnVuY3Rpb24gZm9yXG4gKiBsYXJnZSBhcHBzLCBzaW5jZSBzdHJpbmdzIGFuZCByZWdleGVzIGJvdGggY29udHJpYnV0ZSB0byBHQyBhbGxvY2F0aW9ucy5cbiAqXG4gKiBUZXN0aW5nIGZvciB0aGUgcHJlc2VuY2Ugb2YgYSBjaGFyYWN0ZXIgYmVmb3JlIGVzY2FwaW5nIGluY3JlYXNlcyB0aGUgbnVtYmVyXG4gKiBvZiBmdW5jdGlvbiBjYWxscywgYnV0IGFjdHVhbGx5IHByb3ZpZGVzIGEgc3BlZWQgaW5jcmVhc2UgZm9yIHRoZSBhdmVyYWdlXG4gKiBjYXNlIC0tIHNpbmNlIHRoZSBhdmVyYWdlIGNhc2Ugb2Z0ZW4gZG9lc24ndCByZXF1aXJlIHRoZSBlc2NhcGluZyBvZiBhbGwgNFxuICogY2hhcmFjdGVycyBhbmQgaW5kZXhPZigpIGlzIG11Y2ggY2hlYXBlciB0aGFuIHJlcGxhY2UoKS5cbiAqIFRoZSB3b3JzdCBjYXNlIGRvZXMgc3VmZmVyIHNsaWdodGx5IGZyb20gdGhlIGFkZGl0aW9uYWwgY2FsbHMsIHRoZXJlZm9yZSB0aGVcbiAqIG9wdF9pc0xpa2VseVRvQ29udGFpbkh0bWxDaGFycyBvcHRpb24gaGFzIGJlZW4gaW5jbHVkZWQgZm9yIHNpdHVhdGlvbnNcbiAqIHdoZXJlIGFsbCA0IEhUTUwgZW50aXRpZXMgYXJlIHZlcnkgbGlrZWx5IHRvIGJlIHByZXNlbnQgYW5kIG5lZWQgZXNjYXBpbmcuXG4gKlxuICogU29tZSBiZW5jaG1hcmtzICh0aW1lcyB0ZW5kZWQgdG8gZmx1Y3R1YXRlICstMC4wNW1zKTpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZpcmVGb3ggICAgICAgICAgICAgICAgICAgICBJRTZcbiAqIChubyBjaGFycyAvIGF2ZXJhZ2UgKG1peCBvZiBjYXNlcykgLyBhbGwgNCBjaGFycylcbiAqIG5vIGNoZWNrcyAgICAgICAgICAgICAgICAgICAgIDAuMTMgLyAwLjIyIC8gMC4yMiAgICAgICAgIDAuMjMgLyAwLjUzIC8gMC44MFxuICogaW5kZXhPZiAgICAgICAgICAgICAgICAgICAgICAgMC4wOCAvIDAuMTcgLyAwLjI2ICAgICAgICAgMC4yMiAvIDAuNTQgLyAwLjg0XG4gKiBpbmRleE9mICsgcmUgdGVzdCAgICAgICAgICAgICAwLjA3IC8gMC4xNyAvIDAuMjggICAgICAgICAwLjE5IC8gMC41MCAvIDAuODVcbiAqXG4gKiBBbiBhZGRpdGlvbmFsIGFkdmFudGFnZSBvZiBjaGVja2luZyBpZiByZXBsYWNlIGFjdHVhbGx5IG5lZWRzIHRvIGJlIGNhbGxlZFxuICogaXMgYSByZWR1Y3Rpb24gaW4gdGhlIG51bWJlciBvZiBvYmplY3QgYWxsb2NhdGlvbnMsIHNvIGFzIHRoZSBzaXplIG9mIHRoZVxuICogYXBwbGljYXRpb24gZ3Jvd3MgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgdmFyaW91cyBtZXRob2RzIHdvdWxkIGluY3JlYXNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgc3RyaW5nIHRvIGJlIGVzY2FwZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaXNMaWtlbHlUb0NvbnRhaW5IdG1sQ2hhcnMgRG9uJ3QgcGVyZm9ybSBhIGNoZWNrIHRvIHNlZVxuICogICAgIGlmIHRoZSBjaGFyYWN0ZXIgbmVlZHMgcmVwbGFjaW5nIC0gdXNlIHRoaXMgb3B0aW9uIGlmIHlvdSBleHBlY3QgZWFjaCBvZlxuICogICAgIHRoZSBjaGFyYWN0ZXJzIHRvIGFwcGVhciBvZnRlbi4gTGVhdmUgZmFsc2UgaWYgeW91IGV4cGVjdCBmZXcgaHRtbFxuICogICAgIGNoYXJhY3RlcnMgdG8gb2NjdXIgaW4geW91ciBzdHJpbmdzLCBzdWNoIGFzIGlmIHlvdSBhcmUgZXNjYXBpbmcgSFRNTC5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBjb3B5IG9mIHtAY29kZSBzdHJ9LlxuICovXG5nb29nLnN0cmluZy5odG1sRXNjYXBlID0gZnVuY3Rpb24oc3RyLCBvcHRfaXNMaWtlbHlUb0NvbnRhaW5IdG1sQ2hhcnMpIHtcblxuICBpZiAob3B0X2lzTGlrZWx5VG9Db250YWluSHRtbENoYXJzKSB7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoZ29vZy5zdHJpbmcuQU1QX1JFXywgJyZhbXA7JylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoZ29vZy5zdHJpbmcuTFRfUkVfLCAnJmx0OycpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKGdvb2cuc3RyaW5nLkdUX1JFXywgJyZndDsnKVxuICAgICAgICAgICAgICAucmVwbGFjZShnb29nLnN0cmluZy5RVU9UX1JFXywgJyZxdW90OycpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKGdvb2cuc3RyaW5nLlNJTkdMRV9RVU9URV9SRV8sICcmIzM5OycpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKGdvb2cuc3RyaW5nLk5VTExfUkVfLCAnJiMwOycpO1xuICAgIGlmIChnb29nLnN0cmluZy5ERVRFQ1RfRE9VQkxFX0VTQ0FQSU5HKSB7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShnb29nLnN0cmluZy5FX1JFXywgJyYjMTAxOycpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuXG4gIH0gZWxzZSB7XG4gICAgLy8gcXVpY2sgdGVzdCBoZWxwcyBpbiB0aGUgY2FzZSB3aGVuIHRoZXJlIGFyZSBubyBjaGFycyB0byByZXBsYWNlLCBpblxuICAgIC8vIHdvcnN0IGNhc2UgdGhpcyBtYWtlcyBiYXJlbHkgYSBkaWZmZXJlbmNlIHRvIHRoZSB0aW1lIHRha2VuXG4gICAgaWYgKCFnb29nLnN0cmluZy5BTExfUkVfLnRlc3Qoc3RyKSkgcmV0dXJuIHN0cjtcblxuICAgIC8vIHN0ci5pbmRleE9mIGlzIGZhc3RlciB0aGFuIHJlZ2V4LnRlc3QgaW4gdGhpcyBjYXNlXG4gICAgaWYgKHN0ci5pbmRleE9mKCcmJykgIT0gLTEpIHtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKGdvb2cuc3RyaW5nLkFNUF9SRV8sICcmYW1wOycpO1xuICAgIH1cbiAgICBpZiAoc3RyLmluZGV4T2YoJzwnKSAhPSAtMSkge1xuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoZ29vZy5zdHJpbmcuTFRfUkVfLCAnJmx0OycpO1xuICAgIH1cbiAgICBpZiAoc3RyLmluZGV4T2YoJz4nKSAhPSAtMSkge1xuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoZ29vZy5zdHJpbmcuR1RfUkVfLCAnJmd0OycpO1xuICAgIH1cbiAgICBpZiAoc3RyLmluZGV4T2YoJ1wiJykgIT0gLTEpIHtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKGdvb2cuc3RyaW5nLlFVT1RfUkVfLCAnJnF1b3Q7Jyk7XG4gICAgfVxuICAgIGlmIChzdHIuaW5kZXhPZignXFwnJykgIT0gLTEpIHtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKGdvb2cuc3RyaW5nLlNJTkdMRV9RVU9URV9SRV8sICcmIzM5OycpO1xuICAgIH1cbiAgICBpZiAoc3RyLmluZGV4T2YoJ1xceDAwJykgIT0gLTEpIHtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKGdvb2cuc3RyaW5nLk5VTExfUkVfLCAnJiMwOycpO1xuICAgIH1cbiAgICBpZiAoZ29vZy5zdHJpbmcuREVURUNUX0RPVUJMRV9FU0NBUElORyAmJiBzdHIuaW5kZXhPZignZScpICE9IC0xKSB7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShnb29nLnN0cmluZy5FX1JFXywgJyYjMTAxOycpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG59O1xuXG5cbmdvb2cuZGVidWcgPSB7fTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0eXBlIG9mIGEgdmFsdWUuIElmIGEgY29uc3RydWN0b3IgaXMgcGFzc2VkLCBhbmQgYSBzdWl0YWJsZVxuICogc3RyaW5nIGNhbm5vdCBiZSBmb3VuZCwgJ3Vua25vd24gdHlwZSBuYW1lJyB3aWxsIGJlIHJldHVybmVkLlxuICpcbiAqIDxwPkZvcmtlZCByYXRoZXIgdGhhbiBtb3ZlZCBmcm9tIHtAbGluayBnb29nLmFzc2VydHMuZ2V0VHlwZV99XG4gKiB0byBhdm9pZCBhZGRpbmcgYSBkZXBlbmRlbmN5IHRvIGdvb2cuYXNzZXJ0cy5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQSBjb25zdHJ1Y3Rvciwgb2JqZWN0LCBvciBwcmltaXRpdmUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBiZXN0IGRpc3BsYXkgbmFtZSBmb3IgdGhlIHZhbHVlLCBvciAndW5rbm93biB0eXBlIG5hbWUnLlxuICovXG5nb29nLmRlYnVnLnJ1bnRpbWVUeXBlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gdmFsdWUuZGlzcGxheU5hbWUgfHwgdmFsdWUubmFtZSB8fCAndW5rbm93biB0eXBlIG5hbWUnO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHxcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgdmFsdWU7XG4gIH1cbn07XG5cbi8vIENvcHlyaWdodCAyMDA5IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUHJvdmlkZXMgYSBiYXNlIGNsYXNzIGZvciBjdXN0b20gRXJyb3Igb2JqZWN0cyBzdWNoIHRoYXQgdGhlXG4gKiBzdGFjayBpcyBjb3JyZWN0bHkgbWFpbnRhaW5lZC5cbiAqXG4gKiBZb3Ugc2hvdWxkIG5ldmVyIG5lZWQgdG8gdGhyb3cgZ29vZy5kZWJ1Zy5FcnJvcihtc2cpIGRpcmVjdGx5LCBFcnJvcihtc2cpIGlzXG4gKiBzdWZmaWNpZW50LlxuICpcbiAqL1xuXG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgY3VzdG9tIGVycm9yIG9iamVjdHMuXG4gKiBAcGFyYW0geyo9fSBvcHRfbXNnIFRoZSBtZXNzYWdlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXJyb3IuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtFcnJvcn1cbiAqL1xuZ29vZy5kZWJ1Zy5FcnJvciA9IGZ1bmN0aW9uKG9wdF9tc2cpIHtcblxuICAvLyBBdHRlbXB0IHRvIGVuc3VyZSB0aGVyZSBpcyBhIHN0YWNrIHRyYWNlLlxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBnb29nLmRlYnVnLkVycm9yKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICBpZiAoc3RhY2spIHtcbiAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICB9XG4gIH1cblxuICBpZiAob3B0X21zZykge1xuICAgIHRoaXMubWVzc2FnZSA9IFN0cmluZyhvcHRfbXNnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlcG9ydCB0aGlzIGVycm9yIHRvIHRoZSBzZXJ2ZXIuIFNldHRpbmcgdGhpcyB0byBmYWxzZSB3aWxsXG4gICAqIGNhdXNlIHRoZSBlcnJvciByZXBvcnRlciB0byBub3QgcmVwb3J0IHRoZSBlcnJvciBiYWNrIHRvIHRoZSBzZXJ2ZXIsXG4gICAqIHdoaWNoIGNhbiBiZSB1c2VmdWwgaWYgdGhlIGNsaWVudCBrbm93cyB0aGF0IHRoZSBlcnJvciBoYXMgYWxyZWFkeSBiZWVuXG4gICAqIGxvZ2dlZCBvbiB0aGUgc2VydmVyLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMucmVwb3J0RXJyb3JUb1NlcnZlciA9IHRydWU7XG59O1xuZ29vZy5pbmhlcml0cyhnb29nLmRlYnVnLkVycm9yLCBFcnJvcik7XG5cblxuLyoqIEBvdmVycmlkZSAqL1xuZ29vZy5kZWJ1Zy5FcnJvci5wcm90b3R5cGUubmFtZSA9ICdDdXN0b21FcnJvcic7XG5cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERlZmluaXRpb24gb2YgZ29vZy5kb20uTm9kZVR5cGUuXG4gKi9cblxuZ29vZy5kb20gPSB7fTtcblxuLyoqXG4gKiBDb25zdGFudHMgZm9yIHRoZSBub2RlVHlwZSBhdHRyaWJ1dGUgaW4gdGhlIE5vZGUgaW50ZXJmYWNlLlxuICpcbiAqIFRoZXNlIGNvbnN0YW50cyBtYXRjaCB0aG9zZSBzcGVjaWZpZWQgaW4gdGhlIE5vZGUgaW50ZXJmYWNlLiBUaGVzZSBhcmVcbiAqIHVzdWFsbHkgcHJlc2VudCBvbiB0aGUgTm9kZSBvYmplY3QgaW4gcmVjZW50IGJyb3dzZXJzLCBidXQgbm90IGluIG9sZGVyXG4gKiBicm93c2VycyAoc3BlY2lmaWNhbGx5LCBlYXJseSBJRXMpIGFuZCB0aHVzIGFyZSBnaXZlbiBoZXJlLlxuICpcbiAqIEluIHNvbWUgYnJvd3NlcnMgKGVhcmx5IElFcyksIHRoZXNlIGFyZSBub3QgZGVmaW5lZCBvbiB0aGUgTm9kZSBvYmplY3QsXG4gKiBzbyB0aGV5IGFyZSBwcm92aWRlZCBoZXJlLlxuICpcbiAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1Db3JlL2NvcmUuaHRtbCNJRC0xOTUwNjQxMjQ3XG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5nb29nLmRvbS5Ob2RlVHlwZSA9IHtcbiAgRUxFTUVOVDogMSxcbiAgQVRUUklCVVRFOiAyLFxuICBURVhUOiAzLFxuICBDREFUQV9TRUNUSU9OOiA0LFxuICBFTlRJVFlfUkVGRVJFTkNFOiA1LFxuICBFTlRJVFk6IDYsXG4gIFBST0NFU1NJTkdfSU5TVFJVQ1RJT046IDcsXG4gIENPTU1FTlQ6IDgsXG4gIERPQ1VNRU5UOiA5LFxuICBET0NVTUVOVF9UWVBFOiAxMCxcbiAgRE9DVU1FTlRfRlJBR01FTlQ6IDExLFxuICBOT1RBVElPTjogMTJcbn07XG5cbi8vIENvcHlyaWdodCAyMDA3IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHN1cHBvcnRpbmcgQmlkaSBpc3N1ZXMuXG4gKi9cblxuXG4vKipcbiAqIE5hbWVzcGFjZSBmb3IgYmlkaSBzdXBwb3J0aW5nIGZ1bmN0aW9ucy5cbiAqL1xuZ29vZy5wcm92aWRlKCdnb29nLmkxOG4uYmlkaScpO1xuZ29vZy5wcm92aWRlKCdnb29nLmkxOG4uYmlkaS5EaXInKTtcbmdvb2cucHJvdmlkZSgnZ29vZy5pMThuLmJpZGkuRGlyZWN0aW9uYWxTdHJpbmcnKTtcbmdvb2cucHJvdmlkZSgnZ29vZy5pMThuLmJpZGkuRm9ybWF0Jyk7XG5cblxuLyoqXG4gKiBAZGVmaW5lIHtib29sZWFufSBGT1JDRV9SVEwgZm9yY2VzIHRoZSB7QGxpbmsgZ29vZy5pMThuLmJpZGkuSVNfUlRMfSBjb25zdGFudFxuICogdG8gc2F5IHRoYXQgdGhlIGN1cnJlbnQgbG9jYWxlIGlzIGEgUlRMIGxvY2FsZS4gIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZFxuICogaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3IgZm9yIGRlY2lkaW5nIHdoZXRoZXIgdGhlXG4gKiBjdXJyZW50IGxvY2FsZSBpcyBSVEwgb3Igbm90LlxuICpcbiAqIHtAc2VlIGdvb2cuaTE4bi5iaWRpLklTX1JUTH1cbiAqL1xuZ29vZy5kZWZpbmUoJ2dvb2cuaTE4bi5iaWRpLkZPUkNFX1JUTCcsIGZhbHNlKTtcblxuXG4vKipcbiAqIENvbnN0YW50IHRoYXQgZGVmaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgY3VycmVudCBsb2NhbGUgaXMgYSBSVEwgbG9jYWxlLlxuICogSWYge0BsaW5rIGdvb2cuaTE4bi5iaWRpLkZPUkNFX1JUTH0gaXMgbm90IHRydWUsIHRoaXMgY29uc3RhbnQgd2lsbCBkZWZhdWx0XG4gKiB0byBjaGVjayB0aGF0IHtAbGluayBnb29nLkxPQ0FMRX0gaXMgb25lIG9mIGEgZmV3IG1ham9yIFJUTCBsb2NhbGVzLlxuICpcbiAqIDxwPlRoaXMgaXMgZGVzaWduZWQgdG8gYmUgYSBtYXhpbWFsbHkgZWZmaWNpZW50IGNvbXBpbGUtdGltZSBjb25zdGFudC4gRm9yXG4gKiBleGFtcGxlLCBmb3IgdGhlIGRlZmF1bHQgZ29vZy5MT0NBTEUsIGNvbXBpbGluZ1xuICogXCJpZiAoZ29vZy5pMThuLmJpZGkuSVNfUlRMKSBhbGVydCgncnRsJykgZWxzZSB7fVwiIHNob3VsZCBwcm9kdWNlIG5vIGNvZGUuIEl0XG4gKiBpcyB0aGlzIGRlc2lnbiBjb25zaWRlcmF0aW9uIHRoYXQgbGltaXRzIHRoZSBpbXBsZW1lbnRhdGlvbiB0byBvbmx5XG4gKiBzdXBwb3J0aW5nIGEgZmV3IG1ham9yIFJUTCBsb2NhbGVzLCBhcyBvcHBvc2VkIHRvIHRoZSBicm9hZGVyIHJlcGVydG9pcmUgb2ZcbiAqIHNvbWV0aGluZyBsaWtlIGdvb2cuaTE4bi5iaWRpLmlzUnRsTGFuZ3VhZ2UuXG4gKlxuICogPHA+U2luY2UgdGhpcyBjb25zdGFudCByZWZlcnMgdG8gdGhlIGRpcmVjdGlvbmFsaXR5IG9mIHRoZSBsb2NhbGUsIGl0IGlzIHVwXG4gKiB0byB0aGUgY2FsbGVyIHRvIGRldGVybWluZSBpZiB0aGlzIGNvbnN0YW50IHNob3VsZCBhbHNvIGJlIHVzZWQgZm9yIHRoZVxuICogZGlyZWN0aW9uIG9mIHRoZSBVSS5cbiAqXG4gKiB7QHNlZSBnb29nLkxPQ0FMRX1cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqXG4gKiBUT0RPKHVzZXIpOiB3cml0ZSBhIHRlc3QgdGhhdCBjaGVja3MgdGhhdCB0aGlzIGlzIGEgY29tcGlsZS10aW1lIGNvbnN0YW50LlxuICovXG5nb29nLmkxOG4uYmlkaS5JU19SVEwgPSBnb29nLmkxOG4uYmlkaS5GT1JDRV9SVEwgfHxcbiAgICAoKGdvb2cuTE9DQUxFLnN1YnN0cmluZygwLCAyKS50b0xvd2VyQ2FzZSgpID09ICdhcicgfHxcbiAgICAgIGdvb2cuTE9DQUxFLnN1YnN0cmluZygwLCAyKS50b0xvd2VyQ2FzZSgpID09ICdmYScgfHxcbiAgICAgIGdvb2cuTE9DQUxFLnN1YnN0cmluZygwLCAyKS50b0xvd2VyQ2FzZSgpID09ICdoZScgfHxcbiAgICAgIGdvb2cuTE9DQUxFLnN1YnN0cmluZygwLCAyKS50b0xvd2VyQ2FzZSgpID09ICdpdycgfHxcbiAgICAgIGdvb2cuTE9DQUxFLnN1YnN0cmluZygwLCAyKS50b0xvd2VyQ2FzZSgpID09ICdwcycgfHxcbiAgICAgIGdvb2cuTE9DQUxFLnN1YnN0cmluZygwLCAyKS50b0xvd2VyQ2FzZSgpID09ICdzZCcgfHxcbiAgICAgIGdvb2cuTE9DQUxFLnN1YnN0cmluZygwLCAyKS50b0xvd2VyQ2FzZSgpID09ICd1ZycgfHxcbiAgICAgIGdvb2cuTE9DQUxFLnN1YnN0cmluZygwLCAyKS50b0xvd2VyQ2FzZSgpID09ICd1cicgfHxcbiAgICAgIGdvb2cuTE9DQUxFLnN1YnN0cmluZygwLCAyKS50b0xvd2VyQ2FzZSgpID09ICd5aScpICYmXG4gICAgIChnb29nLkxPQ0FMRS5sZW5ndGggPT0gMiB8fCBnb29nLkxPQ0FMRS5zdWJzdHJpbmcoMiwgMykgPT0gJy0nIHx8XG4gICAgICBnb29nLkxPQ0FMRS5zdWJzdHJpbmcoMiwgMykgPT0gJ18nKSkgfHxcbiAgICAoZ29vZy5MT0NBTEUubGVuZ3RoID49IDMgJiZcbiAgICAgZ29vZy5MT0NBTEUuc3Vic3RyaW5nKDAsIDMpLnRvTG93ZXJDYXNlKCkgPT0gJ2NrYicgJiZcbiAgICAgKGdvb2cuTE9DQUxFLmxlbmd0aCA9PSAzIHx8IGdvb2cuTE9DQUxFLnN1YnN0cmluZygzLCA0KSA9PSAnLScgfHxcbiAgICAgIGdvb2cuTE9DQUxFLnN1YnN0cmluZygzLCA0KSA9PSAnXycpKTtcblxuXG4vKipcbiAqIFVuaWNvZGUgZm9ybWF0dGluZyBjaGFyYWN0ZXJzIGFuZCBkaXJlY3Rpb25hbGl0eSBzdHJpbmcgY29uc3RhbnRzLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZ29vZy5pMThuLmJpZGkuRm9ybWF0ID0ge1xuICAvKiogVW5pY29kZSBcIkxlZnQtVG8tUmlnaHQgRW1iZWRkaW5nXCIgKExSRSkgY2hhcmFjdGVyLiAqL1xuICBMUkU6ICdcXHUyMDJBJyxcbiAgLyoqIFVuaWNvZGUgXCJSaWdodC1Uby1MZWZ0IEVtYmVkZGluZ1wiIChSTEUpIGNoYXJhY3Rlci4gKi9cbiAgUkxFOiAnXFx1MjAyQicsXG4gIC8qKiBVbmljb2RlIFwiUG9wIERpcmVjdGlvbmFsIEZvcm1hdHRpbmdcIiAoUERGKSBjaGFyYWN0ZXIuICovXG4gIFBERjogJ1xcdTIwMkMnLFxuICAvKiogVW5pY29kZSBcIkxlZnQtVG8tUmlnaHQgTWFya1wiIChMUk0pIGNoYXJhY3Rlci4gKi9cbiAgTFJNOiAnXFx1MjAwRScsXG4gIC8qKiBVbmljb2RlIFwiUmlnaHQtVG8tTGVmdCBNYXJrXCIgKFJMTSkgY2hhcmFjdGVyLiAqL1xuICBSTE06ICdcXHUyMDBGJ1xufTtcblxuXG4vKipcbiAqIERpcmVjdGlvbmFsaXR5IGVudW0uXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5nb29nLmkxOG4uYmlkaS5EaXIgPSB7XG4gIC8qKlxuICAgKiBMZWZ0LXRvLXJpZ2h0LlxuICAgKi9cbiAgTFRSOiAxLFxuXG4gIC8qKlxuICAgKiBSaWdodC10by1sZWZ0LlxuICAgKi9cbiAgUlRMOiAtMSxcblxuICAvKipcbiAgICogTmVpdGhlciBsZWZ0LXRvLXJpZ2h0IG5vciByaWdodC10by1sZWZ0LlxuICAgKi9cbiAgTkVVVFJBTDogMFxufTtcblxuXG4vKipcbiAqICdyaWdodCcgc3RyaW5nIGNvbnN0YW50LlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZ29vZy5pMThuLmJpZGkuUklHSFQgPSAncmlnaHQnO1xuXG5cbi8qKlxuICogJ2xlZnQnIHN0cmluZyBjb25zdGFudC5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmdvb2cuaTE4bi5iaWRpLkxFRlQgPSAnbGVmdCc7XG5cblxuLyoqXG4gKiAnbGVmdCcgaWYgbG9jYWxlIGlzIFJUTCwgJ3JpZ2h0JyBpZiBub3QuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5nb29nLmkxOG4uYmlkaS5JMThOX1JJR0hUID1cbiAgICBnb29nLmkxOG4uYmlkaS5JU19SVEwgPyBnb29nLmkxOG4uYmlkaS5MRUZUIDogZ29vZy5pMThuLmJpZGkuUklHSFQ7XG5cblxuLyoqXG4gKiAncmlnaHQnIGlmIGxvY2FsZSBpcyBSVEwsICdsZWZ0JyBpZiBub3QuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5nb29nLmkxOG4uYmlkaS5JMThOX0xFRlQgPVxuICAgIGdvb2cuaTE4bi5iaWRpLklTX1JUTCA/IGdvb2cuaTE4bi5iaWRpLlJJR0hUIDogZ29vZy5pMThuLmJpZGkuTEVGVDtcblxuXG4vKipcbiAqIENvbnZlcnQgYSBkaXJlY3Rpb25hbGl0eSBnaXZlbiBpbiB2YXJpb3VzIGZvcm1hdHMgdG8gYSBnb29nLmkxOG4uYmlkaS5EaXJcbiAqIGNvbnN0YW50LiBVc2VmdWwgZm9yIGludGVyYWN0aW9uIHdpdGggZGlmZmVyZW50IHN0YW5kYXJkcyBvZiBkaXJlY3Rpb25hbGl0eVxuICogcmVwcmVzZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtnb29nLmkxOG4uYmlkaS5EaXJ8bnVtYmVyfGJvb2xlYW58bnVsbH0gZ2l2ZW5EaXIgRGlyZWN0aW9uYWxpdHkgZ2l2ZW5cbiAqICAgICBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtYXRzOlxuICogICAgIDEuIEEgZ29vZy5pMThuLmJpZGkuRGlyIGNvbnN0YW50LlxuICogICAgIDIuIEEgbnVtYmVyIChwb3NpdGl2ZSA9IExUUiwgbmVnYXRpdmUgPSBSVEwsIDAgPSBuZXV0cmFsKS5cbiAqICAgICAzLiBBIGJvb2xlYW4gKHRydWUgPSBSVEwsIGZhbHNlID0gTFRSKS5cbiAqICAgICA0LiBBIG51bGwgZm9yIHVua25vd24gZGlyZWN0aW9uYWxpdHkuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfbm9OZXV0cmFsIFdoZXRoZXIgYSBnaXZlbkRpciBvZiB6ZXJvIG9yXG4gKiAgICAgZ29vZy5pMThuLmJpZGkuRGlyLk5FVVRSQUwgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgbnVsbCwgaS5lLiB1bmtub3duLCBpblxuICogICAgIG9yZGVyIHRvIHByZXNlcnZlIGxlZ2FjeSBiZWhhdmlvci5cbiAqIEByZXR1cm4gez9nb29nLmkxOG4uYmlkaS5EaXJ9IEEgZ29vZy5pMThuLmJpZGkuRGlyIGNvbnN0YW50IG1hdGNoaW5nIHRoZVxuICogICAgIGdpdmVuIGRpcmVjdGlvbmFsaXR5LiBJZiBnaXZlbiBudWxsLCByZXR1cm5zIG51bGwgKGkuZS4gdW5rbm93bikuXG4gKi9cbmdvb2cuaTE4bi5iaWRpLnRvRGlyID0gZnVuY3Rpb24oZ2l2ZW5EaXIsIG9wdF9ub05ldXRyYWwpIHtcbiAgaWYgKHR5cGVvZiBnaXZlbkRpciA9PSAnbnVtYmVyJykge1xuICAgIC8vIFRoaXMgaW5jbHVkZXMgdGhlIG5vbi1udWxsIGdvb2cuaTE4bi5iaWRpLkRpciBjYXNlLlxuICAgIHJldHVybiBnaXZlbkRpciA+IDAgPyBnb29nLmkxOG4uYmlkaS5EaXIuTFRSIDogZ2l2ZW5EaXIgPCAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ29vZy5pMThuLmJpZGkuRGlyLlJUTCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdF9ub05ldXRyYWwgPyBudWxsIDogZ29vZy5pMThuLmJpZGkuRGlyLk5FVVRSQUw7XG4gIH0gZWxzZSBpZiAoZ2l2ZW5EaXIgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIC8vIE11c3QgYmUgdHlwZW9mIGdpdmVuRGlyID09ICdib29sZWFuJy5cbiAgICByZXR1cm4gZ2l2ZW5EaXIgPyBnb29nLmkxOG4uYmlkaS5EaXIuUlRMIDogZ29vZy5pMThuLmJpZGkuRGlyLkxUUjtcbiAgfVxufTtcblxuXG4vKipcbiAqIEEgcHJhY3RpY2FsIHBhdHRlcm4gdG8gaWRlbnRpZnkgc3Ryb25nIExUUiBjaGFyYWN0ZXJzLiBUaGlzIHBhdHRlcm4gaXMgbm90XG4gKiB0aGVvcmV0aWNhbGx5IGNvcnJlY3QgYWNjb3JkaW5nIHRvIHRoZSBVbmljb2RlIHN0YW5kYXJkLiBJdCBpcyBzaW1wbGlmaWVkIGZvclxuICogcGVyZm9ybWFuY2UgYW5kIHNtYWxsIGNvZGUgc2l6ZS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmkxOG4uYmlkaS5sdHJDaGFyc18gPVxuICAgICdBLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyQjhcXHUwMzAwLVxcdTA1OTBcXHUwODAwLVxcdTFGRkYnICtcbiAgICAnXFx1MjAwRVxcdTJDMDAtXFx1RkIxQ1xcdUZFMDAtXFx1RkU2RlxcdUZFRkQtXFx1RkZGRic7XG5cblxuLyoqXG4gKiBBIHByYWN0aWNhbCBwYXR0ZXJuIHRvIGlkZW50aWZ5IHN0cm9uZyBSVEwgY2hhcmFjdGVyLiBUaGlzIHBhdHRlcm4gaXMgbm90XG4gKiB0aGVvcmV0aWNhbGx5IGNvcnJlY3QgYWNjb3JkaW5nIHRvIHRoZSBVbmljb2RlIHN0YW5kYXJkLiBJdCBpcyBzaW1wbGlmaWVkXG4gKiBmb3IgcGVyZm9ybWFuY2UgYW5kIHNtYWxsIGNvZGUgc2l6ZS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmkxOG4uYmlkaS5ydGxDaGFyc18gPVxuICAgICdcXHUwNTkxLVxcdTA2RUZcXHUwNkZBLVxcdTA3RkZcXHUyMDBGXFx1RkIxRC1cXHVGREZGXFx1RkU3MC1cXHVGRUZDJztcblxuXG4vKipcbiAqIFNpbXBsaWZpZWQgcmVndWxhciBleHByZXNzaW9uIGZvciBhbiBIVE1MIHRhZyAob3BlbmluZyBvciBjbG9zaW5nKSBvciBhbiBIVE1MXG4gKiBlc2NhcGUuIFdlIG1pZ2h0IHdhbnQgdG8gc2tpcCBvdmVyIHN1Y2ggZXhwcmVzc2lvbnMgd2hlbiBlc3RpbWF0aW5nIHRoZSB0ZXh0XG4gKiBkaXJlY3Rpb25hbGl0eS5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmkxOG4uYmlkaS5odG1sU2tpcFJlZ18gPSAvPFtePl0qPnwmW147XSs7L2c7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnB1dCB0ZXh0IHdpdGggc3BhY2VzIGluc3RlYWQgb2YgSFRNTCB0YWdzIG9yIEhUTUwgZXNjYXBlcywgaWZcbiAqIG9wdF9pc1N0cmlwTmVlZGVkIGlzIHRydWUuIEVsc2UgcmV0dXJucyB0aGUgaW5wdXQgYXMgaXMuXG4gKiBVc2VmdWwgZm9yIHRleHQgZGlyZWN0aW9uYWxpdHkgZXN0aW1hdGlvbi5cbiAqIE5vdGU6IHRoZSBmdW5jdGlvbiBzaG91bGQgbm90IGJlIHVzZWQgaW4gb3RoZXIgY29udGV4dHM7IGl0IGlzIG5vdCAxMDAlXG4gKiBjb3JyZWN0LCBidXQgcmF0aGVyIGEgZ29vZC1lbm91Z2ggaW1wbGVtZW50YXRpb24gZm9yIGRpcmVjdGlvbmFsaXR5XG4gKiBlc3RpbWF0aW9uIHB1cnBvc2VzLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgZ2l2ZW4gc3RyaW5nLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2lzU3RyaXBOZWVkZWQgV2hldGhlciB0byBwZXJmb3JtIHRoZSBzdHJpcHBpbmcuXG4gKiAgICAgRGVmYXVsdDogZmFsc2UgKHRvIHJldGFpbiBjb25zaXN0ZW5jeSB3aXRoIGNhbGxpbmcgZnVuY3Rpb25zKS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGdpdmVuIHN0cmluZyBjbGVhbmVkIG9mIEhUTUwgdGFncyAvIGVzY2FwZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmkxOG4uYmlkaS5zdHJpcEh0bWxJZk5lZWRlZF8gPSBmdW5jdGlvbihzdHIsIG9wdF9pc1N0cmlwTmVlZGVkKSB7XG4gIHJldHVybiBvcHRfaXNTdHJpcE5lZWRlZCA/IHN0ci5yZXBsYWNlKGdvb2cuaTE4bi5iaWRpLmh0bWxTa2lwUmVnXywgJycpIDogc3RyO1xufTtcblxuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0byBjaGVjayBmb3IgUlRMIGNoYXJhY3RlcnMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5pMThuLmJpZGkucnRsQ2hhclJlZ18gPSBuZXcgUmVnRXhwKCdbJyArIGdvb2cuaTE4bi5iaWRpLnJ0bENoYXJzXyArICddJyk7XG5cblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdG8gY2hlY2sgZm9yIExUUiBjaGFyYWN0ZXJzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cuaTE4bi5iaWRpLmx0ckNoYXJSZWdfID0gbmV3IFJlZ0V4cCgnWycgKyBnb29nLmkxOG4uYmlkaS5sdHJDaGFyc18gKyAnXScpO1xuXG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiBzdHJpbmcgaGFzIGFueSBSVEwgY2hhcmFjdGVycyBpbiBpdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIGdpdmVuIHN0cmluZyB0aGF0IG5lZWQgdG8gYmUgdGVzdGVkLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2lzSHRtbCBXaGV0aGVyIHN0ciBpcyBIVE1MIC8gSFRNTC1lc2NhcGVkLlxuICogICAgIERlZmF1bHQ6IGZhbHNlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgc3RyaW5nIGNvbnRhaW5zIFJUTCBjaGFyYWN0ZXJzLlxuICovXG5nb29nLmkxOG4uYmlkaS5oYXNBbnlSdGwgPSBmdW5jdGlvbihzdHIsIG9wdF9pc0h0bWwpIHtcbiAgcmV0dXJuIGdvb2cuaTE4bi5iaWRpLnJ0bENoYXJSZWdfLnRlc3QoXG4gICAgICBnb29nLmkxOG4uYmlkaS5zdHJpcEh0bWxJZk5lZWRlZF8oc3RyLCBvcHRfaXNIdG1sKSk7XG59O1xuXG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiBzdHJpbmcgaGFzIGFueSBSVEwgY2hhcmFjdGVycyBpbiBpdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIGdpdmVuIHN0cmluZyB0aGF0IG5lZWQgdG8gYmUgdGVzdGVkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgc3RyaW5nIGNvbnRhaW5zIFJUTCBjaGFyYWN0ZXJzLlxuICogQGRlcHJlY2F0ZWQgVXNlIGhhc0FueVJ0bC5cbiAqL1xuZ29vZy5pMThuLmJpZGkuaGFzUnRsQ2hhciA9IGdvb2cuaTE4bi5iaWRpLmhhc0FueVJ0bDtcblxuXG4vKipcbiAqIFRlc3Qgd2hldGhlciB0aGUgZ2l2ZW4gc3RyaW5nIGhhcyBhbnkgTFRSIGNoYXJhY3RlcnMgaW4gaXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBnaXZlbiBzdHJpbmcgdGhhdCBuZWVkIHRvIGJlIHRlc3RlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9pc0h0bWwgV2hldGhlciBzdHIgaXMgSFRNTCAvIEhUTUwtZXNjYXBlZC5cbiAqICAgICBEZWZhdWx0OiBmYWxzZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHN0cmluZyBjb250YWlucyBMVFIgY2hhcmFjdGVycy5cbiAqL1xuZ29vZy5pMThuLmJpZGkuaGFzQW55THRyID0gZnVuY3Rpb24oc3RyLCBvcHRfaXNIdG1sKSB7XG4gIHJldHVybiBnb29nLmkxOG4uYmlkaS5sdHJDaGFyUmVnXy50ZXN0KFxuICAgICAgZ29vZy5pMThuLmJpZGkuc3RyaXBIdG1sSWZOZWVkZWRfKHN0ciwgb3B0X2lzSHRtbCkpO1xufTtcblxuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIHRvIGNoZWNrIGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZ1xuICogaXMgTFRSLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cuaTE4bi5iaWRpLmx0clJlXyA9IG5ldyBSZWdFeHAoJ15bJyArIGdvb2cuaTE4bi5iaWRpLmx0ckNoYXJzXyArICddJyk7XG5cblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiB0byBjaGVjayBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSBzdHJpbmdcbiAqIGlzIFJUTC5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmkxOG4uYmlkaS5ydGxSZV8gPSBuZXcgUmVnRXhwKCdeWycgKyBnb29nLmkxOG4uYmlkaS5ydGxDaGFyc18gKyAnXScpO1xuXG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nIGlzIFJUTCBvciBub3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBnaXZlbiBzdHJpbmcgdGhhdCBuZWVkIHRvIGJlIHRlc3RlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBzdHIgaXMgYW4gUlRMIGNoYXIuXG4gKi9cbmdvb2cuaTE4bi5iaWRpLmlzUnRsQ2hhciA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gZ29vZy5pMThuLmJpZGkucnRsUmVfLnRlc3Qoc3RyKTtcbn07XG5cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcgaXMgTFRSIG9yIG5vdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIGdpdmVuIHN0cmluZyB0aGF0IG5lZWQgdG8gYmUgdGVzdGVkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHN0ciBpcyBhbiBMVFIgY2hhci5cbiAqL1xuZ29vZy5pMThuLmJpZGkuaXNMdHJDaGFyID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBnb29nLmkxOG4uYmlkaS5sdHJSZV8udGVzdChzdHIpO1xufTtcblxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZyBpcyBuZXV0cmFsIG9yIG5vdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIGdpdmVuIHN0cmluZyB0aGF0IG5lZWQgdG8gYmUgdGVzdGVkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHN0ciBpcyBhIG5ldXRyYWwgY2hhci5cbiAqL1xuZ29vZy5pMThuLmJpZGkuaXNOZXV0cmFsQ2hhciA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gIWdvb2cuaTE4bi5iaWRpLmlzTHRyQ2hhcihzdHIpICYmICFnb29nLmkxOG4uYmlkaS5pc1J0bENoYXIoc3RyKTtcbn07XG5cblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb25zIHRvIGNoZWNrIGlmIGEgcGllY2Ugb2YgdGV4dCBpcyBvZiBMVFIgZGlyZWN0aW9uYWxpdHlcbiAqIG9uIGZpcnN0IGNoYXJhY3RlciB3aXRoIHN0cm9uZyBkaXJlY3Rpb25hbGl0eS5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmkxOG4uYmlkaS5sdHJEaXJDaGVja1JlXyA9IG5ldyBSZWdFeHAoXG4gICAgJ15bXicgKyBnb29nLmkxOG4uYmlkaS5ydGxDaGFyc18gKyAnXSpbJyArIGdvb2cuaTE4bi5iaWRpLmx0ckNoYXJzXyArICddJyk7XG5cblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb25zIHRvIGNoZWNrIGlmIGEgcGllY2Ugb2YgdGV4dCBpcyBvZiBSVEwgZGlyZWN0aW9uYWxpdHlcbiAqIG9uIGZpcnN0IGNoYXJhY3RlciB3aXRoIHN0cm9uZyBkaXJlY3Rpb25hbGl0eS5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmkxOG4uYmlkaS5ydGxEaXJDaGVja1JlXyA9IG5ldyBSZWdFeHAoXG4gICAgJ15bXicgKyBnb29nLmkxOG4uYmlkaS5sdHJDaGFyc18gKyAnXSpbJyArIGdvb2cuaTE4bi5iaWRpLnJ0bENoYXJzXyArICddJyk7XG5cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBmaXJzdCBzdHJvbmdseSBkaXJlY3Rpb25hbCBjaGFyYWN0ZXIgKGlmIGFueSkgaXMgUlRMLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgYmVpbmcgY2hlY2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9pc0h0bWwgV2hldGhlciBzdHIgaXMgSFRNTCAvIEhUTUwtZXNjYXBlZC5cbiAqICAgICBEZWZhdWx0OiBmYWxzZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgUlRMIGRpcmVjdGlvbmFsaXR5IGlzIGRldGVjdGVkIHVzaW5nIHRoZSBmaXJzdFxuICogICAgIHN0cm9uZ2x5LWRpcmVjdGlvbmFsIGNoYXJhY3RlciBtZXRob2QuXG4gKi9cbmdvb2cuaTE4bi5iaWRpLnN0YXJ0c1dpdGhSdGwgPSBmdW5jdGlvbihzdHIsIG9wdF9pc0h0bWwpIHtcbiAgcmV0dXJuIGdvb2cuaTE4bi5iaWRpLnJ0bERpckNoZWNrUmVfLnRlc3QoXG4gICAgICBnb29nLmkxOG4uYmlkaS5zdHJpcEh0bWxJZk5lZWRlZF8oc3RyLCBvcHRfaXNIdG1sKSk7XG59O1xuXG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZmlyc3Qgc3Ryb25nbHkgZGlyZWN0aW9uYWwgY2hhcmFjdGVyIChpZiBhbnkpIGlzIFJUTC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIGJlaW5nIGNoZWNrZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaXNIdG1sIFdoZXRoZXIgc3RyIGlzIEhUTUwgLyBIVE1MLWVzY2FwZWQuXG4gKiAgICAgRGVmYXVsdDogZmFsc2UuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIFJUTCBkaXJlY3Rpb25hbGl0eSBpcyBkZXRlY3RlZCB1c2luZyB0aGUgZmlyc3RcbiAqICAgICBzdHJvbmdseS1kaXJlY3Rpb25hbCBjaGFyYWN0ZXIgbWV0aG9kLlxuICogQGRlcHJlY2F0ZWQgVXNlIHN0YXJ0c1dpdGhSdGwuXG4gKi9cbmdvb2cuaTE4bi5iaWRpLmlzUnRsVGV4dCA9IGdvb2cuaTE4bi5iaWRpLnN0YXJ0c1dpdGhSdGw7XG5cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBmaXJzdCBzdHJvbmdseSBkaXJlY3Rpb25hbCBjaGFyYWN0ZXIgKGlmIGFueSkgaXMgTFRSLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgYmVpbmcgY2hlY2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9pc0h0bWwgV2hldGhlciBzdHIgaXMgSFRNTCAvIEhUTUwtZXNjYXBlZC5cbiAqICAgICBEZWZhdWx0OiBmYWxzZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgTFRSIGRpcmVjdGlvbmFsaXR5IGlzIGRldGVjdGVkIHVzaW5nIHRoZSBmaXJzdFxuICogICAgIHN0cm9uZ2x5LWRpcmVjdGlvbmFsIGNoYXJhY3RlciBtZXRob2QuXG4gKi9cbmdvb2cuaTE4bi5iaWRpLnN0YXJ0c1dpdGhMdHIgPSBmdW5jdGlvbihzdHIsIG9wdF9pc0h0bWwpIHtcbiAgcmV0dXJuIGdvb2cuaTE4bi5iaWRpLmx0ckRpckNoZWNrUmVfLnRlc3QoXG4gICAgICBnb29nLmkxOG4uYmlkaS5zdHJpcEh0bWxJZk5lZWRlZF8oc3RyLCBvcHRfaXNIdG1sKSk7XG59O1xuXG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZmlyc3Qgc3Ryb25nbHkgZGlyZWN0aW9uYWwgY2hhcmFjdGVyIChpZiBhbnkpIGlzIExUUi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIGJlaW5nIGNoZWNrZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaXNIdG1sIFdoZXRoZXIgc3RyIGlzIEhUTUwgLyBIVE1MLWVzY2FwZWQuXG4gKiAgICAgRGVmYXVsdDogZmFsc2UuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIExUUiBkaXJlY3Rpb25hbGl0eSBpcyBkZXRlY3RlZCB1c2luZyB0aGUgZmlyc3RcbiAqICAgICBzdHJvbmdseS1kaXJlY3Rpb25hbCBjaGFyYWN0ZXIgbWV0aG9kLlxuICogQGRlcHJlY2F0ZWQgVXNlIHN0YXJ0c1dpdGhMdHIuXG4gKi9cbmdvb2cuaTE4bi5iaWRpLmlzTHRyVGV4dCA9IGdvb2cuaTE4bi5iaWRpLnN0YXJ0c1dpdGhMdHI7XG5cblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdG8gY2hlY2sgaWYgYSBzdHJpbmcgbG9va3MgbGlrZSBzb21ldGhpbmcgdGhhdCBtdXN0XG4gKiBhbHdheXMgYmUgTFRSIGV2ZW4gaW4gUlRMIHRleHQsIGUuZy4gYSBVUkwuIFdoZW4gZXN0aW1hdGluZyB0aGVcbiAqIGRpcmVjdGlvbmFsaXR5IG9mIHRleHQgY29udGFpbmluZyB0aGVzZSwgd2UgdHJlYXQgdGhlc2UgYXMgd2Vha2x5IExUUixcbiAqIGxpa2UgbnVtYmVycy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmkxOG4uYmlkaS5pc1JlcXVpcmVkTHRyUmVfID0gL15odHRwOlxcL1xcLy4qLztcblxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGlucHV0IHN0cmluZyBlaXRoZXIgY29udGFpbnMgbm8gc3Ryb25nbHkgZGlyZWN0aW9uYWxcbiAqIGNoYXJhY3RlcnMgb3IgbG9va3MgbGlrZSBhIHVybC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIGJlaW5nIGNoZWNrZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaXNIdG1sIFdoZXRoZXIgc3RyIGlzIEhUTUwgLyBIVE1MLWVzY2FwZWQuXG4gKiAgICAgRGVmYXVsdDogZmFsc2UuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG5ldXRyYWwgZGlyZWN0aW9uYWxpdHkgaXMgZGV0ZWN0ZWQuXG4gKi9cbmdvb2cuaTE4bi5iaWRpLmlzTmV1dHJhbFRleHQgPSBmdW5jdGlvbihzdHIsIG9wdF9pc0h0bWwpIHtcbiAgc3RyID0gZ29vZy5pMThuLmJpZGkuc3RyaXBIdG1sSWZOZWVkZWRfKHN0ciwgb3B0X2lzSHRtbCk7XG4gIHJldHVybiBnb29nLmkxOG4uYmlkaS5pc1JlcXVpcmVkTHRyUmVfLnRlc3Qoc3RyKSB8fFxuICAgICAgIWdvb2cuaTE4bi5iaWRpLmhhc0FueUx0cihzdHIpICYmICFnb29nLmkxOG4uYmlkaS5oYXNBbnlSdGwoc3RyKTtcbn07XG5cblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb25zIHRvIGNoZWNrIGlmIHRoZSBsYXN0IHN0cm9uZ2x5LWRpcmVjdGlvbmFsIGNoYXJhY3RlciBpbiBhXG4gKiBwaWVjZSBvZiB0ZXh0IGlzIExUUi5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmkxOG4uYmlkaS5sdHJFeGl0RGlyQ2hlY2tSZV8gPSBuZXcgUmVnRXhwKFxuICAgICdbJyArIGdvb2cuaTE4bi5iaWRpLmx0ckNoYXJzXyArICddW14nICsgZ29vZy5pMThuLmJpZGkucnRsQ2hhcnNfICsgJ10qJCcpO1xuXG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9ucyB0byBjaGVjayBpZiB0aGUgbGFzdCBzdHJvbmdseS1kaXJlY3Rpb25hbCBjaGFyYWN0ZXIgaW4gYVxuICogcGllY2Ugb2YgdGV4dCBpcyBSVEwuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5pMThuLmJpZGkucnRsRXhpdERpckNoZWNrUmVfID0gbmV3IFJlZ0V4cChcbiAgICAnWycgKyBnb29nLmkxOG4uYmlkaS5ydGxDaGFyc18gKyAnXVteJyArIGdvb2cuaTE4bi5iaWRpLmx0ckNoYXJzXyArICddKiQnKTtcblxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBleGl0IGRpcmVjdGlvbmFsaXR5IGEgcGllY2Ugb2YgdGV4dCBpcyBMVFIsIGkuZS4gaWYgdGhlIGxhc3RcbiAqIHN0cm9uZ2x5LWRpcmVjdGlvbmFsIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nIGlzIExUUi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIGJlaW5nIGNoZWNrZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaXNIdG1sIFdoZXRoZXIgc3RyIGlzIEhUTUwgLyBIVE1MLWVzY2FwZWQuXG4gKiAgICAgRGVmYXVsdDogZmFsc2UuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIExUUiBleGl0IGRpcmVjdGlvbmFsaXR5IHdhcyBkZXRlY3RlZC5cbiAqL1xuZ29vZy5pMThuLmJpZGkuZW5kc1dpdGhMdHIgPSBmdW5jdGlvbihzdHIsIG9wdF9pc0h0bWwpIHtcbiAgcmV0dXJuIGdvb2cuaTE4bi5iaWRpLmx0ckV4aXREaXJDaGVja1JlXy50ZXN0KFxuICAgICAgZ29vZy5pMThuLmJpZGkuc3RyaXBIdG1sSWZOZWVkZWRfKHN0ciwgb3B0X2lzSHRtbCkpO1xufTtcblxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBleGl0IGRpcmVjdGlvbmFsaXR5IGEgcGllY2Ugb2YgdGV4dCBpcyBMVFIsIGkuZS4gaWYgdGhlIGxhc3RcbiAqIHN0cm9uZ2x5LWRpcmVjdGlvbmFsIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nIGlzIExUUi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIGJlaW5nIGNoZWNrZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaXNIdG1sIFdoZXRoZXIgc3RyIGlzIEhUTUwgLyBIVE1MLWVzY2FwZWQuXG4gKiAgICAgRGVmYXVsdDogZmFsc2UuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIExUUiBleGl0IGRpcmVjdGlvbmFsaXR5IHdhcyBkZXRlY3RlZC5cbiAqIEBkZXByZWNhdGVkIFVzZSBlbmRzV2l0aEx0ci5cbiAqL1xuZ29vZy5pMThuLmJpZGkuaXNMdHJFeGl0VGV4dCA9IGdvb2cuaTE4bi5iaWRpLmVuZHNXaXRoTHRyO1xuXG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGV4aXQgZGlyZWN0aW9uYWxpdHkgYSBwaWVjZSBvZiB0ZXh0IGlzIFJUTCwgaS5lLiBpZiB0aGUgbGFzdFxuICogc3Ryb25nbHktZGlyZWN0aW9uYWwgY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcgaXMgUlRMLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgYmVpbmcgY2hlY2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9pc0h0bWwgV2hldGhlciBzdHIgaXMgSFRNTCAvIEhUTUwtZXNjYXBlZC5cbiAqICAgICBEZWZhdWx0OiBmYWxzZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgUlRMIGV4aXQgZGlyZWN0aW9uYWxpdHkgd2FzIGRldGVjdGVkLlxuICovXG5nb29nLmkxOG4uYmlkaS5lbmRzV2l0aFJ0bCA9IGZ1bmN0aW9uKHN0ciwgb3B0X2lzSHRtbCkge1xuICByZXR1cm4gZ29vZy5pMThuLmJpZGkucnRsRXhpdERpckNoZWNrUmVfLnRlc3QoXG4gICAgICBnb29nLmkxOG4uYmlkaS5zdHJpcEh0bWxJZk5lZWRlZF8oc3RyLCBvcHRfaXNIdG1sKSk7XG59O1xuXG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGV4aXQgZGlyZWN0aW9uYWxpdHkgYSBwaWVjZSBvZiB0ZXh0IGlzIFJUTCwgaS5lLiBpZiB0aGUgbGFzdFxuICogc3Ryb25nbHktZGlyZWN0aW9uYWwgY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcgaXMgUlRMLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgYmVpbmcgY2hlY2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9pc0h0bWwgV2hldGhlciBzdHIgaXMgSFRNTCAvIEhUTUwtZXNjYXBlZC5cbiAqICAgICBEZWZhdWx0OiBmYWxzZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgUlRMIGV4aXQgZGlyZWN0aW9uYWxpdHkgd2FzIGRldGVjdGVkLlxuICogQGRlcHJlY2F0ZWQgVXNlIGVuZHNXaXRoUnRsLlxuICovXG5nb29nLmkxOG4uYmlkaS5pc1J0bEV4aXRUZXh0ID0gZ29vZy5pMThuLmJpZGkuZW5kc1dpdGhSdGw7XG5cblxuLyoqXG4gKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgbWF0Y2hpbmcgcmlnaHQtdG8tbGVmdCBsYW5ndWFnZSBjb2Rlcy5cbiAqIFNlZSB7QGxpbmsgI2lzUnRsTGFuZ3VhZ2V9IGZvciB0aGUgZGVzaWduLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cuaTE4bi5iaWRpLnJ0bExvY2FsZXNSZV8gPSBuZXcgUmVnRXhwKFxuICAgICdeKGFyfGNrYnxkdnxoZXxpd3xmYXxucW98cHN8c2R8dWd8dXJ8eWl8JyArXG4gICAgICAgICcuKlstX10oQXJhYnxIZWJyfFRoYWF8Tmtvb3xUZm5nKSknICtcbiAgICAgICAgJyg/IS4qWy1fXShMYXRufEN5cmwpKCR8LXxfKSkoJHwtfF8pJyxcbiAgICAnaScpO1xuXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBCQ1AgNDcgLyBJSUkgbGFuZ3VhZ2UgY29kZSBpbmRpY2F0ZXMgYW4gUlRMIGxhbmd1YWdlLCBpLmUuIGVpdGhlcjpcbiAqIC0gYSBsYW5ndWFnZSBjb2RlIGV4cGxpY2l0bHkgc3BlY2lmeWluZyBvbmUgb2YgdGhlIHJpZ2h0LXRvLWxlZnQgc2NyaXB0cyxcbiAqICAgZS5nLiBcImF6LUFyYWJcIiwgb3I8cD5cbiAqIC0gYSBsYW5ndWFnZSBjb2RlIHNwZWNpZnlpbmcgb25lIG9mIHRoZSBsYW5ndWFnZXMgbm9ybWFsbHkgd3JpdHRlbiBpbiBhXG4gKiAgIHJpZ2h0LXRvLWxlZnQgc2NyaXB0LCBlLmcuIFwiZmFcIiAoRmFyc2kpLCBleGNlcHQgb25lcyBleHBsaWNpdGx5IHNwZWNpZnlpbmdcbiAqICAgTGF0aW4gb3IgQ3lyaWxsaWMgc2NyaXB0ICh3aGljaCBhcmUgdGhlIHVzdWFsIExUUiBhbHRlcm5hdGl2ZXMpLjxwPlxuICogVGhlIGxpc3Qgb2YgcmlnaHQtdG8tbGVmdCBzY3JpcHRzIGFwcGVhcnMgaW4gdGhlIDEwMC0xOTkgcmFuZ2UgaW5cbiAqIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvaXNvMTU5MjQvaXNvMTU5MjQtbnVtLmh0bWwsIG9mIHdoaWNoIEFyYWJpYyBhbmRcbiAqIEhlYnJldyBhcmUgYnkgZmFyIHRoZSBtb3N0IHdpZGVseSB1c2VkLiBXZSBhbHNvIHJlY29nbml6ZSBUaGFhbmEsIE4nS28sIGFuZFxuICogVGlmaW5hZ2gsIHdoaWNoIGFsc28gaGF2ZSBzaWduaWZpY2FudCBtb2Rlcm4gdXNhZ2UuIFRoZSByZXN0IChTeXJpYWMsXG4gKiBTYW1hcml0YW4sIE1hbmRhaWMsIGV0Yy4pIHNlZW0gdG8gaGF2ZSBleHRyZW1lbHkgbGltaXRlZCBvciBubyBtb2Rlcm4gdXNhZ2VcbiAqIGFuZCBhcmUgbm90IHJlY29nbml6ZWQgdG8gc2F2ZSBvbiBjb2RlIHNpemUuXG4gKiBUaGUgbGFuZ3VhZ2VzIHVzdWFsbHkgd3JpdHRlbiBpbiBhIHJpZ2h0LXRvLWxlZnQgc2NyaXB0IGFyZSB0YWtlbiBhcyB0aG9zZVxuICogd2l0aCBTdXBwcmVzcy1TY3JpcHQ6IEhlYnJ8QXJhYnxUaGFhfE5rb298VGZuZyAgaW5cbiAqIGh0dHA6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvbGFuZ3VhZ2Utc3VidGFnLXJlZ2lzdHJ5LFxuICogYXMgd2VsbCBhcyBDZW50cmFsIChvciBTb3JhbmkpIEt1cmRpc2ggKGNrYiksIFNpbmRoaSAoc2QpIGFuZCBVeWdodXIgKHVnKS5cbiAqIE90aGVyIHN1YnRhZ3Mgb2YgdGhlIGxhbmd1YWdlIGNvZGUsIGUuZy4gcmVnaW9ucyBsaWtlIEVHIChFZ3lwdCksIGFyZVxuICogaWdub3JlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBsYW5nIEJDUCA0NyAoYS5rLmEgSUlJKSBsYW5ndWFnZSBjb2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgbGFuZ3VhZ2UgY29kZSBpcyBhbiBSVEwgbGFuZ3VhZ2UuXG4gKi9cbmdvb2cuaTE4bi5iaWRpLmlzUnRsTGFuZ3VhZ2UgPSBmdW5jdGlvbihsYW5nKSB7XG4gIHJldHVybiBnb29nLmkxOG4uYmlkaS5ydGxMb2NhbGVzUmVfLnRlc3QobGFuZyk7XG59O1xuXG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIGZvciBicmFja2V0IGd1YXJkIHJlcGxhY2VtZW50IGluIHRleHQuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5pMThuLmJpZGkuYnJhY2tldEd1YXJkVGV4dFJlXyA9XG4gICAgLyhcXCguKj9cXCkrKXwoXFxbLio/XFxdKyl8KFxcey4qP1xcfSspfCg8Lio/PispL2c7XG5cblxuLyoqXG4gKiBBcHBseSBicmFja2V0IGd1YXJkIHVzaW5nIExSTSBhbmQgUkxNLiBUaGlzIGlzIHRvIGFkZHJlc3MgdGhlIHByb2JsZW0gb2ZcbiAqIG1lc3N5IGJyYWNrZXQgZGlzcGxheSBmcmVxdWVudGx5IGhhcHBlbnMgaW4gUlRMIGxheW91dC5cbiAqIFRoaXMgZnVuY3Rpb24gd29ya3MgZm9yIHBsYWluIHRleHQsIG5vdCBmb3IgSFRNTC4gSW4gSFRNTCwgdGhlIG9wZW5pbmdcbiAqIGJyYWNrZXQgbWlnaHQgYmUgaW4gYSBkaWZmZXJlbnQgY29udGV4dCB0aGFuIHRoZSBjbG9zaW5nIGJyYWNrZXQgKHN1Y2ggYXNcbiAqIGFuIGF0dHJpYnV0ZSB2YWx1ZSkuXG4gKiBAcGFyYW0ge3N0cmluZ30gcyBUaGUgc3RyaW5nIHRoYXQgbmVlZCB0byBiZSBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaXNSdGxDb250ZXh0IHNwZWNpZmllcyBkZWZhdWx0IGRpcmVjdGlvbiAodXN1YWxseVxuICogICAgIGRpcmVjdGlvbiBvZiB0aGUgVUkpLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgcHJvY2Vzc2VkIHN0cmluZywgd2l0aCBhbGwgYnJhY2tldCBndWFyZGVkLlxuICovXG5nb29nLmkxOG4uYmlkaS5ndWFyZEJyYWNrZXRJblRleHQgPSBmdW5jdGlvbihzLCBvcHRfaXNSdGxDb250ZXh0KSB7XG4gIHZhciB1c2VSdGwgPSBvcHRfaXNSdGxDb250ZXh0ID09PSB1bmRlZmluZWQgPyBnb29nLmkxOG4uYmlkaS5oYXNBbnlSdGwocykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0X2lzUnRsQ29udGV4dDtcbiAgdmFyIG1hcmsgPSB1c2VSdGwgPyBnb29nLmkxOG4uYmlkaS5Gb3JtYXQuUkxNIDogZ29vZy5pMThuLmJpZGkuRm9ybWF0LkxSTTtcbiAgcmV0dXJuIHMucmVwbGFjZShnb29nLmkxOG4uYmlkaS5icmFja2V0R3VhcmRUZXh0UmVfLCBtYXJrICsgJyQmJyArIG1hcmspO1xufTtcblxuXG4vKipcbiAqIEVuZm9yY2UgdGhlIGh0bWwgc25pcHBldCBpbiBSVEwgZGlyZWN0aW9uYWxpdHkgcmVnYXJkbGVzcyBvdmVyYWxsIGNvbnRleHQuXG4gKiBJZiB0aGUgaHRtbCBwaWVjZSB3YXMgZW5jbG9zZWQgYnkgdGFnLCBkaXIgd2lsbCBiZSBhcHBsaWVkIHRvIGV4aXN0aW5nXG4gKiB0YWcsIG90aGVyd2lzZSBhIHNwYW4gdGFnIHdpbGwgYmUgYWRkZWQgYXMgd3JhcHBlci4gRm9yIHRoaXMgcmVhc29uLCBpZlxuICogaHRtbCBzbmlwcGV0IHN0YXJ0IHdpdGggd2l0aCB0YWcsIHRoaXMgdGFnIG11c3QgZW5jbG9zZSB0aGUgd2hvbGUgcGllY2UuIElmXG4gKiB0aGUgdGFnIGFscmVhZHkgaGFzIGEgZGlyIHNwZWNpZmllZCwgdGhpcyBuZXcgb25lIHdpbGwgb3ZlcnJpZGUgZXhpc3RpbmdcbiAqIG9uZSBpbiBiZWhhdmlvciAodGVzdGVkIG9uIEZGIGFuZCBJRSkuXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbCBUaGUgc3RyaW5nIHRoYXQgbmVlZCB0byBiZSBwcm9jZXNzZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwcm9jZXNzZWQgc3RyaW5nLCB3aXRoIGRpcmVjdGlvbmFsaXR5IGVuZm9yY2VkIHRvIFJUTC5cbiAqL1xuZ29vZy5pMThuLmJpZGkuZW5mb3JjZVJ0bEluSHRtbCA9IGZ1bmN0aW9uKGh0bWwpIHtcbiAgaWYgKGh0bWwuY2hhckF0KDApID09ICc8Jykge1xuICAgIHJldHVybiBodG1sLnJlcGxhY2UoLzxcXHcrLywgJyQmIGRpcj1ydGwnKTtcbiAgfVxuICAvLyAnXFxuJyBpcyBpbXBvcnRhbnQgZm9yIEZGIHNvIHRoYXQgaXQgd29uJ3QgaW5jb3JyZWN0bHkgbWVyZ2Ugc3BhbiBncm91cHNcbiAgcmV0dXJuICdcXG48c3BhbiBkaXI9cnRsPicgKyBodG1sICsgJzwvc3Bhbj4nO1xufTtcblxuXG4vKipcbiAqIEVuZm9yY2UgUlRMIG9uIGJvdGggZW5kIG9mIHRoZSBnaXZlbiB0ZXh0IHBpZWNlIHVzaW5nIHVuaWNvZGUgQmlEaSBmb3JtYXR0aW5nXG4gKiBjaGFyYWN0ZXJzIFJMRSBhbmQgUERGLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHBpZWNlIG9mIHRleHQgdGhhdCBuZWVkIHRvIGJlIHdyYXBwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB3cmFwcGVkIHN0cmluZyBhZnRlciBwcm9jZXNzLlxuICovXG5nb29nLmkxOG4uYmlkaS5lbmZvcmNlUnRsSW5UZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gZ29vZy5pMThuLmJpZGkuRm9ybWF0LlJMRSArIHRleHQgKyBnb29nLmkxOG4uYmlkaS5Gb3JtYXQuUERGO1xufTtcblxuXG4vKipcbiAqIEVuZm9yY2UgdGhlIGh0bWwgc25pcHBldCBpbiBSVEwgZGlyZWN0aW9uYWxpdHkgcmVnYXJkbGVzcyBvdmVyYWxsIGNvbnRleHQuXG4gKiBJZiB0aGUgaHRtbCBwaWVjZSB3YXMgZW5jbG9zZWQgYnkgdGFnLCBkaXIgd2lsbCBiZSBhcHBsaWVkIHRvIGV4aXN0aW5nXG4gKiB0YWcsIG90aGVyd2lzZSBhIHNwYW4gdGFnIHdpbGwgYmUgYWRkZWQgYXMgd3JhcHBlci4gRm9yIHRoaXMgcmVhc29uLCBpZlxuICogaHRtbCBzbmlwcGV0IHN0YXJ0IHdpdGggd2l0aCB0YWcsIHRoaXMgdGFnIG11c3QgZW5jbG9zZSB0aGUgd2hvbGUgcGllY2UuIElmXG4gKiB0aGUgdGFnIGFscmVhZHkgaGFzIGEgZGlyIHNwZWNpZmllZCwgdGhpcyBuZXcgb25lIHdpbGwgb3ZlcnJpZGUgZXhpc3RpbmdcbiAqIG9uZSBpbiBiZWhhdmlvciAodGVzdGVkIG9uIEZGIGFuZCBJRSkuXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbCBUaGUgc3RyaW5nIHRoYXQgbmVlZCB0byBiZSBwcm9jZXNzZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwcm9jZXNzZWQgc3RyaW5nLCB3aXRoIGRpcmVjdGlvbmFsaXR5IGVuZm9yY2VkIHRvIFJUTC5cbiAqL1xuZ29vZy5pMThuLmJpZGkuZW5mb3JjZUx0ckluSHRtbCA9IGZ1bmN0aW9uKGh0bWwpIHtcbiAgaWYgKGh0bWwuY2hhckF0KDApID09ICc8Jykge1xuICAgIHJldHVybiBodG1sLnJlcGxhY2UoLzxcXHcrLywgJyQmIGRpcj1sdHInKTtcbiAgfVxuICAvLyAnXFxuJyBpcyBpbXBvcnRhbnQgZm9yIEZGIHNvIHRoYXQgaXQgd29uJ3QgaW5jb3JyZWN0bHkgbWVyZ2Ugc3BhbiBncm91cHNcbiAgcmV0dXJuICdcXG48c3BhbiBkaXI9bHRyPicgKyBodG1sICsgJzwvc3Bhbj4nO1xufTtcblxuXG4vKipcbiAqIEVuZm9yY2UgTFRSIG9uIGJvdGggZW5kIG9mIHRoZSBnaXZlbiB0ZXh0IHBpZWNlIHVzaW5nIHVuaWNvZGUgQmlEaSBmb3JtYXR0aW5nXG4gKiBjaGFyYWN0ZXJzIExSRSBhbmQgUERGLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHBpZWNlIG9mIHRleHQgdGhhdCBuZWVkIHRvIGJlIHdyYXBwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB3cmFwcGVkIHN0cmluZyBhZnRlciBwcm9jZXNzLlxuICovXG5nb29nLmkxOG4uYmlkaS5lbmZvcmNlTHRySW5UZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gZ29vZy5pMThuLmJpZGkuRm9ybWF0LkxSRSArIHRleHQgKyBnb29nLmkxOG4uYmlkaS5Gb3JtYXQuUERGO1xufTtcblxuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0byBmaW5kIGRpbWVuc2lvbnMgc3VjaCBhcyBcInBhZGRpbmc6IC4zIDAuNGV4IDVweCA2O1wiXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5pMThuLmJpZGkuZGltZW5zaW9uc1JlXyA9XG4gICAgLzpcXHMqKFsuXFxkXVsuXFx3XSopXFxzKyhbLlxcZF1bLlxcd10qKVxccysoWy5cXGRdWy5cXHddKilcXHMrKFsuXFxkXVsuXFx3XSopL2c7XG5cblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gZm9yIGxlZnQuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5pMThuLmJpZGkubGVmdFJlXyA9IC9sZWZ0L2dpO1xuXG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIGZvciByaWdodC5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmkxOG4uYmlkaS5yaWdodFJlXyA9IC9yaWdodC9naTtcblxuXG4vKipcbiAqIFBsYWNlaG9sZGVyIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3Igc3dhcHBpbmcuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5pMThuLmJpZGkudGVtcFJlXyA9IC8lJSUlL2c7XG5cblxuLyoqXG4gKiBTd2FwIGxvY2F0aW9uIHBhcmFtZXRlcnMgYW5kICdsZWZ0Jy8ncmlnaHQnIGluIENTUyBzcGVjaWZpY2F0aW9uLiBUaGVcbiAqIHByb2Nlc3NlZCBzdHJpbmcgd2lsbCBiZSBzdWl0ZWQgZm9yIFJUTCBsYXlvdXQuIFRob3VnaCB0aGlzIGZ1bmN0aW9uIGNhblxuICogY292ZXIgbW9zdCBjYXNlcywgdGhlcmUgYXJlIGFsd2F5cyBleGNlcHRpb25zLiBJdCBpcyBzdWdnZXN0ZWQgdG8gcHV0XG4gKiB0aG9zZSBleGNlcHRpb25zIGluIHNlcGFyYXRlIGdyb3VwIG9mIENTUyBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzU3RyIENTUyBzcGVmaWNhdGlvbiBzdHJpbmcuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFByb2Nlc3NlZCBDU1Mgc3BlY2lmaWNhdGlvbiBzdHJpbmcuXG4gKi9cbmdvb2cuaTE4bi5iaWRpLm1pcnJvckNTUyA9IGZ1bmN0aW9uKGNzc1N0cikge1xuICByZXR1cm4gY3NzU3RyXG4gICAgICAuXG4gICAgICAvLyByZXZlcnNlIGRpbWVuc2lvbnNcbiAgICAgIHJlcGxhY2UoZ29vZy5pMThuLmJpZGkuZGltZW5zaW9uc1JlXywgJzokMSAkNCAkMyAkMicpXG4gICAgICAucmVwbGFjZShnb29nLmkxOG4uYmlkaS5sZWZ0UmVfLCAnJSUlJScpXG4gICAgICAuICAvLyBzd2FwIGxlZnQgYW5kIHJpZ2h0XG4gICAgICByZXBsYWNlKGdvb2cuaTE4bi5iaWRpLnJpZ2h0UmVfLCBnb29nLmkxOG4uYmlkaS5MRUZUKVxuICAgICAgLnJlcGxhY2UoZ29vZy5pMThuLmJpZGkudGVtcFJlXywgZ29vZy5pMThuLmJpZGkuUklHSFQpO1xufTtcblxuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgaGVicmV3IGRvdWJsZSBxdW90ZSBzdWJzdGl0dXRpb24sIGZpbmRpbmcgcXVvdGVcbiAqIGRpcmVjdGx5IGFmdGVyIGhlYnJldyBjaGFyYWN0ZXJzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cuaTE4bi5iaWRpLmRvdWJsZVF1b3RlU3Vic3RpdHV0ZVJlXyA9IC8oW1xcdTA1OTEtXFx1MDVmMl0pXCIvZztcblxuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgaGVicmV3IHNpbmdsZSBxdW90ZSBzdWJzdGl0dXRpb24sIGZpbmRpbmcgcXVvdGVcbiAqIGRpcmVjdGx5IGFmdGVyIGhlYnJldyBjaGFyYWN0ZXJzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cuaTE4bi5iaWRpLnNpbmdsZVF1b3RlU3Vic3RpdHV0ZVJlXyA9IC8oW1xcdTA1OTEtXFx1MDVmMl0pJy9nO1xuXG5cbi8qKlxuICogUmVwbGFjZSB0aGUgZG91YmxlIGFuZCBzaW5nbGUgcXVvdGUgZGlyZWN0bHkgYWZ0ZXIgYSBIZWJyZXcgY2hhcmFjdGVyIHdpdGhcbiAqIEdFUkVTSCBhbmQgR0VSU0hBWUlNLiBJbiBzdWNoIGNhc2UsIG1vc3QgbGlrZWx5IHRoYXQncyB1c2VyIGludGVudGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRoYXQgbmVlZCB0byBiZSBwcm9jZXNzZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFByb2Nlc3NlZCBzdHJpbmcgd2l0aCBkb3VibGUvc2luZ2xlIHF1b3RlIHJlcGxhY2VkLlxuICovXG5nb29nLmkxOG4uYmlkaS5ub3JtYWxpemVIZWJyZXdRdW90ZSA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoZ29vZy5pMThuLmJpZGkuZG91YmxlUXVvdGVTdWJzdGl0dXRlUmVfLCAnJDFcXHUwNWY0JylcbiAgICAgIC5yZXBsYWNlKGdvb2cuaTE4bi5iaWRpLnNpbmdsZVF1b3RlU3Vic3RpdHV0ZVJlXywgJyQxXFx1MDVmMycpO1xufTtcblxuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0byBzcGxpdCBhIHN0cmluZyBpbnRvIFwid29yZHNcIiBmb3IgZGlyZWN0aW9uYWxpdHlcbiAqIGVzdGltYXRpb24gYmFzZWQgb24gcmVsYXRpdmUgd29yZCBjb3VudHMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQHByaXZhdGVcbiAqL1xuZ29vZy5pMThuLmJpZGkud29yZFNlcGFyYXRvclJlXyA9IC9cXHMrLztcblxuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0byBjaGVjayBpZiBhIHN0cmluZyBjb250YWlucyBhbnkgbnVtZXJhbHMuIFVzZWQgdG9cbiAqIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBjb21wbGV0ZWx5IG5ldXRyYWwgc3RyaW5ncyBhbmQgdGhvc2UgY29udGFpbmluZ1xuICogbnVtYmVycywgd2hpY2ggYXJlIHdlYWtseSBMVFIuXG4gKlxuICogTmF0aXZlIEFyYWJpYyBkaWdpdHMgKFxcdTA2NjAgLSBcXHUwNjY5KSBhcmUgbm90IGluY2x1ZGVkIGJlY2F1c2UgYWx0aG91Z2ggdGhleVxuICogZG8gZmxvdyBsZWZ0LXRvLXJpZ2h0IGluc2lkZSBhIG51bWJlciwgdGhpcyBpcyB0aGUgY2FzZSBldmVuIGlmIHRoZSAgb3ZlcmFsbFxuICogZGlyZWN0aW9uYWxpdHkgaXMgUlRMLCBhbmQgYSBtYXRoZW1hdGljYWwgZXhwcmVzc2lvbiB1c2luZyB0aGVzZSBkaWdpdHMgaXNcbiAqIHN1cHBvc2VkIHRvIGZsb3cgcmlnaHQtdG8tbGVmdCBvdmVyYWxsLCBpbmNsdWRpbmcgdW5hcnkgcGx1cyBhbmQgbWludXNcbiAqIGFwcGVhcmluZyB0byB0aGUgcmlnaHQgb2YgYSBudW1iZXIsIGFuZCB0aGlzIGRvZXMgZGVwZW5kIG9uIHRoZSBvdmVyYWxsXG4gKiBkaXJlY3Rpb25hbGl0eSBiZWluZyBSVEwuIFRoZSBkaWdpdHMgdXNlZCBpbiBGYXJzaSAoXFx1MDZGMCAtIFxcdTA2RjkpLCBvbiB0aGVcbiAqIG90aGVyIGhhbmQsIGFyZSBpbmNsdWRlZCwgc2luY2UgRmFyc2kgbWF0aCAoaW5jbHVkaW5nIHVuYXJ5IHBsdXMgYW5kIG1pbnVzKVxuICogZG9lcyBmbG93IGxlZnQtdG8tcmlnaHQuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cuaTE4bi5iaWRpLmhhc051bWVyYWxzUmVfID0gL1tcXGRcXHUwNmYwLVxcdTA2ZjldLztcblxuXG4vKipcbiAqIFRoaXMgY29uc3RhbnQgY29udHJvbHMgdGhyZXNob2xkIG9mIFJUTCBkaXJlY3Rpb25hbGl0eS5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmkxOG4uYmlkaS5ydGxEZXRlY3Rpb25UaHJlc2hvbGRfID0gMC40MDtcblxuXG4vKipcbiAqIEVzdGltYXRlcyB0aGUgZGlyZWN0aW9uYWxpdHkgb2YgYSBzdHJpbmcgYmFzZWQgb24gcmVsYXRpdmUgd29yZCBjb3VudHMuXG4gKiBJZiB0aGUgbnVtYmVyIG9mIFJUTCB3b3JkcyBpcyBhYm92ZSBhIGNlcnRhaW4gcGVyY2VudGFnZSBvZiB0aGUgdG90YWwgbnVtYmVyXG4gKiBvZiBzdHJvbmdseSBkaXJlY3Rpb25hbCB3b3JkcywgcmV0dXJucyBSVEwuXG4gKiBPdGhlcndpc2UsIGlmIGFueSB3b3JkcyBhcmUgc3Ryb25nbHkgb3Igd2Vha2x5IExUUiwgcmV0dXJucyBMVFIuXG4gKiBPdGhlcndpc2UsIHJldHVybnMgVU5LTk9XTiwgd2hpY2ggaXMgdXNlZCB0byBtZWFuIFwibmV1dHJhbFwiLlxuICogTnVtYmVycyBhcmUgY291bnRlZCBhcyB3ZWFrbHkgTFRSLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGJlIGNoZWNrZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaXNIdG1sIFdoZXRoZXIgc3RyIGlzIEhUTUwgLyBIVE1MLWVzY2FwZWQuXG4gKiAgICAgRGVmYXVsdDogZmFsc2UuXG4gKiBAcmV0dXJuIHtnb29nLmkxOG4uYmlkaS5EaXJ9IEVzdGltYXRlZCBvdmVyYWxsIGRpcmVjdGlvbmFsaXR5IG9mIHtAY29kZSBzdHJ9LlxuICovXG5nb29nLmkxOG4uYmlkaS5lc3RpbWF0ZURpcmVjdGlvbiA9IGZ1bmN0aW9uKHN0ciwgb3B0X2lzSHRtbCkge1xuICB2YXIgcnRsQ291bnQgPSAwO1xuICB2YXIgdG90YWxDb3VudCA9IDA7XG4gIHZhciBoYXNXZWFrbHlMdHIgPSBmYWxzZTtcbiAgdmFyIHRva2VucyA9IGdvb2cuaTE4bi5iaWRpLnN0cmlwSHRtbElmTmVlZGVkXyhzdHIsIG9wdF9pc0h0bWwpXG4gICAgICAgICAgICAgICAgICAgLnNwbGl0KGdvb2cuaTE4bi5iaWRpLndvcmRTZXBhcmF0b3JSZV8pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICBpZiAoZ29vZy5pMThuLmJpZGkuc3RhcnRzV2l0aFJ0bCh0b2tlbikpIHtcbiAgICAgIHJ0bENvdW50Kys7XG4gICAgICB0b3RhbENvdW50Kys7XG4gICAgfSBlbHNlIGlmIChnb29nLmkxOG4uYmlkaS5pc1JlcXVpcmVkTHRyUmVfLnRlc3QodG9rZW4pKSB7XG4gICAgICBoYXNXZWFrbHlMdHIgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZ29vZy5pMThuLmJpZGkuaGFzQW55THRyKHRva2VuKSkge1xuICAgICAgdG90YWxDb3VudCsrO1xuICAgIH0gZWxzZSBpZiAoZ29vZy5pMThuLmJpZGkuaGFzTnVtZXJhbHNSZV8udGVzdCh0b2tlbikpIHtcbiAgICAgIGhhc1dlYWtseUx0ciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRvdGFsQ291bnQgPT0gMCA/XG4gICAgICAoaGFzV2Vha2x5THRyID8gZ29vZy5pMThuLmJpZGkuRGlyLkxUUiA6IGdvb2cuaTE4bi5iaWRpLkRpci5ORVVUUkFMKSA6XG4gICAgICAocnRsQ291bnQgLyB0b3RhbENvdW50ID4gZ29vZy5pMThuLmJpZGkucnRsRGV0ZWN0aW9uVGhyZXNob2xkXyA/XG4gICAgICAgICAgIGdvb2cuaTE4bi5iaWRpLkRpci5SVEwgOlxuICAgICAgICAgICBnb29nLmkxOG4uYmlkaS5EaXIuTFRSKTtcbn07XG5cblxuLyoqXG4gKiBDaGVjayB0aGUgZGlyZWN0aW9uYWxpdHkgb2YgYSBwaWVjZSBvZiB0ZXh0LCByZXR1cm4gdHJ1ZSBpZiB0aGUgcGllY2Ugb2ZcbiAqIHRleHQgc2hvdWxkIGJlIGxhaWQgb3V0IGluIFJUTCBkaXJlY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBwaWVjZSBvZiB0ZXh0IHRoYXQgbmVlZCB0byBiZSBkZXRlY3RlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9pc0h0bWwgV2hldGhlciBzdHIgaXMgSFRNTCAvIEhUTUwtZXNjYXBlZC5cbiAqICAgICBEZWZhdWx0OiBmYWxzZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBwaWVjZSBvZiB0ZXh0IHNob3VsZCBiZSBsYWlkIG91dCBpbiBSVEwuXG4gKi9cbmdvb2cuaTE4bi5iaWRpLmRldGVjdFJ0bERpcmVjdGlvbmFsaXR5ID0gZnVuY3Rpb24oc3RyLCBvcHRfaXNIdG1sKSB7XG4gIHJldHVybiBnb29nLmkxOG4uYmlkaS5lc3RpbWF0ZURpcmVjdGlvbihzdHIsIG9wdF9pc0h0bWwpID09XG4gICAgICBnb29nLmkxOG4uYmlkaS5EaXIuUlRMO1xufTtcblxuXG4vKipcbiAqIFNldHMgdGV4dCBpbnB1dCBlbGVtZW50J3MgZGlyZWN0aW9uYWxpdHkgYW5kIHRleHQgYWxpZ25tZW50IGJhc2VkIG9uIGFcbiAqIGdpdmVuIGRpcmVjdGlvbmFsaXR5LiBEb2VzIG5vdGhpbmcgaWYgdGhlIGdpdmVuIGRpcmVjdGlvbmFsaXR5IGlzIHVua25vd24gb3JcbiAqIG5ldXRyYWwuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgSW5wdXQgZmllbGQgZWxlbWVudCB0byBzZXQgZGlyZWN0aW9uYWxpdHkgdG8uXG4gKiBAcGFyYW0ge2dvb2cuaTE4bi5iaWRpLkRpcnxudW1iZXJ8Ym9vbGVhbnxudWxsfSBkaXIgRGVzaXJlZCBkaXJlY3Rpb25hbGl0eSxcbiAqICAgICBnaXZlbiBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtYXRzOlxuICogICAgIDEuIEEgZ29vZy5pMThuLmJpZGkuRGlyIGNvbnN0YW50LlxuICogICAgIDIuIEEgbnVtYmVyIChwb3NpdGl2ZSA9IExSVCwgbmVnYXRpdmUgPSBSVEwsIDAgPSBuZXV0cmFsKS5cbiAqICAgICAzLiBBIGJvb2xlYW4gKHRydWUgPSBSVEwsIGZhbHNlID0gTFRSKS5cbiAqICAgICA0LiBBIG51bGwgZm9yIHVua25vd24gZGlyZWN0aW9uYWxpdHkuXG4gKi9cbmdvb2cuaTE4bi5iaWRpLnNldEVsZW1lbnREaXJBbmRBbGlnbiA9IGZ1bmN0aW9uKGVsZW1lbnQsIGRpcikge1xuICBpZiAoZWxlbWVudCkge1xuICAgIGRpciA9IGdvb2cuaTE4bi5iaWRpLnRvRGlyKGRpcik7XG4gICAgaWYgKGRpcikge1xuICAgICAgZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSBkaXIgPT0gZ29vZy5pMThuLmJpZGkuRGlyLlJUTCA/XG4gICAgICAgICAgZ29vZy5pMThuLmJpZGkuUklHSFQgOlxuICAgICAgICAgIGdvb2cuaTE4bi5iaWRpLkxFRlQ7XG4gICAgICBlbGVtZW50LmRpciA9IGRpciA9PSBnb29nLmkxOG4uYmlkaS5EaXIuUlRMID8gJ3J0bCcgOiAnbHRyJztcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTZXRzIGVsZW1lbnQgZGlyIGJhc2VkIG9uIGVzdGltYXRlZCBkaXJlY3Rpb25hbGl0eSBvZiB0aGUgZ2l2ZW4gdGV4dC5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKi9cbmdvb2cuaTE4bi5iaWRpLnNldEVsZW1lbnREaXJCeVRleHREaXJlY3Rpb25hbGl0eSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHRleHQpIHtcbiAgc3dpdGNoIChnb29nLmkxOG4uYmlkaS5lc3RpbWF0ZURpcmVjdGlvbih0ZXh0KSkge1xuICAgIGNhc2UgKGdvb2cuaTE4bi5iaWRpLkRpci5MVFIpOlxuICAgICAgZWxlbWVudC5kaXIgPSAnbHRyJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgKGdvb2cuaTE4bi5iaWRpLkRpci5SVEwpOlxuICAgICAgZWxlbWVudC5kaXIgPSAncnRsJztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBEZWZhdWx0IGZvciBubyBkaXJlY3Rpb24sIGluaGVyaXQgZnJvbSBkb2N1bWVudC5cbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkaXInKTtcbiAgfVxufTtcblxuXG5cbi8qKlxuICogU3RyaW5ncyB0aGF0IGhhdmUgYW4gKG9wdGlvbmFsKSBrbm93biBkaXJlY3Rpb24uXG4gKlxuICogSW1wbGVtZW50YXRpb25zIG9mIHRoaXMgaW50ZXJmYWNlIGFyZSBzdHJpbmctbGlrZSBvYmplY3RzIHRoYXQgY2FycnkgYW5cbiAqIGF0dGFjaGVkIGRpcmVjdGlvbiwgaWYga25vd24uXG4gKiBAaW50ZXJmYWNlXG4gKi9cbmdvb2cuaTE4bi5iaWRpLkRpcmVjdGlvbmFsU3RyaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuXG4vKipcbiAqIEludGVyZmFjZSBtYXJrZXIgb2YgdGhlIERpcmVjdGlvbmFsU3RyaW5nIGludGVyZmFjZS5cbiAqXG4gKiBUaGlzIHByb3BlcnR5IGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSBhdCBydW50aW1lIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdFxuICogaW1wbGVtZW50cyB0aGlzIGludGVyZmFjZS4gIEFsbCBpbXBsZW1lbnRhdGlvbnMgb2YgdGhpcyBpbnRlcmZhY2Ugc2V0IHRoaXNcbiAqIHByb3BlcnR5IHRvIHtAY29kZSB0cnVlfS5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5nb29nLmkxOG4uYmlkaS5EaXJlY3Rpb25hbFN0cmluZy5wcm90b3R5cGVcbiAgICAuaW1wbGVtZW50c0dvb2dJMThuQmlkaURpcmVjdGlvbmFsU3RyaW5nO1xuXG5cbi8qKlxuICogUmV0cmlldmVzIHRoaXMgb2JqZWN0J3Mga25vd24gZGlyZWN0aW9uIChpZiBhbnkpLlxuICogQHJldHVybiB7P2dvb2cuaTE4bi5iaWRpLkRpcn0gVGhlIGtub3duIGRpcmVjdGlvbi4gTnVsbCBpZiB1bmtub3duLlxuICovXG5nb29nLmkxOG4uYmlkaS5EaXJlY3Rpb25hbFN0cmluZy5wcm90b3R5cGUuZ2V0RGlyZWN0aW9uO1xuXG5cblxuLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuXG4vLyBDb3B5cmlnaHQgMjAwOCBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFV0aWxpdGllcyB0byBjaGVjayB0aGUgcHJlY29uZGl0aW9ucywgcG9zdGNvbmRpdGlvbnMgYW5kXG4gKiBpbnZhcmlhbnRzIHJ1bnRpbWUuXG4gKlxuICogTWV0aG9kcyBpbiB0aGlzIHBhY2thZ2Ugc2hvdWxkIGJlIGdpdmVuIHNwZWNpYWwgdHJlYXRtZW50IGJ5IHRoZSBjb21waWxlclxuICogZm9yIHR5cGUtaW5mZXJlbmNlLiBGb3IgZXhhbXBsZSwgPGNvZGU+Z29vZy5hc3NlcnRzLmFzc2VydChmb28pPC9jb2RlPlxuICogd2lsbCByZXN0cmljdCA8Y29kZT5mb288L2NvZGU+IHRvIGEgdHJ1dGh5IHZhbHVlLlxuICpcbiAqIFRoZSBjb21waWxlciBoYXMgYW4gb3B0aW9uIHRvIGRpc2FibGUgYXNzZXJ0cy4gU28gY29kZSBsaWtlOlxuICogPGNvZGU+XG4gKiB2YXIgeCA9IGdvb2cuYXNzZXJ0cy5hc3NlcnQoZm9vKCkpOyBnb29nLmFzc2VydHMuYXNzZXJ0KGJhcigpKTtcbiAqIDwvY29kZT5cbiAqIHdpbGwgYmUgdHJhbnNmb3JtZWQgaW50bzpcbiAqIDxjb2RlPlxuICogdmFyIHggPSBmb28oKTtcbiAqIDwvY29kZT5cbiAqIFRoZSBjb21waWxlciB3aWxsIGxlYXZlIGluIGZvbygpIChiZWNhdXNlIGl0cyByZXR1cm4gdmFsdWUgaXMgdXNlZCksXG4gKiBidXQgaXQgd2lsbCByZW1vdmUgYmFyKCkgYmVjYXVzZSBpdCBhc3N1bWVzIGl0IGRvZXMgbm90IGhhdmUgc2lkZS1lZmZlY3RzLlxuICpcbiAqIEBhdXRob3IgYWdyaWV2ZUBnb29nbGUuY29tIChBbmRyZXcgR3JpZXZlKVxuICovXG5cbmdvb2cucHJvdmlkZSgnZ29vZy5hc3NlcnRzJyk7XG5cbi8qKlxuICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0byBzdHJpcCBvdXQgYXNzZXJ0cyBvciB0byBsZWF2ZSB0aGVtIGluLlxuICovXG5nb29nLmRlZmluZSgnZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTJywgZ29vZy5ERUJVRyk7XG5cblxuXG4vKipcbiAqIEVycm9yIG9iamVjdCBmb3IgZmFpbGVkIGFzc2VydGlvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVBhdHRlcm4gVGhlIHBhdHRlcm4gdGhhdCB3YXMgdXNlZCB0byBmb3JtIG1lc3NhZ2UuXG4gKiBAcGFyYW0geyFBcnJheTwqPn0gbWVzc2FnZUFyZ3MgVGhlIGl0ZW1zIHRvIHN1YnN0aXR1dGUgaW50byB0aGUgcGF0dGVybi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge2dvb2cuZGVidWcuRXJyb3J9XG4gKiBAZmluYWxcbiAqL1xuZ29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24obWVzc2FnZVBhdHRlcm4sIG1lc3NhZ2VBcmdzKSB7XG4gIG1lc3NhZ2VBcmdzLnVuc2hpZnQobWVzc2FnZVBhdHRlcm4pO1xuICBnb29nLmRlYnVnLkVycm9yLmNhbGwodGhpcywgZ29vZy5zdHJpbmcuc3Vicy5hcHBseShudWxsLCBtZXNzYWdlQXJncykpO1xuICAvLyBSZW1vdmUgdGhlIG1lc3NhZ2VQYXR0ZXJuIGFmdGVyd2FyZHMgdG8gYXZvaWQgcGVybWFuZW50bHkgbW9kaWZ5aW5nIHRoZVxuICAvLyBwYXNzZWQgaW4gYXJyYXkuXG4gIG1lc3NhZ2VBcmdzLnNoaWZ0KCk7XG5cbiAgLyoqXG4gICAqIFRoZSBtZXNzYWdlIHBhdHRlcm4gdXNlZCB0byBmb3JtYXQgdGhlIGVycm9yIG1lc3NhZ2UuIEVycm9yIGhhbmRsZXJzIGNhblxuICAgKiB1c2UgdGhpcyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGUgYXNzZXJ0aW9uLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGhpcy5tZXNzYWdlUGF0dGVybiA9IG1lc3NhZ2VQYXR0ZXJuO1xufTtcbmdvb2cuaW5oZXJpdHMoZ29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yLCBnb29nLmRlYnVnLkVycm9yKTtcblxuXG4vKiogQG92ZXJyaWRlICovXG5nb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuXG5cbi8qKlxuICogVGhlIGRlZmF1bHQgZXJyb3IgaGFuZGxlci5cbiAqIEBwYXJhbSB7IWdvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvcn0gZSBUaGUgZXhjZXB0aW9uIHRvIGJlIGhhbmRsZWQuXG4gKi9cbmdvb2cuYXNzZXJ0cy5ERUZBVUxUX0VSUk9SX0hBTkRMRVIgPSBmdW5jdGlvbihlKSB7XG4gIHRocm93IGU7XG59O1xuXG5cbi8qKlxuICogVGhlIGhhbmRsZXIgcmVzcG9uc2libGUgZm9yIHRocm93aW5nIG9yIGxvZ2dpbmcgYXNzZXJ0aW9uIGVycm9ycy5cbiAqIEBwcml2YXRlIHtmdW5jdGlvbighZ29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yKX1cbiAqL1xuZ29vZy5hc3NlcnRzLmVycm9ySGFuZGxlcl8gPSBnb29nLmFzc2VydHMuREVGQVVMVF9FUlJPUl9IQU5ETEVSO1xuXG5cbi8qKlxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlIGFuZCBcIkFzc2VydGlvbiBmYWlsZWRcIiBwcmVmaXhlZFxuICogb250byBpdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWZhdWx0TWVzc2FnZSBUaGUgbWVzc2FnZSB0byB1c2UgaWYgZ2l2ZW5NZXNzYWdlIGlzIGVtcHR5LlxuICogQHBhcmFtIHtBcnJheTwqPn0gZGVmYXVsdEFyZ3MgVGhlIHN1YnN0aXR1dGlvbiBhcmd1bWVudHMgZm9yIGRlZmF1bHRNZXNzYWdlLlxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBnaXZlbk1lc3NhZ2UgTWVzc2FnZSBzdXBwbGllZCBieSB0aGUgY2FsbGVyLlxuICogQHBhcmFtIHtBcnJheTwqPn0gZ2l2ZW5BcmdzIFRoZSBzdWJzdGl0dXRpb24gYXJndW1lbnRzIGZvciBnaXZlbk1lc3NhZ2UuXG4gKiBAdGhyb3dzIHtnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3J9IFdoZW4gdGhlIHZhbHVlIGlzIG5vdCBhIG51bWJlci5cbiAqIEBwcml2YXRlXG4gKi9cbmdvb2cuYXNzZXJ0cy5kb0Fzc2VydEZhaWx1cmVfID0gZnVuY3Rpb24oXG4gICAgZGVmYXVsdE1lc3NhZ2UsIGRlZmF1bHRBcmdzLCBnaXZlbk1lc3NhZ2UsIGdpdmVuQXJncykge1xuICB2YXIgbWVzc2FnZSA9ICdBc3NlcnRpb24gZmFpbGVkJztcbiAgaWYgKGdpdmVuTWVzc2FnZSkge1xuICAgIG1lc3NhZ2UgKz0gJzogJyArIGdpdmVuTWVzc2FnZTtcbiAgICB2YXIgYXJncyA9IGdpdmVuQXJncztcbiAgfSBlbHNlIGlmIChkZWZhdWx0TWVzc2FnZSkge1xuICAgIG1lc3NhZ2UgKz0gJzogJyArIGRlZmF1bHRNZXNzYWdlO1xuICAgIGFyZ3MgPSBkZWZhdWx0QXJncztcbiAgfVxuICAvLyBUaGUgJycgKyB3b3JrcyBhcm91bmQgYW4gT3BlcmEgMTAgYnVnIGluIHRoZSB1bml0IHRlc3RzLiBXaXRob3V0IGl0LFxuICAvLyBhIHN0YWNrIHRyYWNlIGlzIGFkZGVkIHRvIHZhciBtZXNzYWdlIGFib3ZlLiBXaXRoIHRoaXMsIGEgc3RhY2sgdHJhY2UgaXNcbiAgLy8gbm90IGFkZGVkIHVudGlsIHRoaXMgbGluZSAoaXQgY2F1c2VzIHRoZSBleHRyYSBnYXJiYWdlIHRvIGJlIGFkZGVkIGFmdGVyXG4gIC8vIHRoZSBhc3NlcnRpb24gbWVzc2FnZSBpbnN0ZWFkIG9mIGluIHRoZSBtaWRkbGUgb2YgaXQpLlxuICB2YXIgZSA9IG5ldyBnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3IoJycgKyBtZXNzYWdlLCBhcmdzIHx8IFtdKTtcbiAgZ29vZy5hc3NlcnRzLmVycm9ySGFuZGxlcl8oZSk7XG59O1xuXG5cbi8qKlxuICogU2V0cyBhIGN1c3RvbSBlcnJvciBoYW5kbGVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gY3VzdG9taXplIHRoZSBiZWhhdmlvciBvZlxuICogYXNzZXJ0aW9uIGZhaWx1cmVzLCBmb3IgZXhhbXBsZSBieSB0dXJuaW5nIGFsbCBhc3NlcnRpb24gZmFpbHVyZXMgaW50byBsb2dcbiAqIG1lc3NhZ2VzLlxuICogQHBhcmFtIHtmdW5jdGlvbighZ29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yKX0gZXJyb3JIYW5kbGVyXG4gKi9cbmdvb2cuYXNzZXJ0cy5zZXRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbihlcnJvckhhbmRsZXIpIHtcbiAgaWYgKGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUykge1xuICAgIGdvb2cuYXNzZXJ0cy5lcnJvckhhbmRsZXJfID0gZXJyb3JIYW5kbGVyO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBjb25kaXRpb24gZXZhbHVhdGVzIHRvIHRydWUgaWYgZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTIGlzXG4gKiB0cnVlLlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gY29uZGl0aW9uIFRoZSBjb25kaXRpb24gdG8gY2hlY2suXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9tZXNzYWdlIEVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiBmYWlsdXJlLlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBUaGUgaXRlbXMgdG8gc3Vic3RpdHV0ZSBpbnRvIHRoZSBmYWlsdXJlIG1lc3NhZ2UuXG4gKiBAcmV0dXJuIHtUfSBUaGUgdmFsdWUgb2YgdGhlIGNvbmRpdGlvbi5cbiAqIEB0aHJvd3Mge2dvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvcn0gV2hlbiB0aGUgY29uZGl0aW9uIGV2YWx1YXRlcyB0byBmYWxzZS5cbiAqL1xuZ29vZy5hc3NlcnRzLmFzc2VydCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgb3B0X21lc3NhZ2UsIHZhcl9hcmdzKSB7XG4gIGlmIChnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgJiYgIWNvbmRpdGlvbikge1xuICAgIGdvb2cuYXNzZXJ0cy5kb0Fzc2VydEZhaWx1cmVfKFxuICAgICAgICAnJywgbnVsbCwgb3B0X21lc3NhZ2UsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpO1xuICB9XG4gIHJldHVybiBjb25kaXRpb247XG59O1xuXG5cbi8qKlxuICogRmFpbHMgaWYgZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTIGlzIHRydWUuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZnVsIGluIGNhc2VcbiAqIHdoZW4gd2Ugd2FudCB0byBhZGQgYSBjaGVjayBpbiB0aGUgdW5yZWFjaGFibGUgYXJlYSBsaWtlIHN3aXRjaC1jYXNlXG4gKiBzdGF0ZW1lbnQ6XG4gKlxuICogPHByZT5cbiAqICBzd2l0Y2godHlwZSkge1xuICogICAgY2FzZSBGT086IGRvU29tZXRoaW5nKCk7IGJyZWFrO1xuICogICAgY2FzZSBCQVI6IGRvU29tZXRoaW5nRWxzZSgpOyBicmVhaztcbiAqICAgIGRlZmF1bHQ6IGdvb2cuYXNzZXJ0LmZhaWwoJ1VucmVjb2duaXplZCB0eXBlOiAnICsgdHlwZSk7XG4gKiAgICAgIC8vIFdlIGhhdmUgb25seSAyIHR5cGVzIC0gXCJkZWZhdWx0OlwiIHNlY3Rpb24gaXMgdW5yZWFjaGFibGUgY29kZS5cbiAqICB9XG4gKiA8L3ByZT5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9tZXNzYWdlIEVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiBmYWlsdXJlLlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBUaGUgaXRlbXMgdG8gc3Vic3RpdHV0ZSBpbnRvIHRoZSBmYWlsdXJlIG1lc3NhZ2UuXG4gKiBAdGhyb3dzIHtnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3J9IEZhaWx1cmUuXG4gKi9cbmdvb2cuYXNzZXJ0cy5mYWlsID0gZnVuY3Rpb24ob3B0X21lc3NhZ2UsIHZhcl9hcmdzKSB7XG4gIGlmIChnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMpIHtcbiAgICBnb29nLmFzc2VydHMuZXJyb3JIYW5kbGVyXyhcbiAgICAgICAgbmV3IGdvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvcihcbiAgICAgICAgICAgICdGYWlsdXJlJyArIChvcHRfbWVzc2FnZSA/ICc6ICcgKyBvcHRfbWVzc2FnZSA6ICcnKSxcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIgaWYgZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTIGlzIHRydWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2UgRXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSBpdGVtcyB0byBzdWJzdGl0dXRlIGludG8gdGhlIGZhaWx1cmUgbWVzc2FnZS5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZhbHVlLCBndWFyYW50ZWVkIHRvIGJlIGEgbnVtYmVyIHdoZW4gYXNzZXJ0cyBlbmFibGVkLlxuICogQHRocm93cyB7Z29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yfSBXaGVuIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXIuXG4gKi9cbmdvb2cuYXNzZXJ0cy5hc3NlcnROdW1iZXIgPSBmdW5jdGlvbih2YWx1ZSwgb3B0X21lc3NhZ2UsIHZhcl9hcmdzKSB7XG4gIGlmIChnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgJiYgIWdvb2cuaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgZ29vZy5hc3NlcnRzLmRvQXNzZXJ0RmFpbHVyZV8oXG4gICAgICAgICdFeHBlY3RlZCBudW1iZXIgYnV0IGdvdCAlczogJXMuJywgW2dvb2cudHlwZU9mKHZhbHVlKSwgdmFsdWVdLFxuICAgICAgICBvcHRfbWVzc2FnZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG4gIH1cbiAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodmFsdWUpO1xufTtcblxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcgaWYgZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTIGlzIHRydWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2UgRXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSBpdGVtcyB0byBzdWJzdGl0dXRlIGludG8gdGhlIGZhaWx1cmUgbWVzc2FnZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHZhbHVlLCBndWFyYW50ZWVkIHRvIGJlIGEgc3RyaW5nIHdoZW4gYXNzZXJ0cyBlbmFibGVkLlxuICogQHRocm93cyB7Z29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yfSBXaGVuIHRoZSB2YWx1ZSBpcyBub3QgYSBzdHJpbmcuXG4gKi9cbmdvb2cuYXNzZXJ0cy5hc3NlcnRTdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSwgb3B0X21lc3NhZ2UsIHZhcl9hcmdzKSB7XG4gIGlmIChnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgJiYgIWdvb2cuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgZ29vZy5hc3NlcnRzLmRvQXNzZXJ0RmFpbHVyZV8oXG4gICAgICAgICdFeHBlY3RlZCBzdHJpbmcgYnV0IGdvdCAlczogJXMuJywgW2dvb2cudHlwZU9mKHZhbHVlKSwgdmFsdWVdLFxuICAgICAgICBvcHRfbWVzc2FnZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG4gIH1cbiAgcmV0dXJuIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodmFsdWUpO1xufTtcblxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgdmFsdWUgaXMgYSBmdW5jdGlvbiBpZiBnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgaXMgdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWVzc2FnZSBFcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgZmFpbHVyZS5cbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgVGhlIGl0ZW1zIHRvIHN1YnN0aXR1dGUgaW50byB0aGUgZmFpbHVyZSBtZXNzYWdlLlxuICogQHJldHVybiB7IUZ1bmN0aW9ufSBUaGUgdmFsdWUsIGd1YXJhbnRlZWQgdG8gYmUgYSBmdW5jdGlvbiB3aGVuIGFzc2VydHNcbiAqICAgICBlbmFibGVkLlxuICogQHRocm93cyB7Z29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yfSBXaGVuIHRoZSB2YWx1ZSBpcyBub3QgYSBmdW5jdGlvbi5cbiAqL1xuZ29vZy5hc3NlcnRzLmFzc2VydEZ1bmN0aW9uID0gZnVuY3Rpb24odmFsdWUsIG9wdF9tZXNzYWdlLCB2YXJfYXJncykge1xuICBpZiAoZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTICYmICFnb29nLmlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgZ29vZy5hc3NlcnRzLmRvQXNzZXJ0RmFpbHVyZV8oXG4gICAgICAgICdFeHBlY3RlZCBmdW5jdGlvbiBidXQgZ290ICVzOiAlcy4nLCBbZ29vZy50eXBlT2YodmFsdWUpLCB2YWx1ZV0sXG4gICAgICAgIG9wdF9tZXNzYWdlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcbiAgfVxuICByZXR1cm4gLyoqIEB0eXBlIHshRnVuY3Rpb259ICovICh2YWx1ZSk7XG59O1xuXG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyBhbiBPYmplY3QgaWYgZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTIGlzIHRydWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2UgRXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSBpdGVtcyB0byBzdWJzdGl0dXRlIGludG8gdGhlIGZhaWx1cmUgbWVzc2FnZS5cbiAqIEByZXR1cm4geyFPYmplY3R9IFRoZSB2YWx1ZSwgZ3VhcmFudGVlZCB0byBiZSBhIG5vbi1udWxsIG9iamVjdC5cbiAqIEB0aHJvd3Mge2dvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvcn0gV2hlbiB0aGUgdmFsdWUgaXMgbm90IGFuIG9iamVjdC5cbiAqL1xuZ29vZy5hc3NlcnRzLmFzc2VydE9iamVjdCA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRfbWVzc2FnZSwgdmFyX2FyZ3MpIHtcbiAgaWYgKGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyAmJiAhZ29vZy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICBnb29nLmFzc2VydHMuZG9Bc3NlcnRGYWlsdXJlXyhcbiAgICAgICAgJ0V4cGVjdGVkIG9iamVjdCBidXQgZ290ICVzOiAlcy4nLCBbZ29vZy50eXBlT2YodmFsdWUpLCB2YWx1ZV0sXG4gICAgICAgIG9wdF9tZXNzYWdlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcbiAgfVxuICByZXR1cm4gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAodmFsdWUpO1xufTtcblxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgdmFsdWUgaXMgYW4gQXJyYXkgaWYgZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTIGlzIHRydWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2UgRXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSBpdGVtcyB0byBzdWJzdGl0dXRlIGludG8gdGhlIGZhaWx1cmUgbWVzc2FnZS5cbiAqIEByZXR1cm4geyFBcnJheTw/Pn0gVGhlIHZhbHVlLCBndWFyYW50ZWVkIHRvIGJlIGEgbm9uLW51bGwgYXJyYXkuXG4gKiBAdGhyb3dzIHtnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3J9IFdoZW4gdGhlIHZhbHVlIGlzIG5vdCBhbiBhcnJheS5cbiAqL1xuZ29vZy5hc3NlcnRzLmFzc2VydEFycmF5ID0gZnVuY3Rpb24odmFsdWUsIG9wdF9tZXNzYWdlLCB2YXJfYXJncykge1xuICBpZiAoZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTICYmICFnb29nLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgZ29vZy5hc3NlcnRzLmRvQXNzZXJ0RmFpbHVyZV8oXG4gICAgICAgICdFeHBlY3RlZCBhcnJheSBidXQgZ290ICVzOiAlcy4nLCBbZ29vZy50eXBlT2YodmFsdWUpLCB2YWx1ZV0sXG4gICAgICAgIG9wdF9tZXNzYWdlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcbiAgfVxuICByZXR1cm4gLyoqIEB0eXBlIHshQXJyYXk8Pz59ICovICh2YWx1ZSk7XG59O1xuXG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4gaWYgZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTIGlzIHRydWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2UgRXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSBpdGVtcyB0byBzdWJzdGl0dXRlIGludG8gdGhlIGZhaWx1cmUgbWVzc2FnZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB2YWx1ZSwgZ3VhcmFudGVlZCB0byBiZSBhIGJvb2xlYW4gd2hlbiBhc3NlcnRzIGFyZVxuICogICAgIGVuYWJsZWQuXG4gKiBAdGhyb3dzIHtnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3J9IFdoZW4gdGhlIHZhbHVlIGlzIG5vdCBhIGJvb2xlYW4uXG4gKi9cbmdvb2cuYXNzZXJ0cy5hc3NlcnRCb29sZWFuID0gZnVuY3Rpb24odmFsdWUsIG9wdF9tZXNzYWdlLCB2YXJfYXJncykge1xuICBpZiAoZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTICYmICFnb29nLmlzQm9vbGVhbih2YWx1ZSkpIHtcbiAgICBnb29nLmFzc2VydHMuZG9Bc3NlcnRGYWlsdXJlXyhcbiAgICAgICAgJ0V4cGVjdGVkIGJvb2xlYW4gYnV0IGdvdCAlczogJXMuJywgW2dvb2cudHlwZU9mKHZhbHVlKSwgdmFsdWVdLFxuICAgICAgICBvcHRfbWVzc2FnZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG4gIH1cbiAgcmV0dXJuIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gKHZhbHVlKTtcbn07XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGEgRE9NIEVsZW1lbnQgaWYgZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTIGlzIHRydWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2UgRXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSBpdGVtcyB0byBzdWJzdGl0dXRlIGludG8gdGhlIGZhaWx1cmUgbWVzc2FnZS5cbiAqIEByZXR1cm4geyFFbGVtZW50fSBUaGUgdmFsdWUsIGxpa2VseSB0byBiZSBhIERPTSBFbGVtZW50IHdoZW4gYXNzZXJ0cyBhcmVcbiAqICAgICBlbmFibGVkLlxuICogQHRocm93cyB7Z29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yfSBXaGVuIHRoZSB2YWx1ZSBpcyBub3QgYW4gRWxlbWVudC5cbiAqL1xuZ29vZy5hc3NlcnRzLmFzc2VydEVsZW1lbnQgPSBmdW5jdGlvbih2YWx1ZSwgb3B0X21lc3NhZ2UsIHZhcl9hcmdzKSB7XG4gIGlmIChnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgJiZcbiAgICAgICghZ29vZy5pc09iamVjdCh2YWx1ZSkgfHwgdmFsdWUubm9kZVR5cGUgIT0gZ29vZy5kb20uTm9kZVR5cGUuRUxFTUVOVCkpIHtcbiAgICBnb29nLmFzc2VydHMuZG9Bc3NlcnRGYWlsdXJlXyhcbiAgICAgICAgJ0V4cGVjdGVkIEVsZW1lbnQgYnV0IGdvdCAlczogJXMuJywgW2dvb2cudHlwZU9mKHZhbHVlKSwgdmFsdWVdLFxuICAgICAgICBvcHRfbWVzc2FnZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG4gIH1cbiAgcmV0dXJuIC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovICh2YWx1ZSk7XG59O1xuXG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgdXNlci1kZWZpbmVkIHR5cGUgaWZcbiAqIGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyBpcyB0cnVlLlxuICpcbiAqIFRoZSBjb21waWxlciBtYXkgdGlnaHRlbiB0aGUgdHlwZSByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7P30gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtmdW5jdGlvbihuZXc6IFQsIC4uLil9IHR5cGUgQSB1c2VyLWRlZmluZWQgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9tZXNzYWdlIEVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiBmYWlsdXJlLlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBUaGUgaXRlbXMgdG8gc3Vic3RpdHV0ZSBpbnRvIHRoZSBmYWlsdXJlIG1lc3NhZ2UuXG4gKiBAdGhyb3dzIHtnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3J9IFdoZW4gdGhlIHZhbHVlIGlzIG5vdCBhbiBpbnN0YW5jZSBvZlxuICogICAgIHR5cGUuXG4gKiBAcmV0dXJuIHtUfVxuICogQHRlbXBsYXRlIFRcbiAqL1xuZ29vZy5hc3NlcnRzLmFzc2VydEluc3RhbmNlb2YgPSBmdW5jdGlvbih2YWx1ZSwgdHlwZSwgb3B0X21lc3NhZ2UsIHZhcl9hcmdzKSB7XG4gIGlmIChnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIHR5cGUpKSB7XG4gICAgZ29vZy5hc3NlcnRzLmRvQXNzZXJ0RmFpbHVyZV8oXG4gICAgICAgICdFeHBlY3RlZCBpbnN0YW5jZW9mICVzIGJ1dCBnb3QgJXMuJyxcbiAgICAgICAgW2dvb2cuYXNzZXJ0cy5nZXRUeXBlXyh0eXBlKSwgZ29vZy5hc3NlcnRzLmdldFR5cGVfKHZhbHVlKV0sXG4gICAgICAgIG9wdF9tZXNzYWdlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5cbi8qKlxuICogQ2hlY2tzIHRoYXQgbm8gZW51bWVyYWJsZSBrZXlzIGFyZSBwcmVzZW50IGluIE9iamVjdC5wcm90b3R5cGUuIFN1Y2gga2V5c1xuICogd291bGQgYnJlYWsgbW9zdCBjb2RlIHRoYXQgdXNlIHtAY29kZSBmb3IgKHZhciAuLi4gaW4gLi4uKX0gbG9vcHMuXG4gKi9cbmdvb2cuYXNzZXJ0cy5hc3NlcnRPYmplY3RQcm90b3R5cGVJc0ludGFjdCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgIGdvb2cuYXNzZXJ0cy5mYWlsKGtleSArICcgc2hvdWxkIG5vdCBiZSBlbnVtZXJhYmxlIGluIE9iamVjdC5wcm90b3R5cGUuJyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0eXBlIG9mIGEgdmFsdWUuIElmIGEgY29uc3RydWN0b3IgaXMgcGFzc2VkLCBhbmQgYSBzdWl0YWJsZVxuICogc3RyaW5nIGNhbm5vdCBiZSBmb3VuZCwgJ3Vua25vd24gdHlwZSBuYW1lJyB3aWxsIGJlIHJldHVybmVkLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBBIGNvbnN0cnVjdG9yLCBvYmplY3QsIG9yIHByaW1pdGl2ZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGJlc3QgZGlzcGxheSBuYW1lIGZvciB0aGUgdmFsdWUsIG9yICd1bmtub3duIHR5cGUgbmFtZScuXG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLmFzc2VydHMuZ2V0VHlwZV8gPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIHJldHVybiB2YWx1ZS5kaXNwbGF5TmFtZSB8fCB2YWx1ZS5uYW1lIHx8ICd1bmtub3duIHR5cGUgbmFtZSc7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiB2YWx1ZTtcbiAgfVxufTtcblxuXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBVdGlsaXR5IGZvciBmYXN0IHN0cmluZyBjb25jYXRlbmF0aW9uLlxuICovXG5cblxuXG5cbi8qKlxuICogVXRpbGl0eSBjbGFzcyB0byBmYWNpbGl0YXRlIHN0cmluZyBjb25jYXRlbmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7Kj19IG9wdF9hMSBPcHRpb25hbCBmaXJzdCBpbml0aWFsIGl0ZW0gdG8gYXBwZW5kLlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBPdGhlciBpbml0aWFsIGl0ZW1zIHRvXG4gKiAgICAgYXBwZW5kLCBlLmcuLCBuZXcgZ29vZy5zdHJpbmcuU3RyaW5nQnVmZmVyKCdmb28nLCAnYmFyJykuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZ29vZy5zdHJpbmcuU3RyaW5nQnVmZmVyID0gZnVuY3Rpb24ob3B0X2ExLCB2YXJfYXJncykge1xuICBpZiAob3B0X2ExICE9IG51bGwpIHtcbiAgICB0aGlzLmFwcGVuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogSW50ZXJuYWwgYnVmZmVyIGZvciB0aGUgc3RyaW5nIHRvIGJlIGNvbmNhdGVuYXRlZC5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5nb29nLnN0cmluZy5TdHJpbmdCdWZmZXIucHJvdG90eXBlLmJ1ZmZlcl8gPSAnJztcblxuXG4vKipcbiAqIFNldHMgdGhlIGNvbnRlbnRzIG9mIHRoZSBzdHJpbmcgYnVmZmVyIG9iamVjdCwgcmVwbGFjaW5nIHdoYXQncyBjdXJyZW50bHlcbiAqIHRoZXJlLlxuICpcbiAqIEBwYXJhbSB7Kn0gcyBTdHJpbmcgdG8gc2V0LlxuICovXG5nb29nLnN0cmluZy5TdHJpbmdCdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHMpIHtcbiAgdGhpcy5idWZmZXJfID0gJycgKyBzO1xufTtcblxuXG4vKipcbiAqIEFwcGVuZHMgb25lIG9yIG1vcmUgaXRlbXMgdG8gdGhlIGJ1ZmZlci5cbiAqXG4gKiBDYWxsaW5nIHRoaXMgd2l0aCBudWxsLCB1bmRlZmluZWQsIG9yIGVtcHR5IGFyZ3VtZW50cyBpcyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0geyp9IGExIFJlcXVpcmVkIGZpcnN0IHN0cmluZy5cbiAqIEBwYXJhbSB7Kj19IG9wdF9hMiBPcHRpb25hbCBzZWNvbmQgc3RyaW5nLlxuICogQHBhcmFtIHsuLi4/fSB2YXJfYXJncyBPdGhlciBpdGVtcyB0byBhcHBlbmQsXG4gKiAgICAgZS5nLiwgc2IuYXBwZW5kKCdmb28nLCAnYmFyJywgJ2JheicpLlxuICogQHJldHVybiB7IWdvb2cuc3RyaW5nLlN0cmluZ0J1ZmZlcn0gVGhpcyBzYW1lIFN0cmluZ0J1ZmZlciBvYmplY3QuXG4gKiBAc3VwcHJlc3Mge2R1cGxpY2F0ZX1cbiAqL1xuZ29vZy5zdHJpbmcuU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihhMSwgb3B0X2EyLCB2YXJfYXJncykge1xuICAvLyBVc2UgYTEgZGlyZWN0bHkgdG8gYXZvaWQgYXJndW1lbnRzIGluc3RhbnRpYXRpb24gZm9yIHNpbmdsZS1hcmcgY2FzZS5cbiAgdGhpcy5idWZmZXJfICs9IFN0cmluZyhhMSk7XG4gIGlmIChvcHRfYTIgIT0gbnVsbCkgeyAgLy8gc2Vjb25kIGFyZ3VtZW50IGlzIHVuZGVmaW5lZCAobnVsbCA9PSB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuYnVmZmVyXyArPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIENsZWFycyB0aGUgaW50ZXJuYWwgYnVmZmVyLlxuICovXG5nb29nLnN0cmluZy5TdHJpbmdCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYnVmZmVyXyA9ICcnO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGxlbmd0aCBvZiB0aGUgY3VycmVudCBjb250ZW50cyBvZiB0aGUgYnVmZmVyLlxuICovXG5nb29nLnN0cmluZy5TdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5idWZmZXJfLmxlbmd0aDtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb25jYXRlbmF0ZWQgc3RyaW5nLlxuICogQG92ZXJyaWRlXG4gKi9cbmdvb2cuc3RyaW5nLlN0cmluZ0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYnVmZmVyXztcbn07XG5cblxuLy8gQ29weXJpZ2h0IDIwMTIgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBTb3kgZGF0YSBwcmltaXRpdmVzLlxuICpcbiAqIFRoZSBnb2FsIGlzIHRvIGVuY29tcGFzcyBkYXRhIHR5cGVzIHVzZWQgYnkgU295LCBlc3BlY2lhbGx5IHRvIG1hcmsgY29udGVudFxuICogYXMga25vd24gdG8gYmUgXCJzYWZlXCIuXG4gKlxuICogQGF1dGhvciBnYm95ZXJAZ29vZ2xlLmNvbSAoR2FycmV0dCBCb3llcilcbiAqL1xuXG5cblxuZ29vZy5zb3kgPSB7fTtcbmdvb2cuc295LmRhdGEgPSB7fTtcblxuXG4vKipcbiAqIEEgdHlwZSBvZiB0ZXh0dWFsIGNvbnRlbnQuXG4gKlxuICogVGhpcyBpcyBhbiBlbnVtIG9mIHR5cGUgT2JqZWN0IHNvIHRoYXQgdGhlc2UgdmFsdWVzIGFyZSB1bmZvcmdlYWJsZS5cbiAqXG4gKiBAZW51bSB7IU9iamVjdH1cbiAqL1xuZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50S2luZCA9IHtcblxuICAvKipcbiAgICogQSBzbmlwcGV0IG9mIEhUTUwgdGhhdCBkb2VzIG5vdCBzdGFydCBvciBlbmQgaW5zaWRlIGEgdGFnLCBjb21tZW50LCBlbnRpdHksXG4gICAqIG9yIERPQ1RZUEU7IGFuZCB0aGF0IGRvZXMgbm90IGNvbnRhaW4gYW55IGV4ZWN1dGFibGUgY29kZVxuICAgKiAoSlMsIHtAY29kZSA8b2JqZWN0Pn1zLCBldGMuKSBmcm9tIGEgZGlmZmVyZW50IHRydXN0IGRvbWFpbi5cbiAgICovXG4gIEhUTUw6IGdvb2cuREVCVUcgPyB7c2FuaXRpemVkQ29udGVudEtpbmRIdG1sOiB0cnVlfSA6IHt9LFxuXG4gIC8qKlxuICAgKiBFeGVjdXRhYmxlIEphdmFzY3JpcHQgY29kZSBvciBleHByZXNzaW9uLCBzYWZlIGZvciBpbnNlcnRpb24gaW4gYVxuICAgKiBzY3JpcHQtdGFnIG9yIGV2ZW50IGhhbmRsZXIgY29udGV4dCwga25vd24gdG8gYmUgZnJlZSBvZiBhbnlcbiAgICogYXR0YWNrZXItY29udHJvbGxlZCBzY3JpcHRzLiBUaGlzIGNhbiBlaXRoZXIgYmUgc2lkZS1lZmZlY3QtZnJlZVxuICAgKiBKYXZhc2NyaXB0IChzdWNoIGFzIEpTT04pIG9yIEphdmFzY3JpcHQgdGhhdCdzIGVudGlyZWx5IHVuZGVyIEdvb2dsZSdzXG4gICAqIGNvbnRyb2wuXG4gICAqL1xuICBKUzogZ29vZy5ERUJVRyA/IHtzYW5pdGl6ZWRDb250ZW50SnNDaGFyczogdHJ1ZX0gOiB7fSxcblxuICAvKiogQSBwcm9wZXJseSBlbmNvZGVkIHBvcnRpb24gb2YgYSBVUkkuICovXG4gIFVSSTogZ29vZy5ERUJVRyA/IHtzYW5pdGl6ZWRDb250ZW50VXJpOiB0cnVlfSA6IHt9LFxuXG4gIC8qKiBBIHJlc291cmNlIFVSSSBub3QgdW5kZXIgYXR0YWNrZXIgY29udHJvbC4gKi9cbiAgVFJVU1RFRF9SRVNPVVJDRV9VUkk6XG4gICAgICBnb29nLkRFQlVHID8ge3Nhbml0aXplZENvbnRlbnRUcnVzdGVkUmVzb3VyY2VVcmk6IHRydWV9IDoge30sXG5cbiAgLyoqXG4gICAqIFJlcGVhdGVkIGF0dHJpYnV0ZSBuYW1lcyBhbmQgdmFsdWVzLiBGb3IgZXhhbXBsZSxcbiAgICoge0Bjb2RlIGRpcj1cImx0clwiIGZvbz1cImJhclwiIG9uY2xpY2s9XCJ0cnVzdGVkRnVuY3Rpb24oKVwiIGNoZWNrZWR9LlxuICAgKi9cbiAgQVRUUklCVVRFUzogZ29vZy5ERUJVRyA/IHtzYW5pdGl6ZWRDb250ZW50SHRtbEF0dHJpYnV0ZTogdHJ1ZX0gOiB7fSxcblxuICAvLyBUT0RPOiBDb25zaWRlciBzZXBhcmF0aW5nIHJ1bGVzLCBkZWNsYXJhdGlvbnMsIGFuZCB2YWx1ZXMgaW50b1xuICAvLyBzZXBhcmF0ZSB0eXBlcywgYnV0IGZvciBzaW1wbGljaXR5LCB3ZSdsbCB0cmVhdCBleHBsaWNpdGx5IGJsZXNzZWRcbiAgLy8gU2FuaXRpemVkQ29udGVudCBhcyBhbGxvd2VkIGluIGFsbCBvZiB0aGVzZSBjb250ZXh0cy5cbiAgLyoqXG4gICAqIEEgQ1NTMyBkZWNsYXJhdGlvbiwgcHJvcGVydHksIHZhbHVlIG9yIGdyb3VwIG9mIHNlbWljb2xvbiBzZXBhcmF0ZWRcbiAgICogZGVjbGFyYXRpb25zLlxuICAgKi9cbiAgQ1NTOiBnb29nLkRFQlVHID8ge3Nhbml0aXplZENvbnRlbnRDc3M6IHRydWV9IDoge30sXG5cbiAgLyoqXG4gICAqIFVuc2FuaXRpemVkIHBsYWluLXRleHQgY29udGVudC5cbiAgICpcbiAgICogVGhpcyBpcyBlZmZlY3RpdmVseSB0aGUgXCJudWxsXCIgZW50cnkgb2YgdGhpcyBlbnVtLCBhbmQgaXMgc29tZXRpbWVzIHVzZWRcbiAgICogdG8gZXhwbGljaXRseSBtYXJrIGNvbnRlbnQgdGhhdCBzaG91bGQgbmV2ZXIgYmUgdXNlZCB1bmVzY2FwZWQuIFNpbmNlIGFueVxuICAgKiBzdHJpbmcgaXMgc2FmZSB0byB1c2UgYXMgdGV4dCwgYmVpbmcgb2YgQ29udGVudEtpbmQuVEVYVCBtYWtlcyBub1xuICAgKiBndWFyYW50ZWVzIGFib3V0IGl0cyBzYWZldHkgaW4gYW55IG90aGVyIGNvbnRleHQgc3VjaCBhcyBIVE1MLlxuICAgKi9cbiAgVEVYVDogZ29vZy5ERUJVRyA/IHtzYW5pdGl6ZWRDb250ZW50S2luZFRleHQ6IHRydWV9IDoge31cbn07XG5cblxuXG4vKipcbiAqIEEgc3RyaW5nLWxpa2Ugb2JqZWN0IHRoYXQgY2FycmllcyBhIGNvbnRlbnQtdHlwZSBhbmQgYSBjb250ZW50IGRpcmVjdGlvbi5cbiAqXG4gKiBJTVBPUlRBTlQhIERvIG5vdCBjcmVhdGUgdGhlc2UgZGlyZWN0bHksIG5vciBpbnN0YW50aWF0ZSB0aGUgc3ViY2xhc3Nlcy5cbiAqIEluc3RlYWQsIHVzZSBhIHRydXN0ZWQsIGNlbnRyYWxseSByZXZpZXdlZCBsaWJyYXJ5IGFzIGVuZG9yc2VkIGJ5IHlvdXIgdGVhbVxuICogdG8gZ2VuZXJhdGUgdGhlc2Ugb2JqZWN0cy4gT3RoZXJ3aXNlLCB5b3UgcmlzayBhY2NpZGVudGFsbHkgY3JlYXRpbmdcbiAqIFNhbml0aXplZENvbnRlbnQgdGhhdCBpcyBhdHRhY2tlci1jb250cm9sbGVkIGFuZCBnZXRzIGV2YWx1YXRlZCB1bmVzY2FwZWQgaW5cbiAqIHRlbXBsYXRlcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50ID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IEVycm9yKCdEbyBub3QgaW5zdGFudGlhdGUgZGlyZWN0bHknKTtcbn07XG5cblxuLyoqXG4gKiBUaGUgY29udGV4dCBpbiB3aGljaCB0aGlzIGNvbnRlbnQgaXMgc2FmZSBmcm9tIFhTUyBhdHRhY2tzLlxuICogQHR5cGUge2dvb2cuc295LmRhdGEuU2FuaXRpemVkQ29udGVudEtpbmR9XG4gKi9cbmdvb2cuc295LmRhdGEuU2FuaXRpemVkQ29udGVudC5wcm90b3R5cGUuY29udGVudEtpbmQ7XG5cblxuLyoqXG4gKiBUaGUgY29udGVudCdzIGRpcmVjdGlvbjsgbnVsbCBpZiB1bmtub3duIGFuZCB0aHVzIHRvIGJlIGVzdGltYXRlZCB3aGVuXG4gKiBuZWNlc3NhcnkuXG4gKiBAdHlwZSB7P2dvb2cuaTE4bi5iaWRpLkRpcn1cbiAqL1xuZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50LnByb3RvdHlwZS5jb250ZW50RGlyID0gbnVsbDtcblxuXG4vKipcbiAqIFRoZSBhbHJlYWR5LXNhZmUgY29udGVudC5cbiAqIEBwcm90ZWN0ZWQge3N0cmluZ31cbiAqL1xuZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50LnByb3RvdHlwZS5jb250ZW50O1xuXG5cbi8qKlxuICogR2V0cyB0aGUgYWxyZWFkeS1zYWZlIGNvbnRlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmdvb2cuc295LmRhdGEuU2FuaXRpemVkQ29udGVudC5wcm90b3R5cGUuZ2V0Q29udGVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jb250ZW50O1xufTtcblxuXG4vKiogQG92ZXJyaWRlICovXG5nb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNvbnRlbnQ7XG59O1xuXG4vKipcbiAqIEFuIGludGVybWVkaWFyeSBiYXNlIGNsYXNzIHRvIGFsbG93IHRoZSB0eXBlIHN5c3RlbSB0byBzZXBjaWZ5IHRleHQgdGVtcGxhdGVzXG4gKiB3aXRob3V0IHJlZmVyZW5jaW5nIHRoZSBzb3lkYXRhIHBhY2thZ2UuXG4gKiBAZXh0ZW5kcyB7Z29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmdvb2cuc295LmRhdGEuVW5zYW5pdGl6ZWRUZXh0ID0gZnVuY3Rpb24oKSB7XG4gIC8vIFRPRE8oZ2JveWVyKTogRGVsZXRlIHRoaXMgY2xhc3MgYWZ0ZXIgbW92aW5nIHNveWRhdGEgdG8gQ2xvc3VyZS5cbiAgZ29vZy5zb3kuZGF0YS5VbnNhbml0aXplZFRleHQuYmFzZSh0aGlzLCAnY29uc3RydWN0b3InKTtcbn07XG5nb29nLmluaGVyaXRzKGdvb2cuc295LmRhdGEuVW5zYW5pdGl6ZWRUZXh0LCBnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnQpO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBhbmQgY2xhc3NlcyBmb3IgU295LlxuICpcbiAqIDxwPlxuICogVGhlIHRvcCBwb3J0aW9uIG9mIHRoaXMgZmlsZSBjb250YWlucyB1dGlsaXRpZXMgZm9yIFNveSB1c2Vyczo8dWw+XG4gKiAgIDxsaT4gc295LlN0cmluZ0J1aWxkZXI6IENvbXBhdGlibGUgd2l0aCB0aGUgJ3N0cmluZ2J1aWxkZXInIGNvZGUgc3R5bGUuXG4gKiA8L3VsPlxuICpcbiAqIDxwPlxuICogVGhlIGJvdHRvbSBwb3J0aW9uIG9mIHRoaXMgZmlsZSBjb250YWlucyB1dGlsaXRpZXMgdGhhdCBzaG91bGQgb25seSBiZSBjYWxsZWRcbiAqIGJ5IFNveS1nZW5lcmF0ZWQgSlMgY29kZS4gUGxlYXNlIGRvIG5vdCB1c2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IGZyb21cbiAqIHlvdXIgaGFuZC13cml0ZW4gY29kZS4gVGhlaXIgbmFtZXMgYWxsIHN0YXJ0IHdpdGggJyQkJy5cbiAqXG4gKi9cblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU3RyaW5nQnVpbGRlciAoY29tcGF0aWJsZSB3aXRoIHRoZSAnc3RyaW5nYnVpbGRlcicgY29kZSBzdHlsZSkuXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIHNveSA9IHt9O1xuICBzb3kuYXNzZXJ0cyA9IHt9O1xuICBzb3kuZXNjID0ge307XG4gIHZhciBzb3lkYXRhID0ge307XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgY2xhc3MgdG8gZmFjaWxpdGF0ZSBtdWNoIGZhc3RlciBzdHJpbmcgY29uY2F0ZW5hdGlvbiBpbiBJRSxcbiAgICogdXNpbmcgQXJyYXkuam9pbigpIHJhdGhlciB0aGFuIHRoZSAnKycgb3BlcmF0b3IuIEZvciBvdGhlciBicm93c2Vyc1xuICAgKiB3ZSBzaW1wbHkgdXNlIHRoZSAnKycgb3BlcmF0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YXJfYXJncyBJbml0aWFsIGl0ZW1zIHRvIGFwcGVuZCxcbiAgICogICAgIGUuZy4sIG5ldyBzb3kuU3RyaW5nQnVpbGRlcignZm9vJywgJ2JhcicpLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIHNveS5TdHJpbmdCdWlsZGVyID0gZ29vZy5zdHJpbmcuU3RyaW5nQnVmZmVyO1xuXG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gc295ZGF0YTogRGVmaW5lcyB0eXBlZCBzdHJpbmdzLCBlLmcuIGFuIEhUTUwgc3RyaW5nIHtAY29kZSBcImE8Yj5jXCJ9IGlzXG4gIC8vIHNlbWFudGljYWxseSBkaXN0aW5jdCBmcm9tIHRoZSBwbGFpbiB0ZXh0IHN0cmluZyB7QGNvZGUgXCJhPGI+Y1wifSBhbmQgc21hcnRcbiAgLy8gdGVtcGxhdGVzIGNhbiB0YWtlIHRoYXQgZGlzdGluY3Rpb24gaW50byBhY2NvdW50LlxuXG4gIC8qKlxuICAgKiBBIHR5cGUgb2YgdGV4dHVhbCBjb250ZW50LlxuICAgKlxuICAgKiBUaGlzIGlzIGFuIGVudW0gb2YgdHlwZSBPYmplY3Qgc28gdGhhdCB0aGVzZSB2YWx1ZXMgYXJlIHVuZm9yZ2VhYmxlLlxuICAgKlxuICAgKiBAZW51bSB7IU9iamVjdH1cbiAgICovXG4gIHNveWRhdGEuU2FuaXRpemVkQ29udGVudEtpbmQgPSBnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnRLaW5kO1xuXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGEgZ2l2ZW4gdmFsdWUgaXMgb2YgYSBnaXZlbiBjb250ZW50IGtpbmQuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGV4YW1pbmVkLlxuICAgKiBAcGFyYW0ge3NveWRhdGEuU2FuaXRpemVkQ29udGVudEtpbmR9IGNvbnRlbnRLaW5kIFRoZSBkZXNpcmVkIGNvbnRlbnRcbiAgICogICAgIGtpbmQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIG9mIHRoZSBnaXZlbiBraW5kLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc295ZGF0YS5pc0NvbnRlbnRLaW5kID0gZnVuY3Rpb24odmFsdWUsIGNvbnRlbnRLaW5kKSB7XG4gICAgLy8gVE9ETyh1c2VyKTogVGhpcyBmdW5jdGlvbiBzaG91bGQgcmVhbGx5IGluY2x1ZGUgdGhlIGFzc2VydCBvblxuICAgIC8vIHZhbHVlLmNvbnN0cnVjdG9yIHRoYXQgaXMgY3VycmVudGx5IHNwcmlua2xlZCBhdCBtb3N0IG9mIHRoZSBjYWxsIHNpdGVzLlxuICAgIC8vIFVuZm9ydHVuYXRlbHksIHRoYXQgd291bGQgcmVxdWlyZSBhIChkZWJ1Zy1tb2RlLW9ubHkpIHN3aXRjaCBzdGF0ZW1lbnQuXG4gICAgLy8gVE9ETyh1c2VyKTogUGVyaGFwcyB3ZSBzaG91bGQgZ2V0IHJpZCBvZiB0aGUgY29udGVudEtpbmQgcHJvcGVydHlcbiAgICAvLyBhbHRvZ2V0aGVyIGFuZCBvbmx5IGF0IHRoZSBjb25zdHJ1Y3Rvci5cbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5jb250ZW50S2luZCA9PT0gY29udGVudEtpbmQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnRlbnQgb2YgdHlwZSB7QGxpbmsgc295ZGF0YS5TYW5pdGl6ZWRDb250ZW50S2luZC5VUkl9LlxuICAgKlxuICAgKiBUaGUgY29udGVudCBpcyBhIFVSSSBjaHVuayB0aGF0IHRoZSBjYWxsZXIga25vd3MgaXMgc2FmZSB0byBlbWl0IGluIGFcbiAgICogdGVtcGxhdGUuIFRoZSBjb250ZW50IGRpcmVjdGlvbiBpcyBMVFIuXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyB7Z29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50fVxuICAgKi9cbiAgc295ZGF0YS5TYW5pdGl6ZWRVcmkgPSBmdW5jdGlvbigpIHtcbiAgICBnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnQuY2FsbCh0aGlzKTsgIC8vIFRocm93cyBhbiBleGNlcHRpb24uXG4gIH07XG4gIGdvb2cuaW5oZXJpdHMoc295ZGF0YS5TYW5pdGl6ZWRVcmksIGdvb2cuc295LmRhdGEuU2FuaXRpemVkQ29udGVudCk7XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBzb3lkYXRhLlNhbml0aXplZFVyaS5wcm90b3R5cGUuY29udGVudEtpbmQgPSBzb3lkYXRhLlNhbml0aXplZENvbnRlbnRLaW5kLlVSSTtcblxuICAvKiogQG92ZXJyaWRlICovXG4gIHNveWRhdGEuU2FuaXRpemVkVXJpLnByb3RvdHlwZS5jb250ZW50RGlyID0gZ29vZy5pMThuLmJpZGkuRGlyLkxUUjtcblxuICAvKipcbiAgICogVW5zYW5pdGl6ZWQgcGxhaW4gdGV4dCBzdHJpbmcuXG4gICAqXG4gICAqIFdoaWxlIGFsbCBzdHJpbmdzIGFyZSBlZmZlY3RpdmVseSBzYWZlIHRvIHVzZSBhcyBhIHBsYWluIHRleHQsIHRoZXJlIGFyZSBub1xuICAgKiBndWFyYW50ZWVzIGFib3V0IHNhZmV0eSBpbiBhbnkgb3RoZXIgY29udGV4dCBzdWNoIGFzIEhUTUwuIFRoaXMgaXNcbiAgICogc29tZXRpbWVzIHVzZWQgdG8gbWFyayB0aGF0IHNob3VsZCBuZXZlciBiZSB1c2VkIHVuZXNjYXBlZC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBjb250ZW50IFBsYWluIHRleHQgd2l0aCBubyBndWFyYW50ZWVzLlxuICAgKiBAcGFyYW0gez9nb29nLmkxOG4uYmlkaS5EaXI9fSBvcHRfY29udGVudERpciBUaGUgY29udGVudCBkaXJlY3Rpb247IG51bGwgaWZcbiAgICogICAgIHVua25vd24gYW5kIHRodXMgdG8gYmUgZXN0aW1hdGVkIHdoZW4gbmVjZXNzYXJ5LiBEZWZhdWx0OiBudWxsLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMge2dvb2cuc295LmRhdGEuVW5zYW5pdGl6ZWRUZXh0fVxuICAgKi9cbiAgc295ZGF0YS5VbnNhbml0aXplZFRleHQgPSBmdW5jdGlvbihjb250ZW50LCBvcHRfY29udGVudERpcikge1xuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICB0aGlzLmNvbnRlbnQgPSBTdHJpbmcoY29udGVudCk7XG4gICAgdGhpcy5jb250ZW50RGlyID0gb3B0X2NvbnRlbnREaXIgIT0gbnVsbCA/IG9wdF9jb250ZW50RGlyIDogbnVsbDtcbiAgfTtcbiAgZ29vZy5pbmhlcml0cyhzb3lkYXRhLlVuc2FuaXRpemVkVGV4dCwgZ29vZy5zb3kuZGF0YS5VbnNhbml0aXplZFRleHQpO1xuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgc295ZGF0YS5VbnNhbml0aXplZFRleHQucHJvdG90eXBlLmNvbnRlbnRLaW5kID1cbiAgICAgIHNveWRhdGEuU2FuaXRpemVkQ29udGVudEtpbmQuVEVYVDtcblxuXG4gIC8qKlxuICAgKiBFbXB0eSBzdHJpbmcsIHVzZWQgYXMgYSB0eXBlIGluIFNveSB0ZW1wbGF0ZXMuXG4gICAqIEBlbnVtIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzb3lkYXRhLiQkRU1QVFlfU1RSSU5HXyA9IHtcbiAgICBWQUxVRTogJydcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmb3IgU2FuaXRpemVkQ29udGVudCB0eXBlcy5cbiAgICpcbiAgICogVGhpcyBpcyBhIGhhY2sgc28gdGhhdCB0aGUgc295ZGF0YS5WRVJZX1VOU0FGRS5vcmRhaW5TYW5pdGl6ZWQqIGNhblxuICAgKiBpbnN0YW50aWF0ZSBTYW5pdGl6ZWQqIGNsYXNzZXMsIHdpdGhvdXQgbWFraW5nIHRoZSBTYW5pdGl6ZWQqIGNvbnN0cnVjdG9yc1xuICAgKiBwdWJsaWNseSB1c2FibGUuIFJlcXVpcmluZyBhbGwgY29uc3RydWN0aW9uIHRvIHVzZSB0aGUgVkVSWV9VTlNBRkUgbmFtZXNcbiAgICogaGVscHMgY2FsbGVycyBhbmQgdGhlaXIgcmV2aWV3ZXJzIGVhc2lseSB0ZWxsIHRoYXQgY3JlYXRpbmcgU2FuaXRpemVkQ29udGVudFxuICAgKiBpcyBub3QgYWx3YXlzIHNhZmUgYW5kIGNhbGxzIGZvciBjYXJlZnVsIHJldmlldy5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihuZXc6IFQpfSBjdG9yIEEgY29uc3RydWN0b3IuXG4gICAqIEByZXR1cm4geyFmdW5jdGlvbigqLCA/Z29vZy5pMThuLmJpZGkuRGlyPSk6IFR9IEEgZmFjdG9yeSB0aGF0IHRha2VzXG4gICAqICAgICBjb250ZW50IGFuZCBhbiBvcHRpb25hbCBjb250ZW50IGRpcmVjdGlvbiBhbmQgcmV0dXJucyBhIG5ldyBpbnN0YW5jZS4gSWZcbiAgICogICAgIHRoZSBjb250ZW50IGRpcmVjdGlvbiBpcyB1bmRlZmluZWQsIGN0b3IucHJvdG90eXBlLmNvbnRlbnREaXIgaXMgdXNlZC5cbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNveWRhdGEuJCRtYWtlU2FuaXRpemVkQ29udGVudEZhY3RvcnlfID0gZnVuY3Rpb24oY3Rvcikge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge2dvb2cuc295LmRhdGEuU2FuaXRpemVkQ29udGVudH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbnN0YW50aWFibGVDdG9yKGNvbnRlbnQpIHtcbiAgICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgfVxuICAgIEluc3RhbnRpYWJsZUN0b3IucHJvdG90eXBlID0gY3Rvci5wcm90b3R5cGU7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGN0b3ItdHlwZSBTYW5pdGl6ZWRDb250ZW50IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBjb250ZW50IFRoZSBjb250ZW50IHRvIHB1dCBpbiB0aGUgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHs/Z29vZy5pMThuLmJpZGkuRGlyPX0gb3B0X2NvbnRlbnREaXIgVGhlIGNvbnRlbnQgZGlyZWN0aW9uLiBJZlxuICAgICAqICAgICB1bmRlZmluZWQsIGN0b3IucHJvdG90eXBlLmNvbnRlbnREaXIgaXMgdXNlZC5cbiAgICAgKiBAcmV0dXJuIHshZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50fSBUaGUgbmV3IGluc3RhbmNlLiBJdCBpcyBhY3R1YWxseVxuICAgICAqICAgICBvZiB0eXBlIFQgYWJvdmUgKGN0b3IncyB0eXBlLCBhIGRlc2NlbmRhbnQgb2YgU2FuaXRpemVkQ29udGVudCksIGJ1dFxuICAgICAqICAgICB0aGVyZSBpcyBubyB3YXkgdG8gZXhwcmVzcyB0aGF0IGhlcmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FuaXRpemVkQ29udGVudEZhY3RvcnkoY29udGVudCwgb3B0X2NvbnRlbnREaXIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgSW5zdGFudGlhYmxlQ3RvcihTdHJpbmcoY29udGVudCkpO1xuICAgICAgaWYgKG9wdF9jb250ZW50RGlyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LmNvbnRlbnREaXIgPSBvcHRfY29udGVudERpcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBzYW5pdGl6ZWRDb250ZW50RmFjdG9yeTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmb3IgU2FuaXRpemVkQ29udGVudCB0eXBlcyB0aGF0IHNob3VsZCBhbHdheXMgaGF2ZSB0aGVpclxuICAgKiBkZWZhdWx0IGRpcmVjdGlvbmFsaXR5LlxuICAgKlxuICAgKiBUaGlzIGlzIGEgaGFjayBzbyB0aGF0IHRoZSBzb3lkYXRhLlZFUllfVU5TQUZFLm9yZGFpblNhbml0aXplZCogY2FuXG4gICAqIGluc3RhbnRpYXRlIFNhbml0aXplZCogY2xhc3Nlcywgd2l0aG91dCBtYWtpbmcgdGhlIFNhbml0aXplZCogY29uc3RydWN0b3JzXG4gICAqIHB1YmxpY2x5IHVzYWJsZS4gUmVxdWlyaW5nIGFsbCBjb25zdHJ1Y3Rpb24gdG8gdXNlIHRoZSBWRVJZX1VOU0FGRSBuYW1lc1xuICAgKiBoZWxwcyBjYWxsZXJzIGFuZCB0aGVpciByZXZpZXdlcnMgZWFzaWx5IHRlbGwgdGhhdCBjcmVhdGluZyBTYW5pdGl6ZWRDb250ZW50XG4gICAqIGlzIG5vdCBhbHdheXMgc2FmZSBhbmQgY2FsbHMgZm9yIGNhcmVmdWwgcmV2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzogVCwgc3RyaW5nKX0gY3RvciBBIGNvbnN0cnVjdG9yLlxuICAgKiBAcmV0dXJuIHshZnVuY3Rpb24oKik6IFR9IEEgZmFjdG9yeSB0aGF0IHRha2VzIGNvbnRlbnQgYW5kIHJldHVybnMgYSBuZXdcbiAgICogICAgIGluc3RhbmNlICh3aXRoIGRlZmF1bHQgZGlyZWN0aW9uYWxpdHksIGkuZS4gY3Rvci5wcm90b3R5cGUuY29udGVudERpcikuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzb3lkYXRhLiQkbWFrZVNhbml0aXplZENvbnRlbnRGYWN0b3J5V2l0aERlZmF1bHREaXJPbmx5XyA9IGZ1bmN0aW9uKGN0b3IpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIHtnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5zdGFudGlhYmxlQ3Rvcihjb250ZW50KSB7XG4gICAgICAvKiogQG92ZXJyaWRlICovXG4gICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIH1cbiAgICBJbnN0YW50aWFibGVDdG9yLnByb3RvdHlwZSA9IGN0b3IucHJvdG90eXBlO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjdG9yLXR5cGUgU2FuaXRpemVkQ29udGVudCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gY29udGVudCBUaGUgY29udGVudCB0byBwdXQgaW4gdGhlIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm4geyFnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnR9IFRoZSBuZXcgaW5zdGFuY2UuIEl0IGlzIGFjdHVhbGx5XG4gICAgICogICAgIG9mIHR5cGUgVCBhYm92ZSAoY3RvcidzIHR5cGUsIGEgZGVzY2VuZGFudCBvZiBTYW5pdGl6ZWRDb250ZW50KSwgYnV0XG4gICAgICogICAgIHRoZXJlIGlzIG5vIHdheSB0byBleHByZXNzIHRoYXQgaGVyZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW5pdGl6ZWRDb250ZW50RmFjdG9yeShjb250ZW50KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IEluc3RhbnRpYWJsZUN0b3IoU3RyaW5nKGNvbnRlbnQpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBzYW5pdGl6ZWRDb250ZW50RmFjdG9yeTtcbiAgfTtcblxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFNhbml0aXplZCBjb250ZW50IG9yZGFpbmVycy4gUGxlYXNlIHVzZSB0aGVzZSB3aXRoIGV4dHJlbWUgY2F1dGlvbiAod2l0aCB0aGVcbiAgLy8gZXhjZXB0aW9uIG9mIG1hcmtVbnNhbml0aXplZFRleHQpLiBBIGdvb2QgcmVjb21tZW5kYXRpb24gaXMgdG8gbGltaXQgdXNhZ2VcbiAgLy8gb2YgdGhlc2UgdG8ganVzdCBhIGhhbmRmdWwgb2YgZmlsZXMgaW4geW91ciBzb3VyY2UgdHJlZSB3aGVyZSB1c2FnZXMgY2FuIGJlXG4gIC8vIGNhcmVmdWxseSBhdWRpdGVkLlxuXG5cbiAgLyoqXG4gICAqIFByb3RlY3RzIGEgc3RyaW5nIGZyb20gYmVpbmcgdXNlZCBpbiBhbiBub0F1dG9lc2NhcGVkIGNvbnRleHQuXG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZnVsIGZvciBjb250ZW50IHdoZXJlIHRoZXJlIGlzIHNpZ25pZmljYW50IHJpc2sgb2YgYWNjaWRlbnRhbFxuICAgKiB1bmVzY2FwZWQgdXNhZ2UgaW4gYSBTb3kgdGVtcGxhdGUuIEEgZ3JlYXQgY2FzZSBpcyBmb3IgdXNlci1jb250cm9sbGVkXG4gICAqIGRhdGEgdGhhdCBoYXMgaGlzdG9yaWNhbGx5IGJlZW4gYSBzb3VyY2Ugb2YgdnVsZXJuYWJpbGl0aWVzLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGNvbnRlbnQgVGV4dCB0byBwcm90ZWN0LlxuICAgKiBAcGFyYW0gez9nb29nLmkxOG4uYmlkaS5EaXI9fSBvcHRfY29udGVudERpciBUaGUgY29udGVudCBkaXJlY3Rpb247IG51bGwgaWZcbiAgICogICAgIHVua25vd24gYW5kIHRodXMgdG8gYmUgZXN0aW1hdGVkIHdoZW4gbmVjZXNzYXJ5LiBEZWZhdWx0OiBudWxsLlxuICAgKiBAcmV0dXJuIHshc295ZGF0YS5VbnNhbml0aXplZFRleHR9IEEgd3JhcHBlciB0aGF0IGlzIHJlamVjdGVkIGJ5IHRoZVxuICAgKiAgICAgU295IG5vQXV0b2VzY2FwZSBwcmludCBkaXJlY3RpdmUuXG4gICAqL1xuICBzb3lkYXRhLm1hcmtVbnNhbml0aXplZFRleHQgPSBmdW5jdGlvbihjb250ZW50LCBvcHRfY29udGVudERpcikge1xuICAgIHJldHVybiBuZXcgc295ZGF0YS5VbnNhbml0aXplZFRleHQoY29udGVudCwgb3B0X2NvbnRlbnREaXIpO1xuICB9O1xuXG4gIHNveWRhdGEuVkVSWV9VTlNBRkUgPSB7fTtcblxuXG4gIC8qKlxuICAqIFRha2VzIGEgbGVhcCBvZiBmYWl0aCB0aGF0IHRoZSBwcm92aWRlZCBjb250ZW50IGlzIFwic2FmZVwiIHRvIHVzZSBhcyBhIFVSSVxuICAqIGluIGEgU295IHRlbXBsYXRlLlxuICAqXG4gICogVGhpcyBjcmVhdGVzIGEgU295IFNhbml0aXplZENvbnRlbnQgb2JqZWN0IHdoaWNoIGluZGljYXRlcyB0byBTb3kgdGhlcmUgaXNcbiAgKiBubyBuZWVkIHRvIGVzY2FwZSBpdCB3aGVuIHByaW50ZWQgYXMgYSBVUkkgKGUuZy4gaW4gYW4gaHJlZiBvciBzcmNcbiAgKiBhdHRyaWJ1dGUpLCBzdWNoIGFzIGlmIGl0J3MgYWxyZWFkeSBiZWVuIGVuY29kZWQgb3IgIGlmIGl0J3MgYSBKYXZhc2NyaXB0OlxuICAqIFVSSS5cbiAgKlxuICAqIEBwYXJhbSB7Kn0gY29udGVudCBBIGNodW5rIG9mIFVSSSB0aGF0IHRoZSBjYWxsZXIga25vd3MgaXMgc2FmZSB0b1xuICAqICAgICBlbWl0IGluIGEgdGVtcGxhdGUuXG4gICogQHJldHVybiB7IXNveWRhdGEuU2FuaXRpemVkVXJpfSBTYW5pdGl6ZWQgY29udGVudCB3cmFwcGVyIHRoYXQgaW5kaWNhdGVzIHRvXG4gICogICAgIFNveSBub3QgdG8gZXNjYXBlIG9yIGZpbHRlciB3aGVuIHByaW50ZWQgaW4gVVJJIGNvbnRleHQuXG4gICovXG4gIHNveWRhdGEuVkVSWV9VTlNBRkUub3JkYWluU2FuaXRpemVkVXJpID1cbiAgICAgIHNveWRhdGEuJCRtYWtlU2FuaXRpemVkQ29udGVudEZhY3RvcnlXaXRoRGVmYXVsdERpck9ubHlfKFxuICAgICAgICAgIHNveWRhdGEuU2FuaXRpemVkVXJpKTtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBCZWxvdyBhcmUgcHJpdmF0ZSB1dGlsaXRpZXMgdG8gYmUgdXNlZCBieSBTb3ktZ2VuZXJhdGVkIGNvZGUgb25seS5cblxuICAvKipcbiAgICogQnVpbGRzIGFuIGF1Z21lbnRlZCBtYXAuIFRoZSByZXR1cm5lZCBtYXAgd2lsbCBjb250YWluIG1hcHBpbmdzIGZyb20gYm90aFxuICAgKiB0aGUgYmFzZSBtYXAgYW5kIHRoZSBhZGRpdGlvbmFsIG1hcC4gSWYgdGhlIHNhbWUga2V5IGFwcGVhcnMgaW4gYm90aCwgdGhlblxuICAgKiB0aGUgdmFsdWUgZnJvbSB0aGUgYWRkaXRpb25hbCBtYXAgd2lsbCBiZSB2aXNpYmxlLCB3aGlsZSB0aGUgdmFsdWUgZnJvbSB0aGVcbiAgICogYmFzZSBtYXAgd2lsbCBiZSBoaWRkZW4uIFRoZSBiYXNlIG1hcCB3aWxsIGJlIHVzZWQsIGJ1dCBub3QgbW9kaWZpZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gYmFzZU1hcCBUaGUgb3JpZ2luYWwgbWFwIHRvIGF1Z21lbnQuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gYWRkaXRpb25hbE1hcCBBIG1hcCBjb250YWluaW5nIHRoZSBhZGRpdGlvbmFsIG1hcHBpbmdzLlxuICAgKiBAcmV0dXJuIHshT2JqZWN0fSBBbiBhdWdtZW50ZWQgbWFwIGNvbnRhaW5pbmcgYm90aCB0aGUgb3JpZ2luYWwgYW5kXG4gICAqICAgICBhZGRpdGlvbmFsIG1hcHBpbmdzLlxuICAgKi9cbiAgc295LiQkYXVnbWVudE1hcCA9IGZ1bmN0aW9uKGJhc2VNYXAsIGFkZGl0aW9uYWxNYXApIHtcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBtYXAgd2hvc2UgJ19fcHJvdG9fXycgZmllbGQgaXMgc2V0IHRvIGJhc2VNYXAuXG4gICAgLyoqIEBjb25zdHJ1Y3RvciAqL1xuICAgIGZ1bmN0aW9uIFRlbXBDdG9yKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBiYXNlTWFwO1xuICAgIHZhciBhdWdtZW50ZWRNYXAgPSBuZXcgVGVtcEN0b3IoKTtcblxuICAgIC8vIEFkZCB0aGUgYWRkaXRpb25hbCBtYXBwaW5ncyB0byB0aGUgbmV3IG1hcC5cbiAgICBmb3IgKHZhciBrZXkgaW4gYWRkaXRpb25hbE1hcCkge1xuICAgICAgYXVnbWVudGVkTWFwW2tleV0gPSBhZGRpdGlvbmFsTWFwW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGF1Z21lbnRlZE1hcDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBDaGVja3MgdGhhdCB0aGUgZ2l2ZW4gbWFwIGtleSBpcyBhIHN0cmluZy5cbiAgICogQHBhcmFtIHsqfSBrZXkgS2V5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBnaXZlbiBrZXkuXG4gICAqL1xuICBzb3kuJCRjaGVja01hcEtleSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIC8vIFRPRE86IFN1cHBvcnQgbWFwIGxpdGVyYWwgd2l0aCBub25zdHJpbmcga2V5LlxuICAgIGlmICgodHlwZW9mIGtleSkgIT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICdNYXAgbGl0ZXJhbFxcJ3Mga2V5IGV4cHJlc3Npb24gbXVzdCBldmFsdWF0ZSB0byBzdHJpbmcnICtcbiAgICAgICAgICAnIChlbmNvdW50ZXJlZCB0eXBlIFwiJyArICh0eXBlb2Yga2V5KSArICdcIikuJyk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH07XG5cblxuICAvKipcbiAgICogR2V0cyB0aGUga2V5cyBpbiBhIG1hcCBhcyBhbiBhcnJheS4gVGhlcmUgYXJlIG5vIGd1YXJhbnRlZXMgb24gdGhlIG9yZGVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gZ2V0IHRoZSBrZXlzIG9mLlxuICAgKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPn0gVGhlIGFycmF5IG9mIGtleXMgaW4gdGhlIGdpdmVuIG1hcC5cbiAgICovXG4gIHNveS4kJGdldE1hcEtleXMgPSBmdW5jdGlvbihtYXApIHtcbiAgICB2YXIgbWFwS2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBtYXApIHtcbiAgICAgIG1hcEtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwS2V5cztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcmd1bWVudCBpZiBpdCBpcyBub3QgbnVsbC5cbiAgICpcbiAgICogQHBhcmFtIHtUfSB2YWwgVGhlIHZhbHVlIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge1R9IHZhbCBpZiBpcyBpc24ndCBudWxsXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuICBzb3kuJCRjaGVja05vdE51bGwgPSBmdW5jdGlvbih2YWwpIHtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIHRocm93IEVycm9yKCd1bmV4cGVjdGVkIG51bGwgdmFsdWUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBHZXRzIGEgY29uc2lzdGVudCB1bmlxdWUgaWQgZm9yIHRoZSBnaXZlbiBkZWxlZ2F0ZSB0ZW1wbGF0ZSBuYW1lLiBUd28gY2FsbHNcbiAgICogdG8gdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZSBpZCBpZiBhbmQgb25seSBpZiB0aGUgaW5wdXQgbmFtZXMgYXJlXG4gICAqIHRoZSBzYW1lLlxuICAgKlxuICAgKiA8cD4gSW1wb3J0YW50OiBUaGlzIGZ1bmN0aW9uIG11c3QgYWx3YXlzIGJlIGNhbGxlZCB3aXRoIGEgc3RyaW5nIGNvbnN0YW50LlxuICAgKlxuICAgKiA8cD4gSWYgQ2xvc3VyZSBDb21waWxlciBpcyBub3QgYmVpbmcgdXNlZCwgdGhlbiB0aGlzIGlzIGp1c3QgdGhpcyBpZGVudGl0eVxuICAgKiBmdW5jdGlvbi4gSWYgQ2xvc3VyZSBDb21waWxlciBpcyBiZWluZyB1c2VkLCB0aGVuIGVhY2ggY2FsbCB0byB0aGlzIGZ1bmN0aW9uXG4gICAqIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBhIHNob3J0IHN0cmluZyBjb25zdGFudCwgd2hpY2ggd2lsbCBiZSBjb25zaXN0ZW50IHBlclxuICAgKiBpbnB1dCBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGVsVGVtcGxhdGVOYW1lIFRoZSBkZWxlZ2F0ZSB0ZW1wbGF0ZSBuYW1lIGZvciB3aGljaCB0byBnZXQgYVxuICAgKiAgICAgY29uc2lzdGVudCB1bmlxdWUgaWQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQSB1bmlxdWUgaWQgdGhhdCBpcyBjb25zaXN0ZW50IHBlciBpbnB1dCBuYW1lLlxuICAgKlxuICAgKiBAY29uc2lzdGVudElkR2VuZXJhdG9yXG4gICAqL1xuICBzb3kuJCRnZXREZWxUZW1wbGF0ZUlkID0gZnVuY3Rpb24oZGVsVGVtcGxhdGVOYW1lKSB7XG4gICAgcmV0dXJuIGRlbFRlbXBsYXRlTmFtZTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBNYXAgZnJvbSByZWdpc3RlcmVkIGRlbGVnYXRlIHRlbXBsYXRlIGtleSB0byB0aGUgcHJpb3JpdHkgb2YgdGhlXG4gICAqIGltcGxlbWVudGF0aW9uLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc295LiQkREVMRUdBVEVfUkVHSVNUUllfUFJJT1JJVElFU18gPSB7fTtcblxuICAvKipcbiAgICogTWFwIGZyb20gcmVnaXN0ZXJlZCBkZWxlZ2F0ZSB0ZW1wbGF0ZSBrZXkgdG8gdGhlIGltcGxlbWVudGF0aW9uIGZ1bmN0aW9uLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc295LiQkREVMRUdBVEVfUkVHSVNUUllfRlVOQ1RJT05TXyA9IHt9O1xuXG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGRlbGVnYXRlIGltcGxlbWVudGF0aW9uLiBJZiB0aGUgc2FtZSBkZWxlZ2F0ZSB0ZW1wbGF0ZSBrZXkgKGlkXG4gICAqIGFuZCB2YXJpYW50KSBoYXMgYmVlbiByZWdpc3RlcmVkIHByZXZpb3VzbHksIHRoZW4gcHJpb3JpdHkgdmFsdWVzIGFyZVxuICAgKiBjb21wYXJlZCBhbmQgb25seSB0aGUgaGlnaGVyIHByaW9yaXR5IGltcGxlbWVudGF0aW9uIGlzIHN0b3JlZCAoaWZcbiAgICogcHJpb3JpdGllcyBhcmUgZXF1YWwsIGFuIGVycm9yIGlzIHRocm93bikuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkZWxUZW1wbGF0ZUlkIFRoZSBkZWxlZ2F0ZSB0ZW1wbGF0ZSBpZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRlbFRlbXBsYXRlVmFyaWFudCBUaGUgZGVsZWdhdGUgdGVtcGxhdGUgdmFyaWFudCAoY2FuIGJlXG4gICAqICAgICBlbXB0eSBzdHJpbmcpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsUHJpb3JpdHkgVGhlIGltcGxlbWVudGF0aW9uJ3MgcHJpb3JpdHkgdmFsdWUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRlbEZuIFRoZSBpbXBsZW1lbnRhdGlvbiBmdW5jdGlvbi5cbiAgICovXG4gIHNveS4kJHJlZ2lzdGVyRGVsZWdhdGVGbiA9IGZ1bmN0aW9uKFxuICAgICAgZGVsVGVtcGxhdGVJZCwgZGVsVGVtcGxhdGVWYXJpYW50LCBkZWxQcmlvcml0eSwgZGVsRm4pIHtcblxuICAgIHZhciBtYXBLZXkgPSAna2V5XycgKyBkZWxUZW1wbGF0ZUlkICsgJzonICsgZGVsVGVtcGxhdGVWYXJpYW50O1xuICAgIHZhciBjdXJyUHJpb3JpdHkgPSBzb3kuJCRERUxFR0FURV9SRUdJU1RSWV9QUklPUklUSUVTX1ttYXBLZXldO1xuICAgIGlmIChjdXJyUHJpb3JpdHkgPT09IHVuZGVmaW5lZCB8fCBkZWxQcmlvcml0eSA+IGN1cnJQcmlvcml0eSkge1xuICAgICAgLy8gUmVnaXN0ZXJpbmcgbmV3IG9yIGhpZ2hlci1wcmlvcml0eSBmdW5jdGlvbjogcmVwbGFjZSByZWdpc3RyeSBlbnRyeS5cbiAgICAgIHNveS4kJERFTEVHQVRFX1JFR0lTVFJZX1BSSU9SSVRJRVNfW21hcEtleV0gPSBkZWxQcmlvcml0eTtcbiAgICAgIHNveS4kJERFTEVHQVRFX1JFR0lTVFJZX0ZVTkNUSU9OU19bbWFwS2V5XSA9IGRlbEZuO1xuICAgIH0gZWxzZSBpZiAoZGVsUHJpb3JpdHkgPT0gY3VyclByaW9yaXR5KSB7XG4gICAgICAvLyBSZWdpc3RlcmluZyBzYW1lLXByaW9yaXR5IGZ1bmN0aW9uOiBlcnJvci5cbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICdFbmNvdW50ZXJlZCB0d28gYWN0aXZlIGRlbGVnYXRlcyB3aXRoIHRoZSBzYW1lIHByaW9yaXR5IChcIicgK1xuICAgICAgICAgICAgICBkZWxUZW1wbGF0ZUlkICsgJzonICsgZGVsVGVtcGxhdGVWYXJpYW50ICsgJ1wiKS4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVnaXN0ZXJpbmcgbG93ZXItcHJpb3JpdHkgZnVuY3Rpb246IGRvIG5vdGhpbmcuXG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgKGhpZ2hlc3QtcHJpb3JpdHkpIGltcGxlbWVudGF0aW9uIHRoYXQgaGFzIGJlZW4gcmVnaXN0ZXJlZCBmb3JcbiAgICogYSBnaXZlbiBkZWxlZ2F0ZSB0ZW1wbGF0ZSBrZXkgKGlkIGFuZCB2YXJpYW50KS4gSWYgbm8gaW1wbGVtZW50YXRpb24gaGFzXG4gICAqIGJlZW4gcmVnaXN0ZXJlZCBmb3IgdGhlIGtleSwgdGhlbiB0aGUgZmFsbGJhY2sgaXMgdGhlIHNhbWUgaWQgd2l0aCBlbXB0eVxuICAgKiB2YXJpYW50LiBJZiB0aGUgZmFsbGJhY2sgaXMgYWxzbyBub3QgcmVnaXN0ZXJlZCwgYW5kIGFsbG93c0VtcHR5RGVmYXVsdCBpc1xuICAgKiB0cnVlLCB0aGVuIHJldHVybnMgYW4gaW1wbGVtZW50YXRpb24gdGhhdCBpcyBlcXVpdmFsZW50IHRvIGFuIGVtcHR5IHRlbXBsYXRlXG4gICAqIChpLmUuIHJlbmRlcmVkIG91dHB1dCB3b3VsZCBiZSBlbXB0eSBzdHJpbmcpLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGVsVGVtcGxhdGVJZCBUaGUgZGVsZWdhdGUgdGVtcGxhdGUgaWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkZWxUZW1wbGF0ZVZhcmlhbnQgVGhlIGRlbGVnYXRlIHRlbXBsYXRlIHZhcmlhbnQgKGNhbiBiZVxuICAgKiAgICAgZW1wdHkgc3RyaW5nKS5cbiAgICogQHBhcmFtIHtib29sZWFufSBhbGxvd3NFbXB0eURlZmF1bHQgV2hldGhlciB0byBkZWZhdWx0IHRvIHRoZSBlbXB0eSB0ZW1wbGF0ZVxuICAgKiAgICAgZnVuY3Rpb24gaWYgdGhlcmUncyBubyBhY3RpdmUgaW1wbGVtZW50YXRpb24uXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgcmV0cmlldmVkIGltcGxlbWVudGF0aW9uIGZ1bmN0aW9uLlxuICAgKi9cbiAgc295LiQkZ2V0RGVsZWdhdGVGbiA9IGZ1bmN0aW9uKFxuICAgICAgZGVsVGVtcGxhdGVJZCwgZGVsVGVtcGxhdGVWYXJpYW50LCBhbGxvd3NFbXB0eURlZmF1bHQpIHtcblxuICAgIHZhciBkZWxGbiA9IHNveS4kJERFTEVHQVRFX1JFR0lTVFJZX0ZVTkNUSU9OU19bXG4gICAgICAgICdrZXlfJyArIGRlbFRlbXBsYXRlSWQgKyAnOicgKyBkZWxUZW1wbGF0ZVZhcmlhbnRdO1xuICAgIGlmICghIGRlbEZuICYmIGRlbFRlbXBsYXRlVmFyaWFudCAhPSAnJykge1xuICAgICAgLy8gRmFsbGJhY2sgdG8gZW1wdHkgdmFyaWFudC5cbiAgICAgIGRlbEZuID0gc295LiQkREVMRUdBVEVfUkVHSVNUUllfRlVOQ1RJT05TX1sna2V5XycgKyBkZWxUZW1wbGF0ZUlkICsgJzonXTtcbiAgICB9XG5cbiAgICBpZiAoZGVsRm4pIHtcbiAgICAgIHJldHVybiBkZWxGbjtcbiAgICB9IGVsc2UgaWYgKGFsbG93c0VtcHR5RGVmYXVsdCkge1xuICAgICAgcmV0dXJuIHNveS4kJEVNUFRZX1RFTVBMQVRFX0ZOXztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgJ0ZvdW5kIG5vIGFjdGl2ZSBpbXBsIGZvciBkZWxlZ2F0ZSBjYWxsIHRvIFwiJyArIGRlbFRlbXBsYXRlSWQgKyAnOicgK1xuICAgICAgICAgICAgICBkZWxUZW1wbGF0ZVZhcmlhbnQgKyAnXCIgKGFuZCBub3QgYWxsb3dlbXB0eWRlZmF1bHQ9XCJ0cnVlXCIpLicpO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBQcml2YXRlIGhlbHBlciBzb3kuJCRnZXREZWxlZ2F0ZUZuKCkuIFRoaXMgaXMgdGhlIGVtcHR5IHRlbXBsYXRlIGZ1bmN0aW9uXG4gICAqIHRoYXQgaXMgcmV0dXJuZWQgd2hlbmV2ZXIgdGhlcmUncyBubyBkZWxlZ2F0ZSBpbXBsZW1lbnRhdGlvbiBmb3VuZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCAqPj19IG9wdF9kYXRhXG4gICAqIEBwYXJhbSB7c295LlN0cmluZ0J1aWxkZXI9fSBvcHRfc2JcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCAqPj19IG9wdF9pakRhdGFcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc295LiQkRU1QVFlfVEVNUExBVEVfRk5fID0gZnVuY3Rpb24ob3B0X2RhdGEsIG9wdF9zYiwgb3B0X2lqRGF0YSkge1xuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBCYXNpYyBkaXJlY3RpdmVzL2Z1bmN0aW9ucy5cblxuXG4gIC8qKlxuICAgKiBUcnVuY2F0ZXMgYSBzdHJpbmcgdG8gYSBnaXZlbiBtYXggbGVuZ3RoIChpZiBpdCdzIGN1cnJlbnRseSBsb25nZXIpLFxuICAgKiBvcHRpb25hbGx5IGFkZGluZyBlbGxpcHNpcyBhdCB0aGUgZW5kLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHN0ciBUaGUgc3RyaW5nIHRvIHRydW5jYXRlLiBDYW4gYmUgb3RoZXIgdHlwZXMsIGJ1dCB0aGUgdmFsdWUgd2lsbFxuICAgKiAgICAgYmUgY29lcmNlZCB0byBhIHN0cmluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heExlbiBUaGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIHN0cmluZyBhZnRlciB0cnVuY2F0aW9uXG4gICAqICAgICAoaW5jbHVkaW5nIGVsbGlwc2lzLCBpZiBhcHBsaWNhYmxlKS5cbiAgICogQHBhcmFtIHtib29sZWFufSBkb0FkZEVsbGlwc2lzIFdoZXRoZXIgdG8gYWRkIGVsbGlwc2lzIGlmIHRoZSBzdHJpbmcgbmVlZHNcbiAgICogICAgIHRydW5jYXRpb24uXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZyBhZnRlciB0cnVuY2F0aW9uLlxuICAgKi9cbiAgc295LiQkdHJ1bmNhdGUgPSBmdW5jdGlvbihzdHIsIG1heExlbiwgZG9BZGRFbGxpcHNpcykge1xuXG4gICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgaWYgKHN0ci5sZW5ndGggPD0gbWF4TGVuKSB7XG4gICAgICByZXR1cm4gc3RyOyAgLy8gbm8gbmVlZCB0byB0cnVuY2F0ZVxuICAgIH1cblxuICAgIC8vIElmIGRvQWRkRWxsaXBzaXMsIGVpdGhlciByZWR1Y2UgbWF4TGVuIHRvIGNvbXBlbnNhdGUsIG9yIGVsc2UgaWYgbWF4TGVuIGlzXG4gICAgLy8gdG9vIHNtYWxsLCBqdXN0IHR1cm4gb2ZmIGRvQWRkRWxsaXBzaXMuXG4gICAgaWYgKGRvQWRkRWxsaXBzaXMpIHtcbiAgICAgIGlmIChtYXhMZW4gPiAzKSB7XG4gICAgICAgIG1heExlbiAtPSAzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9BZGRFbGxpcHNpcyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0cnVuY2F0aW5nIGF0IG1heExlbiBkb2Vzbid0IGN1dCB1cCBhIHVuaWNvZGUgc3Vycm9nYXRlIHBhaXIuXG4gICAgaWYgKHNveS4kJGlzSGlnaFN1cnJvZ2F0ZV8oc3RyLmNoYXJBdChtYXhMZW4gLSAxKSkgJiZcbiAgICAgICAgc295LiQkaXNMb3dTdXJyb2dhdGVfKHN0ci5jaGFyQXQobWF4TGVuKSkpIHtcbiAgICAgIG1heExlbiAtPSAxO1xuICAgIH1cblxuICAgIC8vIFRydW5jYXRlLlxuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgbWF4TGVuKTtcblxuICAgIC8vIEFkZCBlbGxpcHNpcy5cbiAgICBpZiAoZG9BZGRFbGxpcHNpcykge1xuICAgICAgc3RyICs9ICcuLi4nO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgaGVscGVyIGZvciAkJHRydW5jYXRlKCkgdG8gY2hlY2sgd2hldGhlciBhIGNoYXIgaXMgYSBoaWdoIHN1cnJvZ2F0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoIFRoZSBjaGFyIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBnaXZlbiBjaGFyIGlzIGEgdW5pY29kZSBoaWdoIHN1cnJvZ2F0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNveS4kJGlzSGlnaFN1cnJvZ2F0ZV8gPSBmdW5jdGlvbihjaCkge1xuICAgIHJldHVybiAweEQ4MDAgPD0gY2ggJiYgY2ggPD0gMHhEQkZGO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcml2YXRlIGhlbHBlciBmb3IgJCR0cnVuY2F0ZSgpIHRvIGNoZWNrIHdoZXRoZXIgYSBjaGFyIGlzIGEgbG93IHN1cnJvZ2F0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoIFRoZSBjaGFyIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBnaXZlbiBjaGFyIGlzIGEgdW5pY29kZSBsb3cgc3Vycm9nYXRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc295LiQkaXNMb3dTdXJyb2dhdGVfID0gZnVuY3Rpb24oY2gpIHtcbiAgICByZXR1cm4gMHhEQzAwIDw9IGNoICYmIGNoIDw9IDB4REZGRjtcbiAgfTtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBBc3NlcnRpb24gbWV0aG9kcyB1c2VkIGJ5IHJ1bnRpbWUuXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgdHlwZSBhc3NlcnRpb24gaXMgdHJ1ZSBpZiBnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgaXNcbiAgICogdHJ1ZS4gUmVwb3J0IGVycm9ycyBvbiBydW50aW1lIHR5cGVzIGlmIGdvb2cuREVCVUcgaXMgdHJ1ZS5cbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHBhcmFtIHtUfSB0eXBlQ2hlY2sgQW4gY29uZGl0aW9uIGZvciB0eXBlIGNoZWNrcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtTmFtZSBUaGUgU295IG5hbWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICogQHBhcmFtIHs/T2JqZWN0fSBwYXJhbSBUaGUgcmVzb2x2ZWQgSlMgb2JqZWN0IGZvciB0aGUgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGpzRG9jVHlwZVN0ciBKU0RvYyB0eXBlIHN0ciB0byBjYXN0IHRoZSB2YWx1ZSB0byBpZiB0aGVcbiAgICogICAgIHR5cGUgdGVzdCBzdWNjZWVkc1xuICAgKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSBpdGVtcyB0byBzdWJzdGl0dXRlIGludG8gdGhlIGZhaWx1cmUgbWVzc2FnZS5cbiAgICogQHJldHVybiB7VH0gVGhlIHZhbHVlIG9mIHRoZSBjb25kaXRpb24uXG4gICAqIEB0aHJvd3Mge2dvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvcn0gV2hlbiB0aGUgY29uZGl0aW9uIGV2YWx1YXRlcyB0byBmYWxzZS5cbiAgICovXG4gIHNveS5hc3NlcnRzLmFzc2VydFR5cGUgPSBmdW5jdGlvbih0eXBlQ2hlY2ssIHBhcmFtTmFtZSxcbiAgICAgIHBhcmFtLCBqc0RvY1R5cGVTdHIsIHZhcl9hcmdzKSB7XG4gICAgdmFyIG1zZyA9ICdleHBlY3RlZCBwYXJhbSAnICsgcGFyYW1OYW1lICsgJyBvZiB0eXBlICcgKyBqc0RvY1R5cGVTdHIgK1xuICAgICAgICAoZ29vZy5ERUJVRyA/ICgnLCBidXQgZ290ICcgKyBnb29nLmRlYnVnLnJ1bnRpbWVUeXBlKHBhcmFtKSkgOiAnJykgK1xuICAgICAgICAnLic7XG4gICAgcmV0dXJuIGdvb2cuYXNzZXJ0cy5hc3NlcnQodHlwZUNoZWNrLCBtc2csIHZhcl9hcmdzKTtcbiAgfTtcblxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEdlbmVyYXRlZCBjb2RlLlxuXG5cbiAgLy8gU1RBUlQgR0VORVJBVEVEIENPREUgRk9SIEVTQ0FQRVJTLlxuXG4gIC8qKlxuICAgKiBAdHlwZSB7ZnVuY3Rpb24gKCopIDogc3RyaW5nfVxuICAgKi9cbiAgc295LmVzYy4kJGVzY2FwZUh0bWxIZWxwZXIgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIGdvb2cuc3RyaW5nLmh0bWxFc2NhcGUoU3RyaW5nKHYpKTtcbiAgfTtcblxuICAvKipcbiAgICogQWxsb3dzIG9ubHkgZGF0YS1wcm90b2NvbCBpbWFnZSBVUkkncy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy4gTWF5IG5vdCBiZSBhIHN0cmluZywgYnV0IHRoZSB2YWx1ZVxuICAgKiAgICAgd2lsbCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHshc295ZGF0YS5TYW5pdGl6ZWRVcml9IEFuIGVzY2FwZWQgdmVyc2lvbiBvZiB2YWx1ZS5cbiAgICovXG4gIHNveS4kJGZpbHRlckltYWdlRGF0YVVyaSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gTk9URTogRXZlbiBpZiBpdCdzIGEgU2FuaXRpemVkVXJpLCB3ZSB3aWxsIHN0aWxsIGZpbHRlciBpdC5cbiAgICByZXR1cm4gc295ZGF0YS5WRVJZX1VOU0FGRS5vcmRhaW5TYW5pdGl6ZWRVcmkoXG4gICAgICAgIHNveS5lc2MuJCRmaWx0ZXJJbWFnZURhdGFVcmlIZWxwZXIodmFsdWUpKTtcbiAgfTtcblxuICAvKipcbiAgICogQSBwYXR0ZXJuIHRoYXQgdmV0cyB2YWx1ZXMgcHJvZHVjZWQgYnkgdGhlIG5hbWVkIGRpcmVjdGl2ZXMuXG4gICAqIEBwcml2YXRlIHshUmVnRXhwfVxuICAgKi9cbiAgc295LmVzYy4kJEZJTFRFUl9GT1JfRklMVEVSX0lNQUdFX0RBVEFfVVJJXyA9IC9eZGF0YTppbWFnZVxcLyg/OmJtcHxnaWZ8anBlP2d8cG5nfHRpZmZ8d2VicCk7YmFzZTY0LFthLXowLTkrXFwvXSs9KiQvaTtcblxuICAvKipcbiAgICogQSBoZWxwZXIgZm9yIHRoZSBTb3kgZGlyZWN0aXZlIHxmaWx0ZXJJbWFnZURhdGFVcmlcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBDYW4gYmUgb2YgYW55IHR5cGUgYnV0IHdpbGwgYmUgY29lcmNlZCB0byBhIHN0cmluZy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgZXNjYXBlZCB0ZXh0LlxuICAgKi9cbiAgc295LmVzYy4kJGZpbHRlckltYWdlRGF0YVVyaUhlbHBlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHN0ciA9IFN0cmluZyh2YWx1ZSk7XG4gICAgaWYgKCFzb3kuZXNjLiQkRklMVEVSX0ZPUl9GSUxURVJfSU1BR0VfREFUQV9VUklfLnRlc3Qoc3RyKSkge1xuICAgICAgZ29vZy5hc3NlcnRzLmZhaWwoJ0JhZCB2YWx1ZSBgJXNgIGZvciB8ZmlsdGVySW1hZ2VEYXRhVXJpJywgW3N0cl0pO1xuICAgICAgcmV0dXJuICdkYXRhOmltYWdlL2dpZjtiYXNlNjQselNveXonO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIC8vIEVORCBHRU5FUkFURUQgQ09ERVxuXG4gIGdvb2cubG9hZE1vZHVsZShmdW5jdGlvbigpIHtcbiAgICBnb29nLm1vZHVsZSgnc295Jyk7XG4gICAgcmV0dXJuIHNveTtcbiAgfSk7XG5cbiAgZ29vZy5sb2FkTW9kdWxlKGZ1bmN0aW9uKCkge1xuICAgIGdvb2cubW9kdWxlKCdzb3lkYXRhJyk7XG4gICAgcmV0dXJuIHNveWRhdGE7XG4gIH0pO1xuXG4gIGdvb2cubG9hZE1vZHVsZShmdW5jdGlvbigpIHtcbiAgICBnb29nLm1vZHVsZSgnc295LmFzc2VydHMnKTtcbiAgICByZXR1cm4gc295O1xuICB9KTtcbn0pKCk7XG5cbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cblxuZ29vZy5sb2FkTW9kdWxlKGZ1bmN0aW9uKCkge1xuICBnb29nLm1vZHVsZSgnaW5jcmVtZW50YWxkb20nKTtcbiAgcmV0dXJuIEluY3JlbWVudGFsRE9NO1xufSk7XG59KS5jYWxsKHdpbmRvdyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCAnbWV0YWwtc295LWJ1bmRsZSc7XG5pbXBvcnQgeyBjb3JlLCBvYmplY3QgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgeyBDb21wb25lbnRSZWdpc3RyeSB9IGZyb20gJ21ldGFsLWNvbXBvbmVudCc7XG5pbXBvcnQgSFRNTDJJbmNEb20gZnJvbSAnaHRtbDJpbmNkb20nO1xuaW1wb3J0IEluY3JlbWVudGFsRG9tUmVuZGVyZXIgZnJvbSAnbWV0YWwtaW5jcmVtZW50YWwtZG9tJztcbmltcG9ydCBTb3lBb3AgZnJvbSAnLi9Tb3lBb3AnO1xuXG4vLyBUaGUgaW5qZWN0ZWQgZGF0YSB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHNveSB0ZW1wbGF0ZXMuXG52YXIgaWpEYXRhID0ge307XG5cbmNsYXNzIFNveSBleHRlbmRzIEluY3JlbWVudGFsRG9tUmVuZGVyZXIge1xuXHQvKipcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG5cdGNvbnN0cnVjdG9yKGNvbXApIHtcblx0XHRzdXBlcihjb21wKTtcblx0XHR0aGlzLmFkZE1pc3NpbmdTdGF0ZUtleXNfKCk7XG5cdH1cblx0LyoqXG5cdCAqIEFkZHMgdGhlIHRlbXBsYXRlIHBhcmFtcyB0byB0aGUgY29tcG9uZW50J3Mgc3RhdGUsIGlmIHRoZXkgZG9uJ3QgZXhpc3QgeWV0LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRhZGRNaXNzaW5nU3RhdGVLZXlzXygpIHtcblx0XHR2YXIgZWxlbWVudFRlbXBsYXRlID0gdGhpcy5jb21wb25lbnRfLmNvbnN0cnVjdG9yLlRFTVBMQVRFO1xuXHRcdGlmICghY29yZS5pc0Z1bmN0aW9uKGVsZW1lbnRUZW1wbGF0ZSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRlbGVtZW50VGVtcGxhdGUgPSBTb3lBb3AuZ2V0T3JpZ2luYWxGbihlbGVtZW50VGVtcGxhdGUpO1xuXHRcdHRoaXMuc295UGFyYW1UeXBlc18gPSBlbGVtZW50VGVtcGxhdGUudHlwZXMgfHwge307XG5cblx0XHR2YXIga2V5cyA9IGVsZW1lbnRUZW1wbGF0ZS5wYXJhbXMgfHwgW107XG5cdFx0dmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50Xztcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICghY29tcG9uZW50LmdldFN0YXRlS2V5Q29uZmlnKGtleXNbaV0pICYmICFjb21wb25lbnRba2V5c1tpXV0pIHtcblx0XHRcdFx0Y29tcG9uZW50LmFkZFRvU3RhdGUoa2V5c1tpXSwge30sIGNvbXBvbmVudC5nZXRJbml0aWFsQ29uZmlnKClba2V5c1tpXV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgdGhlIGNvbXBvbmVudCdzIHN0YXRlIHRvIGFuIG9iamVjdCBzbyBpdCBjYW4gYmUgcGFzc2VkIGFzIGl0J3Ncblx0ICogdGVtcGxhdGUgY2FsbCdzIGRhdGEuIFRoZSBjb3B5aW5nIG5lZWRzIHRvIGJlIGRvbmUgYmVjYXVzZSwgaWYgdGhlIGNvbXBvbmVudFxuXHQgKiBpdHNlbGYgaXMgcGFzc2VkIGRpcmVjdGx5LCBzb21lIHByb2JsZW1zIG9jY3VyIHdoZW4gc295IHRyaWVzIHRvIG1lcmdlIGl0XG5cdCAqIHdpdGggb3RoZXIgZGF0YSwgZHVlIHRvIHByb3BlcnR5IGdldHRlcnMgYW5kIHNldHRlcnMuIFRoaXMgaXMgc2FmZXIuXG5cdCAqIEBwYXJhbSB7IUFycmF5PHN0cmluZz59IHBhcmFtcyBUaGUgcGFyYW1zIHVzZWQgYnkgdGhpcyB0ZW1wbGF0ZS5cblx0ICogQHJldHVybiB7IU9iamVjdH1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0YnVpbGRUZW1wbGF0ZURhdGFfKHBhcmFtcykge1xuXHRcdHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudF87XG5cdFx0dmFyIGRhdGEgPSBvYmplY3QubWl4aW4oe30sIGNvbXBvbmVudC5jb25maWcpO1xuXHRcdGNvbXBvbmVudC5nZXRTdGF0ZUtleXMoKS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0XHQvLyBHZXQgYWxsIHN0YXRlIHZhbHVlcyBleGNlcHQgXCJlbGVtZW50XCIsIHNpbmNlIGl0IGhlbHBzIHBlcmZvcm1hbmNlXG5cdFx0XHQvLyBhbmQgdGhlIGVsZW1lbnQgc2hvdWxkbid0IGJlIHJlZmVyZW5jZWQgaW5zaWRlIGEgc295IHRlbXBsYXRlIGFueXdheS5cblx0XHRcdGlmIChrZXkgPT09ICdlbGVtZW50Jykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciB2YWx1ZSA9IGNvbXBvbmVudFtrZXldO1xuXHRcdFx0aWYgKHRoaXMuaXNIdG1sUGFyYW1fKGtleSkpIHtcblx0XHRcdFx0dmFsdWUgPSBTb3kudG9JbmNEb20odmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0ZGF0YVtrZXldID0gdmFsdWU7XG5cdFx0fSk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICghZGF0YVtwYXJhbXNbaV1dICYmIGNvcmUuaXNGdW5jdGlvbihjb21wb25lbnRbcGFyYW1zW2ldXSkpIHtcblx0XHRcdFx0ZGF0YVtwYXJhbXNbaV1dID0gY29tcG9uZW50W3BhcmFtc1tpXV0uYmluZChjb21wb25lbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZGF0YTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSByZXF1ZXN0ZWQgdGVtcGxhdGUgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSB3cmFwcGVkIGluXG5cdCAqIGFub3RoZXIgdGhvdWdoLCBqdXN0IHRvIGRlZmVyIHRoZSByZXF1aXJlbWVudCBvZiB0aGUgdGVtcGxhdGUncyBtb2R1bGVcblx0ICogYmVpbmcgcmVhZHkgdW50aWwgdGhlIGZ1bmN0aW9uIGlzIGFjdHVhbGx5IGNhbGxlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzcGFjZSBUaGUgc295IHRlbXBsYXRlJ3MgbmFtZXNwYWNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVOYW1lIFRoZSBuYW1lIG9mIHRoZSB0ZW1wbGF0ZSBmdW5jdGlvbi5cblx0ICogQHJldHVybiB7IWZ1bmN0aW9uKCl9XG5cdCAqL1xuXHRzdGF0aWMgZ2V0VGVtcGxhdGUobmFtZXNwYWNlLCB0ZW1wbGF0ZU5hbWUpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24ob3B0X2RhdGEsIG9wdF9pZ25vcmVkLCBvcHRfaWpEYXRhKSB7XG5cdFx0XHRpZiAoIWdvb2cubG9hZGVkTW9kdWxlc19bbmFtZXNwYWNlXSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0J05vIHRlbXBsYXRlIHdpdGggbmFtZXNwYWNlIFwiJyArIG5hbWVzcGFjZSArICdcIiBoYXMgYmVlbiBsb2FkZWQgeWV0Lidcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBnb29nLmxvYWRlZE1vZHVsZXNfW25hbWVzcGFjZV1bdGVtcGxhdGVOYW1lXShvcHRfZGF0YSwgb3B0X2lnbm9yZWQsIG9wdF9pakRhdGEpO1xuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyBhbiBpbnRlcmNlcHRlZCBzb3kgdGVtcGxhdGUgY2FsbC4gSWYgdGhlIGNhbGwgaXMgZm9yIGEgY29tcG9uZW50J3Ncblx0ICogbWFpbiB0ZW1wbGF0ZSwgdGhlbiBpdCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggYSBjYWxsIHRoYXQgaW5jcmVtZW50YWwgZG9tXG5cdCAqIGNhbiB1c2UgZm9yIGJvdGggaGFuZGxpbmcgYW4gaW5zdGFuY2Ugb2YgdGhhdCBjb21wb25lbnQgYW5kIHJlbmRlcmluZyBpdC5cblx0ICogQHBhcmFtIHshZnVuY3Rpb24oKX0gb3JpZ2luYWxGbiBUaGUgb3JpZ2luYWwgdGVtcGxhdGUgZnVuY3Rpb24gdGhhdCB3YXNcblx0ICogICAgIGludGVyY2VwdGVkLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSB0aGUgdGVtcGxhdGUgd2FzIGNhbGxlZCB3aXRoLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzdGF0aWMgaGFuZGxlSW50ZXJjZXB0ZWRDYWxsXyhvcmlnaW5hbEZuLCBvcHRfZGF0YSkge1xuXHRcdHZhciBhcmdzID0gW29yaWdpbmFsRm4uY29tcG9uZW50Q3RvciwgbnVsbCwgW11dO1xuXHRcdHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKG9wdF9kYXRhIHx8IHt9KTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRhcmdzLnB1c2gobmFtZXNbaV0sIG9wdF9kYXRhW25hbWVzW2ldXSk7XG5cdFx0fVxuXHRcdEluY3JlbWVudGFsRE9NLmVsZW1lbnRWb2lkLmFwcGx5KG51bGwsIGFyZ3MpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gcGFyYW0gdHlwZSBpcyBodG1sLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRpc0h0bWxQYXJhbV8obmFtZSkge1xuXHRcdGlmICh0aGlzLmNvbXBvbmVudF8uZ2V0U3RhdGVLZXlDb25maWcobmFtZSkuaXNIdG1sKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0dmFyIHR5cGUgPSB0aGlzLnNveVBhcmFtVHlwZXNfW25hbWVdIHx8ICcnO1xuXHRcdHJldHVybiB0eXBlLnNwbGl0KCd8JykuaW5kZXhPZignaHRtbCcpICE9PSAtMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgdGhlIGdpdmVuIHRlbXBsYXRlcyB0byBiZSB1c2VkIGJ5IGBTb3lgIGZvciB0aGUgc3BlY2lmaWVkXG5cdCAqIGNvbXBvbmVudCBjb25zdHJ1Y3Rvci5cblx0ICogQHBhcmFtIHshRnVuY3Rpb259IGNvbXBvbmVudEN0b3IgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBjb21wb25lbnQgdGhhdFxuXHQgKiAgICAgc2hvdWxkIHVzZSB0aGUgZ2l2ZW4gdGVtcGxhdGVzLlxuXHQgKiBAcGFyYW0geyFPYmplY3R9IHRlbXBsYXRlcyBPYmplY3QgY29udGFpbmluZyBzb3kgdGVtcGxhdGUgZnVuY3Rpb25zLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG1haW5UZW1wbGF0ZSBUaGUgbmFtZSBvZiB0aGUgbWFpbiB0ZW1wbGF0ZSB0aGF0IHNob3VsZCBiZVxuXHQgKiAgICAgdXNlZCB0byByZW5kZXIgdGhlIGNvbXBvbmVudC4gRGVmYXVsdHMgdG8gXCJyZW5kZXJcIi5cblx0ICovXG5cdHN0YXRpYyByZWdpc3Rlcihjb21wb25lbnRDdG9yLCB0ZW1wbGF0ZXMsIG1haW5UZW1wbGF0ZSA9ICdyZW5kZXInKSB7XG5cdFx0Y29tcG9uZW50Q3Rvci5SRU5ERVJFUiA9IFNveTtcblx0XHRjb21wb25lbnRDdG9yLlRFTVBMQVRFID0gU295QW9wLmdldE9yaWdpbmFsRm4odGVtcGxhdGVzW21haW5UZW1wbGF0ZV0pO1xuXHRcdGNvbXBvbmVudEN0b3IuVEVNUExBVEUuY29tcG9uZW50Q3RvciA9IGNvbXBvbmVudEN0b3I7XG5cdFx0U295QW9wLnJlZ2lzdGVyRm9ySW50ZXJjZXB0aW9uKHRlbXBsYXRlcywgbWFpblRlbXBsYXRlKTtcblx0XHRDb21wb25lbnRSZWdpc3RyeS5yZWdpc3Rlcihjb21wb25lbnRDdG9yKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQgbWV0aG9kIGZyb20gYEluY3JlbWVudGFsRG9tUmVuZGVyZXJgIHNvIHRoZSBjb21wb25lbnQnc1xuXHQgKiBzb3kgdGVtcGxhdGUgY2FuIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cblx0ICogQHBhcmFtIHshT2JqZWN0fSBkYXRhIERhdGEgcGFzc2VkIHRvIHRoZSBjb21wb25lbnQgd2hlbiByZW5kZXJpbmcgaXQuXG5cdCAqIEBvdmVycmlkZVxuXHQgKi9cblx0cmVuZGVySW5jRG9tKCkge1xuXHRcdHZhciBlbGVtZW50VGVtcGxhdGUgPSB0aGlzLmNvbXBvbmVudF8uY29uc3RydWN0b3IuVEVNUExBVEU7XG5cdFx0aWYgKGNvcmUuaXNGdW5jdGlvbihlbGVtZW50VGVtcGxhdGUpKSB7XG5cdFx0XHRlbGVtZW50VGVtcGxhdGUgPSBTb3lBb3AuZ2V0T3JpZ2luYWxGbihlbGVtZW50VGVtcGxhdGUpO1xuXHRcdFx0U295QW9wLnN0YXJ0SW50ZXJjZXB0aW9uKFNveS5oYW5kbGVJbnRlcmNlcHRlZENhbGxfKTtcblx0XHRcdGVsZW1lbnRUZW1wbGF0ZSh0aGlzLmJ1aWxkVGVtcGxhdGVEYXRhXyhlbGVtZW50VGVtcGxhdGUucGFyYW1zIHx8IFtdKSwgbnVsbCwgaWpEYXRhKTtcblx0XHRcdFNveUFvcC5zdG9wSW50ZXJjZXB0aW9uKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN1cGVyLnJlbmRlckluY0RvbSgpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBpbmplY3RlZCBkYXRhIG9iamVjdCB0aGF0IHNob3VsZCBiZSBwYXNzZWQgdG8gdGVtcGxhdGVzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHQgKi9cblx0c3RhdGljIHNldEluamVjdGVkRGF0YShkYXRhKSB7XG5cdFx0aWpEYXRhID0gZGF0YSB8fCB7fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBPdmVycmlkZXMgdGhlIG9yaWdpbmFsIGBJbmNyZW1lbnRhbERvbVJlbmRlcmVyYCBtZXRob2Qgc28gdGhhdCBvbmx5XG5cdCAqIHN0YXRlIGtleXMgdXNlZCBieSB0aGUgbWFpbiB0ZW1wbGF0ZSBjYW4gY2F1c2UgdXBkYXRlcy5cblx0ICogQHBhcmFtIHshT2JqZWN0fSBjaGFuZ2VzXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRzaG91bGRVcGRhdGUoY2hhbmdlcykge1xuXHRcdHZhciBmbiA9IHRoaXMuY29tcG9uZW50Xy5jb25zdHJ1Y3Rvci5URU1QTEFURTtcblx0XHR2YXIgcGFyYW1zID0gZm4gPyBTb3lBb3AuZ2V0T3JpZ2luYWxGbihmbikucGFyYW1zIDogW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChjaGFuZ2VzW3BhcmFtc1tpXV0pIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gaW5jcmVtZW50YWwgZG9tIGZ1bmN0aW9uIGludG8gYW4gaHRtbCBzdHJpbmcuXG5cdCAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGluY0RvbUZuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdHN0YXRpYyB0b0h0bWxTdHJpbmcoaW5jRG9tRm4pIHtcblx0XHR2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdEluY3JlbWVudGFsRE9NLnBhdGNoKGVsZW1lbnQsIGluY0RvbUZuKTtcblx0XHRyZXR1cm4gZWxlbWVudC5pbm5lckhUTUw7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgdGhlIGdpdmVuIGh0bWwgc3RyaW5nIGludG8gYW4gaW5jcmVtZW50YWwgZG9tIGZ1bmN0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ3x7Y29udGVudEtpbmQ6IHN0cmluZywgY29udGVudDogc3RyaW5nfX0gdmFsdWVcblx0ICogQHJldHVybiB7IWZ1bmN0aW9uKCl9XG5cdCAqL1xuXHRzdGF0aWMgdG9JbmNEb20odmFsdWUpIHtcblx0XHRpZiAoY29yZS5pc09iamVjdCh2YWx1ZSkgJiYgY29yZS5pc1N0cmluZyh2YWx1ZS5jb250ZW50KSAmJiAodmFsdWUuY29udGVudEtpbmQgPT09ICdIVE1MJykpIHtcblx0XHRcdHZhbHVlID0gdmFsdWUuY29udGVudDtcblx0XHR9XG5cdFx0aWYgKGNvcmUuaXNTdHJpbmcodmFsdWUpKSB7XG5cdFx0XHR2YWx1ZSA9IEhUTUwySW5jRG9tLmJ1aWxkRm4odmFsdWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU295O1xuZXhwb3J0IHsgU295LCBTb3lBb3AgfTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFNveUFvcCA9IHtcblx0LyoqXG5cdCAqIFRoZSBmdW5jdGlvbnMgdGhhdCBzaG91bGQgYmUgY2FsbGVkIGluc3RlYWQgb2YgYSB0ZW1wbGF0ZSBjYWxsLiBUaGUgbGFzdFxuXHQgKiBmdW5jdGlvbiBpbiB0aGUgYXJyYXkgaXMgdGhlIG9uZSB0aGF0IGlzIGludGVyY2VwdGluZyBhdCB0aGUgbW9tZW50LiBJZiB0aGVcblx0ICogYXJyYXkgaXMgZW1wdHksIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBpbnN0ZWFkLlxuXHQgKiBAdHlwZSB7IUFycmF5PGZ1bmN0aW9uKCk+fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRpbnRlcmNlcHRGbnNfOiBbXSxcblxuXHQvKipcblx0ICogR2V0cyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gb2YgdGhlIGdpdmVuIHRlbXBsYXRlIGZ1bmN0aW9uLiBJZiBubyBvcmlnaW5hbCBleGlzdHMsXG5cdCAqIHJldHVybnMgdGhlIGdpdmVuIGZ1bmN0aW9uIGl0c2VsZi5cblx0ICogQHBhcmFtIHshZnVuY3Rpb24oKX0gZm5cblx0ICogQHJldHVybiB7IWZ1bmN0aW9uKCl9XG5cdCAqL1xuXHRnZXRPcmlnaW5hbEZuOiBmdW5jdGlvbihmbikge1xuXHRcdHJldHVybiBmbi5vcmlnaW5hbEZuID8gZm4ub3JpZ2luYWxGbiA6IGZuO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIGEgdGVtcGxhdGUgY2FsbCwgY2FsbGluZyB0aGUgY3VycmVudCBpbnRlcmNlcHRpb24gZnVuY3Rpb24gaWYgb25lXG5cdCAqIGlzIHNldCwgb3Igb3RoZXJ3aXNlIGp1c3QgY2FsbGluZyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gaW5zdGVhZC5cblx0ICogQHBhcmFtIHshZnVuY3Rpb24oKX0gb3JpZ2luYWxGbiBUaGUgb3JpZ2luYWwgdGVtcGxhdGUgZnVuY3Rpb24gdGhhdCB3YXNcblx0ICogICAgIGludGVyY2VwdGVkLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0X2RhdGEgVGVtcGxhdGUgZGF0YSBvYmplY3QuXG5cdCAqIEBwYXJhbSB7Kn0gb3B0X2lnbm9yZWRcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdF9pakRhdGEgVGVtcGxhdGUgaW5qZWN0ZWQgZGF0YSBvYmplY3QuXG5cdCAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHRvIGhhbmRsZSB0aGlzXG5cdCAqICAgICBpbnRlcmNlcHRpb24uXG5cdCAqL1xuXHRoYW5kbGVUZW1wbGF0ZUNhbGxfOiBmdW5jdGlvbihvcmlnaW5hbEZuLCBvcHRfZGF0YSwgb3B0X2lnbm9yZWQsIG9wdF9pakRhdGEpIHtcblx0XHR2YXIgaW50ZXJjZXB0Rm4gPSBTb3lBb3AuaW50ZXJjZXB0Rm5zX1tTb3lBb3AuaW50ZXJjZXB0Rm5zXy5sZW5ndGggLSAxXTtcblx0XHRpZiAoaW50ZXJjZXB0Rm4pIHtcblx0XHRcdHJldHVybiBpbnRlcmNlcHRGbi5jYWxsKG51bGwsIG9yaWdpbmFsRm4sIG9wdF9kYXRhLCBvcHRfaWdub3JlZCwgb3B0X2lqRGF0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBvcmlnaW5hbEZuLmNhbGwobnVsbCwgb3B0X2RhdGEsIG9wdF9pZ25vcmVkLCBvcHRfaWpEYXRhKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBhIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGludGVyY2VwdGVkLlxuXHQgKiBAcGFyYW0geyFPYmplY3R9IHRlbXBsYXRlcyBUaGUgb3JpZ2luYWwgdGVtcGxhdGVzIG9iamVjdCBjb250YWluaW5nIHRoZVxuXHQgKiAgICAgZnVuY3Rpb24gdG8gYmUgaW50ZXJjZXB0ZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0ZW1wbGF0ZSBmdW5jdGlvbiB0byBpbnRlcmNlcHQuXG5cdCAqL1xuXHRyZWdpc3RlckZvckludGVyY2VwdGlvbjogZnVuY3Rpb24odGVtcGxhdGVzLCBuYW1lKSB7XG5cdFx0dmFyIG9yaWdpbmFsRm4gPSB0ZW1wbGF0ZXNbbmFtZV07XG5cdFx0aWYgKCFvcmlnaW5hbEZuLm9yaWdpbmFsRm4pIHtcblx0XHRcdHRlbXBsYXRlc1tuYW1lXSA9IFNveUFvcC5oYW5kbGVUZW1wbGF0ZUNhbGxfLmJpbmQobnVsbCwgb3JpZ2luYWxGbik7XG5cdFx0XHR0ZW1wbGF0ZXNbbmFtZV0ub3JpZ2luYWxGbiA9IG9yaWdpbmFsRm47XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTdGFydHMgaW50ZXJjZXB0aW5nIGFsbCB0ZW1wbGF0ZSBjYWxscywgcmVwbGFjaW5nIHRoZW0gd2l0aCBhIGNhbGwgdG8gdGhlXG5cdCAqIGdpdmVuIGZ1bmN0aW9uIGluc3RlYWQuXG5cdCAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGZuXG5cdCAqL1xuXHRzdGFydEludGVyY2VwdGlvbjogZnVuY3Rpb24oZm4pIHtcblx0XHRTb3lBb3AuaW50ZXJjZXB0Rm5zXy5wdXNoKGZuKTtcblx0fSxcblxuXHQvKipcblx0ICogU3RvcHMgaW50ZXJjZXB0aW5nIHRlbXBsYXRlIGNhbGxzLlxuXHQgKi9cblx0c3RvcEFsbEludGVyY2VwdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFNveUFvcC5pbnRlcmNlcHRGbnNfID0gW107XG5cdH0sXG5cblx0LyoqXG5cdCAqIFN0b3BzIGludGVyY2VwdGluZyB0ZW1wbGF0ZSBjYWxscyB3aXRoIHRoZSBsYXN0IHJlZ2lzdGVyZWQgZnVuY3Rpb24uXG5cdCAqL1xuXHRzdG9wSW50ZXJjZXB0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRTb3lBb3AuaW50ZXJjZXB0Rm5zXy5wb3AoKTtcblx0fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgU295QW9wO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBhcnJheSwgYXN5bmMsIGNvcmUsIG9iamVjdCB9IGZyb20gJ21ldGFsJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ21ldGFsLWV2ZW50cyc7XG5cbi8qKlxuICogU3RhdGUgYWRkcyBzdXBwb3J0IGZvciBoYXZpbmcgb2JqZWN0IHByb3BlcnRpZXMgdGhhdCBjYW4gYmUgd2F0Y2hlZCBmb3JcbiAqIGNoYW5nZXMsIGFzIHdlbGwgYXMgY29uZmlndXJlZCB3aXRoIHZhbGlkYXRvcnMsIHNldHRlcnMgYW5kIG90aGVyIG9wdGlvbnMuXG4gKiBTZWUgdGhlIGBhZGRUb1N0YXRlYCBtZXRob2QgZm9yIGEgY29tcGxldGUgbGlzdCBvZiBhdmFpbGFibGUgY29uZmlndXJhdGlvblxuICogb3B0aW9ucyBmb3IgZWFjaCBzdGF0ZSBrZXkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtFdmVudEVtaXR0ZXJ9XG4gKi9cbmNsYXNzIFN0YXRlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblx0Y29uc3RydWN0b3Iob3B0X2NvbmZpZykge1xuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBPYmplY3Qgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYmF0Y2ggZXZlbnQgdGhhdCBpcyBjdXJyZW50bHlcblx0XHQgKiBzY2hlZHVsZWQsIG9yIG51bGwgaWYgbm9uZSBpcy5cblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLnNjaGVkdWxlZEJhdGNoRGF0YV8gPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogT2JqZWN0IHRoYXQgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgYWxsIHRoaXMgaW5zdGFuY2UncyBzdGF0ZSBrZXlzLlxuXHRcdCAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgIU9iamVjdD59XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuc3RhdGVJbmZvXyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogT2JqZWN0IHdpdGggdGhlIG1vc3QgcmVjZW50IHZhbHVlcyB0aGF0IHN0YXRlIHByb3BlcnRpZXMgd2VyZSBzZXQgdG9cblx0XHQgKiB0aHJvdWdoIGVpdGhlciB0aGUgY29uc3RydWN0b3Igb3Igc2V0U3RhdGUgY2FsbHMuXG5cdFx0ICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCAqPn1cblx0XHQgKi9cblx0XHR0aGlzLmNvbmZpZyA9IG9iamVjdC5taXhpbih7fSwgb3B0X2NvbmZpZyB8fCB7fSk7XG5cblx0XHR0aGlzLnNldFNob3VsZFVzZUZhY2FkZSh0cnVlKTtcblx0XHR0aGlzLm1lcmdlSW52YWxpZEtleXNfKCk7XG5cdFx0dGhpcy5hZGRUb1N0YXRlRnJvbVN0YXRpY0hpbnRfKG9wdF9jb25maWcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIGdpdmVuIGtleSB0byB0aGUgc3RhdGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBuZXcgc3RhdGUga2V5LlxuXHQgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCAqPj19IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBuZXdcblx0ICogICAgIGtleS4gU2VlIGBhZGRUb1N0YXRlYCBmb3Igc3VwcG9ydGVkIHNldHRpbmdzLlxuXHQgKiBAcGFyYW0geyp9IGluaXRpYWxWYWx1ZSBUaGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgbmV3IGtleS5cblx0ICovXG5cdGFkZEtleVRvU3RhdGUobmFtZSwgY29uZmlnLCBpbml0aWFsVmFsdWUpIHtcblx0XHR0aGlzLmJ1aWxkS2V5SW5mb18obmFtZSwgY29uZmlnLCBpbml0aWFsVmFsdWUpO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB0aGlzLmJ1aWxkS2V5UHJvcGVydHlEZWZfKG5hbWUpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBnaXZlbiBrZXkocykgdG8gdGhlIHN0YXRlLCB0b2dldGhlciB3aXRoIGl0cyh0aGVpcikgY29uZmlncy5cblx0ICogQ29uZmlnIG9iamVjdHMgc3VwcG9ydCB0aGUgZ2l2ZW4gc2V0dGluZ3M6XG5cdCAqICAgICBzZXR0ZXIgLSBGdW5jdGlvbiBmb3Igbm9ybWFsaXppbmcgc3RhdGUga2V5IHZhbHVlcy4gSXQgcmVjZWl2ZXMgdGhlIG5ld1xuXHQgKiAgICAgdmFsdWUgdGhhdCB3YXMgc2V0LCBhbmQgcmV0dXJucyB0aGUgdmFsdWUgdGhhdCBzaG91bGQgYmUgc3RvcmVkLlxuXHQgKlxuXHQgKiAgICAgdmFsaWRhdG9yIC0gRnVuY3Rpb24gdGhhdCB2YWxpZGF0ZXMgc3RhdGUga2V5IHZhbHVlcy4gV2hlbiBpdCByZXR1cm5zXG5cdCAqICAgICBmYWxzZSwgdGhlIG5ldyB2YWx1ZSBpcyBpZ25vcmVkLlxuXHQgKlxuXHQgKiAgICAgdmFsdWUgLSBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIHN0YXRlIGtleS4gTm90ZSB0aGF0IHNldHRpbmcgdGhpcyB0b1xuXHQgKiAgICAgYW4gb2JqZWN0IHdpbGwgY2F1c2UgYWxsIGNsYXNzIGluc3RhbmNlcyB0byB1c2UgdGhlIHNhbWUgcmVmZXJlbmNlIHRvXG5cdCAqICAgICB0aGUgb2JqZWN0LiBUbyBoYXZlIGVhY2ggaW5zdGFuY2UgdXNlIGEgZGlmZmVyZW50IHJlZmVyZW5jZSBmb3Igb2JqZWN0cyxcblx0ICogICAgIHVzZSB0aGUgYHZhbHVlRm5gIG9wdGlvbiBpbnN0ZWFkLlxuXHQgKlxuXHQgKiAgICAgdmFsdWVGbiAtIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlIGZvciBhIHN0YXRlIGtleS5cblx0ICpcblx0ICogICAgIHdyaXRlT25jZSAtIElnbm9yZXMgd3JpdGVzIHRvIHRoZSBzdGF0ZSBrZXkgYWZ0ZXIgaXQncyBiZWVuIGZpcnN0XG5cdCAqICAgICB3cml0dGVuIHRvLiBUaGF0IGlzLCBhbGxvd3Mgd3JpdGVzIG9ubHkgd2hlbiBzZXR0aW5nIHRoZSB2YWx1ZSBmb3IgdGhlXG5cdCAqICAgICBmaXJzdCB0aW1lLlxuXHQgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywgIU9iamVjdD58c3RyaW5nfSBjb25maWdzT3JOYW1lIEFuIG9iamVjdCB0aGF0IG1hcHNcblx0ICogICAgIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3Iga2V5cyB0byBiZSBhZGRlZCB0byB0aGUgc3RhdGUgb3IgdGhlIG5hbWUgb2Zcblx0ICogICAgIGEgc2luZ2xlIGtleSB0byBiZSBhZGRlZC5cblx0ICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgKj49fSBvcHRfaW5pdGlhbFZhbHVlc09yQ29uZmlnIEFuIG9iamVjdCB0aGF0IG1hcHNcblx0ICogICAgIHN0YXRlIGtleXMgdG8gdGhlaXIgaW5pdGlhbCB2YWx1ZXMuIFRoZXNlIHZhbHVlcyBoYXZlIGhpZ2hlciBwcmVjZWRlbmNlXG5cdCAqICAgICB0aGFuIHRoZSBkZWZhdWx0IHZhbHVlcyBzcGVjaWZpZWQgaW4gdGhlIGNvbmZpZ3VyYXRpb25zLiBJZiBhIHNpbmdsZVxuXHQgKiAgICAga2V5IG5hbWUgd2FzIHBhc3NlZCBhcyB0aGUgZmlyc3QgcGFyYW0gaW5zdGVhZCB0aG91Z2gsIHRoZW4gdGhpcyBzaG91bGRcblx0ICogICAgIGJlIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhhdCBrZXkuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R8Kj19IG9wdF9jb250ZXh0T3JJbml0aWFsVmFsdWUgSWYgdGhlIGZpcnN0XG5cdCAqICAgICBwYXJhbSBwYXNzZWQgdG8gdGhpcyBtZXRob2Qgd2FzIGEgY29uZmlnIG9iamVjdCwgdGhpcyBzaG91bGQgYmUgdGhlXG5cdCAqICAgICBjb250ZXh0IHdoZXJlIHRoZSBhZGRlZCBzdGF0ZSBrZXlzIHdpbGwgYmUgZGVmaW5lZCAoZGVmYXVsdHMgdG8gYHRoaXNgKSxcblx0ICogICAgIG9yIGZhbHNlIGlmIHRoZXkgc2hvdWxkbid0IGJlIGRlZmluZWQgYXQgYWxsLiBJZiB0aGUgZmlyc3QgcGFyYW0gd2FzIGFcblx0ICogICAgIHNpbmdsZSBrZXkgbmFtZSB0aG91Z2gsIHRoaXMgc2hvdWxkIGJlIGl0cyBpbml0aWFsIHZhbHVlLlxuXHQgKi9cblx0YWRkVG9TdGF0ZShjb25maWdzT3JOYW1lLCBvcHRfaW5pdGlhbFZhbHVlc09yQ29uZmlnLCBvcHRfY29udGV4dE9ySW5pdGlhbFZhbHVlKSB7XG5cdFx0aWYgKGNvcmUuaXNTdHJpbmcoY29uZmlnc09yTmFtZSkpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZEtleVRvU3RhdGUoXG5cdFx0XHRcdGNvbmZpZ3NPck5hbWUsXG5cdFx0XHRcdG9wdF9pbml0aWFsVmFsdWVzT3JDb25maWcsXG5cdFx0XHRcdG9wdF9jb250ZXh0T3JJbml0aWFsVmFsdWVcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dmFyIGluaXRpYWxWYWx1ZXMgPSBvcHRfaW5pdGlhbFZhbHVlc09yQ29uZmlnIHx8IHt9O1xuXHRcdHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKGNvbmZpZ3NPck5hbWUpO1xuXG5cdFx0dmFyIHByb3BzID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIG5hbWUgPSBuYW1lc1tpXTtcblx0XHRcdHRoaXMuYnVpbGRLZXlJbmZvXyhuYW1lLCBjb25maWdzT3JOYW1lW25hbWVdLCBpbml0aWFsVmFsdWVzW25hbWVdKTtcblx0XHRcdHByb3BzW25hbWVdID0gdGhpcy5idWlsZEtleVByb3BlcnR5RGVmXyhuYW1lKTtcblx0XHR9XG5cblx0XHRpZiAob3B0X2NvbnRleHRPckluaXRpYWxWYWx1ZSAhPT0gZmFsc2UpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9wdF9jb250ZXh0T3JJbml0aWFsVmFsdWUgfHwgdGhpcywgcHJvcHMpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHN0YXRlIGtleXMgZnJvbSBzdXBlciBjbGFzc2VzIHN0YXRpYyBoaW50IGBNeUNsYXNzLlNUQVRFID0ge307YC5cblx0ICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgIU9iamVjdD49fSBvcHRfY29uZmlnIEFuIG9iamVjdCB0aGF0IG1hcHMgYWxsIHRoZVxuXHQgKiAgICAgY29uZmlndXJhdGlvbnMgZm9yIHN0YXRlIGtleXMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGFkZFRvU3RhdGVGcm9tU3RhdGljSGludF8ob3B0X2NvbmZpZykge1xuXHRcdHZhciBjdG9yID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0XHR2YXIgZGVmaW5lQ29udGV4dCA9IGZhbHNlO1xuXHRcdGlmIChTdGF0ZS5tZXJnZVN0YXRlU3RhdGljKGN0b3IpKSB7XG5cdFx0XHRkZWZpbmVDb250ZXh0ID0gY3Rvci5wcm90b3R5cGU7XG5cdFx0fVxuXHRcdHRoaXMuYWRkVG9TdGF0ZShjdG9yLlNUQVRFX01FUkdFRCwgb3B0X2NvbmZpZywgZGVmaW5lQ29udGV4dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIHRoYXQgdGhlIGdpdmVuIG5hbWUgaXMgYSB2YWxpZCBzdGF0ZSBrZXkgbmFtZS4gSWYgaXQncyBub3QsIGFuIGVycm9yXG5cdCAqIHdpbGwgYmUgdGhyb3duLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSB0byBiZSB2YWxpZGF0ZWQuXG5cdCAqIEB0aHJvd3Mge0Vycm9yfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRhc3NlcnRWYWxpZFN0YXRlS2V5TmFtZV8obmFtZSkge1xuXHRcdGlmICh0aGlzLmNvbnN0cnVjdG9yLklOVkFMSURfS0VZU19NRVJHRURbbmFtZV0pIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSXRcXCdzIG5vdCBhbGxvd2VkIHRvIGNyZWF0ZSBhIHN0YXRlIGtleSB3aXRoIHRoZSBuYW1lIFwiJyArIG5hbWUgKyAnXCIuJyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEJ1aWxkcyB0aGUgaW5mbyBvYmplY3QgZm9yIHRoZSBzcGVjaWZpZWQgc3RhdGUga2V5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUga2V5LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgb2JqZWN0IGZvciB0aGUga2V5LlxuXHQgKiBAcGFyYW0geyp9IGluaXRpYWxWYWx1ZSBUaGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUga2V5LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRidWlsZEtleUluZm9fKG5hbWUsIGNvbmZpZywgaW5pdGlhbFZhbHVlKSB7XG5cdFx0dGhpcy5hc3NlcnRWYWxpZFN0YXRlS2V5TmFtZV8obmFtZSk7XG5cblx0XHR0aGlzLnN0YXRlSW5mb19bbmFtZV0gPSB7XG5cdFx0XHRjb25maWc6IGNvbmZpZyB8fCB7fSxcblx0XHRcdGluaXRpYWxWYWx1ZTogaW5pdGlhbFZhbHVlLFxuXHRcdFx0c3RhdGU6IFN0YXRlLktleVN0YXRlcy5VTklOSVRJQUxJWkVEXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCdWlsZHMgdGhlIHByb3BlcnR5IGRlZmluaXRpb24gb2JqZWN0IGZvciB0aGUgc3BlY2lmaWVkIHN0YXRlIGtleS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleS5cblx0ICogQHJldHVybiB7IU9iamVjdH1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0YnVpbGRLZXlQcm9wZXJ0eURlZl8obmFtZSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0U3RhdGVLZXlWYWx1ZV8obmFtZSk7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbih2YWwpIHtcblx0XHRcdFx0dGhpcy5zZXRTdGF0ZUtleVZhbHVlXyhuYW1lLCB2YWwpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbHMgdGhlIHJlcXVlc3RlZCBmdW5jdGlvbiwgcnVubmluZyB0aGUgYXBwcm9wcmlhdGUgY29kZSBmb3Igd2hlbiBpdCdzXG5cdCAqIHBhc3NlZCBhcyBhbiBhY3R1YWwgZnVuY3Rpb24gb2JqZWN0IG9yIGp1c3QgdGhlIGZ1bmN0aW9uJ3MgbmFtZS5cblx0ICogQHBhcmFtIHshRnVuY3Rpb258c3RyaW5nfSBmbiBGdW5jdGlvbiwgb3IgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gcnVuLlxuXHQgKiBAcGFyYW0geyFBcnJheX0gQW4gb3B0aW9uYWwgYXJyYXkgb2YgcGFyYW1ldGVycyB0byBiZSBwYXNzZWQgdG8gdGhlXG5cdCAqICAgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZC5cblx0ICogQHJldHVybiB7Kn0gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGVkIGZ1bmN0aW9uLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRjYWxsRnVuY3Rpb25fKGZuLCBhcmdzKSB7XG5cdFx0aWYgKGNvcmUuaXNTdHJpbmcoZm4pKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1tmbl0uYXBwbHkodGhpcywgYXJncyk7XG5cdFx0fSBlbHNlIGlmIChjb3JlLmlzRnVuY3Rpb24oZm4pKSB7XG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENhbGxzIHRoZSBzdGF0ZSBrZXkncyBzZXR0ZXIsIGlmIHRoZXJlIGlzIG9uZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgc2V0LlxuXHQgKiBAcGFyYW0geyp9IGN1cnJlbnRWYWx1ZSBUaGUgY3VycmVudCB2YWx1ZS5cblx0ICogQHJldHVybiB7Kn0gVGhlIGZpbmFsIHZhbHVlIHRvIGJlIHNldC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Y2FsbFNldHRlcl8obmFtZSwgdmFsdWUsIGN1cnJlbnRWYWx1ZSkge1xuXHRcdHZhciBpbmZvID0gdGhpcy5zdGF0ZUluZm9fW25hbWVdO1xuXHRcdHZhciBjb25maWcgPSBpbmZvLmNvbmZpZztcblx0XHRpZiAoY29uZmlnLnNldHRlcikge1xuXHRcdFx0dmFsdWUgPSB0aGlzLmNhbGxGdW5jdGlvbl8oY29uZmlnLnNldHRlciwgW3ZhbHVlLCBjdXJyZW50VmFsdWVdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGxzIHRoZSBzdGF0ZSBrZXkncyB2YWxpZGF0b3IsIGlmIHRoZXJlIGlzIG9uZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgdmFsaWRhdGVkLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBGbGFnIGluZGljYXRpbmcgaWYgdmFsdWUgaXMgdmFsaWQgb3Igbm90LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRjYWxsVmFsaWRhdG9yXyhuYW1lLCB2YWx1ZSkge1xuXHRcdHZhciBpbmZvID0gdGhpcy5zdGF0ZUluZm9fW25hbWVdO1xuXHRcdHZhciBjb25maWcgPSBpbmZvLmNvbmZpZztcblx0XHRpZiAoY29uZmlnLnZhbGlkYXRvcikge1xuXHRcdFx0cmV0dXJuIHRoaXMuY2FsbEZ1bmN0aW9uXyhjb25maWcudmFsaWRhdG9yLCBbdmFsdWVdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBpdCdzIGFsbG93ZWQgdG8gd3JpdGUgb24gdGhlIHJlcXVlc3RlZCBzdGF0ZSBrZXkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBrZXkuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRjYW5TZXRTdGF0ZShuYW1lKSB7XG5cdFx0dmFyIGluZm8gPSB0aGlzLnN0YXRlSW5mb19bbmFtZV07XG5cdFx0cmV0dXJuICFpbmZvLmNvbmZpZy53cml0ZU9uY2UgfHwgIWluZm8ud3JpdHRlbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0ZGlzcG9zZUludGVybmFsKCkge1xuXHRcdHN1cGVyLmRpc3Bvc2VJbnRlcm5hbCgpO1xuXHRcdHRoaXMuc3RhdGVJbmZvXyA9IG51bGw7XG5cdFx0dGhpcy5zY2hlZHVsZWRCYXRjaERhdGFfID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbWl0cyB0aGUgc3RhdGUgY2hhbmdlIGJhdGNoIGV2ZW50LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRlbWl0QmF0Y2hFdmVudF8oKSB7XG5cdFx0aWYgKCF0aGlzLmlzRGlzcG9zZWQoKSkge1xuXHRcdFx0dmFyIGRhdGEgPSB0aGlzLnNjaGVkdWxlZEJhdGNoRGF0YV87XG5cdFx0XHR0aGlzLnNjaGVkdWxlZEJhdGNoRGF0YV8gPSBudWxsO1xuXHRcdFx0dGhpcy5lbWl0KCdzdGF0ZUNoYW5nZWQnLCBkYXRhKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHJlcXVlc3RlZCBzdGF0ZSBrZXkuXG5cdCAqIE5vdGU6IHRoaXMgY2FuIGFuZCBzaG91bGQgYmUgYWNjb21wbGlzaGVkIGJ5IGFjY2Vzc2luZyB0aGUgdmFsdWUgYXMgYVxuXHQgKiByZWd1bGFyIHByb3BlcnR5LiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gY2FzZXMgd2hlcmUgYSBmdW5jdGlvbiBpc1xuXHQgKiBhY3R1YWxseSBuZWVkZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuXHRnZXQobmFtZSkge1xuXHRcdHJldHVybiB0aGlzW25hbWVdO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgbWFwcyBzdGF0ZSBrZXlzIHRvIHRoZWlyIHZhbHVlcy5cblx0ICogQHBhcmFtIHtBcnJheTxzdHJpbmc+PX0gb3B0X25hbWVzIEEgbGlzdCBvZiBuYW1lcyBvZiB0aGUga2V5cyB0aGF0IHNob3VsZFxuXHQgKiAgIGJlIHJldHVybmVkLiBJZiBub25lIGlzIGdpdmVuLCB0aGUgd2hvbGUgc3RhdGUgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsICo+fVxuXHQgKi9cblx0Z2V0U3RhdGUob3B0X25hbWVzKSB7XG5cdFx0dmFyIHN0YXRlID0ge307XG5cdFx0dmFyIG5hbWVzID0gb3B0X25hbWVzIHx8IHRoaXMuZ2V0U3RhdGVLZXlzKCk7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzdGF0ZVtuYW1lc1tpXV0gPSB0aGlzW25hbWVzW2ldXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3RhdGU7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgY29uZmlnIG9iamVjdCBmb3IgdGhlIHJlcXVlc3RlZCBzdGF0ZSBrZXkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBrZXkncyBuYW1lLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGdldFN0YXRlS2V5Q29uZmlnKG5hbWUpIHtcblx0XHRyZXR1cm4gKHRoaXMuc3RhdGVJbmZvX1tuYW1lXSB8fCB7fSkuY29uZmlnO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCBhbGwgc3RhdGUga2V5cy5cblx0ICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59XG5cdCAqL1xuXHRnZXRTdGF0ZUtleXMoKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc3RhdGVJbmZvXyk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBzdGF0ZSBrZXkuIFRoaXMgaXMgcGFzc2VkIGFzIHRoYXQga2V5J3Ncblx0ICogZ2V0dGVyIHRvIHRoZSBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBjYWxsIGluc2lkZSB0aGUgYGFkZEtleVRvU3RhdGVgIG1ldGhvZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleS5cblx0ICogQHJldHVybiB7Kn1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0Z2V0U3RhdGVLZXlWYWx1ZV8obmFtZSkge1xuXHRcdHRoaXMuaW5pdFN0YXRlS2V5XyhuYW1lKTtcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZUluZm9fW25hbWVdLnZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgdmFsdWUgb2YgdGhlIHN0YXRlIGtleSB3aXRoIHRoZSBnaXZlbiBuYW1lIGhhcyBhbHJlYWR5IGJlZW5cblx0ICogc2V0LiBOb3RlIHRoYXQgdGhpcyBkb2Vzbid0IHJ1biB0aGUga2V5J3MgZ2V0dGVyLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUga2V5LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzQmVlblNldChuYW1lKSB7XG5cdFx0dmFyIGluZm8gPSB0aGlzLnN0YXRlSW5mb19bbmFtZV07XG5cdFx0cmV0dXJuIGluZm8uc3RhdGUgPT09IFN0YXRlLktleVN0YXRlcy5JTklUSUFMSVpFRCB8fCBpbmZvLmluaXRpYWxWYWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbmZvcm1zIG9mIGNoYW5nZXMgdG8gYSBzdGF0ZSBrZXkncyB2YWx1ZSB0aHJvdWdoIGFuIGV2ZW50LiBXb24ndCB0cmlnZ2VyXG5cdCAqIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzbid0IGNoYW5nZWQgb3IgaWYgaXQncyBiZWluZyBpbml0aWFsaXplZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleS5cblx0ICogQHBhcmFtIHsqfSBwcmV2VmFsIFRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUga2V5LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRpbmZvcm1DaGFuZ2VfKG5hbWUsIHByZXZWYWwpIHtcblx0XHRpZiAodGhpcy5zaG91bGRJbmZvcm1DaGFuZ2VfKG5hbWUsIHByZXZWYWwpKSB7XG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0a2V5OiBuYW1lLFxuXHRcdFx0XHRuZXdWYWw6IHRoaXNbbmFtZV0sXG5cdFx0XHRcdHByZXZWYWw6IHByZXZWYWxcblx0XHRcdH07XG5cdFx0XHR0aGlzLmVtaXQobmFtZSArICdDaGFuZ2VkJywgZGF0YSk7XG5cdFx0XHR0aGlzLmVtaXQoJ3N0YXRlS2V5Q2hhbmdlZCcsIGRhdGEpO1xuXHRcdFx0dGhpcy5zY2hlZHVsZUJhdGNoRXZlbnRfKGRhdGEpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyB0aGUgc3BlY2lmaWVkIHN0YXRlIGtleSwgZ2l2aW5nIGl0IGEgZmlyc3QgdmFsdWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBrZXkuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGluaXRTdGF0ZUtleV8obmFtZSkge1xuXHRcdHZhciBpbmZvID0gdGhpcy5zdGF0ZUluZm9fW25hbWVdO1xuXHRcdGlmIChpbmZvLnN0YXRlICE9PSBTdGF0ZS5LZXlTdGF0ZXMuVU5JTklUSUFMSVpFRCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGluZm8uc3RhdGUgPSBTdGF0ZS5LZXlTdGF0ZXMuSU5JVElBTElaSU5HO1xuXHRcdHRoaXMuc2V0SW5pdGlhbFZhbHVlXyhuYW1lKTtcblx0XHRpZiAoIWluZm8ud3JpdHRlbikge1xuXHRcdFx0aW5mby5zdGF0ZSA9IFN0YXRlLktleVN0YXRlcy5JTklUSUFMSVpJTkdfREVGQVVMVDtcblx0XHRcdHRoaXMuc2V0RGVmYXVsdFZhbHVlXyhuYW1lKTtcblx0XHR9XG5cdFx0aW5mby5zdGF0ZSA9IFN0YXRlLktleVN0YXRlcy5JTklUSUFMSVpFRDtcblx0fVxuXG5cdC8qKlxuXHQgKiBNZXJnZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGZvciB0aGUgU1RBVEUgcHJvcGVydHkgaW50byBhIHNpbmdsZSBvYmplY3QuXG5cdCAqIEBwYXJhbSB7IUFycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBiZSBtZXJnZWQuXG5cdCAqIEByZXR1cm4geyFPYmplY3R9IFRoZSBtZXJnZWQgdmFsdWUuXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c3RhdGljIG1lcmdlU3RhdGVfKHZhbHVlcykge1xuXHRcdHJldHVybiBvYmplY3QubWl4aW4uYXBwbHkobnVsbCwgW3t9XS5jb25jYXQodmFsdWVzLnJldmVyc2UoKSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1lcmdlcyB0aGUgU1RBVEUgc3RhdGljIHZhcmlhYmxlIGZvciB0aGUgZ2l2ZW4gY29uc3RydWN0b3IgZnVuY3Rpb24uXG5cdCAqIEBwYXJhbSAgeyFGdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbi5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIG1lcmdlIGhhcHBlbnMsIGZhbHNlIG90aGVyd2lzZS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIG1lcmdlU3RhdGVTdGF0aWMoY3Rvcikge1xuXHRcdHJldHVybiBjb3JlLm1lcmdlU3VwZXJDbGFzc2VzUHJvcGVydHkoY3RvciwgJ1NUQVRFJywgU3RhdGUubWVyZ2VTdGF0ZV8pO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1lcmdlcyB0aGUgdmFsdWVzIG9mIHRoZSBgSU5WQUxJRF9LRVlTYCBzdGF0aWMgZm9yIHRoZSB3aG9sZSBoaWVyYXJjaHkgb2Zcblx0ICogdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdG1lcmdlSW52YWxpZEtleXNfKCkge1xuXHRcdGNvcmUubWVyZ2VTdXBlckNsYXNzZXNQcm9wZXJ0eSh0aGlzLmNvbnN0cnVjdG9yLCAnSU5WQUxJRF9LRVlTJywgZnVuY3Rpb24odmFsdWVzKSB7XG5cdFx0XHRyZXR1cm4gYXJyYXkuZmxhdHRlbih2YWx1ZXMpLnJlZHVjZShmdW5jdGlvbihtZXJnZWQsIHZhbCkge1xuXHRcdFx0XHRpZiAodmFsKSB7XG5cdFx0XHRcdFx0bWVyZ2VkW3ZhbF0gPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtZXJnZWQ7XG5cdFx0XHR9LCB7fSk7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgcmVxdWVzdGVkIHN0YXRlIGtleS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleS5cblx0ICovXG5cdHJlbW92ZVN0YXRlS2V5KG5hbWUpIHtcblx0XHR0aGlzLnN0YXRlSW5mb19bbmFtZV0gPSBudWxsO1xuXHRcdGRlbGV0ZSB0aGlzW25hbWVdO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNjaGVkdWxlcyBhIHN0YXRlIGNoYW5nZSBiYXRjaCBldmVudCB0byBiZSBlbWl0dGVkIGFzeW5jaHJvbm91c2x5LlxuXHQgKiBAcGFyYW0geyFPYmplY3R9IGNoYW5nZURhdGEgSW5mb3JtYXRpb24gYWJvdXQgYSBzdGF0ZSBrZXkncyB1cGRhdGUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHNjaGVkdWxlQmF0Y2hFdmVudF8oY2hhbmdlRGF0YSkge1xuXHRcdGlmICghdGhpcy5zY2hlZHVsZWRCYXRjaERhdGFfKSB7XG5cdFx0XHRhc3luYy5uZXh0VGljayh0aGlzLmVtaXRCYXRjaEV2ZW50XywgdGhpcyk7XG5cdFx0XHR0aGlzLnNjaGVkdWxlZEJhdGNoRGF0YV8gPSB7XG5cdFx0XHRcdGNoYW5nZXM6IHt9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHZhciBuYW1lID0gY2hhbmdlRGF0YS5rZXk7XG5cdFx0dmFyIGNoYW5nZXMgPSB0aGlzLnNjaGVkdWxlZEJhdGNoRGF0YV8uY2hhbmdlcztcblx0XHRpZiAoY2hhbmdlc1tuYW1lXSkge1xuXHRcdFx0Y2hhbmdlc1tuYW1lXS5uZXdWYWwgPSBjaGFuZ2VEYXRhLm5ld1ZhbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2hhbmdlc1tuYW1lXSA9IGNoYW5nZURhdGE7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSByZXF1ZXN0ZWQgc3RhdGUga2V5LlxuXHQgKiBOb3RlOiB0aGlzIGNhbiBhbmQgc2hvdWxkIGJlIGFjY29tcGxpc2hlZCBieSBzZXR0aW5nIHRoZSBzdGF0ZSBrZXkgYXMgYVxuXHQgKiByZWd1bGFyIHByb3BlcnR5LiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gY2FzZXMgd2hlcmUgYSBmdW5jdGlvbiBpc1xuXHQgKiBhY3R1YWxseSBuZWVkZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWVcblx0ICogQHJldHVybiB7Kn1cblx0ICovXG5cdHNldChuYW1lLCB2YWx1ZSkge1xuXHRcdHRoaXNbbmFtZV0gPSB2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoZSByZXF1ZXN0ZWQgc3RhdGUga2V5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUga2V5LlxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzZXREZWZhdWx0VmFsdWVfKG5hbWUpIHtcblx0XHR2YXIgY29uZmlnID0gdGhpcy5zdGF0ZUluZm9fW25hbWVdLmNvbmZpZztcblxuXHRcdGlmIChjb25maWcudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpc1tuYW1lXSA9IGNvbmZpZy52YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpc1tuYW1lXSA9IHRoaXMuY2FsbEZ1bmN0aW9uXyhjb25maWcudmFsdWVGbik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIHJlcXVlc3RlZCBzdGF0ZSBrZXkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBrZXkuXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHNldEluaXRpYWxWYWx1ZV8obmFtZSkge1xuXHRcdHZhciBpbmZvID0gdGhpcy5zdGF0ZUluZm9fW25hbWVdO1xuXHRcdGlmIChpbmZvLmluaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzW25hbWVdID0gaW5mby5pbml0aWFsVmFsdWU7XG5cdFx0XHRpbmZvLmluaXRpYWxWYWx1ZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmFsdWUgb2YgYWxsIHRoZSBzcGVjaWZpZWQgc3RhdGUga2V5cy5cblx0ICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsKj59IHZhbHVlcyBBIG1hcCBvZiBzdGF0ZSBrZXlzIHRvIHRoZSB2YWx1ZXMgdGhleVxuXHQgKiAgIHNob3VsZCBiZSBzZXQgdG8uXG5cdCAqL1xuXHRzZXRTdGF0ZSh2YWx1ZXMpIHtcblx0XHRvYmplY3QubWl4aW4odGhpcy5jb25maWcsIHZhbHVlcyk7XG5cblx0XHR2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyh2YWx1ZXMpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXNbbmFtZXNbaV1dID0gdmFsdWVzW25hbWVzW2ldXTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBzdGF0ZSBrZXkuIFRoaXMgaXMgcGFzc2VkIGFzIHRoYXQga2V5J3Ncblx0ICogc2V0dGVyIHRvIHRoZSBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBjYWxsIGluc2lkZSB0aGUgYGFkZEtleVRvU3RhdGVgXG5cdCAqIG1ldGhvZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBrZXkuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHNldFN0YXRlS2V5VmFsdWVfKG5hbWUsIHZhbHVlKSB7XG5cdFx0aWYgKCF0aGlzLmNhblNldFN0YXRlKG5hbWUpIHx8ICF0aGlzLnZhbGlkYXRlS2V5VmFsdWVfKG5hbWUsIHZhbHVlKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBpbmZvID0gdGhpcy5zdGF0ZUluZm9fW25hbWVdO1xuXHRcdGlmIChpbmZvLmluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIGluZm8uc3RhdGUgPT09IFN0YXRlLktleVN0YXRlcy5VTklOSVRJQUxJWkVEKSB7XG5cdFx0XHRpbmZvLnN0YXRlID0gU3RhdGUuS2V5U3RhdGVzLklOSVRJQUxJWkVEO1xuXHRcdH1cblxuXHRcdHZhciBwcmV2VmFsID0gdGhpc1tuYW1lXTtcblx0XHRpbmZvLnZhbHVlID0gdGhpcy5jYWxsU2V0dGVyXyhuYW1lLCB2YWx1ZSwgcHJldlZhbCk7XG5cdFx0aW5mby53cml0dGVuID0gdHJ1ZTtcblx0XHR0aGlzLmluZm9ybUNoYW5nZV8obmFtZSwgcHJldlZhbCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHdlIHNob3VsZCBpbmZvcm0gYWJvdXQgYSBzdGF0ZSB1cGRhdGUuIFVwZGF0ZXMgYXJlIGlnbm9yZWQgZHVyaW5nXG5cdCAqIHN0YXRlIGluaXRpYWxpemF0aW9uLiBPdGhlcndpc2UsIHVwZGF0ZXMgdG8gcHJpbWl0aXZlIHZhbHVlcyBhcmUgb25seVxuXHQgKiBpbmZvcm1lZCB3aGVuIHRoZSBuZXcgdmFsdWUgaXMgZGlmZmVyZW50IGZyb20gdGhlIHByZXZpb3VzIG9uZS4gVXBkYXRlcyB0b1xuXHQgKiBvYmplY3RzICh3aGljaCBpbmNsdWRlcyBmdW5jdGlvbnMgYW5kIGFycmF5cykgYXJlIGFsd2F5cyBpbmZvcm1lZCBvdXRzaWRlXG5cdCAqIGluaXRpYWxpemF0aW9uIHRob3VnaCwgc2luY2Ugd2UgY2FuJ3QgYmUgc3VyZSBpZiBhbGwgb2YgdGhlIGludGVybmFsIGRhdGFcblx0ICogaGFzIHN0YXllZCB0aGUgc2FtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleS5cblx0ICogQHBhcmFtIHsqfSBwcmV2VmFsIFRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUga2V5LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzaG91bGRJbmZvcm1DaGFuZ2VfKG5hbWUsIHByZXZWYWwpIHtcblx0XHR2YXIgaW5mbyA9IHRoaXMuc3RhdGVJbmZvX1tuYW1lXTtcblx0XHRyZXR1cm4gKGluZm8uc3RhdGUgPT09IFN0YXRlLktleVN0YXRlcy5JTklUSUFMSVpFRCkgJiZcblx0XHRcdChjb3JlLmlzT2JqZWN0KHByZXZWYWwpIHx8IHByZXZWYWwgIT09IHRoaXNbbmFtZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFZhbGlkYXRlcyB0aGUgc3RhdGUga2V5J3MgdmFsdWUsIHdoaWNoIGluY2x1ZGVzIGNhbGxpbmcgdGhlIHZhbGlkYXRvclxuXHQgKiBkZWZpbmVkIGluIHRoZSBrZXkncyBjb25maWd1cmF0aW9uIG9iamVjdCwgaWYgdGhlcmUgaXMgb25lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUga2V5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWQuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IEZsYWcgaW5kaWNhdGluZyBpZiB2YWx1ZSBpcyB2YWxpZCBvciBub3QuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHZhbGlkYXRlS2V5VmFsdWVfKG5hbWUsIHZhbHVlKSB7XG5cdFx0dmFyIGluZm8gPSB0aGlzLnN0YXRlSW5mb19bbmFtZV07XG5cblx0XHRyZXR1cm4gaW5mby5zdGF0ZSA9PT0gU3RhdGUuS2V5U3RhdGVzLklOSVRJQUxJWklOR19ERUZBVUxUIHx8XG5cdFx0XHR0aGlzLmNhbGxWYWxpZGF0b3JfKG5hbWUsIHZhbHVlKTtcblx0fVxufVxuXG4vKipcbiAqIEEgbGlzdCB3aXRoIHN0YXRlIGtleSBuYW1lcyB0aGF0IHdpbGwgYXV0b21hdGljYWxseSBiZSByZWplY3RlZCBhcyBpbnZhbGlkLlxuICogU3ViY2xhc3NlcyBjYW4gZGVmaW5lIHRoZWlyIG93biBpbnZhbGlkIGtleXMgYnkgc2V0dGluZyB0aGlzIHN0YXRpYyBvbiB0aGVpclxuICogY29uc3RydWN0b3JzLCB3aGljaCB3aWxsIGJlIG1lcmdlZCB0b2dldGhlciBhbmQgaGFuZGxlZCBhdXRvbWF0aWNhbGx5LlxuICogQHR5cGUgeyFBcnJheTxzdHJpbmc+fVxuICovXG5TdGF0ZS5JTlZBTElEX0tFWVMgPSBbJ2NvbmZpZycsICdzdGF0ZScsICdzdGF0ZUtleSddO1xuXG4vKipcbiAqIENvbnN0YW50cyB0aGF0IHJlcHJlc2VudCB0aGUgc3RhdGVzIHRoYXQgYW4gYSBzdGF0ZSBrZXkgY2FuIGJlIGluLlxuICogQHR5cGUgeyFPYmplY3R9XG4gKi9cblN0YXRlLktleVN0YXRlcyA9IHtcblx0VU5JTklUSUFMSVpFRDogMCxcblx0SU5JVElBTElaSU5HOiAxLFxuXHRJTklUSUFMSVpJTkdfREVGQVVMVDogMixcblx0SU5JVElBTElaRUQ6IDNcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFN0YXRlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlLCBzdHJpbmcgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgcGFyc2UgZnJvbSAnLi9wYXJzZSc7XG5pbXBvcnQgTXVsdGlNYXAgZnJvbSAnbWV0YWwtbXVsdGltYXAnO1xuXG52YXIgcGFyc2VGbl8gPSBwYXJzZTtcblxuY2xhc3MgVXJpIHtcblxuXHQvKipcblx0ICogVGhpcyBjbGFzcyBjb250YWlucyBzZXR0ZXJzIGFuZCBnZXR0ZXJzIGZvciB0aGUgcGFydHMgb2YgdGhlIFVSSS5cblx0ICogVGhlIGZvbGxvd2luZyBmaWd1cmUgZGlzcGxheXMgYW4gZXhhbXBsZSBVUklzIGFuZCB0aGVpciBjb21wb25lbnQgcGFydHMuXG5cdCAqXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhcblx0ICpcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSM4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSQXG5cdCAqXHQgIGFiYzovL2V4YW1wbGUuY29tOjEyMy9wYXRoL2RhdGE/a2V5PXZhbHVlI2ZyYWdpZDFcblx0ICpcdCAg4pSU4pSs4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSYIOKUlOKUrOKUmCAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSYIOKUlOKUgOKUgOKUrOKUgOKUgOKUmFxuXHQgKiBwcm90b2NvbCAgaG9zdG5hbWUgIHBvcnQgICAgICAgICAgICBzZWFyY2ggICAgaGFzaFxuXHQgKiAgICAgICAgICDilJTilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilJhcblx0ICogICAgICAgICAgICAgICAgaG9zdFxuXHQgKlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdXJpIE9wdGlvbmFsIHN0cmluZyBVUkkgdG8gcGFyc2Vcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvcHRfdXJpID0gJycpIHtcblx0XHR0aGlzLnVybCA9IFVyaS5wYXJzZSh0aGlzLm1heWJlQWRkUHJvdG9jb2xBbmRIb3N0bmFtZV8ob3B0X3VyaSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgcGFyYW1ldGVycyB0byB1cmkgZnJvbSBhIDxjb2RlPk11bHRpTWFwPC9jb2RlPiBhcyBzb3VyY2UuXG5cdCAqIEBwYXJhbSB7TXVsdGlNYXB9IG11bHRpbWFwIFRoZSA8Y29kZT5NdWx0aU1hcDwvY29kZT4gY29udGFpbmluZyB0aGVcblx0ICogICBwYXJhbWV0ZXJzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGFkZFBhcmFtZXRlcnNGcm9tTXVsdGlNYXAobXVsdGltYXApIHtcblx0XHRtdWx0aW1hcC5uYW1lcygpLmZvckVhY2goKG5hbWUpID0+IHtcblx0XHRcdG11bHRpbWFwLmdldEFsbChuYW1lKS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuXHRcdFx0XHR0aGlzLmFkZFBhcmFtZXRlclZhbHVlKG5hbWUsIHZhbHVlKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBxdWVyeSBwYXJhbWV0ZXJzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBwYXJhbWV0ZXIgdG8gc2V0LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBuZXcgdmFsdWUuIFdpbGwgYmUgZXhwbGljaXRseSBjYXN0ZWQgdG8gU3RyaW5nLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRhZGRQYXJhbWV0ZXJWYWx1ZShuYW1lLCB2YWx1ZSkge1xuXHRcdHRoaXMuZW5zdXJlUXVlcnlJbml0aWFsaXplZF8oKTtcblx0XHRpZiAoY29yZS5pc0RlZih2YWx1ZSkpIHtcblx0XHRcdHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcblx0XHR9XG5cdFx0dGhpcy5xdWVyeS5hZGQobmFtZSwgdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIHZhbHVlcyBvZiB0aGUgbmFtZWQgcXVlcnkgcGFyYW1ldGVyLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBwYXJhbWV0ZXIgdG8gc2V0LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBuZXcgdmFsdWUuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGFkZFBhcmFtZXRlclZhbHVlcyhuYW1lLCB2YWx1ZXMpIHtcblx0XHR2YWx1ZXMuZm9yRWFjaCgodmFsdWUpID0+IHRoaXMuYWRkUGFyYW1ldGVyVmFsdWUobmFtZSwgdmFsdWUpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBFbnN1cmVzIHF1ZXJ5IGludGVybmFsIG1hcCBpcyBpbml0aWFsaXplZCBhbmQgc3luY2VkIHdpdGggaW5pdGlhbCB2YWx1ZVxuXHQgKiBleHRyYWN0ZWQgZnJvbSBVUkkgc2VhcmNoIHBhcnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGVuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfKCkge1xuXHRcdGlmICh0aGlzLnF1ZXJ5KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMucXVlcnkgPSBuZXcgTXVsdGlNYXAoKTtcblx0XHR2YXIgc2VhcmNoID0gdGhpcy51cmwuc2VhcmNoO1xuXHRcdGlmIChzZWFyY2gpIHtcblx0XHRcdHNlYXJjaC5zdWJzdHJpbmcoMSkuc3BsaXQoJyYnKS5mb3JFYWNoKChwYXJhbSkgPT4ge1xuXHRcdFx0XHR2YXIgW2tleSwgdmFsdWVdID0gcGFyYW0uc3BsaXQoJz0nKTtcblx0XHRcdFx0aWYgKGNvcmUuaXNEZWYodmFsdWUpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBVcmkudXJsRGVjb2RlKHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmFkZFBhcmFtZXRlclZhbHVlKGtleSwgdmFsdWUpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGhhc2ggcGFydCBvZiB1cmkuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldEhhc2goKSB7XG5cdFx0cmV0dXJuIHRoaXMudXJsLmhhc2ggfHwgJyc7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgaG9zdCBwYXJ0IG9mIHVyaS4gRS5nLiA8Y29kZT5baG9zdG5hbWVdOltwb3J0XTwvY29kZT4uXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldEhvc3QoKSB7XG5cdFx0dmFyIGhvc3QgPSB0aGlzLmdldEhvc3RuYW1lKCk7XG5cdFx0aWYgKGhvc3QpIHtcblx0XHRcdHZhciBwb3J0ID0gdGhpcy5nZXRQb3J0KCk7XG5cdFx0XHRpZiAocG9ydCAmJiBwb3J0ICE9PSAnODAnKSB7XG5cdFx0XHRcdGhvc3QgKz0gJzonICsgcG9ydDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGhvc3Q7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgaG9zdG5hbWUgcGFydCBvZiB1cmkgd2l0aG91dCBwcm90b2NvbCBhbmQgcG9ydC5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0SG9zdG5hbWUoKSB7XG5cdFx0dmFyIGhvc3RuYW1lID0gdGhpcy51cmwuaG9zdG5hbWU7XG5cdFx0aWYgKGhvc3RuYW1lID09PSBVcmkuSE9TVE5BTUVfUExBQ0VIT0xERVIpIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cdFx0cmV0dXJuIGhvc3RuYW1lO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIG9yaWdpbiBwYXJ0IG9mIHVyaS4gRS5nLiA8Y29kZT5odHRwOi8vW2hvc3RuYW1lXTpbcG9ydF08L2NvZGU+LlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRPcmlnaW4oKSB7XG5cdFx0dmFyIGhvc3QgPSB0aGlzLmdldEhvc3QoKTtcblx0XHRpZiAoaG9zdCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0UHJvdG9jb2woKSArICcvLycgKyBob3N0O1xuXHRcdH1cblx0XHRyZXR1cm4gJyc7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZmlyc3QgdmFsdWUgZm9yIGEgZ2l2ZW4gcGFyYW1ldGVyIG9yIHVuZGVmaW5lZCBpZiB0aGUgZ2l2ZW5cblx0ICogcGFyYW1ldGVyIG5hbWUgZG9lcyBub3QgYXBwZWFyIGluIHRoZSBxdWVyeSBzdHJpbmcuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbU5hbWUgVW5lc2NhcGVkIHBhcmFtZXRlciBuYW1lLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBUaGUgZmlyc3QgdmFsdWUgZm9yIGEgZ2l2ZW4gcGFyYW1ldGVyIG9yXG5cdCAqICAgdW5kZWZpbmVkIGlmIHRoZSBnaXZlbiBwYXJhbWV0ZXIgbmFtZSBkb2VzIG5vdCBhcHBlYXIgaW4gdGhlIHF1ZXJ5XG5cdCAqICAgc3RyaW5nLlxuXHQgKi9cblx0Z2V0UGFyYW1ldGVyVmFsdWUobmFtZSkge1xuXHRcdHRoaXMuZW5zdXJlUXVlcnlJbml0aWFsaXplZF8oKTtcblx0XHRyZXR1cm4gdGhpcy5xdWVyeS5nZXQobmFtZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdmFsdWU8Yj5zPC9iPiBmb3IgYSBnaXZlbiBwYXJhbWV0ZXIgYXMgYSBsaXN0IG9mIGRlY29kZWRcblx0ICogcXVlcnkgcGFyYW1ldGVyIHZhbHVlcy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHBhcmFtZXRlciB0byBnZXQgdmFsdWVzIGZvci5cblx0ICogQHJldHVybiB7IUFycmF5PD8+fSBUaGUgdmFsdWVzIGZvciBhIGdpdmVuIHBhcmFtZXRlciBhcyBhIGxpc3Qgb2YgZGVjb2RlZFxuXHQgKiAgIHF1ZXJ5IHBhcmFtZXRlciB2YWx1ZXMuXG5cdCAqL1xuXHRnZXRQYXJhbWV0ZXJWYWx1ZXMobmFtZSkge1xuXHRcdHRoaXMuZW5zdXJlUXVlcnlJbml0aWFsaXplZF8oKTtcblx0XHRyZXR1cm4gdGhpcy5xdWVyeS5nZXRBbGwobmFtZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbmFtZTxiPnM8L2I+IG9mIHRoZSBwYXJhbWV0ZXJzLlxuXHQgKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPn0gVGhlIG5hbWVzIGZvciB0aGUgcGFyYW1ldGVycyBhcyBhIGxpc3Qgb2Zcblx0ICogICBzdHJpbmdzLlxuXHQgKi9cblx0Z2V0UGFyYW1ldGVyTmFtZXMoKSB7XG5cdFx0dGhpcy5lbnN1cmVRdWVyeUluaXRpYWxpemVkXygpO1xuXHRcdHJldHVybiB0aGlzLnF1ZXJ5Lm5hbWVzKCk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgZnVuY3Rpb24gY3VycmVudGx5IGJlaW5nIHVzZWQgdG8gcGFyc2UgVVJJcy5cblx0ICogQHJldHVybiB7IWZ1bmN0aW9uKCl9XG5cdCAqL1xuXHRzdGF0aWMgZ2V0UGFyc2VGbigpIHtcblx0XHRyZXR1cm4gcGFyc2VGbl87XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcGF0aG5hbWUgcGFydCBvZiB1cmkuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldFBhdGhuYW1lKCkge1xuXHRcdHJldHVybiB0aGlzLnVybC5wYXRobmFtZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBwb3J0IG51bWJlciBwYXJ0IG9mIHVyaSBhcyBzdHJpbmcuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGdldFBvcnQoKSB7XG5cdFx0cmV0dXJuIHRoaXMudXJsLnBvcnQ7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcHJvdG9jb2wgcGFydCBvZiB1cmkuIEUuZy4gPGNvZGU+aHR0cDo8L2NvZGU+LlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRQcm90b2NvbCgpIHtcblx0XHRyZXR1cm4gdGhpcy51cmwucHJvdG9jb2w7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgc2VhcmNoIHBhcnQgb2YgdXJpLiBTZWFyY2ggdmFsdWUgaXMgcmV0cmlldmVkIGZyb20gcXVlcnlcblx0ICogcGFyYW1ldGVycy5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0U2VhcmNoKCkge1xuXHRcdHZhciBzZWFyY2ggPSAnJztcblx0XHR2YXIgcXVlcnlzdHJpbmcgPSAnJztcblx0XHR0aGlzLmdldFBhcmFtZXRlck5hbWVzKCkuZm9yRWFjaCgobmFtZSkgPT4ge1xuXHRcdFx0dGhpcy5nZXRQYXJhbWV0ZXJWYWx1ZXMobmFtZSkuZm9yRWFjaCgodmFsdWUpID0+IHtcblx0XHRcdFx0cXVlcnlzdHJpbmcgKz0gbmFtZTtcblx0XHRcdFx0aWYgKGNvcmUuaXNEZWYodmFsdWUpKSB7XG5cdFx0XHRcdFx0cXVlcnlzdHJpbmcgKz0gJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRxdWVyeXN0cmluZyArPSAnJic7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRxdWVyeXN0cmluZyA9IHF1ZXJ5c3RyaW5nLnNsaWNlKDAsIC0xKTtcblx0XHRpZiAocXVlcnlzdHJpbmcpIHtcblx0XHRcdHNlYXJjaCArPSAnPycgKyBxdWVyeXN0cmluZztcblx0XHR9XG5cdFx0cmV0dXJuIHNlYXJjaDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdXJpIGNvbnRhaW5zIHRoZSBwYXJhbWV0ZXIuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNQYXJhbWV0ZXIobmFtZSkge1xuXHRcdHRoaXMuZW5zdXJlUXVlcnlJbml0aWFsaXplZF8oKTtcblx0XHRyZXR1cm4gdGhpcy5xdWVyeS5jb250YWlucyhuYW1lKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNYWtlcyB0aGlzIFVSTCB1bmlxdWUgYnkgYWRkaW5nIGEgcmFuZG9tIHBhcmFtIHRvIGl0LiBVc2VmdWwgZm9yIGF2b2lkaW5nXG5cdCAqIGNhY2hlLlxuXHQgKi9cblx0bWFrZVVuaXF1ZSgpIHtcblx0XHR0aGlzLnNldFBhcmFtZXRlclZhbHVlKFVyaS5SQU5ET01fUEFSQU0sIHN0cmluZy5nZXRSYW5kb21TdHJpbmcoKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogTWF5YmUgYWRkcyBwcm90b2NvbCBhbmQgYSBob3N0bmFtZSBwbGFjZWhvbGRlciBvbiBhIHBhcmlhbCBVUkkgaWYgbmVlZGVkLlxuXHQgKiBSZWxldmVudCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIDxjb2RlPlVSTDwvY29kZT4gbmF0aXZlIG9iamVjdC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfdXJpXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gVVJJIHdpdGggcHJvdG9jb2wgYW5kIGhvc3RuYW1lIHBsYWNlaG9sZGVyLlxuXHQgKi9cblx0bWF5YmVBZGRQcm90b2NvbEFuZEhvc3RuYW1lXyhvcHRfdXJpKSB7XG5cdFx0dmFyIHVybCA9IG9wdF91cmk7XG5cdFx0aWYgKG9wdF91cmkuaW5kZXhPZignOi8vJykgPT09IC0xICYmXG5cdFx0XHRvcHRfdXJpLmluZGV4T2YoJ2phdmFzY3JpcHQ6JykgIT09IDApIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cblx0XHRcdHVybCA9IFVyaS5ERUZBVUxUX1BST1RPQ09MO1xuXHRcdFx0aWYgKG9wdF91cmlbMF0gIT09ICcvJyB8fCBvcHRfdXJpWzFdICE9PSAnLycpIHtcblx0XHRcdFx0dXJsICs9ICcvLyc7XG5cdFx0XHR9XG5cblx0XHRcdHN3aXRjaCAob3B0X3VyaS5jaGFyQXQoMCkpIHtcblx0XHRcdFx0Y2FzZSAnLic6XG5cdFx0XHRcdGNhc2UgJz8nOlxuXHRcdFx0XHRjYXNlICcjJzpcblx0XHRcdFx0XHR1cmwgKz0gVXJpLkhPU1ROQU1FX1BMQUNFSE9MREVSO1xuXHRcdFx0XHRcdHVybCArPSAnLyc7XG5cdFx0XHRcdFx0dXJsICs9IG9wdF91cmk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJyc6XG5cdFx0XHRcdGNhc2UgJy8nOlxuXHRcdFx0XHRcdGlmIChvcHRfdXJpWzFdICE9PSAnLycpIHtcblx0XHRcdFx0XHRcdHVybCArPSBVcmkuSE9TVE5BTUVfUExBQ0VIT0xERVI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHVybCArPSBvcHRfdXJpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHVybCArPSBvcHRfdXJpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdXJsO1xuXHR9XG5cblx0LyoqXG5cdCAqIE5vcm1hbGl6ZXMgdGhlIHBhcnNlZCBvYmplY3QgdG8gYmUgaW4gdGhlIGV4cGVjdGVkIHN0YW5kYXJkLlxuXHQgKiBAcGFyYW0geyFPYmplY3R9XG5cdCAqL1xuXHRzdGF0aWMgbm9ybWFsaXplT2JqZWN0KHBhcnNlZCkge1xuXHRcdHZhciBsZW5ndGggPSBwYXJzZWQucGF0aG5hbWUgPyBwYXJzZWQucGF0aG5hbWUubGVuZ3RoIDogMDtcblx0XHRpZiAobGVuZ3RoID4gMSAmJiBwYXJzZWQucGF0aG5hbWVbbGVuZ3RoIC0gMV0gPT09ICcvJykge1xuXHRcdFx0cGFyc2VkLnBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lLnN1YnN0cigwLCBsZW5ndGggLSAxKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcnNlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgdGhlIGdpdmVuIHVyaSBzdHJpbmcgaW50byBhbiBvYmplY3QuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF91cmkgT3B0aW9uYWwgc3RyaW5nIFVSSSB0byBwYXJzZVxuXHQgKi9cblx0c3RhdGljIHBhcnNlKG9wdF91cmkpIHtcblx0XHRyZXR1cm4gVXJpLm5vcm1hbGl6ZU9iamVjdChwYXJzZUZuXyhvcHRfdXJpKSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgbmFtZWQgcXVlcnkgcGFyYW1ldGVyLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgcGFyYW1ldGVyIHRvIHJlbW92ZS5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0cmVtb3ZlUGFyYW1ldGVyKG5hbWUpIHtcblx0XHR0aGlzLmVuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfKCk7XG5cdFx0dGhpcy5xdWVyeS5yZW1vdmUobmFtZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB1bmlxdWVuZXNzIHBhcmFtZXRlciBvZiB0aGUgdXJpLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRyZW1vdmVVbmlxdWUoKSB7XG5cdFx0dGhpcy5yZW1vdmVQYXJhbWV0ZXIoVXJpLlJBTkRPTV9QQVJBTSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgaGFzaC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGhhc2hcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0c2V0SGFzaChoYXNoKSB7XG5cdFx0dGhpcy51cmwuaGFzaCA9IGhhc2g7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgaG9zdG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBob3N0bmFtZVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXRIb3N0bmFtZShob3N0bmFtZSkge1xuXHRcdHRoaXMudXJsLmhvc3RuYW1lID0gaG9zdG5hbWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIHF1ZXJ5IHBhcmFtZXRlcnMsIGNsZWFyaW5nIHByZXZpb3VzIHZhbHVlc1xuXHQgKiBmb3IgdGhhdCBrZXkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHBhcmFtZXRlciB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZS5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0c2V0UGFyYW1ldGVyVmFsdWUobmFtZSwgdmFsdWUpIHtcblx0XHR0aGlzLnJlbW92ZVBhcmFtZXRlcihuYW1lKTtcblx0XHR0aGlzLmFkZFBhcmFtZXRlclZhbHVlKG5hbWUsIHZhbHVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2YWx1ZXMgb2YgdGhlIG5hbWVkIHF1ZXJ5IHBhcmFtZXRlcnMsIGNsZWFyaW5nIHByZXZpb3VzIHZhbHVlc1xuXHQgKiBmb3IgdGhhdCBrZXkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHBhcmFtZXRlciB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZS5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0c2V0UGFyYW1ldGVyVmFsdWVzKG5hbWUsIHZhbHVlcykge1xuXHRcdHRoaXMucmVtb3ZlUGFyYW1ldGVyKG5hbWUpO1xuXHRcdHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSkgPT4gdGhpcy5hZGRQYXJhbWV0ZXJWYWx1ZShuYW1lLCB2YWx1ZSkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHBhdGhuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcGF0aG5hbWVcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0c2V0UGF0aG5hbWUocGF0aG5hbWUpIHtcblx0XHR0aGlzLnVybC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHBvcnQgbnVtYmVyLlxuXHQgKiBAcGFyYW0geyp9IHBvcnQgUG9ydCBudW1iZXIuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHNldFBvcnQocG9ydCkge1xuXHRcdHRoaXMudXJsLnBvcnQgPSBwb3J0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBwYXJzaW5nIHRoZSBvcmlnaW5hbCBzdHJpbmcgdXJpXG5cdCAqIGludG8gYW4gb2JqZWN0LlxuXHQgKiBAcGFyYW0geyFmdW5jdGlvbigpfSBwYXJzZUZuXG5cdCAqL1xuXHRzdGF0aWMgc2V0UGFyc2VGbihwYXJzZUZuKSB7XG5cdFx0cGFyc2VGbl8gPSBwYXJzZUZuO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHByb3RvY29sLiBJZiBtaXNzaW5nIDxjb2RlPmh0dHA6PC9jb2RlPiBpcyB1c2VkIGFzIGRlZmF1bHQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b2NvbFxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRzZXRQcm90b2NvbChwcm90b2NvbCkge1xuXHRcdHRoaXMudXJsLnByb3RvY29sID0gcHJvdG9jb2w7XG5cdFx0aWYgKHRoaXMudXJsLnByb3RvY29sW3RoaXMudXJsLnByb3RvY29sLmxlbmd0aCAtIDFdICE9PSAnOicpIHtcblx0XHRcdHRoaXMudXJsLnByb3RvY29sICs9ICc6Jztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIGZvcm0gb2YgdGhlIHVybC5cblx0ICogQG92ZXJyaWRlXG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHR2YXIgaHJlZiA9ICcnO1xuXHRcdHZhciBob3N0ID0gdGhpcy5nZXRIb3N0KCk7XG5cdFx0aWYgKGhvc3QpIHtcblx0XHRcdGhyZWYgKz0gdGhpcy5nZXRQcm90b2NvbCgpICsgJy8vJztcblx0XHR9XG5cdFx0aHJlZiArPSBob3N0ICsgdGhpcy5nZXRQYXRobmFtZSgpICsgdGhpcy5nZXRTZWFyY2goKSArIHRoaXMuZ2V0SGFzaCgpO1xuXHRcdHJldHVybiBocmVmO1xuXHR9XG5cblx0LyoqXG5cdCAqIEpvaW5zIHRoZSBnaXZlbiBwYXRocy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGJhc2VQYXRoXG5cdCAqIEBwYXJhbSB7Li4uc3RyaW5nfSAuLi5wYXRocyBBbnkgbnVtYmVyIG9mIHBhdGhzIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSBiYXNlIHVybC5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGpvaW5QYXRocyhiYXNlUGF0aCwgLi4ucGF0aHMpIHtcblx0XHRpZiAoYmFzZVBhdGguY2hhckF0KGJhc2VQYXRoLmxlbmd0aCAtIDEpID09PSAnLycpIHtcblx0XHRcdGJhc2VQYXRoID0gYmFzZVBhdGguc3Vic3RyaW5nKDAsIGJhc2VQYXRoLmxlbmd0aCAtIDEpO1xuXHRcdH1cblx0XHRwYXRocyA9IHBhdGhzLm1hcChwYXRoID0+IHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnN1YnN0cmluZygxKSA6IHBhdGgpO1xuXHRcdHJldHVybiBbYmFzZVBhdGhdLmNvbmNhdChwYXRocykuam9pbignLycpLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cdH1cblxuXHQvKipcblx0ICogVVJMLWRlY29kZXMgdGhlIHN0cmluZy4gV2UgbmVlZCB0byBzcGVjaWFsbHkgaGFuZGxlICcrJ3MgYmVjYXVzZVxuXHQgKiB0aGUgamF2YXNjcmlwdCBsaWJyYXJ5IGRvZXNuJ3QgY29udmVydCB0aGVtIHRvIHNwYWNlcy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHVybCBkZWNvZGUuXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGRlY29kZWQge0Bjb2RlIHN0cn0uXG5cdCAqL1xuXHRzdGF0aWMgdXJsRGVjb2RlKHN0cikge1xuXHRcdHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcblx0fVxuXG59XG5cbi8qKlxuICogRGVmYXVsdCBwcm90b2NvbCB2YWx1ZS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAZGVmYXVsdCBodHRwOlxuICogQHN0YXRpY1xuICovXG5VcmkuREVGQVVMVF9QUk9UT0NPTCA9ICdodHRwOic7XG5cbi8qKlxuICogSG9zdG5hbWUgcGxhY2Vob2xkZXIuIFJlbGV2YW50IHRvIGludGVybmFsIHVzYWdlIG9ubHkuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHN0YXRpY1xuICovXG5VcmkuSE9TVE5BTUVfUExBQ0VIT0xERVIgPSAnaG9zdG5hbWUnICsgRGF0ZS5ub3coKTtcblxuLyoqXG4gKiBOYW1lIHVzZWQgYnkgdGhlIHBhcmFtIGdlbmVyYXRlZCBieSBgbWFrZVVuaXF1ZWAuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHN0YXRpY1xuICovXG5VcmkuUkFORE9NX1BBUkFNID0gJ3p4JztcblxuZXhwb3J0IGRlZmF1bHQgVXJpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IHBhcnNlRnJvbUFuY2hvciBmcm9tICcuL3BhcnNlRnJvbUFuY2hvcic7XG5cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiB1cmkgc3RyaW5nIGludG8gYW4gb2JqZWN0LiBUaGUgVVJMIGZ1bmN0aW9uIHdpbGwgYmUgdXNlZFxuICogd2hlbiBwcmVzZW50LCBvdGhlcndpc2Ugd2UnbGwgZmFsbCBiYWNrIHRvIHRoZSBhbmNob3Igbm9kZSBlbGVtZW50LlxuICogQHBhcmFtIHsqPX0gb3B0X3VyaSBPcHRpb25hbCBzdHJpbmcgVVJJIHRvIHBhcnNlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKG9wdF91cmkpIHtcblx0aWYgKGNvcmUuaXNGdW5jdGlvbihVUkwpICYmIFVSTC5sZW5ndGgpIHtcblx0XHRyZXR1cm4gbmV3IFVSTChvcHRfdXJpKTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gcGFyc2VGcm9tQW5jaG9yKG9wdF91cmkpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gdXJpIHN0cmluZyBpbnRvIGFuIG9iamVjdC5cbiAqIEBwYXJhbSB7Kj19IG9wdF91cmkgT3B0aW9uYWwgc3RyaW5nIFVSSSB0byBwYXJzZVxuICovXG5mdW5jdGlvbiBwYXJzZUZyb21BbmNob3Iob3B0X3VyaSkge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblx0bGluay5ocmVmID0gb3B0X3VyaTtcblx0cmV0dXJuIHtcblx0XHRoYXNoOiBsaW5rLmhhc2gsXG5cdFx0aG9zdG5hbWU6IGxpbmsuaG9zdG5hbWUsXG5cdFx0cGFzc3dvcmQ6IGxpbmsucGFzc3dvcmQsXG5cdFx0cGF0aG5hbWU6IGxpbmsucGF0aG5hbWVbMF0gPT09ICcvJyA/IGxpbmsucGF0aG5hbWUgOiAnLycgKyBsaW5rLnBhdGhuYW1lLFxuXHRcdHBvcnQ6IGxpbmsucG9ydCxcblx0XHRwcm90b2NvbDogbGluay5wcm90b2NvbCxcblx0XHRzZWFyY2g6IGxpbmsuc2VhcmNoLFxuXHRcdHVzZXJuYW1lOiBsaW5rLnVzZXJuYW1lXG5cdH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlRnJvbUFuY2hvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNZXRhbC5qcyBicm93c2VyIHVzZXIgYWdlbnQgZGV0ZWN0aW9uLiBJdCdzIGV4dHJlbWVseSByZWNvbW1lbmRlZCB0aGUgdXNhZ2VcbiAqIG9mIGZlYXR1cmUgY2hlY2tpbmcgb3ZlciBicm93c2VyIHVzZXIgYWdlbnQgc25pZmZpbmcuIFVuZm9ydHVuYXRlbHksIGluIHNvbWVcbiAqIHNpdHVhdGlvbnMgZmVhdHVyZSBjaGVja2luZyBjYW4gYmUgc2xvdyBvciBldmVuIGltcG9zc2libGUsIHRoZXJlZm9yZSB1c2VcbiAqIHRoaXMgdXRpbGl0eSB3aXRoIGNhdXRpb24uXG4gKiBAc2VlIDxhIGhyZWY9XCJodHRwOi8vd3d3LnVzZXJhZ2VudHN0cmluZy5jb20vXCI+VXNlciBhZ2VudCBzdHJpbmdzPC9hPi5cbiAqL1xuY2xhc3MgVUEge1xuXHQvKipcblx0ICogR2V0cyB0aGUgbmF0aXZlIHVzZXJBZ2VudCBzdHJpbmcgZnJvbSBuYXZpZ2F0b3IgaWYgaXQgZXhpc3RzLiBJZlxuXHQgKiBuYXZpZ2F0b3Igb3IgbmF2aWdhdG9yLnVzZXJBZ2VudCBzdHJpbmcgaXMgbWlzc2luZywgcmV0dXJucyBhbiBlbXB0eVxuXHQgKiBzdHJpbmcuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGdldE5hdGl2ZVVzZXJBZ2VudCgpIHtcblx0XHR2YXIgbmF2aWdhdG9yID0gVUEuZ2xvYmFscy53aW5kb3cubmF2aWdhdG9yO1xuXHRcdGlmIChuYXZpZ2F0b3IpIHtcblx0XHRcdHZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuXHRcdFx0aWYgKHVzZXJBZ2VudCkge1xuXHRcdFx0XHRyZXR1cm4gdXNlckFnZW50O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gJyc7XG5cdH1cblxuXHQvKipcblx0ICogV2hldGhlciB0aGUgdXNlciBhZ2VudCBjb250YWlucyB0aGUgZ2l2ZW4gc3RyaW5nLCBpZ25vcmluZyBjYXNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0Ki9cblx0c3RhdGljIG1hdGNoVXNlckFnZW50KHN0cikge1xuXHRcdHJldHVybiBVQS51c2VyQWdlbnQuaW5kZXhPZihzdHIpICE9PSAtMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUZXN0cyB0aGUgdXNlciBhZ2VudC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHVzZXJBZ2VudCBUaGUgdXNlciBhZ2VudCBzdHJpbmcuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyB0ZXN0VXNlckFnZW50KHVzZXJBZ2VudCkge1xuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIHRoZSB1c2VyIGFnZW50IHZhbHVlIGV4dHJhY3RlZCBmcm9tIGJyb3dzZXIgbmF0aXZlIHVzZXIgYWdlbnQuXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAc3RhdGljXG5cdFx0ICovXG5cdFx0VUEudXNlckFnZW50ID0gdXNlckFnZW50O1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0aGUgdXNlcidzIGJyb3dzZXIgaXMgT3BlcmEuXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHN0YXRpY1xuXHRcdCAqL1xuXHRcdFVBLmlzT3BlcmEgPSBVQS5tYXRjaFVzZXJBZ2VudCgnT3BlcmEnKSB8fCBVQS5tYXRjaFVzZXJBZ2VudCgnT1BSJyk7XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRoZSB1c2VyJ3MgYnJvd3NlciBpcyBJRS5cblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAc3RhdGljXG5cdFx0ICovXG5cdFx0VUEuaXNJZSA9IFVBLm1hdGNoVXNlckFnZW50KCdUcmlkZW50JykgfHwgVUEubWF0Y2hVc2VyQWdlbnQoJ01TSUUnKTtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdGhlIHVzZXIncyBicm93c2VyIGlzIEVkZ2UuXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHN0YXRpY1xuXHRcdCAqL1xuXHRcdFVBLmlzRWRnZSA9IFVBLm1hdGNoVXNlckFnZW50KCdFZGdlJyk7XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRoZSB1c2VyJ3MgYnJvd3NlciBpcyBJRSBvciBFZGdlLlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBzdGF0aWNcblx0XHQgKi9cblx0XHRVQS5pc0llT3JFZGdlID0gVUEuaXNJZSB8fCBVQS5pc0VkZ2U7XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRoZSB1c2VyJ3MgYnJvd3NlciBpcyBDaHJvbWUuXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHN0YXRpY1xuXHRcdCAqL1xuXHRcdFVBLmlzQ2hyb21lID0gKFVBLm1hdGNoVXNlckFnZW50KCdDaHJvbWUnKSB8fCBVQS5tYXRjaFVzZXJBZ2VudCgnQ3JpT1MnKSkgJiYgIVVBLmlzT3BlcmEgJiYgIVVBLmlzRWRnZTtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdGhlIHVzZXIncyBicm93c2VyIGlzIFNhZmFyaS5cblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAc3RhdGljXG5cdFx0ICovXG5cdFx0VUEuaXNTYWZhcmkgPSBVQS5tYXRjaFVzZXJBZ2VudCgnU2FmYXJpJykgJiYgIShVQS5pc0Nocm9tZSB8fCBVQS5pc09wZXJhIHx8IFVBLmlzRWRnZSk7XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRoZSB1c2VyJ3MgYnJvd3NlciBpcyBGaXJlZm94LlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBzdGF0aWNcblx0XHQgKi9cblx0XHRVQS5pc0ZpcmVmb3ggPSBVQS5tYXRjaFVzZXJBZ2VudCgnRmlyZWZveCcpO1xuXHR9XG59XG5cbi8qKlxuICogRXhwb3NlcyBnbG9iYWwgcmVmZXJlbmNlcy5cbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAc3RhdGljXG4gKi9cblVBLmdsb2JhbHMgPSB7XG5cdHdpbmRvdzogd2luZG93XG59O1xuXG5VQS50ZXN0VXNlckFnZW50KFVBLmdldE5hdGl2ZVVzZXJBZ2VudCgpKTtcblxuZXhwb3J0IGRlZmF1bHQgVUE7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBjb3JlIGZyb20gJy4uL2NvcmUnO1xuXG5jbGFzcyBhcnJheSB7XG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFycmF5cyBoYXZlIHRoZSBzYW1lIGNvbnRlbnQuXG5cdCAqIEBwYXJhbSB7IUFycmF5PCo+fSBhcnIxXG5cdCAqIEBwYXJhbSB7IUFycmF5PCo+fSBhcnIyXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgZXF1YWwoYXJyMSwgYXJyMikge1xuXHRcdGlmIChhcnIxLmxlbmd0aCAhPT0gYXJyMi5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBnaXZlbiBhcnJheSB0aGF0IGlzbid0IHVuZGVmaW5lZC5cblx0ICogQHBhcmFtIHshQXJyYXl9IGFyclxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKi9cblx0c3RhdGljIGZpcnN0RGVmaW5lZFZhbHVlKGFycikge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoYXJyW2ldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuIGFycltpXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVHJhbnNmb3JtcyB0aGUgaW5wdXQgbmVzdGVkIGFycmF5IHRvIGJlY29tZSBmbGF0LlxuXHQgKiBAcGFyYW0ge0FycmF5LjwqfEFycmF5LjwqPj59IGFyciBOZXN0ZWQgYXJyYXkgdG8gZmxhdHRlbi5cblx0ICogQHBhcmFtIHtBcnJheS48Kj59IG9wdF9vdXRwdXQgT3B0aW9uYWwgb3V0cHV0IGFycmF5LlxuXHQgKiBAcmV0dXJuIHtBcnJheS48Kj59IEZsYXQgYXJyYXkuXG5cdCAqL1xuXHRzdGF0aWMgZmxhdHRlbihhcnIsIG9wdF9vdXRwdXQpIHtcblx0XHR2YXIgb3V0cHV0ID0gb3B0X291dHB1dCB8fCBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJyW2ldKSkge1xuXHRcdFx0XHRhcnJheS5mbGF0dGVuKGFycltpXSwgb3V0cHV0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKGFycltpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhIHBhcnRpY3VsYXIgdmFsdWUgZnJvbSBhbiBhcnJheS5cblx0ICogQHBhcmFtIHtBcnJheS48VD59IGFyciBBcnJheSBmcm9tIHdoaWNoIHRvIHJlbW92ZSB2YWx1ZS5cblx0ICogQHBhcmFtIHtUfSBvYmogT2JqZWN0IHRvIHJlbW92ZS5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlbGVtZW50IHdhcyByZW1vdmVkLlxuXHQgKiBAdGVtcGxhdGUgVFxuXHQgKi9cblx0c3RhdGljIHJlbW92ZShhcnIsIG9iaikge1xuXHRcdHZhciBpID0gYXJyLmluZGV4T2Yob2JqKTtcblx0XHR2YXIgcnY7XG5cdFx0aWYgKCAocnYgPSBpID49IDApICkge1xuXHRcdFx0YXJyYXkucmVtb3ZlQXQoYXJyLCBpKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJ2O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgZnJvbSBhbiBhcnJheSB0aGUgZWxlbWVudCBhdCBpbmRleCBpXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFyciBBcnJheSBvciBhcnJheSBsaWtlIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJlbW92ZSB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGluZGV4IHRvIHJlbW92ZS5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlbGVtZW50IHdhcyByZW1vdmVkLlxuXHQgKi9cblx0c3RhdGljIHJlbW92ZUF0KGFyciwgaSkge1xuXHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJyLCBpLCAxKS5sZW5ndGggPT09IDE7XG5cdH1cblxuXHQvKipcblx0ICogU2xpY2VzIHRoZSBnaXZlbiBhcnJheSwganVzdCBsaWtlIEFycmF5LnByb3RvdHlwZS5zbGljZSwgYnV0IHRoaXNcblx0ICogaXMgZmFzdGVyIGFuZCB3b3JraW5nIG9uIGFsbCBhcnJheS1saWtlIG9iamVjdHMgKGxpa2UgYXJndW1lbnRzKS5cblx0ICogQHBhcmFtIHshT2JqZWN0fSBhcnIgQXJyYXktbGlrZSBvYmplY3QgdG8gc2xpY2UuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgaW5kZXggdGhhdCBzaG91bGQgc3RhcnQgdGhlIHNsaWNlLlxuXHQgKiBAcGFyYW0ge251bWJlcj19IG9wdF9lbmQgVGhlIGluZGV4IHdoZXJlIHRoZSBzbGljZSBzaG91bGQgZW5kLCBub3Rcblx0ICogICBpbmNsdWRlZCBpbiB0aGUgZmluYWwgYXJyYXkuIElmIG5vdCBnaXZlbiwgYWxsIGVsZW1lbnRzIGFmdGVyIHRoZVxuXHQgKiAgIHN0YXJ0IGluZGV4IHdpbGwgYmUgaW5jbHVkZWQuXG5cdCAqIEByZXR1cm4geyFBcnJheX1cblx0ICovXG5cdHN0YXRpYyBzbGljZShhcnIsIHN0YXJ0LCBvcHRfZW5kKSB7XG5cdFx0dmFyIHNsaWNlZCA9IFtdO1xuXHRcdHZhciBlbmQgPSBjb3JlLmlzRGVmKG9wdF9lbmQpID8gb3B0X2VuZCA6IGFyci5sZW5ndGg7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHNsaWNlZC5wdXNoKGFycltpXSk7XG5cdFx0fVxuXHRcdHJldHVybiBzbGljZWQ7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXk7XG4iLCIvKiFcbiAqIFBvbHlmaWxsIGZyb20gR29vZ2xlJ3MgQ2xvc3VyZSBMaWJyYXJ5LlxuICogQ29weXJpZ2h0IDIwMTMgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzeW5jID0ge307XG5cblxuLyoqXG4gKiBUaHJvdyBhbiBpdGVtIHdpdGhvdXQgaW50ZXJydXB0aW5nIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBjb250ZXh0LiAgRm9yXG4gKiBleGFtcGxlLCBpZiBwcm9jZXNzaW5nIGEgZ3JvdXAgb2YgaXRlbXMgaW4gYSBsb29wLCBzb21ldGltZXMgaXQgaXMgdXNlZnVsXG4gKiB0byByZXBvcnQgYW4gZXJyb3Igd2hpbGUgc3RpbGwgYWxsb3dpbmcgdGhlIHJlc3Qgb2YgdGhlIGJhdGNoIHRvIGJlXG4gKiBwcm9jZXNzZWQuXG4gKiBAcGFyYW0geyp9IGV4Y2VwdGlvblxuICovXG5hc3luYy50aHJvd0V4Y2VwdGlvbiA9IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuXHQvLyBFYWNoIHRocm93IG5lZWRzIHRvIGJlIGluIGl0cyBvd24gY29udGV4dC5cblx0YXN5bmMubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXhjZXB0aW9uO1xuXHR9KTtcbn07XG5cblxuLyoqXG4gKiBGaXJlcyB0aGUgcHJvdmlkZWQgY2FsbGJhY2sganVzdCBiZWZvcmUgdGhlIGN1cnJlbnQgY2FsbHN0YWNrIHVud2luZHMsIG9yIGFzXG4gKiBzb29uIGFzIHBvc3NpYmxlIGFmdGVyIHRoZSBjdXJyZW50IEpTIGV4ZWN1dGlvbiBjb250ZXh0LlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlRISVMpfSBjYWxsYmFja1xuICogQHBhcmFtIHtUSElTPX0gb3B0X2NvbnRleHQgT2JqZWN0IHRvIHVzZSBhcyB0aGUgXCJ0aGlzIHZhbHVlXCIgd2hlbiBjYWxsaW5nXG4gKiAgICAgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICogQHRlbXBsYXRlIFRISVNcbiAqL1xuYXN5bmMucnVuID0gZnVuY3Rpb24oY2FsbGJhY2ssIG9wdF9jb250ZXh0KSB7XG5cdGlmICghYXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8pIHtcblx0XHQvLyBOb3RoaW5nIGlzIGN1cnJlbnRseSBzY2hlZHVsZWQsIHNjaGVkdWxlIGl0IG5vdy5cblx0XHRhc3luYy5uZXh0VGljayhhc3luYy5ydW4ucHJvY2Vzc1dvcmtRdWV1ZSk7XG5cdFx0YXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8gPSB0cnVlO1xuXHR9XG5cblx0YXN5bmMucnVuLndvcmtRdWV1ZV8ucHVzaChcblx0XHRuZXcgYXN5bmMucnVuLldvcmtJdGVtXyhjYWxsYmFjaywgb3B0X2NvbnRleHQpKTtcbn07XG5cblxuLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuYXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8gPSBmYWxzZTtcblxuXG4vKiogQHByaXZhdGUgeyFBcnJheS48IWFzeW5jLnJ1bi5Xb3JrSXRlbV8+fSAqL1xuYXN5bmMucnVuLndvcmtRdWV1ZV8gPSBbXTtcblxuLyoqXG4gKiBSdW4gYW55IHBlbmRpbmcgYXN5bmMucnVuIHdvcmsgaXRlbXMuIFRoaXMgZnVuY3Rpb24gaXMgbm90IGludGVuZGVkXG4gKiBmb3IgZ2VuZXJhbCB1c2UsIGJ1dCBmb3IgdXNlIGJ5IGVudHJ5IHBvaW50IGhhbmRsZXJzIHRvIHJ1biBpdGVtcyBhaGVhZCBvZlxuICogYXN5bmMubmV4dFRpY2suXG4gKi9cbmFzeW5jLnJ1bi5wcm9jZXNzV29ya1F1ZXVlID0gZnVuY3Rpb24oKSB7XG5cdC8vIE5PVEU6IGFkZGl0aW9uYWwgd29yayBxdWV1ZSBpdGVtcyBtYXkgYmUgcHVzaGVkIHdoaWxlIHByb2Nlc3NpbmcuXG5cdHdoaWxlIChhc3luYy5ydW4ud29ya1F1ZXVlXy5sZW5ndGgpIHtcblx0XHQvLyBEb24ndCBsZXQgdGhlIHdvcmsgcXVldWUgZ3JvdyBpbmRlZmluaXRlbHkuXG5cdFx0dmFyIHdvcmtJdGVtcyA9IGFzeW5jLnJ1bi53b3JrUXVldWVfO1xuXHRcdGFzeW5jLnJ1bi53b3JrUXVldWVfID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB3b3JrSXRlbXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB3b3JrSXRlbSA9IHdvcmtJdGVtc1tpXTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHdvcmtJdGVtLmZuLmNhbGwod29ya0l0ZW0uc2NvcGUpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRhc3luYy50aHJvd0V4Y2VwdGlvbihlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBUaGVyZSBhcmUgbm8gbW9yZSB3b3JrIGl0ZW1zLCByZXNldCB0aGUgd29yayBxdWV1ZS5cblx0YXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8gPSBmYWxzZTtcbn07XG5cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBmaW5hbFxuICogQHN0cnVjdFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGZuXG4gKiBAcGFyYW0ge09iamVjdHxudWxsfHVuZGVmaW5lZH0gc2NvcGVcbiAqL1xuYXN5bmMucnVuLldvcmtJdGVtXyA9IGZ1bmN0aW9uKGZuLCBzY29wZSkge1xuXHQvKiogQGNvbnN0ICovXG5cdHRoaXMuZm4gPSBmbjtcblx0LyoqIEBjb25zdCAqL1xuXHR0aGlzLnNjb3BlID0gc2NvcGU7XG59O1xuXG5cbi8qKlxuICogRmlyZXMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrcyBhcyBzb29uIGFzIHBvc3NpYmxlIGFmdGVyIHRoZSBjdXJyZW50IEpTXG4gKiBleGVjdXRpb24gY29udGV4dC4gc2V0VGltZW91dCjigKYsIDApIGFsd2F5cyB0YWtlcyBhdCBsZWFzdCA1bXMgZm9yIGxlZ2FjeVxuICogcmVhc29ucy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpTQ09QRSl9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgYXMgc29vbiBhc1xuICogICAgIHBvc3NpYmxlLlxuICogQHBhcmFtIHtTQ09QRT19IG9wdF9jb250ZXh0IE9iamVjdCBpbiB3aG9zZSBzY29wZSB0byBjYWxsIHRoZSBsaXN0ZW5lci5cbiAqIEB0ZW1wbGF0ZSBTQ09QRVxuICovXG5hc3luYy5uZXh0VGljayA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBvcHRfY29udGV4dCkge1xuXHR2YXIgY2IgPSBjYWxsYmFjaztcblx0aWYgKG9wdF9jb250ZXh0KSB7XG5cdFx0Y2IgPSBjYWxsYmFjay5iaW5kKG9wdF9jb250ZXh0KTtcblx0fVxuXHRjYiA9IGFzeW5jLm5leHRUaWNrLndyYXBDYWxsYmFja18oY2IpO1xuXHQvLyBJbnRyb2R1Y2VkIGFuZCBjdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgYnkgSUUxMC5cblx0Ly8gVmVyaWZ5IGlmIHZhcmlhYmxlIGlzIGRlZmluZWQgb24gdGhlIGN1cnJlbnQgcnVudGltZSAoaS5lLiwgbm9kZSwgYnJvd3NlcikuXG5cdC8vIENhbid0IHVzZSB0eXBlb2YgZW5jbG9zZWQgaW4gYSBmdW5jdGlvbiAoc3VjaCBhcyBjb3JlLmlzRnVuY3Rpb24pIG9yIGFuXG5cdC8vIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgb24gYW4gZW52aXJvbm1lbnRcblx0Ly8gd2hlcmUgdGhlIHZhcmlhYmxlIGlzIHVuZGVmaW5lZC5cblx0aWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRzZXRJbW1lZGlhdGUoY2IpO1xuXHRcdHJldHVybjtcblx0fVxuXHQvLyBMb29rIGZvciBhbmQgY2FjaGUgdGhlIGN1c3RvbSBmYWxsYmFjayB2ZXJzaW9uIG9mIHNldEltbWVkaWF0ZS5cblx0aWYgKCFhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfKSB7XG5cdFx0YXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXyA9IGFzeW5jLm5leHRUaWNrLmdldFNldEltbWVkaWF0ZUVtdWxhdG9yXygpO1xuXHR9XG5cdGFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8oY2IpO1xufTtcblxuXG4vKipcbiAqIENhY2hlIGZvciB0aGUgc2V0SW1tZWRpYXRlIGltcGxlbWVudGF0aW9uLlxuICogQHR5cGUge2Z1bmN0aW9uKGZ1bmN0aW9uKCkpfVxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXyA9IG51bGw7XG5cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBiZXN0IHBvc3NpYmxlIGltcGxlbWVudGF0aW9uIHRvIHJ1biBhIGZ1bmN0aW9uIGFzIHNvb24gYXNcbiAqIHRoZSBKUyBldmVudCBsb29wIGlzIGlkbGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihmdW5jdGlvbigpKX0gVGhlIFwic2V0SW1tZWRpYXRlXCIgaW1wbGVtZW50YXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay5nZXRTZXRJbW1lZGlhdGVFbXVsYXRvcl8gPSBmdW5jdGlvbigpIHtcblx0Ly8gQ3JlYXRlIGEgcHJpdmF0ZSBtZXNzYWdlIGNoYW5uZWwgYW5kIHVzZSBpdCB0byBwb3N0TWVzc2FnZSBlbXB0eSBtZXNzYWdlc1xuXHQvLyB0byBvdXJzZWx2ZXMuXG5cdHZhciBDaGFubmVsO1xuXG5cdC8vIFZlcmlmeSBpZiB2YXJpYWJsZSBpcyBkZWZpbmVkIG9uIHRoZSBjdXJyZW50IHJ1bnRpbWUgKGkuZS4sIG5vZGUsIGJyb3dzZXIpLlxuXHQvLyBDYW4ndCB1c2UgdHlwZW9mIGVuY2xvc2VkIGluIGEgZnVuY3Rpb24gKHN1Y2ggYXMgY29yZS5pc0Z1bmN0aW9uKSBvciBhblxuXHQvLyBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24gd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGFuIGVudmlyb25tZW50XG5cdC8vIHdoZXJlIHRoZSB2YXJpYWJsZSBpcyB1bmRlZmluZWQuXG5cdGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgPT09ICdmdW5jdGlvbicpIHtcblx0XHRDaGFubmVsID0gTWVzc2FnZUNoYW5uZWw7XG5cdH1cblxuXHQvLyBJZiBNZXNzYWdlQ2hhbm5lbCBpcyBub3QgYXZhaWxhYmxlIGFuZCB3ZSBhcmUgaW4gYSBicm93c2VyLCBpbXBsZW1lbnRcblx0Ly8gYW4gaWZyYW1lIGJhc2VkIHBvbHlmaWxsIGluIGJyb3dzZXJzIHRoYXQgaGF2ZSBwb3N0TWVzc2FnZSBhbmRcblx0Ly8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lci4gVGhlIGxhdHRlciBleGNsdWRlcyBJRTggYmVjYXVzZSBpdCBoYXMgYVxuXHQvLyBzeW5jaHJvbm91cyBwb3N0TWVzc2FnZSBpbXBsZW1lbnRhdGlvbi5cblx0aWYgKHR5cGVvZiBDaGFubmVsID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdC8qKiBAY29uc3RydWN0b3IgKi9cblx0XHRDaGFubmVsID0gZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBNYWtlIGFuIGVtcHR5LCBpbnZpc2libGUgaWZyYW1lLlxuXHRcdFx0dmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXHRcdFx0aWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0XHRpZnJhbWUuc3JjID0gJyc7XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblx0XHRcdHZhciB3aW4gPSBpZnJhbWUuY29udGVudFdpbmRvdztcblx0XHRcdHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG5cdFx0XHRkb2Mub3BlbigpO1xuXHRcdFx0ZG9jLndyaXRlKCcnKTtcblx0XHRcdGRvYy5jbG9zZSgpO1xuXHRcdFx0dmFyIG1lc3NhZ2UgPSAnY2FsbEltbWVkaWF0ZScgKyBNYXRoLnJhbmRvbSgpO1xuXHRcdFx0dmFyIG9yaWdpbiA9IHdpbi5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyB3aW4ubG9jYXRpb24uaG9zdDtcblx0XHRcdHZhciBvbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdC8vIFZhbGlkYXRlIG9yaWdpbiBhbmQgbWVzc2FnZSB0byBtYWtlIHN1cmUgdGhhdCB0aGlzIG1lc3NhZ2Ugd2FzXG5cdFx0XHRcdC8vIGludGVuZGVkIGZvciB1cy5cblx0XHRcdFx0aWYgKGUub3JpZ2luICE9PSBvcmlnaW4gJiYgZS5kYXRhICE9PSBtZXNzYWdlKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucG9ydDEub25tZXNzYWdlKCk7XG5cdFx0XHR9LmJpbmQodGhpcyk7XG5cdFx0XHR3aW4uYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9ubWVzc2FnZSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5wb3J0MSA9IHt9O1xuXHRcdFx0dGhpcy5wb3J0MiA9IHtcblx0XHRcdFx0cG9zdE1lc3NhZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHdpbi5wb3N0TWVzc2FnZShtZXNzYWdlLCBvcmlnaW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cblx0aWYgKHR5cGVvZiBDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuXHRcdHZhciBjaGFubmVsID0gbmV3IENoYW5uZWwoKTtcblx0XHQvLyBVc2UgYSBmaWZvIGxpbmtlZCBsaXN0IHRvIGNhbGwgY2FsbGJhY2tzIGluIHRoZSByaWdodCBvcmRlci5cblx0XHR2YXIgaGVhZCA9IHt9O1xuXHRcdHZhciB0YWlsID0gaGVhZDtcblx0XHRjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aGVhZCA9IGhlYWQubmV4dDtcblx0XHRcdHZhciBjYiA9IGhlYWQuY2I7XG5cdFx0XHRoZWFkLmNiID0gbnVsbDtcblx0XHRcdGNiKCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oY2IpIHtcblx0XHRcdHRhaWwubmV4dCA9IHtcblx0XHRcdFx0Y2I6IGNiXG5cdFx0XHR9O1xuXHRcdFx0dGFpbCA9IHRhaWwubmV4dDtcblx0XHRcdGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG5cdFx0fTtcblx0fVxuXHQvLyBJbXBsZW1lbnRhdGlvbiBmb3IgSUU2LTg6IFNjcmlwdCBlbGVtZW50cyBmaXJlIGFuIGFzeW5jaHJvbm91c1xuXHQvLyBvbnJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2hlbiBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG5cdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmICdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluXG5cdFx0ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oY2IpIHtcblx0XHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblx0XHRcdHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gQ2xlYW4gdXAgYW5kIGNhbGwgdGhlIGNhbGxiYWNrLlxuXHRcdFx0XHRzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblx0XHRcdFx0c2NyaXB0ID0gbnVsbDtcblx0XHRcdFx0Y2IoKTtcblx0XHRcdFx0Y2IgPSBudWxsO1xuXHRcdFx0fTtcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXHRcdH07XG5cdH1cblx0Ly8gRmFsbCBiYWNrIHRvIHNldFRpbWVvdXQgd2l0aCAwLiBJbiBicm93c2VycyB0aGlzIGNyZWF0ZXMgYSBkZWxheSBvZiA1bXNcblx0Ly8gb3IgbW9yZS5cblx0cmV0dXJuIGZ1bmN0aW9uKGNiKSB7XG5cdFx0c2V0VGltZW91dChjYiwgMCk7XG5cdH07XG59O1xuXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgaXMgb3ZlcnJpZGVkIHRvIHByb3RlY3QgY2FsbGJhY2tzIHdpdGggZW50cnkgcG9pbnRcbiAqIG1vbml0b3IgaWYgdGhlIGFwcGxpY2F0aW9uIG1vbml0b3JzIGVudHJ5IHBvaW50cy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSBhcyBzb29uIGFzIHBvc3NpYmxlLlxuICogQHJldHVybiB7ZnVuY3Rpb24oKX0gVGhlIHdyYXBwZWQgY2FsbGJhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay53cmFwQ2FsbGJhY2tfID0gZnVuY3Rpb24ob3B0X3JldHVyblZhbHVlKSB7XG5cdHJldHVybiBvcHRfcmV0dXJuVmFsdWU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgY29yZSB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqIEBjb25zdFxuICovXG5jbGFzcyBjb3JlIHtcblx0LyoqXG5cdCAqIFdoZW4gZGVmaW5pbmcgYSBjbGFzcyBGb28gd2l0aCBhbiBhYnN0cmFjdCBtZXRob2QgYmFyKCksIHlvdSBjYW4gZG86XG5cdCAqIEZvby5wcm90b3R5cGUuYmFyID0gY29yZS5hYnN0cmFjdE1ldGhvZFxuXHQgKlxuXHQgKiBOb3cgaWYgYSBzdWJjbGFzcyBvZiBGb28gZmFpbHMgdG8gb3ZlcnJpZGUgYmFyKCksIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duXG5cdCAqIHdoZW4gYmFyKCkgaXMgaW52b2tlZC5cblx0ICpcblx0ICogQHR5cGUgeyFGdW5jdGlvbn1cblx0ICogQHRocm93cyB7RXJyb3J9IHdoZW4gaW52b2tlZCB0byBpbmRpY2F0ZSB0aGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuXHQgKi9cblx0c3RhdGljIGFic3RyYWN0TWV0aG9kKCkge1xuXHRcdHRocm93IEVycm9yKCdVbmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExvb3BzIGNvbnN0cnVjdG9yIHN1cGVyIGNsYXNzZXMgY29sbGVjdGluZyBpdHMgcHJvcGVydGllcyB2YWx1ZXMuIElmXG5cdCAqIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIHN1cGVyIGNsYXNzIGB1bmRlZmluZWRgIHdpbGwgYmVcblx0ICogY29sbGVjdGVkIGFzIHZhbHVlIGZvciB0aGUgY2xhc3MgaGllcmFyY2h5IHBvc2l0aW9uLlxuXHQgKiBAcGFyYW0geyFmdW5jdGlvbigpfSBjb25zdHJ1Y3RvciBDbGFzcyBjb25zdHJ1Y3Rvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZSBQcm9wZXJ0eSBuYW1lIHRvIGJlIGNvbGxlY3RlZC5cblx0ICogQHJldHVybiB7QXJyYXkuPCo+fSBBcnJheSBvZiBjb2xsZWN0ZWQgdmFsdWVzLlxuXHQgKiBUT0RPKCopOiBSZXRoaW5rIHN1cGVyY2xhc3MgbG9vcC5cblx0ICovXG5cdHN0YXRpYyBjb2xsZWN0U3VwZXJDbGFzc2VzUHJvcGVydHkoY29uc3RydWN0b3IsIHByb3BlcnR5TmFtZSkge1xuXHRcdHZhciBwcm9wZXJ0eVZhbHVlcyA9IFtjb25zdHJ1Y3Rvcltwcm9wZXJ0eU5hbWVdXTtcblx0XHR3aGlsZSAoY29uc3RydWN0b3IuX19wcm90b19fICYmICFjb25zdHJ1Y3Rvci5fX3Byb3RvX18uaXNQcm90b3R5cGVPZihGdW5jdGlvbikpIHtcblx0XHRcdGNvbnN0cnVjdG9yID0gY29uc3RydWN0b3IuX19wcm90b19fO1xuXHRcdFx0cHJvcGVydHlWYWx1ZXMucHVzaChjb25zdHJ1Y3Rvcltwcm9wZXJ0eU5hbWVdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHByb3BlcnR5VmFsdWVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIGdpdmVuIGZ1bmN0aW9uLiBJZiB0aGUgY3VycmVudCBicm93c2VyIGRvZXNuJ3Rcblx0ICogc3VwcG9ydCB0aGUgYG5hbWVgIHByb3BlcnR5LCB0aGlzIHdpbGwgY2FsY3VsYXRlIGl0IGZyb20gdGhlIGZ1bmN0aW9uJ3Ncblx0ICogY29udGVudCBzdHJpbmcuXG5cdCAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGZuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdHN0YXRpYyBnZXRGdW5jdGlvbk5hbWUoZm4pIHtcblx0XHRpZiAoIWZuLm5hbWUpIHtcblx0XHRcdHZhciBzdHIgPSBmbi50b1N0cmluZygpO1xuXHRcdFx0Zm4ubmFtZSA9IHN0ci5zdWJzdHJpbmcoOSwgc3RyLmluZGV4T2YoJygnKSk7XG5cdFx0fVxuXHRcdHJldHVybiBmbi5uYW1lO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgYW4gdW5pcXVlIGlkLiBJZiBgb3B0X29iamVjdGAgYXJndW1lbnQgaXMgcGFzc2VkLCB0aGUgb2JqZWN0IGlzXG5cdCAqIG11dGF0ZWQgd2l0aCBhbiB1bmlxdWUgaWQuIENvbnNlY3V0aXZlIGNhbGxzIHdpdGggdGhlIHNhbWUgb2JqZWN0XG5cdCAqIHJlZmVyZW5jZSB3b24ndCBtdXRhdGUgdGhlIG9iamVjdCBhZ2FpbiwgaW5zdGVhZCB0aGUgY3VycmVudCBvYmplY3QgdWlkXG5cdCAqIHJldHVybnMuIFNlZSB7QGxpbmsgY29yZS5VSURfUFJPUEVSVFl9LlxuXHQgKiBAdHlwZSB7b3B0X29iamVjdH0gT3B0aW9uYWwgb2JqZWN0IHRvIGJlIG11dGF0ZWQgd2l0aCB0aGUgdWlkLiBJZiBub3Rcblx0ICogICAgIHNwZWNpZmllZCB0aGlzIG1ldGhvZCBvbmx5IHJldHVybnMgdGhlIHVpZC5cblx0ICogQHRocm93cyB7RXJyb3J9IHdoZW4gaW52b2tlZCB0byBpbmRpY2F0ZSB0aGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuXHQgKi9cblx0c3RhdGljIGdldFVpZChvcHRfb2JqZWN0KSB7XG5cdFx0aWYgKG9wdF9vYmplY3QpIHtcblx0XHRcdHJldHVybiBvcHRfb2JqZWN0W2NvcmUuVUlEX1BST1BFUlRZXSB8fFxuXHRcdFx0XHQob3B0X29iamVjdFtjb3JlLlVJRF9QUk9QRVJUWV0gPSBjb3JlLnVuaXF1ZUlkQ291bnRlcl8rKyk7XG5cdFx0fVxuXHRcdHJldHVybiBjb3JlLnVuaXF1ZUlkQ291bnRlcl8rKztcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgaWRlbnRpdHkgZnVuY3Rpb24uIFJldHVybnMgaXRzIGZpcnN0IGFyZ3VtZW50LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfcmV0dXJuVmFsdWUgVGhlIHNpbmdsZSB2YWx1ZSB0aGF0IHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4gez99IFRoZSBmaXJzdCBhcmd1bWVudC5cblx0ICovXG5cdHN0YXRpYyBpZGVudGl0eUZ1bmN0aW9uKG9wdF9yZXR1cm5WYWx1ZSkge1xuXHRcdHJldHVybiBvcHRfcmV0dXJuVmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBib29sZWFuLlxuXHQgKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGJvb2xlYW4uXG5cdCAqL1xuXHRzdGF0aWMgaXNCb29sZWFuKHZhbCkge1xuXHRcdHJldHVybiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbic7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgbm90IHVuZGVmaW5lZC5cblx0ICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBkZWZpbmVkLlxuXHQgKi9cblx0c3RhdGljIGlzRGVmKHZhbCkge1xuXHRcdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgbm90IHVuZGVmaW5lZCBvciBudWxsLlxuXHQgKiBAcGFyYW0geyp9IHZhbFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0c3RhdGljIGlzRGVmQW5kTm90TnVsbCh2YWwpIHtcblx0XHRyZXR1cm4gY29yZS5pc0RlZih2YWwpICYmICFjb3JlLmlzTnVsbCh2YWwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGRvY3VtZW50LlxuXHQgKiBAcGFyYW0geyp9IHZhbFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0c3RhdGljIGlzRG9jdW1lbnQodmFsKSB7XG5cdFx0cmV0dXJuIHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwubm9kZVR5cGUgPT09IDk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgZG9tIGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgaXNFbGVtZW50KHZhbCkge1xuXHRcdHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsLm5vZGVUeXBlID09PSAxO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG5cdCAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYSBmdW5jdGlvbi5cblx0ICovXG5cdHN0YXRpYyBpc0Z1bmN0aW9uKHZhbCkge1xuXHRcdHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBudWxsLlxuXHQgKiBAcGFyYW0geyp9IHZhbFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0c3RhdGljIGlzTnVsbCh2YWwpIHtcblx0XHRyZXR1cm4gdmFsID09PSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgbnVtYmVyLlxuXHQgKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGEgbnVtYmVyLlxuXHQgKi9cblx0c3RhdGljIGlzTnVtYmVyKHZhbCkge1xuXHRcdHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSB3aW5kb3cuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgaXNXaW5kb3codmFsKSB7XG5cdFx0cmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB2YWwgPT09IHZhbC53aW5kb3c7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gb2JqZWN0LiBUaGlzIGluY2x1ZGVzIGFycmF5c1xuXHQgKiBhbmQgZnVuY3Rpb25zLlxuXHQgKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGFuIG9iamVjdC5cblx0ICovXG5cdHN0YXRpYyBpc09iamVjdCh2YWwpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG5cdFx0cmV0dXJuIHR5cGUgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCB8fCB0eXBlID09PSAnZnVuY3Rpb24nO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIFByb21pc2UuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgaXNQcm9taXNlKHZhbCkge1xuXHRcdHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIHN0cmluZy5cblx0ICogQHBhcmFtIHsqfSB2YWxcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdHN0YXRpYyBpc1N0cmluZyh2YWwpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG5cdH1cblxuXHQvKipcblx0ICogTWVyZ2VzIHRoZSB2YWx1ZXMgb2YgYSBzdGF0aWMgcHJvcGVydHkgYSBjbGFzcyB3aXRoIHRoZSB2YWx1ZXMgb2YgdGhhdFxuXHQgKiBwcm9wZXJ0eSBmb3IgYWxsIGl0cyBzdXBlciBjbGFzc2VzLCBhbmQgc3RvcmVzIGl0IGFzIGEgbmV3IHN0YXRpY1xuXHQgKiBwcm9wZXJ0eSBvZiB0aGF0IGNsYXNzLiBJZiB0aGUgc3RhdGljIHByb3BlcnR5IGFscmVhZHkgZXhpc3RlZCwgaXQgd29uJ3Rcblx0ICogYmUgcmVjYWxjdWxhdGVkLlxuXHQgKiBAcGFyYW0geyFmdW5jdGlvbigpfSBjb25zdHJ1Y3RvciBDbGFzcyBjb25zdHJ1Y3Rvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZSBQcm9wZXJ0eSBuYW1lIHRvIGJlIGNvbGxlY3RlZC5cblx0ICogQHBhcmFtIHtmdW5jdGlvbigqLCAqKToqPX0gb3B0X21lcmdlRm4gRnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhbiBhcnJheSBmaWxsZWRcblx0ICogICB3aXRoIHRoZSB2YWx1ZXMgb2YgdGhlIHByb3BlcnR5IGZvciB0aGUgY3VycmVudCBjbGFzcyBhbmQgYWxsIGl0cyBzdXBlciBjbGFzc2VzLlxuXHQgKiAgIFNob3VsZCByZXR1cm4gdGhlIG1lcmdlZCB2YWx1ZSB0byBiZSBzdG9yZWQgb24gdGhlIGN1cnJlbnQgY2xhc3MuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBtZXJnZSBoYXBwZW5zLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqL1xuXHRzdGF0aWMgbWVyZ2VTdXBlckNsYXNzZXNQcm9wZXJ0eShjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lLCBvcHRfbWVyZ2VGbikge1xuXHRcdHZhciBtZXJnZWROYW1lID0gcHJvcGVydHlOYW1lICsgJ19NRVJHRUQnO1xuXHRcdGlmIChjb25zdHJ1Y3Rvci5oYXNPd25Qcm9wZXJ0eShtZXJnZWROYW1lKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciBtZXJnZWQgPSBjb3JlLmNvbGxlY3RTdXBlckNsYXNzZXNQcm9wZXJ0eShjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lKTtcblx0XHRpZiAob3B0X21lcmdlRm4pIHtcblx0XHRcdG1lcmdlZCA9IG9wdF9tZXJnZUZuKG1lcmdlZCk7XG5cdFx0fVxuXHRcdGNvbnN0cnVjdG9yW21lcmdlZE5hbWVdID0gbWVyZ2VkO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIE51bGwgZnVuY3Rpb24gdXNlZCBmb3IgZGVmYXVsdCB2YWx1ZXMgb2YgY2FsbGJhY2tzLCBldGMuXG5cdCAqIEByZXR1cm4ge3ZvaWR9IE5vdGhpbmcuXG5cdCAqL1xuXHRzdGF0aWMgbnVsbEZ1bmN0aW9uKCkge31cbn1cblxuLyoqXG4gKiBVbmlxdWUgaWQgcHJvcGVydHkgcHJlZml4LlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuY29yZS5VSURfUFJPUEVSVFkgPSAnY29yZV8nICsgKChNYXRoLnJhbmRvbSgpICogMWU5KSA+Pj4gMCk7XG5cbi8qKlxuICogQ291bnRlciBmb3IgdW5pcXVlIGlkLlxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvcmUudW5pcXVlSWRDb3VudGVyXyA9IDE7XG5cbmV4cG9ydCBkZWZhdWx0IGNvcmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGlzcG9zYWJsZSB1dGlsaXR5LiBXaGVuIGluaGVyaXRlZCBwcm92aWRlcyB0aGUgYGRpc3Bvc2VgIGZ1bmN0aW9uIHRvIGl0c1xuICogc3ViY2xhc3MsIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciBkaXNwb3Npbmcgb2YgYW55IG9iamVjdCByZWZlcmVuY2VzXG4gKiB3aGVuIGFuIGluc3RhbmNlIHdvbid0IGJlIHVzZWQgYW55bW9yZS4gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGVcbiAqIGBkaXNwb3NlSW50ZXJuYWxgIHRvIGltcGxlbWVudCBhbnkgc3BlY2lmaWMgZGlzcG9zaW5nIGxvZ2ljLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIERpc3Bvc2FibGUge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHQvKipcblx0XHQgKiBGbGFnIGluZGljYXRpbmcgaWYgdGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLmRpc3Bvc2VkXyA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIERpc3Bvc2VzIG9mIHRoaXMgaW5zdGFuY2UncyBvYmplY3QgcmVmZXJlbmNlcy4gQ2FsbHMgYGRpc3Bvc2VJbnRlcm5hbGAuXG5cdCAqL1xuXHRkaXNwb3NlKCkge1xuXHRcdGlmICghdGhpcy5kaXNwb3NlZF8pIHtcblx0XHRcdHRoaXMuZGlzcG9zZUludGVybmFsKCk7XG5cdFx0XHR0aGlzLmRpc3Bvc2VkXyA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGltcGxlbWVudCBhbnkgc3BlY2lmaWNcblx0ICogZGlzcG9zaW5nIGxvZ2ljIChsaWtlIGNsZWFyaW5nIHJlZmVyZW5jZXMgYW5kIGNhbGxpbmcgYGRpc3Bvc2VgIG9uIG90aGVyXG5cdCAqIGRpc3Bvc2FibGVzKS5cblx0ICovXG5cdGRpc3Bvc2VJbnRlcm5hbCgpIHt9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGlzIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0Rpc3Bvc2VkKCkge1xuXHRcdHJldHVybiB0aGlzLmRpc3Bvc2VkXztcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBEaXNwb3NhYmxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgY29yZSBmcm9tICcuL2NvcmUnO1xuaW1wb3J0IGFycmF5IGZyb20gJy4vYXJyYXkvYXJyYXknO1xuaW1wb3J0IGFzeW5jIGZyb20gJy4vYXN5bmMvYXN5bmMnO1xuaW1wb3J0IERpc3Bvc2FibGUgZnJvbSAnLi9kaXNwb3NhYmxlL0Rpc3Bvc2FibGUnO1xuaW1wb3J0IG9iamVjdCBmcm9tICcuL29iamVjdC9vYmplY3QnO1xuaW1wb3J0IHN0cmluZyBmcm9tICcuL3N0cmluZy9zdHJpbmcnO1xuXG5leHBvcnQgZGVmYXVsdCBjb3JlO1xuZXhwb3J0IHsgY29yZSwgYXJyYXksIGFzeW5jLCBEaXNwb3NhYmxlLCBvYmplY3QsIHN0cmluZyB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jbGFzcyBvYmplY3Qge1xuXHQvKipcblx0ICogQ29waWVzIGFsbCB0aGUgbWVtYmVycyBvZiBhIHNvdXJjZSBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRhcmdldCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7Li4uT2JqZWN0fSB2YXJfYXJncyBUaGUgb2JqZWN0cyBmcm9tIHdoaWNoIHZhbHVlcyB3aWxsIGJlIGNvcGllZC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSB0YXJnZXQgb2JqZWN0IHJlZmVyZW5jZS5cblx0ICovXG5cdHN0YXRpYyBtaXhpbih0YXJnZXQpIHtcblx0XHR2YXIga2V5LCBzb3VyY2U7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGZvciAoa2V5IGluIHNvdXJjZSkge1xuXHRcdFx0XHR0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gb2JqZWN0IGJhc2VkIG9uIGl0cyBmdWxseSBxdWFsaWZpZWQgZXh0ZXJuYWwgbmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lLlxuXHQgKiBAcGFyYW0ge29iamVjdD19IG9wdF9vYmogVGhlIG9iamVjdCB3aXRoaW4gd2hpY2ggdG8gbG9vazsgZGVmYXVsdCBpc1xuXHQgKiAgICAgPGNvZGU+d2luZG93PC9jb2RlPi5cblx0ICogQHJldHVybiB7P30gVGhlIHZhbHVlIChvYmplY3Qgb3IgcHJpbWl0aXZlKSBvciwgaWYgbm90IGZvdW5kLCB1bmRlZmluZWQuXG5cdCAqL1xuXHRzdGF0aWMgZ2V0T2JqZWN0QnlOYW1lKG5hbWUsIG9wdF9vYmopIHtcblx0XHR2YXIgc2NvcGUgPSBvcHRfb2JqIHx8IHdpbmRvdztcblx0XHR2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG5cdFx0cmV0dXJuIHBhcnRzLnJlZHVjZSgocGFydCwga2V5KSA9PiBwYXJ0W2tleV0sIHNjb3BlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgdGhlIGdpdmVuIG9uZSwgYnV0IHdpdGhcblx0ICogdGhlaXIgdmFsdWVzIHNldCB0byB0aGUgcmV0dXJuIHZhbHVlcyBvZiB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuXHQgKiBAcGFyYW0geyFPYmplY3R9IG9ialxuXHQgKiBAcGFyYW0geyFmdW5jdGlvbihzdHJpbmcsICopfSBmblxuXHQgKiBAcmV0dXJuIHshT2JqZWN0fVxuXHQgKi9cblx0c3RhdGljIG1hcChvYmosIGZuKSB7XG5cdFx0dmFyIG1hcHBlZE9iaiA9IHt9O1xuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdG1hcHBlZE9ialtrZXlzW2ldXSA9IGZuKGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG5cdFx0fVxuXHRcdHJldHVybiBtYXBwZWRPYmo7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgb2JqZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jbGFzcyBzdHJpbmcge1xuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgYnJlYWtpbmcgc3BhY2VzIGZyb20gdGhlIGxlZnQgYW5kIHJpZ2h0IG9mIHRoZSBzdHJpbmcgYW5kXG5cdCAqIGNvbGxhcHNlcyB0aGUgc2VxdWVuY2VzIG9mIGJyZWFraW5nIHNwYWNlcyBpbiB0aGUgbWlkZGxlIGludG8gc2luZ2xlIHNwYWNlcy5cblx0ICogVGhlIG9yaWdpbmFsIGFuZCB0aGUgcmVzdWx0IHN0cmluZ3MgcmVuZGVyIHRoZSBzYW1lIHdheSBpbiBIVE1MLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyIEEgc3RyaW5nIGluIHdoaWNoIHRvIGNvbGxhcHNlIHNwYWNlcy5cblx0ICogQHJldHVybiB7c3RyaW5nfSBDb3B5IG9mIHRoZSBzdHJpbmcgd2l0aCBub3JtYWxpemVkIGJyZWFraW5nIHNwYWNlcy5cblx0ICovXG5cdHN0YXRpYyBjb2xsYXBzZUJyZWFraW5nU3BhY2VzKHN0cikge1xuXHRcdHJldHVybiBzdHIucmVwbGFjZSgvW1xcdFxcclxcbiBdKy9nLCAnICcpLnJlcGxhY2UoL15bXFx0XFxyXFxuIF0rfFtcXHRcXHJcXG4gXSskL2csICcnKTtcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgYSBzdHJpbmcgd2l0aCBhdCBsZWFzdCA2NC1iaXRzIG9mIHJhbmRvbW5lc3MuXG5cdCogQHJldHVybiB7c3RyaW5nfSBBIHJhbmRvbSBzdHJpbmcsIGUuZy4gc24xczd2YjRnY2ljLlxuXHQqL1xuXHRzdGF0aWMgZ2V0UmFuZG9tU3RyaW5nKCkge1xuXHRcdHZhciB4ID0gMjE0NzQ4MzY0ODtcblx0XHRyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogeCkudG9TdHJpbmcoMzYpICtcblx0XHRcdE1hdGguYWJzKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHgpIF4gRGF0ZS5ub3coKSkudG9TdHJpbmcoMzYpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZXMgdGhlIGhhc2hjb2RlIGZvciBhIHN0cmluZy4gVGhlIGhhc2hjb2RlIHZhbHVlIGlzIGNvbXB1dGVkIGJ5XG5cdCAqIHRoZSBzdW0gYWxnb3JpdGhtOiBzWzBdKjMxXihuLTEpICsgc1sxXSozMV4obi0yKSArIC4uLiArIHNbbi0xXS4gQSBuaWNlXG5cdCAqIHByb3BlcnR5IG9mIHVzaW5nIDMxIHByaW1lIGlzIHRoYXQgdGhlIG11bHRpcGxpY2F0aW9uIGNhbiBiZSByZXBsYWNlZCBieVxuXHQgKiBhIHNoaWZ0IGFuZCBhIHN1YnRyYWN0aW9uIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2U6IDMxKmkgPT0gKGk8PDUpLWkuXG5cdCAqIE1vZGVybiBWTXMgZG8gdGhpcyBzb3J0IG9mIG9wdGltaXphdGlvbiBhdXRvbWF0aWNhbGx5LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsIFRhcmdldCBzdHJpbmcuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIGhhc2hjb2RlLlxuXHQgKi9cblx0c3RhdGljIGhhc2hDb2RlKHZhbCkge1xuXHRcdHZhciBoYXNoID0gMDtcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRoYXNoID0gMzEgKiBoYXNoICsgdmFsLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoICU9IDB4MTAwMDAwMDAwO1xuXHRcdH1cblx0XHRyZXR1cm4gaGFzaDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXBsYWNlcyBpbnRlcnZhbCBpbnRvIHRoZSBzdHJpbmcgd2l0aCBzcGVjaWZpZWQgdmFsdWUsIGUuZy5cblx0ICogYHJlcGxhY2VJbnRlcnZhbChcImFiY2RlXCIsIDEsIDQsIFwiXCIpYCByZXR1cm5zIFwiYWVcIi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgaW5wdXQgc3RyaW5nLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgU3RhcnQgaW50ZXJ2YWwgcG9zaXRpb24gdG8gYmUgcmVwbGFjZWQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgRW5kIGludGVydmFsIHBvc2l0aW9uIHRvIGJlIHJlcGxhY2VkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRoYXQgcmVwbGFjZXMgdGhlIHNwZWNpZmllZCBpbnRlcnZhbC5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0c3RhdGljIHJlcGxhY2VJbnRlcnZhbChzdHIsIHN0YXJ0LCBlbmQsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgc3RhcnQpICsgdmFsdWUgKyBzdHIuc3Vic3RyaW5nKGVuZCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RyaW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBhcnJheSwgYXN5bmMsIGNvcmUgfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgZG9tIGZyb20gJ21ldGFsLWRvbSc7XG5pbXBvcnQgQ2FuY2VsbGFibGVQcm9taXNlIGZyb20gJ21ldGFsLXByb21pc2UnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBFdmVudEhhbmRsZXIgfSBmcm9tICdtZXRhbC1ldmVudHMnO1xuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCBnbG9iYWxzIGZyb20gJy4uL2dsb2JhbHMvZ2xvYmFscyc7XG5pbXBvcnQgUm91dGUgZnJvbSAnLi4vcm91dGUvUm91dGUnO1xuaW1wb3J0IFNjcmVlbiBmcm9tICcuLi9zY3JlZW4vU2NyZWVuJztcbmltcG9ydCBTdXJmYWNlIGZyb20gJy4uL3N1cmZhY2UvU3VyZmFjZSc7XG5pbXBvcnQgVXJpIGZyb20gJ21ldGFsLXVyaSc7XG5cbmNsYXNzIEFwcCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cblx0LyoqXG5cdCAqIEFwcCBjbGFzcyB0aGF0IGhhbmRsZSByb3V0ZXMgYW5kIHNjcmVlbnMgbGlmZWN5Y2xlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQGV4dGVuZHMge0V2ZW50RW1pdHRlcn1cblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBIb2xkcyB0aGUgYWN0aXZlIHNjcmVlbi5cblx0XHQgKiBAdHlwZSB7P1NjcmVlbn1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5hY3RpdmVTY3JlZW4gPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgdGhlIGFjdGl2ZSBwYXRoIGNvbnRhaW5pbmcgdGhlIHF1ZXJ5IHBhcmFtZXRlcnMuXG5cdFx0ICogQHR5cGUgez9zdHJpbmd9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuYWN0aXZlUGF0aCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBbGxvd3MgcHJldmVudCBuYXZpZ2F0ZSBmcm9tIGRvbSBwcmV2ZW50ZWQgZXZlbnQuXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLmFsbG93UHJldmVudE5hdmlnYXRlID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIGxpbmsgYmFzZSBwYXRoLlxuXHRcdCAqIEB0eXBlIHshc3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0ICcnXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuYmFzZVBhdGggPSAnJztcblxuXHRcdC8qKlxuXHRcdCAqIENhcHR1cmVzIHNjcm9sbCBwb3NpdGlvbiBmcm9tIHNjcm9sbCBldmVudC5cblx0XHQgKiBAdHlwZSB7IWJvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLmNhcHR1cmVTY3JvbGxQb3NpdGlvbkZyb21TY3JvbGxFdmVudCA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBIb2xkcyB0aGUgZGVmYXVsdCBwYWdlIHRpdGxlLlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLmRlZmF1bHRUaXRsZSA9IGdsb2JhbHMuZG9jdW1lbnQudGl0bGU7XG5cblx0XHQvKipcblx0XHQgKiBIb2xkcyB0aGUgZm9ybSBzZWxlY3RvciB0byBkZWZpbmUgZm9ybXMgdGhhdCBhcmUgcm91dGVkLlxuXHRcdCAqIEB0eXBlIHshc3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IGZvcm1bZW5jdHlwZT1cIm11bHRpcGFydC9mb3JtLWRhdGFcIl06bm90KFtkYXRhLXNlbm5hLW9mZl0pXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuZm9ybVNlbGVjdG9yID0gJ2Zvcm1bZW5jdHlwZT1cIm11bHRpcGFydC9mb3JtLWRhdGFcIl06bm90KFtkYXRhLXNlbm5hLW9mZl0pJztcblxuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIHRoZSBsaW5rIHNlbGVjdG9yIHRvIGRlZmluZSBsaW5rcyB0aGF0IGFyZSByb3V0ZWQuXG5cdFx0ICogQHR5cGUgeyFzdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgYTpub3QoW2RhdGEtc2VubmEtb2ZmXSlcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5saW5rU2VsZWN0b3IgPSAnYTpub3QoW2RhdGEtc2VubmEtb2ZmXSknO1xuXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgdGhlIGxvYWRpbmcgY3NzIGNsYXNzLlxuXHRcdCAqIEB0eXBlIHshc3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IHNlbm5hLWxvYWRpbmdcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5sb2FkaW5nQ3NzQ2xhc3MgPSAnc2VubmEtbG9hZGluZyc7XG5cblx0XHQvKipcblx0XHQgKiBVc2luZyB0aGUgSGlzdG9yeSBBUEkgdG8gbWFuYWdlIHlvdXIgVVJMcyBpcyBhd2Vzb21lIGFuZCwgYXMgaXQgaGFwcGVucyxcblx0XHQgKiBhIGNydWNpYWwgZmVhdHVyZSBvZiBnb29kIHdlYiBhcHBzLiBPbmUgb2YgaXRzIGRvd25zaWRlcywgaG93ZXZlciwgaXNcblx0XHQgKiB0aGF0IHNjcm9sbCBwb3NpdGlvbnMgYXJlIHN0b3JlZCBhbmQgdGhlbiwgbW9yZSBpbXBvcnRhbnRseSwgcmVzdG9yZWRcblx0XHQgKiB3aGVuZXZlciB5b3UgdHJhdmVyc2UgdGhlIGhpc3RvcnkuIFRoaXMgb2Z0ZW4gbWVhbnMgdW5zaWdodGx5IGp1bXBzIGFzXG5cdFx0ICogdGhlIHNjcm9sbCBwb3NpdGlvbiBjaGFuZ2VzIGF1dG9tYXRpY2FsbHksIGFuZCBlc3BlY2lhbGx5IHNvIGlmIHlvdXIgYXBwXG5cdFx0ICogZG9lcyB0cmFuc2l0aW9ucywgb3IgY2hhbmdlcyB0aGUgY29udGVudHMgb2YgdGhlIHBhZ2UgaW4gYW55IHdheS5cblx0XHQgKiBVbHRpbWF0ZWx5IHRoaXMgbGVhZHMgdG8gYW4gaG9ycmlibGUgdXNlciBleHBlcmllbmNlLiBUaGUgZ29vZCBuZXdzIGlzLFxuXHRcdCAqIGhvd2V2ZXIsIHRoYXQgdGhlcmXigJlzIGEgcG90ZW50aWFsIGZpeDogaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbi5cblx0XHQgKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDE1LzA5L2hpc3RvcnktYXBpLXNjcm9sbC1yZXN0b3JhdGlvblxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLm5hdGl2ZVNjcm9sbFJlc3RvcmF0aW9uU3VwcG9ydGVkID0gKCdzY3JvbGxSZXN0b3JhdGlvbicgaW4gZ2xvYmFscy53aW5kb3cuaGlzdG9yeSk7XG5cblx0XHQvKipcblx0XHQgKiBIb2xkcyBhIGRlZmVycmVkIHdpdGggdGhlIGN1cnJlbnQgbmF2aWdhdGlvbi5cblx0XHQgKiBAdHlwZSB7P0NhbmNlbGxhYmxlUHJvbWlzZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMucGVuZGluZ05hdmlnYXRlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIHRoZSB3aW5kb3cgaG9yaXpvbnRhbCBzY3JvbGwgcG9zaXRpb24gd2hlbiB0aGUgbmF2aWdhdGlvbiB1c2luZ1xuXHRcdCAqIGJhY2sgb3IgZm9yd2FyZCBoYXBwZW5zIHRvIGJlIHJlc3RvcmVkIGFmdGVyIHRoZSBzdXJmYWNlcyBhcmUgdXBkYXRlZC5cblx0XHQgKiBAdHlwZSB7IU51bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMucG9wc3RhdGVTY3JvbGxMZWZ0ID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIHRoZSB3aW5kb3cgdmVydGljYWwgc2Nyb2xsIHBvc2l0aW9uIHdoZW4gdGhlIG5hdmlnYXRpb24gdXNpbmdcblx0XHQgKiBiYWNrIG9yIGZvcndhcmQgaGFwcGVucyB0byBiZSByZXN0b3JlZCBhZnRlciB0aGUgc3VyZmFjZXMgYXJlIHVwZGF0ZWQuXG5cdFx0ICogQHR5cGUgeyFOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLnBvcHN0YXRlU2Nyb2xsVG9wID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIHRoZSByZWRpcmVjdCBwYXRoIGNvbnRhaW5pbmcgdGhlIHF1ZXJ5IHBhcmFtZXRlcnMuXG5cdFx0ICogQHR5cGUgez9zdHJpbmd9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMucmVkaXJlY3RQYXRoID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIHRoZSBzY3JlZW4gcm91dGVzIGNvbmZpZ3VyYXRpb24uXG5cdFx0ICogQHR5cGUgez9BcnJheX1cblx0XHQgKiBAZGVmYXVsdCBbXVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLnJvdXRlcyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogTWFwcyB0aGUgc2NyZWVuIGluc3RhbmNlcyBieSB0aGUgdXJsIGNvbnRhaW5pbmcgdGhlIHBhcmFtZXRlcnMuXG5cdFx0ICogQHR5cGUgez9PYmplY3R9XG5cdFx0ICogQGRlZmF1bHQge31cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5zY3JlZW5zID0ge307XG5cblx0XHQvKipcblx0XHQgKiBXaGVuIHNldCB0byB0cnVlIHRoZSBmaXJzdCBlcnJvbmVvdXMgcG9wc3RhdGUgZmlyZWQgb24gcGFnZSBsb2FkIHdpbGwgYmVcblx0XHQgKiBpZ25vcmVkLCBvbmx5IGlmIDxjb2RlPmdsb2JhbHMud2luZG93Lmhpc3Rvcnkuc3RhdGU8L2NvZGU+IGlzIGFsc29cblx0XHQgKiA8Y29kZT5udWxsPC9jb2RlPi5cblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLnNraXBMb2FkUG9wc3RhdGUgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIE1hcHMgdGhhdCBpbmRleCB0aGUgc3VyZmFjZXMgaW5zdGFuY2VzIGJ5IHRoZSBzdXJmYWNlIGlkLlxuXHRcdCAqIEB0eXBlIHs/T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IHt9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuc3VyZmFjZXMgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gc2V0IHRvIHRydWUsIG1vdmVzIHRoZSBzY3JvbGwgcG9zaXRpb24gYWZ0ZXIgcG9wc3RhdGUsIG9yIHRvIHRoZVxuXHRcdCAqIHRvcCBvZiB0aGUgdmlld3BvcnQgZm9yIG5ldyBuYXZpZ2F0aW9uLiBJZiBmYWxzZSwgdGhlIGJyb3dzZXIgd2lsbFxuXHRcdCAqIHRha2UgY2FyZSBvZiBzY3JvbGwgcmVzdG9yYXRpb24uXG5cdFx0ICogQHR5cGUgeyFib29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy51cGRhdGVTY3JvbGxQb3NpdGlvbiA9IHRydWU7XG5cblx0XHR0aGlzLmFwcEV2ZW50SGFuZGxlcnNfID0gbmV3IEV2ZW50SGFuZGxlcigpO1xuXG5cdFx0dGhpcy5hcHBFdmVudEhhbmRsZXJzXy5hZGQoXG5cdFx0XHRkb20ub24oZ2xvYmFscy53aW5kb3csICdzY3JvbGwnLCB0aGlzLm9uU2Nyb2xsXy5iaW5kKHRoaXMpKSxcblx0XHRcdGRvbS5vbihnbG9iYWxzLndpbmRvdywgJ2xvYWQnLCB0aGlzLm9uTG9hZF8uYmluZCh0aGlzKSksXG5cdFx0XHRkb20ub24oZ2xvYmFscy53aW5kb3csICdwb3BzdGF0ZScsIHRoaXMub25Qb3BzdGF0ZV8uYmluZCh0aGlzKSlcblx0XHQpO1xuXG5cdFx0dGhpcy5vbignc3RhcnROYXZpZ2F0ZScsIHRoaXMub25TdGFydE5hdmlnYXRlXyk7XG5cdFx0dGhpcy5vbignYmVmb3JlTmF2aWdhdGUnLCB0aGlzLm9uQmVmb3JlTmF2aWdhdGVfKTtcblx0XHR0aGlzLm9uKCdiZWZvcmVOYXZpZ2F0ZScsIHRoaXMub25CZWZvcmVOYXZpZ2F0ZURlZmF1bHRfLCB0cnVlKTtcblxuXHRcdHRoaXMuc2V0TGlua1NlbGVjdG9yKHRoaXMubGlua1NlbGVjdG9yKTtcblx0XHR0aGlzLnNldEZvcm1TZWxlY3Rvcih0aGlzLmZvcm1TZWxlY3Rvcik7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBvbmUgb3IgbW9yZSBzY3JlZW5zIHRvIHRoZSBhcHBsaWNhdGlvbi5cblx0ICpcblx0ICogRXhhbXBsZTpcblx0ICpcblx0ICogPGNvZGU+XG5cdCAqICAgYXBwLmFkZFJvdXRlcyh7IHBhdGg6ICcvZm9vJywgaGFuZGxlcjogRm9vU2NyZWVuIH0pO1xuXHQgKiAgIG9yXG5cdCAqICAgYXBwLmFkZFJvdXRlcyhbeyBwYXRoOiAnL2ZvbycsIGhhbmRsZXI6IGZ1bmN0aW9uKHJvdXRlKSB7IHJldHVybiBuZXcgRm9vU2NyZWVuKCk7IH0gfV0pO1xuXHQgKiA8L2NvZGU+XG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvciB7QXJyYXl9IHJvdXRlcyBTaW5nbGUgb2JqZWN0IG9yIGFuIGFycmF5IG9mIG9iamVjdC5cblx0ICogICAgIEVhY2ggb2JqZWN0IHNob3VsZCBjb250YWluIDxjb2RlPnBhdGg8L2NvZGU+IGFuZCA8Y29kZT5zY3JlZW48L2NvZGU+LlxuXHQgKiAgICAgVGhlIDxjb2RlPnBhdGg8L2NvZGU+IHNob3VsZCBiZSBhIHN0cmluZyBvciBhIHJlZ2V4IHRoYXQgbWFwcyB0aGVcblx0ICogICAgIG5hdmlnYXRpb24gcm91dGUgdG8gYSBzY3JlZW4gY2xhc3MgZGVmaW5pdGlvbiAobm90IGFuIGluc3RhbmNlKSwgZS5nOlxuXHQgKiAgICAgICAgIDxjb2RlPnsgcGF0aDogXCIvaG9tZTpwYXJhbTFcIiwgaGFuZGxlcjogTXlTY3JlZW4gfTwvY29kZT5cblx0ICogICAgICAgICA8Y29kZT57IHBhdGg6IC9mb28uKy8sIGhhbmRsZXI6IE15U2NyZWVuIH08L2NvZGU+XG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGFkZFJvdXRlcyhyb3V0ZXMpIHtcblx0XHRpZiAoIUFycmF5LmlzQXJyYXkocm91dGVzKSkge1xuXHRcdFx0cm91dGVzID0gW3JvdXRlc107XG5cdFx0fVxuXHRcdHJvdXRlcy5mb3JFYWNoKChyb3V0ZSkgPT4ge1xuXHRcdFx0aWYgKCEocm91dGUgaW5zdGFuY2VvZiBSb3V0ZSkpIHtcblx0XHRcdFx0cm91dGUgPSBuZXcgUm91dGUocm91dGUucGF0aCwgcm91dGUuaGFuZGxlcik7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnJvdXRlcy5wdXNoKHJvdXRlKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIG9uZSBvciBtb3JlIHN1cmZhY2VzIHRvIHRoZSBhcHBsaWNhdGlvbi5cblx0ICogQHBhcmFtIHtTdXJmYWNlfFN0cmluZ3xBcnJheS48U3VyZmFjZXxTdHJpbmc+fSBzdXJmYWNlc1xuXHQgKiAgICAgU3VyZmFjZSBlbGVtZW50IGlkIG9yIHN1cmZhY2UgaW5zdGFuY2UuIFlvdSBjYW4gYWxzbyBwYXNzIGFuIEFycmF5XG5cdCAqICAgICB3aGljaGNvbnRhaW5zIHN1cmZhY2UgaW5zdGFuY2VzIG9yIGlkLiBJbiBjYXNlIG9mIElELCB0aGVzZSBzaG91bGQgYmVcblx0ICogICAgIHRoZSBpZCBvZiBzdXJmYWNlIGVsZW1lbnQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdGFkZFN1cmZhY2VzKHN1cmZhY2VzKSB7XG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KHN1cmZhY2VzKSkge1xuXHRcdFx0c3VyZmFjZXMgPSBbc3VyZmFjZXNdO1xuXHRcdH1cblx0XHRzdXJmYWNlcy5mb3JFYWNoKChzdXJmYWNlKSA9PiB7XG5cdFx0XHRpZiAoY29yZS5pc1N0cmluZyhzdXJmYWNlKSkge1xuXHRcdFx0XHRzdXJmYWNlID0gbmV3IFN1cmZhY2Uoc3VyZmFjZSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnN1cmZhY2VzW3N1cmZhY2UuZ2V0SWQoKV0gPSBzdXJmYWNlO1xuXHRcdH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgaWYgY2FuIG5hdmlnYXRlIHRvIHBhdGguXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gdXJsXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRjYW5OYXZpZ2F0ZSh1cmwpIHtcblx0XHR2YXIgcGF0aCA9IHV0aWxzLmdldFVybFBhdGgodXJsKTtcblx0XHR2YXIgdXJpID0gbmV3IFVyaSh1cmwpO1xuXG5cdFx0aWYgKCF0aGlzLmlzTGlua1NhbWVPcmlnaW5fKHVyaS5nZXRIb3N0bmFtZSgpKSkge1xuXHRcdFx0Y29uc29sZS5sb2coJ09mZnNpdGUgbGluayBjbGlja2VkJyk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGlmICghdGhpcy5pc1NhbWVCYXNlUGF0aF8ocGF0aCkpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdMaW5rIGNsaWNrZWQgb3V0c2lkZSBhcHBcXCdzIGJhc2UgcGF0aCcpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoIXRoaXMuZmluZFJvdXRlKHBhdGgpKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnTm8gcm91dGUgZm9yICcgKyBwYXRoKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhciBzY3JlZW5zIGNhY2hlLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRjbGVhclNjcmVlbnNDYWNoZSgpIHtcblx0XHRPYmplY3Qua2V5cyh0aGlzLnNjcmVlbnMpLmZvckVhY2goKHBhdGgpID0+IHtcblx0XHRcdGlmIChwYXRoID09PSB0aGlzLmFjdGl2ZVBhdGgpIHtcblx0XHRcdFx0dGhpcy5hY3RpdmVTY3JlZW4uY2xlYXJDYWNoZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5yZW1vdmVTY3JlZW4ocGF0aCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0cmlldmVzIG9yIGNyZWF0ZSBhIHNjcmVlbiBpbnN0YW5jZSB0byBhIHBhdGguXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gcGF0aCBQYXRoIGNvbnRhaW5pbmcgdGhlIHF1ZXJ5c3RyaW5nIHBhcnQuXG5cdCAqIEByZXR1cm4ge1NjcmVlbn1cblx0ICovXG5cdGNyZWF0ZVNjcmVlbkluc3RhbmNlKHBhdGgsIHJvdXRlKSB7XG5cdFx0aWYgKCF0aGlzLnBlbmRpbmdOYXZpZ2F0ZSAmJiBwYXRoID09PSB0aGlzLmFjdGl2ZVBhdGgpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdBbHJlYWR5IGF0IGRlc3RpbmF0aW9uLCByZWZyZXNoIG5hdmlnYXRpb24nKTtcblx0XHRcdHJldHVybiB0aGlzLmFjdGl2ZVNjcmVlbjtcblx0XHR9XG5cdFx0LyoganNoaW50IG5ld2NhcDogZmFsc2UgKi9cblx0XHR2YXIgc2NyZWVuID0gdGhpcy5zY3JlZW5zW3BhdGhdO1xuXHRcdGlmICghc2NyZWVuKSB7XG5cdFx0XHR2YXIgaGFuZGxlciA9IHJvdXRlLmdldEhhbmRsZXIoKTtcblx0XHRcdGlmIChoYW5kbGVyID09PSBTY3JlZW4gfHwgU2NyZWVuLmlzSW1wbGVtZW50ZWRCeShoYW5kbGVyLnByb3RvdHlwZSkpIHtcblx0XHRcdFx0c2NyZWVuID0gbmV3IGhhbmRsZXIoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNjcmVlbiA9IGhhbmRsZXIocm91dGUpIHx8IG5ldyBTY3JlZW4oKTtcblx0XHRcdH1cblx0XHRcdGNvbnNvbGUubG9nKCdDcmVhdGUgc2NyZWVuIGZvciBbJyArIHBhdGggKyAnXSBbJyArIHNjcmVlbiArICddJyk7XG5cdFx0fVxuXHRcdHJldHVybiBzY3JlZW47XG5cdH1cblxuXHQvKipcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG5cdGRpc3Bvc2VJbnRlcm5hbCgpIHtcblx0XHRpZiAodGhpcy5hY3RpdmVTY3JlZW4pIHtcblx0XHRcdHRoaXMucmVtb3ZlU2NyZWVuKHRoaXMuYWN0aXZlUGF0aCk7XG5cdFx0fVxuXHRcdHRoaXMuY2xlYXJTY3JlZW5zQ2FjaGUoKTtcblx0XHR0aGlzLmZvcm1FdmVudEhhbmRsZXJfLnJlbW92ZUxpc3RlbmVyKCk7XG5cdFx0dGhpcy5saW5rRXZlbnRIYW5kbGVyXy5yZW1vdmVMaXN0ZW5lcigpO1xuXHRcdHRoaXMuYXBwRXZlbnRIYW5kbGVyc18ucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cdFx0c3VwZXIuZGlzcG9zZUludGVybmFsKCk7XG5cdH1cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlcyB0byB0aGUgZmlyc3Qgcm91dGUgaGFuZGxlciB0aGF0IG1hdGNoZXMgdGhlIGN1cnJlbnQgcGF0aCwgaWZcblx0ICogYW55LlxuXHQgKiBAcmV0dXJuIHtDYW5jZWxsYWJsZVByb21pc2V9IFJldHVybnMgYSBwZW5kaW5nIHJlcXVlc3QgY2FuY2VsbGFibGUgcHJvbWlzZS5cblx0ICovXG5cdGRpc3BhdGNoKCkge1xuXHRcdHJldHVybiB0aGlzLm5hdmlnYXRlKHV0aWxzLmdldEN1cnJlbnRCcm93c2VyUGF0aCgpLCB0cnVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTdGFydHMgbmF2aWdhdGlvbiB0byBhIHBhdGguXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gcGF0aCBQYXRoIGNvbnRhaW5pbmcgdGhlIHF1ZXJ5c3RyaW5nIHBhcnQuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9yZXBsYWNlSGlzdG9yeSBSZXBsYWNlcyBicm93c2VyIGhpc3RvcnkuXG5cdCAqIEByZXR1cm4ge0NhbmNlbGxhYmxlUHJvbWlzZX0gUmV0dXJucyBhIHBlbmRpbmcgcmVxdWVzdCBjYW5jZWxsYWJsZSBwcm9taXNlLlxuXHQgKi9cblx0ZG9OYXZpZ2F0ZV8ocGF0aCwgb3B0X3JlcGxhY2VIaXN0b3J5KSB7XG5cdFx0aWYgKHRoaXMuYWN0aXZlU2NyZWVuICYmIHRoaXMuYWN0aXZlU2NyZWVuLmJlZm9yZURlYWN0aXZhdGUoKSkge1xuXHRcdFx0dGhpcy5wZW5kaW5nTmF2aWdhdGUgPSBDYW5jZWxsYWJsZVByb21pc2UucmVqZWN0KG5ldyBDYW5jZWxsYWJsZVByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3IoJ0NhbmNlbGxlZCBieSBhY3RpdmUgc2NyZWVuJykpO1xuXHRcdFx0cmV0dXJuIHRoaXMucGVuZGluZ05hdmlnYXRlO1xuXHRcdH1cblxuXHRcdHZhciByb3V0ZSA9IHRoaXMuZmluZFJvdXRlKHBhdGgpO1xuXHRcdGlmICghcm91dGUpIHtcblx0XHRcdHRoaXMucGVuZGluZ05hdmlnYXRlID0gQ2FuY2VsbGFibGVQcm9taXNlLnJlamVjdChuZXcgQ2FuY2VsbGFibGVQcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yKCdObyByb3V0ZSBmb3IgJyArIHBhdGgpKTtcblx0XHRcdHJldHVybiB0aGlzLnBlbmRpbmdOYXZpZ2F0ZTtcblx0XHR9XG5cblx0XHRjb25zb2xlLmxvZygnTmF2aWdhdGUgdG8gWycgKyBwYXRoICsgJ10nKTtcblxuXHRcdHRoaXMuc3RvcFBlbmRpbmdOYXZpZ2F0ZV8oKTtcblxuXHRcdHZhciBuZXh0U2NyZWVuID0gdGhpcy5jcmVhdGVTY3JlZW5JbnN0YW5jZShwYXRoLCByb3V0ZSk7XG5cblx0XHRyZXR1cm4gbmV4dFNjcmVlbi5sb2FkKHBhdGgpXG5cdFx0XHQudGhlbigoKSA9PiB7XG5cdFx0XHRcdGlmICh0aGlzLmFjdGl2ZVNjcmVlbikge1xuXHRcdFx0XHRcdHRoaXMuYWN0aXZlU2NyZWVuLmRlYWN0aXZhdGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnByZXBhcmVOYXZpZ2F0ZUhpc3RvcnlfKHBhdGgsIG5leHRTY3JlZW4sIG9wdF9yZXBsYWNlSGlzdG9yeSk7XG5cdFx0XHRcdHRoaXMucHJlcGFyZU5hdmlnYXRlU3VyZmFjZXNfKG5leHRTY3JlZW4sIHRoaXMuc3VyZmFjZXMpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKCgpID0+IG5leHRTY3JlZW4uZXZhbHVhdGVTdHlsZXModGhpcy5zdXJmYWNlcykpXG5cdFx0XHQudGhlbigoKSA9PiBuZXh0U2NyZWVuLmZsaXAodGhpcy5zdXJmYWNlcykpXG5cdFx0XHQudGhlbigoKSA9PiBuZXh0U2NyZWVuLmV2YWx1YXRlU2NyaXB0cyh0aGlzLnN1cmZhY2VzKSlcblx0XHRcdC50aGVuKCgpID0+IHRoaXMuc3luY1Njcm9sbFBvc2l0aW9uU3luY1RoZW5Bc3luY18oKSlcblx0XHRcdC50aGVuKCgpID0+IHRoaXMuZmluYWxpemVOYXZpZ2F0ZV8ocGF0aCwgbmV4dFNjcmVlbikpXG5cdFx0XHQuY2F0Y2goKHJlYXNvbikgPT4ge1xuXHRcdFx0XHR0aGlzLmhhbmRsZU5hdmlnYXRlRXJyb3JfKHBhdGgsIG5leHRTY3JlZW4sIHJlYXNvbik7XG5cdFx0XHRcdHRocm93IHJlYXNvbjtcblx0XHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZpbmFsaXplcyBhIHNjcmVlbiBuYXZpZ2F0aW9uLlxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IHBhdGggUGF0aCBjb250YWluaW5nIHRoZSBxdWVyeXN0cmluZyBwYXJ0LlxuXHQgKiBAcGFyYW0geyFTY3JlZW59IG5leHRTY3JlZW5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0ZmluYWxpemVOYXZpZ2F0ZV8ocGF0aCwgbmV4dFNjcmVlbikge1xuXHRcdG5leHRTY3JlZW4uYWN0aXZhdGUoKTtcblxuXHRcdGlmICh0aGlzLmFjdGl2ZVNjcmVlbiAmJiAhdGhpcy5hY3RpdmVTY3JlZW4uaXNDYWNoZWFibGUoKSkge1xuXHRcdFx0aWYgKHRoaXMuYWN0aXZlU2NyZWVuICE9PSBuZXh0U2NyZWVuKSB7XG5cdFx0XHRcdHRoaXMucmVtb3ZlU2NyZWVuKHRoaXMuYWN0aXZlUGF0aCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5hY3RpdmVQYXRoID0gcGF0aDtcblx0XHR0aGlzLmFjdGl2ZVNjcmVlbiA9IG5leHRTY3JlZW47XG5cdFx0dGhpcy5zY3JlZW5zW3BhdGhdID0gbmV4dFNjcmVlbjtcblx0XHR0aGlzLnBlbmRpbmdOYXZpZ2F0ZSA9IG51bGw7XG5cdFx0Z2xvYmFscy5jYXB0dXJlZEZvcm1FbGVtZW50ID0gbnVsbDtcblx0XHRjb25zb2xlLmxvZygnTmF2aWdhdGlvbiBkb25lJyk7XG5cdH1cblxuXHQvKipcblx0ICogRmluZHMgYSByb3V0ZSBmb3IgdGhlIHRlc3QgcGF0aC4gUmV0dXJucyB0cnVlIGlmIG1hdGNoZXMgaGFzIGEgcm91dGUsXG5cdCAqIG90aGVyd2lzZSByZXR1cm5zIG51bGwuXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gcGF0aCBQYXRoIGNvbnRhaW5pbmcgdGhlIHF1ZXJ5c3RyaW5nIHBhcnQuXG5cdCAqIEByZXR1cm4gez9PYmplY3R9IFJvdXRlIGhhbmRsZXIgaWYgbWF0Y2ggYW55IG9yIDxjb2RlPm51bGw8L2NvZGU+IGlmIHRoZVxuXHQgKiAgICAgcGF0aCBpcyB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCB1cmwgYW5kIHRoZSBwYXRoIGNvbnRhaW5zIGEgZnJhZ21lbnQuXG5cdCAqL1xuXHRmaW5kUm91dGUocGF0aCkge1xuXHRcdC8vIFByZXZlbnRzIG5hdmlnYXRpb24gaWYgaXQncyBhIGhhc2ggY2hhbmdlIG9uIHRoZSBzYW1lIHVybC5cblx0XHRpZiAoKHBhdGgubGFzdEluZGV4T2YoJyMnKSA+IC0xKSAmJiB1dGlscy5pc0N1cnJlbnRCcm93c2VyUGF0aChwYXRoKSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cGF0aCA9IHV0aWxzLmdldFVybFBhdGhXaXRob3V0SGFzaChwYXRoKTtcblxuXHRcdC8vIE1ha2VzIHN1cmUgdGhhdCB0aGUgcGF0aCBzdWJzdHJpbmcgd2lsbCBiZSBpbiB0aGUgZXhwZWN0ZWQgZm9ybWF0XG5cdFx0Ly8gKHRoYXQgaXMsIHdpbGwgZW5kIHdpdGggYSBcIi9cIikuXG5cdFx0cGF0aCA9IHV0aWxzLmdldFVybFBhdGhXaXRob3V0SGFzaChwYXRoLnN1YnN0cih0aGlzLmJhc2VQYXRoLmxlbmd0aCkpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvdXRlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHJvdXRlID0gdGhpcy5yb3V0ZXNbaV07XG5cdFx0XHRpZiAocm91dGUubWF0Y2hlc1BhdGgocGF0aCkpIHtcblx0XHRcdFx0cmV0dXJuIHJvdXRlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgYWxsb3cgcHJldmVudCBuYXZpZ2F0ZS5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGdldEFsbG93UHJldmVudE5hdmlnYXRlKCkge1xuXHRcdHJldHVybiB0aGlzLmFsbG93UHJldmVudE5hdmlnYXRlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgbGluayBiYXNlIHBhdGguXG5cdCAqIEByZXR1cm4geyFzdHJpbmd9XG5cdCAqL1xuXHRnZXRCYXNlUGF0aCgpIHtcblx0XHRyZXR1cm4gdGhpcy5iYXNlUGF0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBkZWZhdWx0IHBhZ2UgdGl0bGUuXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gZGVmYXVsdFRpdGxlXG5cdCAqL1xuXHRnZXREZWZhdWx0VGl0bGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGVmYXVsdFRpdGxlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGZvcm0gc2VsZWN0b3IuXG5cdCAqIEByZXR1cm4geyFzdHJpbmd9XG5cdCAqL1xuXHRnZXRGb3JtU2VsZWN0b3IoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZm9ybVNlbGVjdG9yO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGxpbmsgc2VsZWN0b3IuXG5cdCAqIEByZXR1cm4geyFzdHJpbmd9XG5cdCAqL1xuXHRnZXRMaW5rU2VsZWN0b3IoKSB7XG5cdFx0cmV0dXJuIHRoaXMubGlua1NlbGVjdG9yO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGxvYWRpbmcgY3NzIGNsYXNzLlxuXHQgKiBAcmV0dXJuIHshc3RyaW5nfVxuXHQgKi9cblx0Z2V0TG9hZGluZ0Nzc0NsYXNzKCkge1xuXHRcdHJldHVybiB0aGlzLmxvYWRpbmdDc3NDbGFzcztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSB1cGRhdGUgc2Nyb2xsIHBvc2l0aW9uIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0Z2V0VXBkYXRlU2Nyb2xsUG9zaXRpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlU2Nyb2xsUG9zaXRpb247XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlIG5hdmlnYXRpb24gZXJyb3IuXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gcGF0aCBQYXRoIGNvbnRhaW5pbmcgdGhlIHF1ZXJ5c3RyaW5nIHBhcnQuXG5cdCAqIEBwYXJhbSB7IVNjcmVlbn0gbmV4dFNjcmVlblxuXHQgKiBAcGFyYW0geyFFcnJvcn0gZXJyb3Jcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0aGFuZGxlTmF2aWdhdGVFcnJvcl8ocGF0aCwgbmV4dFNjcmVlbiwgZXJyKSB7XG5cdFx0Y29uc29sZS5sb2coJ05hdmlnYXRpb24gZXJyb3IgZm9yIFsnICsgbmV4dFNjcmVlbiArICddICgnICsgZXJyICsgJyknKTtcblx0XHRpZiAoIXV0aWxzLmlzQ3VycmVudEJyb3dzZXJQYXRoKHBhdGgpKSB7XG5cdFx0XHR0aGlzLnJlbW92ZVNjcmVlbihwYXRoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGFwcCBoYXMgcm91dGVzLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzUm91dGVzKCkge1xuXHRcdHJldHVybiB0aGlzLnJvdXRlcy5sZW5ndGggPiAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRlc3RzIGlmIGhvc3RuYW1lIGlzIGFuIG9mZnNpdGUgbGluay5cblx0ICogQHBhcmFtIHshc3RyaW5nfSBob3N0bmFtZSBMaW5rIGhvc3RuYW1lIHRvIGNvbXBhcmUgd2l0aFxuXHQgKiAgICAgPGNvZGU+Z2xvYmFscy53aW5kb3cubG9jYXRpb24uaG9zdG5hbWU8L2NvZGU+LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRpc0xpbmtTYW1lT3JpZ2luXyhob3N0bmFtZSkge1xuXHRcdHJldHVybiBob3N0bmFtZSA9PT0gZ2xvYmFscy53aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG5cdH1cblxuXHQvKipcblx0ICogVGVzdHMgaWYgbGluayBlbGVtZW50IGhhcyB0aGUgc2FtZSBhcHAncyBiYXNlIHBhdGguXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gcGF0aCBMaW5rIHBhdGggY29udGFpbmluZyB0aGUgcXVlcnlzdHJpbmcgcGFydC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0aXNTYW1lQmFzZVBhdGhfKHBhdGgpIHtcblx0XHRyZXR1cm4gcGF0aC5pbmRleE9mKHRoaXMuYmFzZVBhdGgpID09PSAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIExvY2sgdGhlIGRvY3VtZW50IHNjcm9sbCBpbiBvcmRlciB0byBhdm9pZCB0aGUgYnJvd3NlciBuYXRpdmUgYmFjayBhbmRcblx0ICogZm9yd2FyZCBuYXZpZ2F0aW9uIHRvIGNoYW5nZSB0aGUgc2Nyb2xsIHBvc2l0aW9uLiBJbiB0aGUgZW5kIG9mXG5cdCAqIG5hdmlnYXRpb24gbGlmZWN5Y2xlIHNjcm9sbCBpcyByZXBvc2l0aW9uZWQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGxvY2tIaXN0b3J5U2Nyb2xsUG9zaXRpb25fKCkge1xuXHRcdHZhciBzdGF0ZSA9IGdsb2JhbHMud2luZG93Lmhpc3Rvcnkuc3RhdGU7XG5cdFx0aWYgKCFzdGF0ZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHQvLyBCcm93c2VycyBhcmUgaW5jb25zaXN0ZW50IHdoZW4gcmUtcG9zaXRpb25pbmcgdGhlIHNjcm9sbCBoaXN0b3J5IG9uXG5cdFx0Ly8gcG9wc3RhdGUuIEF0IHNvbWUgYnJvd3NlcnMsIGhpc3Rvcnkgc2Nyb2xsIGhhcHBlbnMgYmVmb3JlIHBvcHN0YXRlLCB0aGVuXG5cdFx0Ly8gbG9jayB0aGUgc2Nyb2xsIG9uIHRoZSBsYXN0IGtub3duIHBvc2l0aW9uIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlXG5cdFx0Ly8gY3VycmVudCBKUyBleGVjdXRpb24gY29udGV4dCBhbmQgY2FwdHVyZSB0aGUgY3VycmVudCB2YWx1ZS4gU29tZSBvdGhlcnMsXG5cdFx0Ly8gaGlzdG9yeSBzY3JvbGwgaGFwcGVucyBhZnRlciBwb3BzdGF0ZSwgaW4gdGhpcyBjYXNlLCB3ZSBiaW5kIGFuIG9uY2Vcblx0XHQvLyBzY3JvbGwgZXZlbnQgdG8gbG9jayB0aGUgbGFzIGtub3duIHBvc2l0aW9uLiBMYXN0bHksIHRoZSBwcmV2aW91cyB0d29cblx0XHQvLyBiZWhhdmlvcnMgY2FuIGhhcHBlbiBldmVuIG9uIHRoZSBzYW1lIGJyb3dzZXIsIGhlbmNlIHRoZSByYWNlIHdpbGwgZGVjaWRlXG5cdFx0Ly8gdGhlIHdpbm5lci5cblx0XHR2YXIgd2lubmVyID0gZmFsc2U7XG5cdFx0dmFyIHN3aXRjaFNjcm9sbFBvc2l0aW9uUmFjZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0Z2xvYmFscy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzd2l0Y2hTY3JvbGxQb3NpdGlvblJhY2UsIGZhbHNlKTtcblx0XHRcdGlmICghd2lubmVyKSB7XG5cdFx0XHRcdGdsb2JhbHMud2luZG93LnNjcm9sbFRvKHN0YXRlLnNjcm9sbExlZnQsIHN0YXRlLnNjcm9sbFRvcCk7XG5cdFx0XHRcdHdpbm5lciA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRhc3luYy5uZXh0VGljayhzd2l0Y2hTY3JvbGxQb3NpdGlvblJhY2UpO1xuXHRcdGdsb2JhbHMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc3dpdGNoU2Nyb2xsUG9zaXRpb25SYWNlLCBmYWxzZSk7XG5cdH1cblxuXHQvKipcblx0ICogSWYgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyLCBkaXNhYmxlcyBuYXRpdmUgc2Nyb2xsIHJlc3RvcmF0aW9uIGFuZFxuXHQgKiBzdG9yZXMgY3VycmVudCB2YWx1ZS5cblx0ICovXG5cdG1heWJlRGlzYWJsZU5hdGl2ZVNjcm9sbFJlc3RvcmF0aW9uKCkge1xuXHRcdGlmICh0aGlzLm5hdGl2ZVNjcm9sbFJlc3RvcmF0aW9uU3VwcG9ydGVkKSB7XG5cdFx0XHR0aGlzLm5hdGl2ZVNjcm9sbFJlc3RvcmF0aW9uXyA9IGdsb2JhbHMud2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb247XG5cdFx0XHRnbG9iYWxzLndpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gJ21hbnVhbCc7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIE1heWJlIG5hdmlnYXRlIHRvIGEgcGF0aC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGhyZWYgSW5mb3JtYXRpb24gYWJvdXQgdGhlIGxpbmsncyBocmVmLlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBEb20gZXZlbnQgdGhhdCBpbml0aWF0ZWQgdGhlIG5hdmlnYXRpb24uXG5cdCAqL1xuXHRtYXliZU5hdmlnYXRlXyhocmVmLCBldmVudCkge1xuXHRcdGlmICghdGhpcy5jYW5OYXZpZ2F0ZShocmVmKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmFsbG93UHJldmVudE5hdmlnYXRlICYmIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdOYXZpZ2F0ZSBwcmV2ZW50ZWQnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRnbG9iYWxzLmNhcHR1cmVkRm9ybUVsZW1lbnQgPSBldmVudC5jYXB0dXJlZEZvcm1FbGVtZW50O1xuXG5cdFx0dmFyIG5hdmlnYXRlRmFpbGVkID0gZmFsc2U7XG5cdFx0dHJ5IHtcblx0XHRcdHRoaXMubmF2aWdhdGUodXRpbHMuZ2V0VXJsUGF0aChocmVmKSk7XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHQvLyBEbyBub3QgcHJldmVudCBsaW5rIG5hdmlnYXRpb24gaW4gY2FzZSBzb21lIHN5bmNocm9ub3VzIGVycm9yIG9jY3Vyc1xuXHRcdFx0bmF2aWdhdGVGYWlsZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICghbmF2aWdhdGVGYWlsZWQpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIE1heWJlIHJlcG9zaXRpb24gc2Nyb2xsIHRvIGhhc2hlZCBhbmNob3IuXG5cdCAqL1xuXHRtYXliZVJlcG9zaXRpb25TY3JvbGxUb0hhc2hlZEFuY2hvcigpIHtcblx0XHR2YXIgaGFzaCA9IGdsb2JhbHMud2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0aWYgKGhhc2gpIHtcblx0XHRcdHZhciBhbmNob3JFbGVtZW50ID0gZ2xvYmFscy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoLnN1YnN0cmluZygxKSk7XG5cdFx0XHRpZiAoYW5jaG9yRWxlbWVudCkge1xuXHRcdFx0XHRnbG9iYWxzLndpbmRvdy5zY3JvbGxUbyhhbmNob3JFbGVtZW50Lm9mZnNldExlZnQsIGFuY2hvckVsZW1lbnQub2Zmc2V0VG9wKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSWYgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyLCByZXN0b3JlcyBuYXRpdmUgc2Nyb2xsIHJlc3RvcmF0aW9uIHRvIHRoZVxuXHQgKiB2YWx1ZSBjYXB0dXJlZCBieSBgbWF5YmVEaXNhYmxlTmF0aXZlU2Nyb2xsUmVzdG9yYXRpb25gLlxuXHQgKi9cblx0bWF5YmVSZXN0b3JlTmF0aXZlU2Nyb2xsUmVzdG9yYXRpb24oKSB7XG5cdFx0aWYgKHRoaXMubmF0aXZlU2Nyb2xsUmVzdG9yYXRpb25TdXBwb3J0ZWQgJiYgdGhpcy5uYXRpdmVTY3JvbGxSZXN0b3JhdGlvbl8pIHtcblx0XHRcdGdsb2JhbHMud2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSB0aGlzLm5hdGl2ZVNjcm9sbFJlc3RvcmF0aW9uXztcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTmF2aWdhdGVzIHRvIHRoZSBzcGVjaWZpZWQgcGF0aCBpZiB0aGVyZSBpcyBhIHJvdXRlIGhhbmRsZXIgdGhhdCBtYXRjaGVzLlxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IHBhdGggUGF0aCB0byBuYXZpZ2F0ZSBjb250YWluaW5nIHRoZSBiYXNlIHBhdGguXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9yZXBsYWNlSGlzdG9yeSBSZXBsYWNlcyBicm93c2VyIGhpc3RvcnkuXG5cdCAqIEByZXR1cm4ge0NhbmNlbGxhYmxlUHJvbWlzZX0gUmV0dXJucyBhIHBlbmRpbmcgcmVxdWVzdCBjYW5jZWxsYWJsZSBwcm9taXNlLlxuXHQgKi9cblx0bmF2aWdhdGUocGF0aCwgb3B0X3JlcGxhY2VIaXN0b3J5KSB7XG5cdFx0aWYgKCF1dGlscy5pc0h0bWw1SGlzdG9yeVN1cHBvcnRlZCgpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0hUTUw1IEhpc3RvcnkgaXMgbm90IHN1cHBvcnRlZC4gU2VubmEgd2lsbCBub3QgaW50ZXJjZXB0IG5hdmlnYXRpb24uJyk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiByZWxvYWRpbmcgdGhlIHNhbWUgcGF0aCBkbyByZXBsYWNlU3RhdGUgaW5zdGVhZCBvZiBwdXNoU3RhdGUgdG9cblx0XHQvLyBhdm9pZCBwb2xsdXRpbmcgaGlzdG9yeSB3aXRoIHN0YXRlcyB3aXRoIHRoZSBzYW1lIHBhdGguXG5cdFx0aWYgKHBhdGggPT09IHRoaXMuYWN0aXZlUGF0aCkge1xuXHRcdFx0b3B0X3JlcGxhY2VIaXN0b3J5ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHR0aGlzLmVtaXQoJ2JlZm9yZU5hdmlnYXRlJywge1xuXHRcdFx0cGF0aDogcGF0aCxcblx0XHRcdHJlcGxhY2VIaXN0b3J5OiAhIW9wdF9yZXBsYWNlSGlzdG9yeVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHRoaXMucGVuZGluZ05hdmlnYXRlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJlZm9yZXMgbmF2aWdhdGlvbiB0byBhIHBhdGguXG5cdCAqIEBwYXJhbSB7IUV2ZW50fSBldmVudCBFdmVudCBmYWNhZGUgY29udGFpbmluZyA8Y29kZT5wYXRoPC9jb2RlPiBhbmRcblx0ICogICAgIDxjb2RlPnJlcGxhY2VIaXN0b3J5PC9jb2RlPi5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0b25CZWZvcmVOYXZpZ2F0ZV8oZXZlbnQpIHtcblx0XHRpZiAoZ2xvYmFscy5jYXB0dXJlZEZvcm1FbGVtZW50KSB7XG5cdFx0XHRldmVudC5mb3JtID0gZ2xvYmFscy5jYXB0dXJlZEZvcm1FbGVtZW50O1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBCZWZvcmVzIG5hdmlnYXRpb24gdG8gYSBwYXRoLiBSdW5zIGFmdGVyIGV4dGVybmFsIGxpc3RlbmVycy5cblx0ICogQHBhcmFtIHshRXZlbnR9IGV2ZW50IEV2ZW50IGZhY2FkZSBjb250YWluaW5nIDxjb2RlPnBhdGg8L2NvZGU+IGFuZFxuXHQgKiAgICAgPGNvZGU+cmVwbGFjZUhpc3Rvcnk8L2NvZGU+LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRvbkJlZm9yZU5hdmlnYXRlRGVmYXVsdF8oZXZlbnQpIHtcblx0XHRpZiAodGhpcy5wZW5kaW5nTmF2aWdhdGUpIHtcblx0XHRcdGlmICh0aGlzLnBlbmRpbmdOYXZpZ2F0ZS5wYXRoID09PSBldmVudC5wYXRoKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdXYWl0aW5nLi4uJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmVtaXQoJ3N0YXJ0TmF2aWdhdGUnLCB7XG5cdFx0XHRmb3JtOiBldmVudC5mb3JtLFxuXHRcdFx0cGF0aDogZXZlbnQucGF0aCxcblx0XHRcdHJlcGxhY2VIaXN0b3J5OiBldmVudC5yZXBsYWNlSGlzdG9yeVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEludGVyY2VwdHMgZG9jdW1lbnQgY2xpY2tzIGFuZCB0ZXN0IGxpbmsgZWxlbWVudHMgaW4gb3JkZXIgdG8gZGVjaWRlXG5cdCAqIHdoZXRoZXIgU3VyZmFjZSBhcHAgY2FuIG5hdmlnYXRlLlxuXHQgKiBAcGFyYW0geyFFdmVudH0gZXZlbnQgRXZlbnQgZmFjYWRlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdG9uRG9jQ2xpY2tEZWxlZ2F0ZV8oZXZlbnQpIHtcblx0XHRpZiAoZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5idXR0b24pIHtcblx0XHRcdGNvbnNvbGUubG9nKCdOYXZpZ2F0ZSBhYm9ydGVkLCBpbnZhbGlkIG1vdXNlIGJ1dHRvbiBvciBtb2RpZmllciBrZXkgcHJlc3NlZC4nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5tYXliZU5hdmlnYXRlXyhldmVudC5kZWxlZ2F0ZVRhcmdldC5ocmVmLCBldmVudCk7XG5cdH1cblxuXHQvKipcblx0ICogSW50ZXJjZXB0cyBkb2N1bWVudCBmb3JtIHN1Ym1pdHMgYW5kIHRlc3QgYWN0aW9uIHBhdGggaW4gb3JkZXIgdG8gZGVjaWRlXG5cdCAqIHdoZXRoZXIgU3VyZmFjZSBhcHAgY2FuIG5hdmlnYXRlLlxuXHQgKiBAcGFyYW0geyFFdmVudH0gZXZlbnQgRXZlbnQgZmFjYWRlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdG9uRG9jU3VibWl0RGVsZWdhdGVfKGV2ZW50KSB7XG5cdFx0dmFyIGZvcm0gPSBldmVudC5kZWxlZ2F0ZVRhcmdldDtcblx0XHRpZiAoZm9ybS5tZXRob2QgPT09ICdnZXQnKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnR0VUIG1ldGhvZCBub3Qgc3VwcG9ydGVkJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGV2ZW50LmNhcHR1cmVkRm9ybUVsZW1lbnQgPSBmb3JtO1xuXHRcdHRoaXMubWF5YmVOYXZpZ2F0ZV8oZm9ybS5hY3Rpb24sIGV2ZW50KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaXN0ZW5zIHRvIHRoZSB3aW5kb3cncyBsb2FkIGV2ZW50IGluIG9yZGVyIHRvIGF2b2lkIGlzc3VlcyB3aXRoIHNvbWUgYnJvd3NlcnNcblx0ICogdGhhdCB0cmlnZ2VyIHBvcHN0YXRlIGNhbGxzIG9uIHRoZSBmaXJzdCBsb2FkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWVcblx0ICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82NDIxNzY5L3BvcHN0YXRlLW9uLXBhZ2VzLWxvYWQtaW4tY2hyb21lLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRvbkxvYWRfKCkge1xuXHRcdHRoaXMuc2tpcExvYWRQb3BzdGF0ZSA9IHRydWU7XG5cdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHQvLyBUaGUgdGltZW91dCBlbnN1cmVzIHRoYXQgcG9wc3RhdGUgZXZlbnRzIHdpbGwgYmUgdW5ibG9ja2VkIHJpZ2h0XG5cdFx0XHQvLyBhZnRlciB0aGUgbG9hZCBldmVudCBvY2N1cmVkLCBidXQgbm90IGluIHRoZSBzYW1lIGV2ZW50LWxvb3AgY3ljbGUuXG5cdFx0XHR0aGlzLnNraXBMb2FkUG9wc3RhdGUgPSBmYWxzZTtcblx0XHR9LCAwKTtcblx0XHQvLyBUcnkgdG8gcmVwb3NpdGlvbiBzY3JvbGwgdG8gdGhlIGhhc2hlZCBhbmNob3Igd2hlbiBwYWdlIGxvYWRzLlxuXHRcdHRoaXMubWF5YmVSZXBvc2l0aW9uU2Nyb2xsVG9IYXNoZWRBbmNob3IoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIGJyb3dzZXIgaGlzdG9yeSBjaGFuZ2VzIGFuZCBmaXJlcyBhcHAncyBuYXZpZ2F0aW9uIGlmIHRoZSBzdGF0ZVxuXHQgKiBiZWxvd3MgdG8gdXMuIElmIHdlIGRldGVjdCBhIHBvcHN0YXRlIGFuZCB0aGUgc3RhdGUgaXMgPGNvZGU+bnVsbDwvY29kZT4sXG5cdCAqIGFzc3VtZSBpdCBpcyBuYXZpZ2F0aW5nIHRvIGFuIGV4dGVybmFsIHBhZ2Ugb3IgdG8gYSBwYWdlIHdlIGRvbid0IGhhdmVcblx0ICogcm91dGUsIHRoZW4gPGNvZGU+Z2xvYmFscy53aW5kb3cubG9jYXRpb24ucmVsb2FkKCk8L2NvZGU+IGlzIGludm9rZWQgaW4gb3JkZXIgdG9cblx0ICogcmVsb2FkIHRoZSBjb250ZW50IHRvIHRoZSBjdXJyZW50IHVybC5cblx0ICogQHBhcmFtIHshRXZlbnR9IGV2ZW50IEV2ZW50IGZhY2FkZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRvblBvcHN0YXRlXyhldmVudCkge1xuXHRcdGlmICh0aGlzLnNraXBMb2FkUG9wc3RhdGUpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgc3RhdGUgPSBldmVudC5zdGF0ZTtcblxuXHRcdGlmICghc3RhdGUpIHtcblx0XHRcdGlmIChnbG9iYWxzLndpbmRvdy5sb2NhdGlvbi5oYXNoKSB7XG5cdFx0XHRcdC8vIElmIHNlbm5hIGlzIG9uIGFuIHJlZGlyZWN0IHBhdGggYW5kIGEgaGFzaCBwb3BzdGF0ZSBoYXBwZW5zXG5cdFx0XHRcdC8vIHRvIGEgZGlmZmVyZW50IHVybCwgcmVsb2FkIHRoZSBicm93c2VyLiBUaGlzIGJlaGF2aW9yIGRvZXNuJ3Rcblx0XHRcdFx0Ly8gcmVxdWlyZSBzZW5uYSB0byByb3V0ZSBoYXNoZWQgbGlua3MgYW5kIGlzIGNsb3NlciB0byBuYXRpdmVcblx0XHRcdFx0Ly8gYnJvd3NlciBiZWhhdmlvci5cblx0XHRcdFx0aWYgKHRoaXMucmVkaXJlY3RQYXRoICYmICF1dGlscy5pc0N1cnJlbnRCcm93c2VyUGF0aCh0aGlzLnJlZGlyZWN0UGF0aCkpIHtcblx0XHRcdFx0XHR0aGlzLnJlbG9hZFBhZ2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBBbHdheXMgdHJ5IHRvIHJlcG9zaXRpb24gc2Nyb2xsIHRvIHRoZSBoYXNoZWQgYW5jaG9yIHdoZW5cblx0XHRcdFx0Ly8gaGFzaCBwb3BzdGF0ZSBoYXBwZW5zLlxuXHRcdFx0XHR0aGlzLm1heWJlUmVwb3NpdGlvblNjcm9sbFRvSGFzaGVkQW5jaG9yKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnJlbG9hZFBhZ2UoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoc3RhdGUuc2VubmEpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdIaXN0b3J5IG5hdmlnYXRpb24gdG8gWycgKyBzdGF0ZS5wYXRoICsgJ10nKTtcblx0XHRcdHRoaXMucG9wc3RhdGVTY3JvbGxUb3AgPSBzdGF0ZS5zY3JvbGxUb3A7XG5cdFx0XHR0aGlzLnBvcHN0YXRlU2Nyb2xsTGVmdCA9IHN0YXRlLnNjcm9sbExlZnQ7XG5cdFx0XHRpZiAoIXRoaXMubmF0aXZlU2Nyb2xsUmVzdG9yYXRpb25TdXBwb3J0ZWQpIHtcblx0XHRcdFx0dGhpcy5sb2NrSGlzdG9yeVNjcm9sbFBvc2l0aW9uXygpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5uYXZpZ2F0ZShzdGF0ZS5wYXRoLCB0cnVlKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTGlzdGVucyBkb2N1bWVudCBzY3JvbGwgY2hhbmdlcyBpbiBvcmRlciB0byBjYXB0dXJlIHRoZSBwb3NzaWJsZSBsb2NrXG5cdCAqIHNjcm9sbCBwb3NpdGlvbiBmb3IgaGlzdG9yeSBzY3JvbGxpbmcuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdG9uU2Nyb2xsXygpIHtcblx0XHRpZiAodGhpcy5jYXB0dXJlU2Nyb2xsUG9zaXRpb25Gcm9tU2Nyb2xsRXZlbnQpIHtcblx0XHRcdHRoaXMuc2F2ZUhpc3RvcnlDdXJyZW50UGFnZVNjcm9sbFBvc2l0aW9uXygpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTdGFydHMgbmF2aWdhdGlvbiB0byBhIHBhdGguXG5cdCAqIEBwYXJhbSB7IUV2ZW50fSBldmVudCBFdmVudCBmYWNhZGUgY29udGFpbmluZyA8Y29kZT5wYXRoPC9jb2RlPiBhbmRcblx0ICogICAgIDxjb2RlPnJlcGxhY2VIaXN0b3J5PC9jb2RlPi5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0b25TdGFydE5hdmlnYXRlXyhldmVudCkge1xuXHRcdHRoaXMubWF5YmVEaXNhYmxlTmF0aXZlU2Nyb2xsUmVzdG9yYXRpb24oKTtcblx0XHR0aGlzLmNhcHR1cmVTY3JvbGxQb3NpdGlvbkZyb21TY3JvbGxFdmVudCA9IGZhbHNlO1xuXHRcdGRvbS5hZGRDbGFzc2VzKGdsb2JhbHMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLmxvYWRpbmdDc3NDbGFzcyk7XG5cblx0XHR2YXIgZW5kTmF2aWdhdGVQYXlsb2FkID0ge1xuXHRcdFx0Zm9ybTogZXZlbnQuZm9ybSxcblx0XHRcdHBhdGg6IGV2ZW50LnBhdGhcblx0XHR9O1xuXG5cdFx0dGhpcy5wZW5kaW5nTmF2aWdhdGUgPSB0aGlzLmRvTmF2aWdhdGVfKGV2ZW50LnBhdGgsIGV2ZW50LnJlcGxhY2VIaXN0b3J5KVxuXHRcdFx0LmNhdGNoKChyZWFzb24pID0+IHtcblx0XHRcdFx0ZW5kTmF2aWdhdGVQYXlsb2FkLmVycm9yID0gcmVhc29uO1xuXHRcdFx0XHR0aHJvdyByZWFzb247XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW5BbHdheXMoKCkgPT4ge1xuXHRcdFx0XHRpZiAoIXRoaXMucGVuZGluZ05hdmlnYXRlKSB7XG5cdFx0XHRcdFx0ZG9tLnJlbW92ZUNsYXNzZXMoZ2xvYmFscy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMubG9hZGluZ0Nzc0NsYXNzKTtcblx0XHRcdFx0XHR0aGlzLm1heWJlUmVzdG9yZU5hdGl2ZVNjcm9sbFJlc3RvcmF0aW9uKCk7XG5cdFx0XHRcdFx0dGhpcy5jYXB0dXJlU2Nyb2xsUG9zaXRpb25Gcm9tU2Nyb2xsRXZlbnQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuZW1pdCgnZW5kTmF2aWdhdGUnLCBlbmROYXZpZ2F0ZVBheWxvYWQpO1xuXHRcdFx0fSk7XG5cblx0XHR0aGlzLnBlbmRpbmdOYXZpZ2F0ZS5wYXRoID0gZXZlbnQucGF0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBQcmVmZXRjaGVzIHRoZSBzcGVjaWZpZWQgcGF0aCBpZiB0aGVyZSBpcyBhIHJvdXRlIGhhbmRsZXIgdGhhdCBtYXRjaGVzLlxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IHBhdGggUGF0aCB0byBuYXZpZ2F0ZSBjb250YWluaW5nIHRoZSBiYXNlIHBhdGguXG5cdCAqIEByZXR1cm4ge0NhbmNlbGxhYmxlUHJvbWlzZX0gUmV0dXJucyBhIHBlbmRpbmcgcmVxdWVzdCBjYW5jZWxsYWJsZSBwcm9taXNlLlxuXHQgKi9cblx0cHJlZmV0Y2gocGF0aCkge1xuXHRcdHZhciByb3V0ZSA9IHRoaXMuZmluZFJvdXRlKHBhdGgpO1xuXHRcdGlmICghcm91dGUpIHtcblx0XHRcdHJldHVybiBDYW5jZWxsYWJsZVByb21pc2UucmVqZWN0KG5ldyBDYW5jZWxsYWJsZVByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3IoJ05vIHJvdXRlIGZvciAnICsgcGF0aCkpO1xuXHRcdH1cblxuXHRcdGNvbnNvbGUubG9nKCdQcmVmZXRjaGluZyBbJyArIHBhdGggKyAnXScpO1xuXG5cdFx0dmFyIG5leHRTY3JlZW4gPSB0aGlzLmNyZWF0ZVNjcmVlbkluc3RhbmNlKHBhdGgsIHJvdXRlKTtcblxuXHRcdHJldHVybiBuZXh0U2NyZWVuLmxvYWQocGF0aClcblx0XHRcdC50aGVuKCgpID0+IHRoaXMuc2NyZWVuc1twYXRoXSA9IG5leHRTY3JlZW4pXG5cdFx0XHQuY2F0Y2goKHJlYXNvbikgPT4ge1xuXHRcdFx0XHR0aGlzLmhhbmRsZU5hdmlnYXRlRXJyb3JfKHBhdGgsIG5leHRTY3JlZW4sIHJlYXNvbik7XG5cdFx0XHRcdHRocm93IHJlYXNvbjtcblx0XHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFByZXBhcmVzIHNjcmVlbiBmbGlwLiBVcGRhdGVzIGhpc3Rvcnkgc3RhdGUgYW5kIHN1cmZhY2VzIGNvbnRlbnQuXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gcGF0aCBQYXRoIGNvbnRhaW5pbmcgdGhlIHF1ZXJ5c3RyaW5nIHBhcnQuXG5cdCAqIEBwYXJhbSB7IVNjcmVlbn0gbmV4dFNjcmVlblxuXHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfcmVwbGFjZUhpc3RvcnkgUmVwbGFjZXMgYnJvd3NlciBoaXN0b3J5LlxuXHQgKi9cblx0cHJlcGFyZU5hdmlnYXRlSGlzdG9yeV8ocGF0aCwgbmV4dFNjcmVlbiwgb3B0X3JlcGxhY2VIaXN0b3J5KSB7XG5cdFx0dmFyIHRpdGxlID0gbmV4dFNjcmVlbi5nZXRUaXRsZSgpO1xuXHRcdGlmICghY29yZS5pc1N0cmluZyh0aXRsZSkpIHtcblx0XHRcdHRpdGxlID0gdGhpcy5nZXREZWZhdWx0VGl0bGUoKTtcblx0XHR9XG5cdFx0dmFyIHJlZGlyZWN0UGF0aCA9IG5leHRTY3JlZW4uYmVmb3JlVXBkYXRlSGlzdG9yeVBhdGgocGF0aCk7XG5cdFx0dmFyIGhpc3RvcnlTdGF0ZSA9IHtcblx0XHRcdGZvcm06IGNvcmUuaXNEZWZBbmROb3ROdWxsKGdsb2JhbHMuY2FwdHVyZWRGb3JtRWxlbWVudCksXG5cdFx0XHRyZWRpcmVjdFBhdGg6IHJlZGlyZWN0UGF0aCxcblx0XHRcdHBhdGg6IHBhdGgsXG5cdFx0XHRzZW5uYTogdHJ1ZSxcblx0XHRcdHNjcm9sbFRvcDogMCxcblx0XHRcdHNjcm9sbExlZnQ6IDBcblx0XHR9O1xuXHRcdGlmIChvcHRfcmVwbGFjZUhpc3RvcnkpIHtcblx0XHRcdGhpc3RvcnlTdGF0ZS5zY3JvbGxUb3AgPSB0aGlzLnBvcHN0YXRlU2Nyb2xsVG9wO1xuXHRcdFx0aGlzdG9yeVN0YXRlLnNjcm9sbExlZnQgPSB0aGlzLnBvcHN0YXRlU2Nyb2xsTGVmdDtcblx0XHR9XG5cdFx0dGhpcy51cGRhdGVIaXN0b3J5Xyh0aXRsZSwgcmVkaXJlY3RQYXRoLCBuZXh0U2NyZWVuLmJlZm9yZVVwZGF0ZUhpc3RvcnlTdGF0ZShoaXN0b3J5U3RhdGUpLCBvcHRfcmVwbGFjZUhpc3RvcnkpO1xuXHRcdHRoaXMucmVkaXJlY3RQYXRoID0gcmVkaXJlY3RQYXRoO1xuXHR9XG5cblx0LyoqXG5cdCAqIFByZXBhcmVzIHNjcmVlbiBmbGlwLiBVcGRhdGVzIGhpc3Rvcnkgc3RhdGUgYW5kIHN1cmZhY2VzIGNvbnRlbnQuXG5cdCAqIEBwYXJhbSB7IVNjcmVlbn0gbmV4dFNjcmVlblxuXHQgKiBAcGFyYW0geyFvYmplY3R9IHN1cmZhY2VzIE1hcCBvZiBzdXJmYWNlcyB0byBmbGlwIGtleWVkIGJ5IHN1cmZhY2UgaWQuXG5cdCAqL1xuXHRwcmVwYXJlTmF2aWdhdGVTdXJmYWNlc18obmV4dFNjcmVlbiwgc3VyZmFjZXMpIHtcblx0XHRPYmplY3Qua2V5cyhzdXJmYWNlcykuZm9yRWFjaCgoaWQpID0+IHtcblx0XHRcdHZhciBzdXJmYWNlQ29udGVudCA9IG5leHRTY3JlZW4uZ2V0U3VyZmFjZUNvbnRlbnQoaWQpO1xuXHRcdFx0c3VyZmFjZXNbaWRdLmFkZENvbnRlbnQobmV4dFNjcmVlbi5nZXRJZCgpLCBzdXJmYWNlQ29udGVudCk7XG5cdFx0XHRjb25zb2xlLmxvZygnU2NyZWVuIFsnICsgbmV4dFNjcmVlbi5nZXRJZCgpICsgJ10gYWRkIGNvbnRlbnQgdG8gc3VyZmFjZSAnICtcblx0XHRcdFx0J1snICsgc3VyZmFjZXNbaWRdICsgJ10gWycgKyAoY29yZS5pc0RlZkFuZE5vdE51bGwoc3VyZmFjZUNvbnRlbnQpID8gJy4uLicgOiAnZW1wdHknKSArICddJyk7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVsb2FkcyB0aGUgcGFnZSBieSBwZXJmb3JtaW5nIGB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClgLlxuXHQgKi9cblx0cmVsb2FkUGFnZSgpIHtcblx0XHRnbG9iYWxzLndpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHJvdXRlIGluc3RhbmNlIGZyb20gYXBwIHJvdXRlcy5cblx0ICogQHBhcmFtIHtSb3V0ZX0gcm91dGVcblx0ICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlbGVtZW50IHdhcyByZW1vdmVkLlxuXHQgKi9cblx0cmVtb3ZlUm91dGUocm91dGUpIHtcblx0XHRyZXR1cm4gYXJyYXkucmVtb3ZlKHRoaXMucm91dGVzLCByb3V0ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhIHNjcmVlbi5cblx0ICogQHBhcmFtIHshc3RyaW5nfSBwYXRoIFBhdGggY29udGFpbmluZyB0aGUgcXVlcnlzdHJpbmcgcGFydC5cblx0ICovXG5cdHJlbW92ZVNjcmVlbihwYXRoKSB7XG5cdFx0dmFyIHNjcmVlbiA9IHRoaXMuc2NyZWVuc1twYXRoXTtcblx0XHRpZiAoc2NyZWVuKSB7XG5cdFx0XHRPYmplY3Qua2V5cyh0aGlzLnN1cmZhY2VzKS5mb3JFYWNoKChzdXJmYWNlSWQpID0+IHRoaXMuc3VyZmFjZXNbc3VyZmFjZUlkXS5yZW1vdmUoc2NyZWVuLmdldElkKCkpKTtcblx0XHRcdHNjcmVlbi5kaXNwb3NlKCk7XG5cdFx0XHRkZWxldGUgdGhpcy5zY3JlZW5zW3BhdGhdO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTYXZlcyBzY3JvbGwgcG9zaXRpb24gZnJvbSBwYWdlIG9mZnNldCBpbnRvIGhpc3Rvcnkgc3RhdGUuXG5cdCAqL1xuXHRzYXZlSGlzdG9yeUN1cnJlbnRQYWdlU2Nyb2xsUG9zaXRpb25fKCkge1xuXHRcdHZhciBzdGF0ZSA9IGdsb2JhbHMud2luZG93Lmhpc3Rvcnkuc3RhdGU7XG5cdFx0aWYgKHN0YXRlICYmIHN0YXRlLnNlbm5hKSB7XG5cdFx0XHRzdGF0ZS5zY3JvbGxUb3AgPSBnbG9iYWxzLndpbmRvdy5wYWdlWU9mZnNldDtcblx0XHRcdHN0YXRlLnNjcm9sbExlZnQgPSBnbG9iYWxzLndpbmRvdy5wYWdlWE9mZnNldDtcblx0XHRcdGdsb2JhbHMud2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCBudWxsLCBudWxsKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBhbGxvdyBwcmV2ZW50IG5hdmlnYXRlLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGFsbG93UHJldmVudE5hdmlnYXRlXG5cdCAqL1xuXHRzZXRBbGxvd1ByZXZlbnROYXZpZ2F0ZShhbGxvd1ByZXZlbnROYXZpZ2F0ZSkge1xuXHRcdHRoaXMuYWxsb3dQcmV2ZW50TmF2aWdhdGUgPSBhbGxvd1ByZXZlbnROYXZpZ2F0ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIGxpbmsgYmFzZSBwYXRoLlxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IHBhdGhcblx0ICovXG5cdHNldEJhc2VQYXRoKGJhc2VQYXRoKSB7XG5cdFx0dGhpcy5iYXNlUGF0aCA9IGJhc2VQYXRoO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGRlZmF1bHQgcGFnZSB0aXRsZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGRlZmF1bHRUaXRsZVxuXHQgKi9cblx0c2V0RGVmYXVsdFRpdGxlKGRlZmF1bHRUaXRsZSkge1xuXHRcdHRoaXMuZGVmYXVsdFRpdGxlID0gZGVmYXVsdFRpdGxlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGZvcm0gc2VsZWN0b3IuXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gZm9ybVNlbGVjdG9yXG5cdCAqL1xuXHRzZXRGb3JtU2VsZWN0b3IoZm9ybVNlbGVjdG9yKSB7XG5cdFx0dGhpcy5mb3JtU2VsZWN0b3IgPSBmb3JtU2VsZWN0b3I7XG5cdFx0aWYgKHRoaXMuZm9ybUV2ZW50SGFuZGxlcl8pIHtcblx0XHRcdHRoaXMuZm9ybUV2ZW50SGFuZGxlcl8ucmVtb3ZlTGlzdGVuZXIoKTtcblx0XHR9XG5cdFx0dGhpcy5mb3JtRXZlbnRIYW5kbGVyXyA9IGRvbS5kZWxlZ2F0ZShkb2N1bWVudCwgJ3N1Ym1pdCcsIHRoaXMuZm9ybVNlbGVjdG9yLCB0aGlzLm9uRG9jU3VibWl0RGVsZWdhdGVfLmJpbmQodGhpcykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGxpbmsgc2VsZWN0b3IuXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gbGlua1NlbGVjdG9yXG5cdCAqL1xuXHRzZXRMaW5rU2VsZWN0b3IobGlua1NlbGVjdG9yKSB7XG5cdFx0dGhpcy5saW5rU2VsZWN0b3IgPSBsaW5rU2VsZWN0b3I7XG5cdFx0aWYgKHRoaXMubGlua0V2ZW50SGFuZGxlcl8pIHtcblx0XHRcdHRoaXMubGlua0V2ZW50SGFuZGxlcl8ucmVtb3ZlTGlzdGVuZXIoKTtcblx0XHR9XG5cdFx0dGhpcy5saW5rRXZlbnRIYW5kbGVyXyA9IGRvbS5kZWxlZ2F0ZShkb2N1bWVudCwgJ2NsaWNrJywgdGhpcy5saW5rU2VsZWN0b3IsIHRoaXMub25Eb2NDbGlja0RlbGVnYXRlXy5iaW5kKHRoaXMpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBsb2FkaW5nIGNzcyBjbGFzcy5cblx0ICogQHBhcmFtIHshc3RyaW5nfSBsb2FkaW5nQ3NzQ2xhc3Ncblx0ICovXG5cdHNldExvYWRpbmdDc3NDbGFzcyhsb2FkaW5nQ3NzQ2xhc3MpIHtcblx0XHR0aGlzLmxvYWRpbmdDc3NDbGFzcyA9IGxvYWRpbmdDc3NDbGFzcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB1cGRhdGUgc2Nyb2xsIHBvc2l0aW9uIHZhbHVlLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHVwZGF0ZVNjcm9sbFBvc2l0aW9uXG5cdCAqL1xuXHRzZXRVcGRhdGVTY3JvbGxQb3NpdGlvbih1cGRhdGVTY3JvbGxQb3NpdGlvbikge1xuXHRcdHRoaXMudXBkYXRlU2Nyb2xsUG9zaXRpb24gPSB1cGRhdGVTY3JvbGxQb3NpdGlvbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYW5jZWxzIHBlbmRpbmcgbmF2aWdhdGUgd2l0aCA8Y29kZT5DYW5jZWwgcGVuZGluZyBuYXZpZ2F0aW9uPC9jb2RlPiBlcnJvci5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c3RvcFBlbmRpbmdOYXZpZ2F0ZV8oKSB7XG5cdFx0aWYgKHRoaXMucGVuZGluZ05hdmlnYXRlKSB7XG5cdFx0XHR0aGlzLnBlbmRpbmdOYXZpZ2F0ZS5jYW5jZWwoJ0NhbmNlbCBwZW5kaW5nIG5hdmlnYXRpb24nKTtcblx0XHRcdHRoaXMucGVuZGluZ05hdmlnYXRlID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU3luYyBkb2N1bWVudCBzY3JvbGwgcG9zaXRpb24gdHdpY2UsIHRoZSBmaXJzdCBvbmUgc3luY2hyb25vdXMgYW5kIHRoZW5cblx0ICogb25lIGluc2lkZSA8Y29kZT5hc3luYy5uZXh0VGljazwvY29kZT4uIFJlbGV2YW50IHRvIGJyb3dzZXJzIHRoYXQgZmlyZXNcblx0ICogc2Nyb2xsIHJlc3RvcmF0aW9uIGFzeW5jaHJvbm91c2x5IGFmdGVyIHBvcHN0YXRlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4gez9DYW5jZWxsYWJsZVByb21pc2U9fVxuXHQgKi9cblx0c3luY1Njcm9sbFBvc2l0aW9uU3luY1RoZW5Bc3luY18oKSB7XG5cdFx0dmFyIHN0YXRlID0gZ2xvYmFscy53aW5kb3cuaGlzdG9yeS5zdGF0ZTtcblx0XHRpZiAoIXN0YXRlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHNjcm9sbFRvcCA9IHN0YXRlLnNjcm9sbFRvcDtcblx0XHR2YXIgc2Nyb2xsTGVmdCA9IHN0YXRlLnNjcm9sbExlZnQ7XG5cblx0XHR2YXIgc3luYyA9ICgpID0+IHtcblx0XHRcdGlmICh0aGlzLnVwZGF0ZVNjcm9sbFBvc2l0aW9uKSB7XG5cdFx0XHRcdGdsb2JhbHMud2luZG93LnNjcm9sbFRvKHNjcm9sbExlZnQsIHNjcm9sbFRvcCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHJldHVybiBuZXcgQ2FuY2VsbGFibGVQcm9taXNlKChyZXNvbHZlKSA9PiBzeW5jKCkgJiBhc3luYy5uZXh0VGljaygoKSA9PiBzeW5jKCkgJiByZXNvbHZlKCkpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIG9yIHJlcGxhY2UgYnJvd3NlciBoaXN0b3J5LlxuXHQgKiBAcGFyYW0gez9zdHJpbmd9IHRpdGxlIERvY3VtZW50IHRpdGxlLlxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IHBhdGggUGF0aCBjb250YWluaW5nIHRoZSBxdWVyeXN0cmluZyBwYXJ0LlxuXHQgKiBAcGFyYW0geyFvYmplY3R9IHN0YXRlXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9yZXBsYWNlSGlzdG9yeSBSZXBsYWNlcyBicm93c2VyIGhpc3RvcnkuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHVwZGF0ZUhpc3RvcnlfKHRpdGxlLCBwYXRoLCBzdGF0ZSwgb3B0X3JlcGxhY2VIaXN0b3J5KSB7XG5cdFx0aWYgKG9wdF9yZXBsYWNlSGlzdG9yeSkge1xuXHRcdFx0Z2xvYmFscy53aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCBwYXRoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Z2xvYmFscy53aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCBwYXRoKTtcblx0XHR9XG5cdFx0Z2xvYmFscy5kb2N1bWVudC50aXRsZSA9IHRpdGxlO1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXBwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBEaXNwb3NhYmxlIH0gZnJvbSAnbWV0YWwnO1xuXG5jbGFzcyBDYWNoZWFibGUgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcblxuXHQvKipcblx0ICogQWJzdHJhY3QgY2xhc3MgZm9yIGRlZmluaW5nIGNhY2hlYWJsZSBiZWhhdmlvci5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgdGhlIGNhY2hlZCBkYXRhLlxuXHRcdCAqIEB0eXBlIHshT2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5jYWNoZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBIb2xkcyB3aGV0aGVyIGNsYXNzIGlzIGNhY2hlYWJsZS5cblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLmNhY2hlYWJsZSA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgY29udGVudCB0byB0aGUgY2FjaGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IENvbnRlbnQgdG8gYmUgY2FjaGVkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRhZGRDYWNoZShjb250ZW50KSB7XG5cdFx0aWYgKHRoaXMuY2FjaGVhYmxlKSB7XG5cdFx0XHR0aGlzLmNhY2hlID0gY29udGVudDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIHRoZSBjYWNoZS5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0Y2xlYXJDYWNoZSgpIHtcblx0XHR0aGlzLmNhY2hlID0gbnVsbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNwb3NlcyBvZiB0aGlzIGluc3RhbmNlJ3Mgb2JqZWN0IHJlZmVyZW5jZXMuXG5cdCAqIEBvdmVycmlkZVxuXHQgKi9cblx0ZGlzcG9zZUludGVybmFsKCkge1xuXHRcdHRoaXMuY2xlYXJDYWNoZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGNhY2hlZCBjb250ZW50LlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IENhY2hlZCBjb250ZW50LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRnZXRDYWNoZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5jYWNoZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBXaGV0aGVyIHRoZSBjbGFzcyBpcyBjYWNoZWFibGUuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSB3aGVuIGNsYXNzIGlzIGNhY2hlYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKi9cblx0aXNDYWNoZWFibGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2FjaGVhYmxlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgd2hldGhlciB0aGUgY2xhc3MgaXMgY2FjaGVhYmxlLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGNhY2hlYWJsZVxuXHQgKi9cblx0c2V0Q2FjaGVhYmxlKGNhY2hlYWJsZSkge1xuXHRcdGlmICghY2FjaGVhYmxlKSB7XG5cdFx0XHR0aGlzLmNsZWFyQ2FjaGUoKTtcblx0XHR9XG5cdFx0dGhpcy5jYWNoZWFibGUgPSBjYWNoZWFibGU7XG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBDYWNoZWFibGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogSG9sZHMgdmFsdWUgZXJyb3IgbWVzc2FnZXMuXG4gKiBAY29uc3RcbiAqL1xuY2xhc3MgZXJyb3JzIHtcbn1cblxuLyoqXG4gKiBJbnZhbGlkIHN0YXR1cyBlcnJvciBtZXNzYWdlLlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBzdGF0aWNcbiAqL1xuZXJyb3JzLklOVkFMSURfU1RBVFVTID0gJ0ludmFsaWQgc3RhdHVzIGNvZGUnO1xuXG4vKipcbiAqIFJlcXVlc3QgZXJyb3IgbWVzc2FnZS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAc3RhdGljXG4gKi9cbmVycm9ycy5SRVFVRVNUX0VSUk9SID0gJ1JlcXVlc3QgZXJyb3InO1xuXG4vKipcbiAqIFJlcXVlc3QgdGltZW91dCBlcnJvciBtZXNzYWdlLlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBzdGF0aWNcbiAqL1xuZXJyb3JzLlJFUVVFU1RfVElNRU9VVCA9ICdSZXF1ZXN0IHRpbWVvdXQnO1xuXG5leHBvcnQgZGVmYXVsdCBlcnJvcnM7IiwidmFyIGdsb2JhbHMgPSB7XG5cdGRvY3VtZW50OiBkb2N1bWVudCxcblx0d2luZG93OiB3aW5kb3dcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGdsb2JhbHM7IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuXG5jbGFzcyBSb3V0ZSB7XG5cblx0LyoqXG5cdCAqIFJvdXRlIGNsYXNzLlxuXHQgKiBAcGFyYW0geyFzdHJpbmd8UmVnRXhwfEZ1bmN0aW9ufSBwYXRoXG5cdCAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IocGF0aCwgaGFuZGxlcikge1xuXHRcdGlmICghY29yZS5pc0RlZkFuZE5vdE51bGwocGF0aCkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignUm91dGUgcGF0aCBub3Qgc3BlY2lmaWVkLicpO1xuXHRcdH1cblx0XHRpZiAoIWNvcmUuaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdSb3V0ZSBoYW5kbGVyIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIERlZmluZXMgdGhlIGhhbmRsZXIgd2hpY2ggd2lsbCBleGVjdXRlIG9uY2UgYSBVUkwgaW4gdGhlIGFwcGxpY2F0aW9uXG5cdFx0ICogbWF0Y2hlcyB0aGUgcGF0aC5cblx0XHQgKiBAdHlwZSB7IUZ1bmN0aW9ufVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyB0aGUgcGF0aCB3aGljaCB3aWxsIHRyaWdnZXIgdGhlIHJvdXRlIGhhbmRsZXIuXG5cdFx0ICogQHR5cGUgeyFzdHJpbmd8UmVnRXhwfEZ1bmN0aW9ufVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLnBhdGggPSBwYXRoO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHJvdXRlIGhhbmRsZXIuXG5cdCAqIEByZXR1cm4geyFGdW5jdGlvbn1cblx0ICovXG5cdGdldEhhbmRsZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaGFuZGxlcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSByb3V0ZSBwYXRoLlxuXHQgKiBAcmV0dXJuIHshc3RyaW5nfFJlZ0V4cHxGdW5jdGlvbn1cblx0ICovXG5cdGdldFBhdGgoKSB7XG5cdFx0cmV0dXJuIHRoaXMucGF0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBNYXRjaGVzIGlmIHRoZSByb3V0ZXIgY2FuIGhhbmRsZSB0aGUgdGVzdGVkIHBhdGguXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gdmFsdWUgUGF0aCB0byB0ZXN0IGFuZCBtYXkgY29udGFpbnMgdGhlIHF1ZXJ5c3RyaW5nXG5cdCAqICAgICBwYXJ0LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgbWF0Y2hlcyBhbnkgcm91dGUuXG5cdCAqL1xuXHRtYXRjaGVzUGF0aCh2YWx1ZSkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5wYXRoO1xuXG5cdFx0aWYgKGNvcmUuaXNTdHJpbmcocGF0aCkpIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gcGF0aDtcblx0XHR9XG5cdFx0aWYgKGNvcmUuaXNGdW5jdGlvbihwYXRoKSkge1xuXHRcdFx0cmV0dXJuIHBhdGgodmFsdWUpO1xuXHRcdH1cblx0XHRpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXHRcdFx0cmV0dXJuIHZhbHVlLnNlYXJjaChwYXRoKSA+IC0xO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJvdXRlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IEFqYXggZnJvbSAnbWV0YWwtYWpheCc7XG5pbXBvcnQgTXVsdGlNYXAgZnJvbSAnbWV0YWwtbXVsdGltYXAnO1xuaW1wb3J0IENhbmNlbGxhYmxlUHJvbWlzZSBmcm9tICdtZXRhbC1wcm9taXNlJztcbmltcG9ydCBlcnJvcnMgZnJvbSAnLi4vZXJyb3JzL2Vycm9ycyc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IGdsb2JhbHMgZnJvbSAnLi4vZ2xvYmFscy9nbG9iYWxzJztcbmltcG9ydCBTY3JlZW4gZnJvbSAnLi9TY3JlZW4nO1xuaW1wb3J0IFVyaSBmcm9tICdtZXRhbC11cmknO1xuaW1wb3J0IFVBIGZyb20gJ21ldGFsLXVzZXJhZ2VudCc7XG5cbmNsYXNzIFJlcXVlc3RTY3JlZW4gZXh0ZW5kcyBTY3JlZW4ge1xuXG5cdC8qKlxuXHQgKiBSZXF1ZXN0IHNjcmVlbiBhYnN0cmFjdCBjbGFzcyB0byBwZXJmb3JtIGlvIG9wZXJhdGlvbnMgb24gZGVzY2VuZGFudFxuXHQgKiBzY3JlZW5zLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQGV4dGVuZHMge1NjcmVlbn1cblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHQvKipcblx0XHQgKiBAaW5oZXJpdERvY1xuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLmNhY2hlYWJsZSA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBIb2xkcyBkZWZhdWx0IGh0dHAgaGVhZGVycyB0byBzZXQgb24gcmVxdWVzdC5cblx0XHQgKiBAdHlwZSB7P09iamVjdD19XG5cdFx0ICogQGRlZmF1bHQge1xuXHRcdCAqICAgJ1gtUEpBWCc6ICd0cnVlJyxcblx0XHQgKiAgICdYLVJlcXVlc3RlZC1XaXRoJzogJ1hNTEh0dHBSZXF1ZXN0J1xuXHRcdCAqIH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5odHRwSGVhZGVycyA9IHtcblx0XHRcdCdYLVBKQVgnOiAndHJ1ZScsXG5cdFx0XHQnWC1SZXF1ZXN0ZWQtV2l0aCc6ICdYTUxIdHRwUmVxdWVzdCdcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgZGVmYXVsdCBodHRwIG1ldGhvZCB0byBwZXJmb3JtIHRoZSByZXF1ZXN0LlxuXHRcdCAqIEB0eXBlIHshc3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IFJlcXVlc3RTY3JlZW4uR0VUXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuaHR0cE1ldGhvZCA9IFJlcXVlc3RTY3JlZW4uR0VUO1xuXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgdGhlIFhIUiBvYmplY3QgcmVzcG9uc2libGUgZm9yIHRoZSByZXF1ZXN0LlxuXHRcdCAqIEB0eXBlIHtYTUxIdHRwUmVxdWVzdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMucmVxdWVzdCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBIb2xkcyB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcy5cblx0XHQgKiBAdHlwZSB7IW51bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAzMDAwMFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLnRpbWVvdXQgPSAzMDAwMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBc3NlcnRzIHRoYXQgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgaXMgdmFsaWQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0YXNzZXJ0VmFsaWRSZXNwb25zZVN0YXR1c0NvZGUoc3RhdHVzKSB7XG5cdFx0aWYgKCF0aGlzLmlzVmFsaWRSZXNwb25zZVN0YXR1c0NvZGUoc3RhdHVzKSkge1xuXHRcdFx0dmFyIGVycm9yID0gbmV3IEVycm9yKGVycm9ycy5JTlZBTElEX1NUQVRVUyk7XG5cdFx0XHRlcnJvci5pbnZhbGlkU3RhdHVzID0gdHJ1ZTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0YmVmb3JlVXBkYXRlSGlzdG9yeVBhdGgocGF0aCkge1xuXHRcdHZhciByZWRpcmVjdFBhdGggPSB0aGlzLmdldFJlcXVlc3RQYXRoKCk7XG5cdFx0aWYgKHJlZGlyZWN0UGF0aCAmJiByZWRpcmVjdFBhdGggIT09IHBhdGgpIHtcblx0XHRcdHJldHVybiByZWRpcmVjdFBhdGg7XG5cdFx0fVxuXHRcdHJldHVybiBwYXRoO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRiZWZvcmVVcGRhdGVIaXN0b3J5U3RhdGUoc3RhdGUpIHtcblx0XHQvLyBJZiBzdGF0ZSBpcyBvdXJzIGFuZCBuYXZpZ2F0ZSB0byBwb3N0LXdpdGhvdXQtcmVkaXJlY3QtZ2V0IHNldFxuXHRcdC8vIGhpc3Rvcnkgc3RhdGUgdG8gbnVsbCwgdGhhdCB3YXkgU2VubmEgd2lsbCByZWxvYWQgdGhlIHBhZ2Ugb25cblx0XHQvLyBwb3BzdGF0ZSBzaW5jZSBpdCBjYW5ub3QgcHJlZGljdCBwb3N0IGRhdGEuXG5cdFx0aWYgKHN0YXRlLnNlbm5hICYmIHN0YXRlLmZvcm0gJiYgc3RhdGUucmVkaXJlY3RQYXRoID09PSBzdGF0ZS5wYXRoKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHN0YXRlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZvcm1hdHMgbG9hZCBwYXRoIGJlZm9yZSBpbnZva2luZyBhamF4IGNhbGwuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gRm9ybWF0dGVkIHBhdGg7XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGZvcm1hdExvYWRQYXRoKHBhdGgpIHtcblx0XHRpZiAoVUEuaXNJZU9yRWRnZSAmJiB0aGlzLmh0dHBNZXRob2QgPT09IFJlcXVlc3RTY3JlZW4uR0VUKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFVyaShwYXRoKS5tYWtlVW5pcXVlKCkudG9TdHJpbmcoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhdGg7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgaHR0cCBoZWFkZXJzLlxuXHQgKiBAcmV0dXJuIHs/T2JqZWN0PX1cblx0ICovXG5cdGdldEh0dHBIZWFkZXJzKCkge1xuXHRcdHJldHVybiB0aGlzLmh0dHBIZWFkZXJzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGh0dHAgbWV0aG9kLlxuXHQgKiBAcmV0dXJuIHshc3RyaW5nfVxuXHQgKi9cblx0Z2V0SHR0cE1ldGhvZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5odHRwTWV0aG9kO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgcmVxdWVzdCBwYXRoLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmc9fVxuXHQgKi9cblx0Z2V0UmVxdWVzdFBhdGgoKSB7XG5cdFx0dmFyIHJlcXVlc3QgPSB0aGlzLmdldFJlcXVlc3QoKTtcblx0XHRpZiAocmVxdWVzdCkge1xuXHRcdFx0dmFyIHJlcXVlc3RQYXRoID0gcmVxdWVzdC5yZXF1ZXN0UGF0aDtcblx0XHRcdHZhciByZXNwb25zZVVybCA9IHRoaXMubWF5YmVFeHRyYWN0UmVzcG9uc2VVcmxGcm9tUmVxdWVzdChyZXF1ZXN0KTtcblx0XHRcdGlmIChyZXNwb25zZVVybCkge1xuXHRcdFx0XHRyZXF1ZXN0UGF0aCA9IHJlc3BvbnNlVXJsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKFVBLmlzSWVPckVkZ2UgJiYgdGhpcy5odHRwTWV0aG9kID09PSBSZXF1ZXN0U2NyZWVuLkdFVCkge1xuXHRcdFx0XHRyZXF1ZXN0UGF0aCA9IG5ldyBVcmkocmVxdWVzdFBhdGgpLnJlbW92ZVVuaXF1ZSgpLnRvU3RyaW5nKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdXRpbHMuZ2V0VXJsUGF0aChyZXF1ZXN0UGF0aCk7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHJlcXVlc3Qgb2JqZWN0LlxuXHQgKiBAcmV0dXJuIHs/T2JqZWN0fVxuXHQgKi9cblx0Z2V0UmVxdWVzdCgpIHtcblx0XHRyZXR1cm4gdGhpcy5yZXF1ZXN0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHJlcXVlc3QgdGltZW91dC5cblx0ICogQHJldHVybiB7IW51bWJlcn1cblx0ICovXG5cdGdldFRpbWVvdXQoKSB7XG5cdFx0cmV0dXJuIHRoaXMudGltZW91dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgcmVzcG9uc2Ugc3VjY2VlZGVkLiBBbnkgc3RhdHVzIGNvZGUgMnh4IG9yIDN4eCBpcyBjb25zaWRlcmVkXG5cdCAqIHZhbGlkLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhdHVzQ29kZVxuXHQgKi9cblx0aXNWYWxpZFJlc3BvbnNlU3RhdHVzQ29kZShzdGF0dXNDb2RlKSB7XG5cdFx0cmV0dXJuIHN0YXR1c0NvZGUgPj0gMjAwICYmIHN0YXR1c0NvZGUgPD0gMzk5O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRsb2FkKHBhdGgpIHtcblx0XHR2YXIgY2FjaGUgPSB0aGlzLmdldENhY2hlKCk7XG5cdFx0aWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKGNhY2hlKSkge1xuXHRcdFx0cmV0dXJuIENhbmNlbGxhYmxlUHJvbWlzZS5yZXNvbHZlKGNhY2hlKTtcblx0XHR9XG5cblx0XHR2YXIgYm9keSA9IG51bGw7XG5cdFx0dmFyIGh0dHBNZXRob2QgPSB0aGlzLmh0dHBNZXRob2Q7XG5cblx0XHR2YXIgaGVhZGVycyA9IG5ldyBNdWx0aU1hcCgpO1xuXHRcdE9iamVjdC5rZXlzKHRoaXMuaHR0cEhlYWRlcnMpLmZvckVhY2goaGVhZGVyID0+IGhlYWRlcnMuYWRkKGhlYWRlciwgdGhpcy5odHRwSGVhZGVyc1toZWFkZXJdKSk7XG5cblx0XHRpZiAoZ2xvYmFscy5jYXB0dXJlZEZvcm1FbGVtZW50KSB7XG5cdFx0XHRib2R5ID0gbmV3IEZvcm1EYXRhKGdsb2JhbHMuY2FwdHVyZWRGb3JtRWxlbWVudCk7XG5cdFx0XHRodHRwTWV0aG9kID0gUmVxdWVzdFNjcmVlbi5QT1NUO1xuXHRcdFx0aWYgKFVBLmlzSWVPckVkZ2UpIHtcblx0XHRcdFx0aGVhZGVycy5hZGQoJ0lmLU5vbmUtTWF0Y2gnLCAnXCIwXCInKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgcmVxdWVzdFBhdGggPSB0aGlzLmZvcm1hdExvYWRQYXRoKHBhdGgpO1xuXHRcdHJldHVybiBBamF4XG5cdFx0XHQucmVxdWVzdChyZXF1ZXN0UGF0aCwgaHR0cE1ldGhvZCwgYm9keSwgaGVhZGVycywgbnVsbCwgdGhpcy50aW1lb3V0KVxuXHRcdFx0LnRoZW4oeGhyID0+IHtcblx0XHRcdFx0dGhpcy5zZXRSZXF1ZXN0KHhocik7XG5cdFx0XHRcdHRoaXMuYXNzZXJ0VmFsaWRSZXNwb25zZVN0YXR1c0NvZGUoeGhyLnN0YXR1cyk7XG5cdFx0XHRcdGlmIChodHRwTWV0aG9kID09PSBSZXF1ZXN0U2NyZWVuLkdFVCAmJiB0aGlzLmlzQ2FjaGVhYmxlKCkpIHtcblx0XHRcdFx0XHR0aGlzLmFkZENhY2hlKHhoci5yZXNwb25zZVRleHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHhoci5yZXF1ZXN0UGF0aCA9IHJlcXVlc3RQYXRoO1xuXHRcdFx0XHRyZXR1cm4geGhyLnJlc3BvbnNlVGV4dDtcblx0XHRcdH0pXG5cdFx0XHQuY2F0Y2goKHJlYXNvbikgPT4ge1xuXHRcdFx0XHRzd2l0Y2ggKHJlYXNvbi5tZXNzYWdlKSB7XG5cdFx0XHRcdFx0Y2FzZSBlcnJvcnMuUkVRVUVTVF9USU1FT1VUOlxuXHRcdFx0XHRcdFx0cmVhc29uLnRpbWVvdXQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBlcnJvcnMuUkVRVUVTVF9FUlJPUjpcblx0XHRcdFx0XHRcdHJlYXNvbi5yZXF1ZXN0RXJyb3IgPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgcmVhc29uO1xuXHRcdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGZvbGxvd2luZyBtZXRob2QgdHJpZXMgdG8gZXh0cmFjdCB0aGUgcmVzcG9uc2UgdXJsIHZhbHVlIGJ5IGNoZWNraW5nXG5cdCAqIHRoZSBjdXN0b20gcmVzcG9uc2UgaGVhZGVyICdYLVJlcXVlc3QtVVJMJyBpZiBwcm9wZXIgdmFsdWUgaXMgbm90IHByZXNlbnRcblx0ICogaW4gWE1MSHR0cFJlcXVlc3QuIFRoZSB2YWx1ZSBvZiByZXNwb25zZVVSTCB3aWxsIGJlIHRoZSBmaW5hbCBVUkxcblx0ICogb2J0YWluZWQgYWZ0ZXIgYW55IHJlZGlyZWN0cy4gSW50ZXJuZXQgRXhwbG9yZXIsIEVkZ2UgYW5kIFNhZmFyaSA8PSA3XG5cdCAqIGRvZXMgbm90IHlldCBzdXBwb3J0IHRoZSBmZWF0dXJlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWU6XG5cdCAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9yZXNwb25zZVVSTFxuXHQgKiBodHRwczovL3hoci5zcGVjLndoYXR3Zy5vcmcvI3RoZS1yZXNwb25zZXVybC1hdHRyaWJ1dGVcblx0ICogQHBhcmFtIHtYTUxIdHRwUmVxdWVzdH0gcmVxdWVzdFxuXHQgKiBAcmV0dXJuIHs/c3RyaW5nfSBSZXNwb25zZSB1cmwgYmVzdCBtYXRjaC5cblx0ICovXG5cdG1heWJlRXh0cmFjdFJlc3BvbnNlVXJsRnJvbVJlcXVlc3QocmVxdWVzdCkge1xuXHRcdHZhciByZXNwb25zZVVybCA9IHJlcXVlc3QucmVzcG9uc2VVUkw7XG5cdFx0aWYgKHJlc3BvbnNlVXJsKSB7XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VVcmw7XG5cdFx0fVxuXHRcdHJldHVybiByZXF1ZXN0LmdldFJlc3BvbnNlSGVhZGVyKFJlcXVlc3RTY3JlZW4uWF9SRVFVRVNUX1VSTF9IRUFERVIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGh0dHAgaGVhZGVycy5cblx0ICogQHBhcmFtIHs/T2JqZWN0PX0gaHR0cEhlYWRlcnNcblx0ICovXG5cdHNldEh0dHBIZWFkZXJzKGh0dHBIZWFkZXJzKSB7XG5cdFx0dGhpcy5odHRwSGVhZGVycyA9IGh0dHBIZWFkZXJzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGh0dHAgbWV0aG9kLlxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IGh0dHBNZXRob2Rcblx0ICovXG5cdHNldEh0dHBNZXRob2QoaHR0cE1ldGhvZCkge1xuXHRcdHRoaXMuaHR0cE1ldGhvZCA9IGh0dHBNZXRob2QudG9Mb3dlckNhc2UoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSByZXF1ZXN0IG9iamVjdC5cblx0ICogQHBhcmFtIHs/T2JqZWN0fSByZXF1ZXN0XG5cdCAqL1xuXHRzZXRSZXF1ZXN0KHJlcXVlc3QpIHtcblx0XHR0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIEBwYXJhbSB7IW51bWJlcn0gdGltZW91dFxuXHQgKi9cblx0c2V0VGltZW91dCh0aW1lb3V0KSB7XG5cdFx0dGhpcy50aW1lb3V0ID0gdGltZW91dDtcblx0fVxuXG59XG5cbi8qKlxuICogSG9sZHMgdmFsdWUgZm9yIG1ldGhvZCBnZXQuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGRlZmF1bHQgJ2dldCdcbiAqIEBzdGF0aWNcbiAqL1xuUmVxdWVzdFNjcmVlbi5HRVQgPSAnZ2V0JztcblxuLyoqXG4gKiBIb2xkcyB2YWx1ZSBmb3IgbWV0aG9kIHBvc3QuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGRlZmF1bHQgJ3Bvc3QnXG4gKiBAc3RhdGljXG4gKi9cblJlcXVlc3RTY3JlZW4uUE9TVCA9ICdwb3N0JztcblxuLyoqXG4gKiBGYWxsYmFjayBodHRwIGhlYWRlciB0byByZXRyaWV2ZSByZXNwb25zZSByZXF1ZXN0IHVybC5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAZGVmYXVsdCAnWC1SZXF1ZXN0LVVSTCdcbiAqIEBzdGF0aWNcbiAqL1xuUmVxdWVzdFNjcmVlbi5YX1JFUVVFU1RfVVJMX0hFQURFUiA9ICdYLVJlcXVlc3QtVVJMJztcblxuZXhwb3J0IGRlZmF1bHQgUmVxdWVzdFNjcmVlbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSB9IGZyb20gJ21ldGFsJztcbmltcG9ydCB7IGdsb2JhbEV2YWwgfSBmcm9tICdtZXRhbC1kb20nO1xuaW1wb3J0IENhY2hlYWJsZSBmcm9tICcuLi9jYWNoZWFibGUvQ2FjaGVhYmxlJztcbmltcG9ydCBDYW5jZWxsYWJsZVByb21pc2UgZnJvbSAnbWV0YWwtcHJvbWlzZSc7XG5cbmNsYXNzIFNjcmVlbiBleHRlbmRzIENhY2hlYWJsZSB7XG5cblx0LyoqXG5cdCAqIFNjcmVlbiBjbGFzcyBpcyBhIHNwZWNpYWwgdHlwZSBvZiByb3V0ZSBoYW5kbGVyIHRoYXQgcHJvdmlkZXMgaGVscGVyXG5cdCAqIHV0aWxpdGllcyB0aGF0IGFkZHMgbGlmZWN5Y2xlIGFuZCBtZXRob2RzIHRvIHByb3ZpZGUgY29udGVudCB0byBlYWNoXG5cdCAqIHJlZ2lzdGVyZWQgc3VyZmFjZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBleHRlbmRzIHtDYWNoZWFibGV9XG5cdCAqL1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgdGhlIHNjcmVlbiBpZC5cblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLmlkID0gdGhpcy5tYWtlSWRfKGNvcmUuZ2V0VWlkKCkpO1xuXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgdGhlIHNjcmVlbiB0aXRsZS4gUmVsZXZhbnQgd2hlbiB0aGUgcGFnZSB0aXRsZSBzaG91bGQgYmVcblx0XHQgKiB1cGFkYXRlZCB3aGVuIHNjcmVlbiBpcyByZW5kZXJlZC5cblx0XHQgKiBAdHlwZSB7P3N0cmluZz19XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLnRpdGxlID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBGaXJlcyB3aGVuIHRoZSBzY3JlZW4gaXMgYWN0aXZlLiBBbGxvd3MgYSBzY3JlZW4gdG8gcGVyZm9ybSBhbnkgc2V0dXBcblx0ICogdGhhdCByZXF1aXJlcyBpdHMgRE9NIHRvIGJlIHZpc2libGUuIExpZmVjeWNsZS5cblx0ICovXG5cdGFjdGl2YXRlKCkge1xuXHRcdGNvbnNvbGUubG9nKCdTY3JlZW4gWycgKyB0aGlzICsgJ10gYWN0aXZhdGUnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHaXZlcyB0aGUgU2NyZWVuIGEgY2hhbmNlIHRvIGNhbmNlbCB0aGUgbmF2aWdhdGlvbiBhbmQgc3RvcCBpdHNlbGYgZnJvbVxuXHQgKiBiZWluZyBkZWFjdGl2YXRlZC4gQ2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCBpZiB0aGUgc2NyZWVuIGhhcyB1bnNhdmVkXG5cdCAqIHN0YXRlLiBMaWZlY3ljbGUuIENsZWFuLXVwIHNob3VsZCBub3QgYmUgcHJlZm9ybWVkIGhlcmUsIHNpbmNlIHRoZVxuXHQgKiBuYXZpZ2F0aW9uIG1heSBzdGlsbCBiZSBjYW5jZWxsZWQuIERvIGNsZWFuLXVwIGluIGRlYWN0aXZhdGUuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW49fSBJZiByZXR1cm5zIHRydWUsIHRoZSBjdXJyZW50IHNjcmVlbiBpcyBsb2NrZWQgYW5kIHRoZVxuXHQgKiAgICAgbmV4dCBuYWdpdmF0aW9uIGludGVycnVwdGVkLlxuXHQgKi9cblx0YmVmb3JlRGVhY3RpdmF0ZSgpIHtcblx0XHRjb25zb2xlLmxvZygnU2NyZWVuIFsnICsgdGhpcyArICddIGJlZm9yZURlYWN0aXZhdGUnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHaXZlcyB0aGUgU2NyZWVuIGEgY2hhbmNlIGZvcm1hdCB0aGUgcGF0aCBiZWZvcmUgaGlzdG9yeSB1cGRhdGUuXG5cdCAqIEBwYXRoIHshc3RyaW5nfSBwYXRoIE5hdmlnYXRpb24gcGF0aC5cblx0ICogQHJldHVybiB7IXN0cmluZ30gTmF2aWdhdGlvbiBwYXRoIHRvIHVzZSBvbiBoaXN0b3J5LlxuXHQgKi9cblx0YmVmb3JlVXBkYXRlSGlzdG9yeVBhdGgocGF0aCkge1xuXHRcdHJldHVybiBwYXRoO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdpdmVzIHRoZSBTY3JlZW4gYSBjaGFuY2UgZm9ybWF0IHRoZSBzdGF0ZSBiZWZvcmUgaGlzdG9yeSB1cGRhdGUuXG5cdCAqIEBwYXRoIHshb2JqZWN0fSBzdGF0ZSBIaXN0b3J5IHN0YXRlLlxuXHQgKiBAcmV0dXJuIHshb2JqZWN0fSBIaXN0b3J5IHN0YXRlIHRvIHVzZSBvbiBoaXN0b3J5LlxuXHQgKi9cblx0YmVmb3JlVXBkYXRlSGlzdG9yeVN0YXRlKHN0YXRlKSB7XG5cdFx0cmV0dXJuIHN0YXRlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFsbG93cyBhIHNjcmVlbiB0byBkbyBhbnkgY2xlYW51cCBuZWNlc3NhcnkgYWZ0ZXIgaXQgaGFzIGJlZW5cblx0ICogZGVhY3RpdmF0ZWQsIGZvciBleGFtcGxlIGNhbmNlbGxpbmcgb3V0c3RhbmRpbmcgcmVxdWVzdHMgb3Igc3RvcHBpbmdcblx0ICogdGltZXJzLiBMaWZlY3ljbGUuXG5cdCAqL1xuXHRkZWFjdGl2YXRlKCkge1xuXHRcdGNvbnNvbGUubG9nKCdTY3JlZW4gWycgKyB0aGlzICsgJ10gZGVhY3RpdmF0ZScpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERpc3Bvc2UgYSBzY3JlZW4sIGVpdGhlciBhZnRlciBpdCBpcyBkZWFjdGl2YXRlZCAoaW4gdGhlIGNhc2Ugb2YgYVxuXHQgKiBub24tY2FjaGVhYmxlIHZpZXcpIG9yIHdoZW4gdGhlIEFwcCBpcyBpdHNlbGYgZGlzcG9zZWQgZm9yIHdoYXRldmVyXG5cdCAqIHJlYXNvbi4gTGlmZWN5Y2xlLlxuXHQgKi9cblx0ZGlzcG9zZUludGVybmFsKCkge1xuXHRcdHN1cGVyLmRpc3Bvc2VJbnRlcm5hbCgpO1xuXHRcdGNvbnNvbGUubG9nKCdTY3JlZW4gWycgKyB0aGlzICsgJ10gZGlzcG9zZScpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFsbG93cyBhIHNjcmVlbiB0byBldmFsdWF0ZSBzY3JpcHRzIGJlZm9yZSB0aGUgZWxlbWVudCBpcyBtYWRlIHZpc2libGUuXG5cdCAqIExpZmVjeWNsZS5cblx0ICogQHBhcmFtIHshb2JqZWN0fSBzdXJmYWNlcyBNYXAgb2Ygc3VyZmFjZXMgdG8gZmxpcCBrZXllZCBieSBzdXJmYWNlIGlkLlxuXHQgKiBAcmV0dXJuIHs/Q2FuY2VsbGFibGVQcm9taXNlPX0gVGhpcyBjYW4gcmV0dXJuIGEgcHJvbWlzZSwgd2hpY2ggd2lsbFxuXHQgKiAgICAgcGF1c2UgdGhlIG5hdmlnYXRpb24gdW50aWwgaXQgaXMgcmVzb2x2ZWQuXG5cdCAqL1xuXHRldmFsdWF0ZVNjcmlwdHMoc3VyZmFjZXMpIHtcblx0XHRPYmplY3Qua2V5cyhzdXJmYWNlcykuZm9yRWFjaChzSWQgPT4ge1xuXHRcdFx0aWYgKHN1cmZhY2VzW3NJZF0uYWN0aXZlQ2hpbGQpIHtcblx0XHRcdFx0Z2xvYmFsRXZhbC5ydW5TY3JpcHRzSW5FbGVtZW50KHN1cmZhY2VzW3NJZF0uYWN0aXZlQ2hpbGQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBDYW5jZWxsYWJsZVByb21pc2UucmVzb2x2ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFsbG93cyBhIHNjcmVlbiB0byBldmFsdWF0ZSBzdHlsZXMgYmVmb3JlIHRoZSBlbGVtZW50IGlzIG1hZGUgdmlzaWJsZS5cblx0ICogTGlmZWN5Y2xlLlxuXHQgKiBAcGFyYW0geyFvYmplY3R9IHN1cmZhY2VzIE1hcCBvZiBzdXJmYWNlcyB0byBmbGlwIGtleWVkIGJ5IHN1cmZhY2UgaWQuXG5cdCAqIEByZXR1cm4gez9DYW5jZWxsYWJsZVByb21pc2U9fSBUaGlzIGNhbiByZXR1cm4gYSBwcm9taXNlLCB3aGljaCB3aWxsXG5cdCAqICAgICBwYXVzZSB0aGUgbmF2aWdhdGlvbiB1bnRpbCBpdCBpcyByZXNvbHZlZC5cblx0ICovXG5cdGV2YWx1YXRlU3R5bGVzKCkge1xuXHRcdHJldHVybiBDYW5jZWxsYWJsZVByb21pc2UucmVzb2x2ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFsbG93cyBhIHNjcmVlbiB0byBwZXJmb3JtIGFueSBzZXR1cCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGVsZW1lbnQgaXNcblx0ICogbWFkZSB2aXNpYmxlLiBMaWZlY3ljbGUuXG5cdCAqIEBwYXJhbSB7IW9iamVjdH0gc3VyZmFjZXMgTWFwIG9mIHN1cmZhY2VzIHRvIGZsaXAga2V5ZWQgYnkgc3VyZmFjZSBpZC5cblx0ICogQHJldHVybiB7P0NhbmNlbGxhYmxlUHJvbWlzZT19IFRoaXMgY2FuIHJldHVybiBhIHByb21pc2UsIHdoaWNoIHdpbGwgcGF1c2UgdGhlXG5cdCAqICAgICBuYXZpZ2F0aW9uIHVudGlsIGl0IGlzIHJlc29sdmVkLlxuXHQgKi9cblx0ZmxpcChzdXJmYWNlcykge1xuXHRcdGNvbnNvbGUubG9nKCdTY3JlZW4gWycgKyB0aGlzICsgJ10gZmxpcCcpO1xuXG5cdFx0dmFyIHRyYW5zaXRpb25zID0gW107XG5cblx0XHRPYmplY3Qua2V5cyhzdXJmYWNlcykuZm9yRWFjaChzSWQgPT4ge1xuXHRcdFx0dmFyIHN1cmZhY2UgPSBzdXJmYWNlc1tzSWRdO1xuXHRcdFx0dmFyIGRlZmVycmVkID0gc3VyZmFjZS5zaG93KHRoaXMuaWQpO1xuXHRcdFx0dHJhbnNpdGlvbnMucHVzaChkZWZlcnJlZCk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gQ2FuY2VsbGFibGVQcm9taXNlLmFsbCh0cmFuc2l0aW9ucyk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgc2NyZWVuIGlkLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRJZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5pZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjb250ZW50IGZvciB0aGUgZ2l2ZW4gc3VyZmFjZSwgb3IgbnVsbCBpZiB0aGUgc3VyZmFjZSBpc24ndFxuXHQgKiB1c2VkIGJ5IHRoaXMgc2NyZWVuLiBUaGlzIHdpbGwgYmUgY2FsbGVkIHdoZW4gYSBzY3JlZW4gaXMgaW5pdGlhbGx5XG5cdCAqIGNvbnN0cnVjdGVkIG9yLCBpZiBhIHNjcmVlbiBpcyBub24tY2FjaGVhYmxlLCB3aGVuIG5hdmlnYXRlZC5cblx0ICogQHBhcmFtIHshc3RyaW5nfSBzdXJmYWNlSWQgVGhlIGlkIG9mIHRoZSBzdXJmYWNlIERPTSBlbGVtZW50LlxuXHQgKiBAcmV0dXJuIHs/c3RyaW5nfEVsZW1lbnQ9fSBUaGlzIGNhbiByZXR1cm4gYSBzdHJpbmcgb3Igbm9kZSByZXByZXNlbnRpbmdcblx0ICogICAgIHRoZSBjb250ZW50IG9mIHRoZSBzdXJmYWNlLiBJZiByZXR1cm5zIGZhbHN5IHZhbHVlcyBzdXJmYWNlIGRlZmF1bHRcblx0ICogICAgIGNvbnRlbnQgaXMgcmVzdG9yZWQuXG5cdCAqL1xuXHRnZXRTdXJmYWNlQ29udGVudCgpIHtcblx0XHRjb25zb2xlLmxvZygnU2NyZWVuIFsnICsgdGhpcyArICddIGdldFN1cmZhY2VDb250ZW50Jyk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgc2NyZWVuIHRpdGxlLlxuXHQgKiBAcmV0dXJuIHs/c3RyaW5nPX1cblx0ICovXG5cdGdldFRpdGxlKCkge1xuXHRcdHJldHVybiB0aGlzLnRpdGxlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYWxsIGNvbnRlbnRzIGZvciB0aGUgc3VyZmFjZXMuIFRoaXMgd2lsbCBwYXNzIHRoZSBsb2FkZWQgY29udGVudFxuXHQgKiB0byA8Y29kZT5TY3JlZW4ubG9hZDwvY29kZT4gd2l0aCBhbGwgaW5mb3JtYXRpb24geW91XG5cdCAqIG5lZWQgdG8gZnVsZmlsbCB0aGUgc3VyZmFjZXMuIExpZmVjeWNsZS5cblx0ICogQHBhcmFtIHshc3RyaW5nPX0gcGF0aCBUaGUgcmVxdWVzdGVkIHBhdGguXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9IFRoaXMgY2FuIHJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlXG5cdCAqICAgICBjb250ZW50cyBvZiB0aGUgc3VyZmFjZXMgb3IgYSBwcm9taXNlLCB3aGljaCB3aWxsIHBhdXNlIHRoZSBuYXZpZ2F0aW9uXG5cdCAqICAgICB1bnRpbCBpdCBpcyByZXNvbHZlZC4gVGhpcyBpcyB1c2VmdWwgZm9yIGxvYWRpbmcgYXN5bmMgY29udGVudC5cblx0ICovXG5cdGxvYWQoKSB7XG5cdFx0Y29uc29sZS5sb2coJ1NjcmVlbiBbJyArIHRoaXMgKyAnXSBsb2FkJyk7XG5cdFx0cmV0dXJuIENhbmNlbGxhYmxlUHJvbWlzZS5yZXNvbHZlKCk7XG5cdH1cblxuXHQvKipcblx0ICogTWFrZXMgdGhlIGlkIGZvciB0aGUgc2NyZWVuLlxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IGlkIFRoZSBzY3JlZW4gaWQgdGhlIGNvbnRlbnQgYmVsb25ncyB0b28uXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICogQHByaXZhdGVcblx0ICovXG5cdG1ha2VJZF8oaWQpIHtcblx0XHRyZXR1cm4gJ3NjcmVlbl8nICsgaWQ7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgc2NyZWVuIGlkLlxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IGlkXG5cdCAqL1xuXHRzZXRJZChpZCkge1xuXHRcdHRoaXMuaWQgPSBpZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBzY3JlZW4gdGl0bGUuXG5cdCAqIEBwYXJhbSB7P3N0cmluZz19IHRpdGxlXG5cdCAqL1xuXHRzZXRUaXRsZSh0aXRsZSkge1xuXHRcdHRoaXMudGl0bGUgPSB0aXRsZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5pZDtcblx0fVxuXG59XG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgYSBnaXZlbiBpbnN0YW5jZSBpbXBsZW1lbnRzXG4gKiA8Y29kZT5TY3JlZW48L2NvZGU+LlxuICovXG5TY3JlZW4uaXNJbXBsZW1lbnRlZEJ5ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG5cdHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBTY3JlZW47XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTY3JlZW47XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBnbG9iYWxzIGZyb20gJy4uL2dsb2JhbHMvZ2xvYmFscyc7XG5pbXBvcnQgeyBjb3JlLCBEaXNwb3NhYmxlIH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IGRvbSBmcm9tICdtZXRhbC1kb20nO1xuaW1wb3J0IENhbmNlbGxhYmxlUHJvbWlzZSBmcm9tICdtZXRhbC1wcm9taXNlJztcblxuY2xhc3MgU3VyZmFjZSBleHRlbmRzIERpc3Bvc2FibGUge1xuXG5cdC8qKlxuXHQgKiBTdXJmYWNlIGNsYXNzIHJlcHJlc2VudGluZyB0aGUgcmVmZXJlbmNlcyB0byBlbGVtZW50cyBvbiB0aGUgcGFnZSB0aGF0XG5cdCAqIGNhbiBwb3RlbnRpYWxseSBiZSB1cGRhdGVkIGJ5IDxjb2RlPkFwcDwvY29kZT4uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKGlkKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdGlmICghaWQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignU3VyZmFjZSBlbGVtZW50IGlkIG5vdCBzcGVjaWZpZWQuIEEgc3VyZmFjZSBlbGVtZW50IHJlcXVpcmVzIGEgdmFsaWQgaWQuJyk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgdGhlIGFjdGl2ZSBjaGlsZCBlbGVtZW50LlxuXHRcdCAqIEB0eXBlIHtFbGVtZW50fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5hY3RpdmVDaGlsZCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBIb2xkcyB0aGUgZGVmYXVsdCBjaGlsZCBlbGVtZW50LlxuXHRcdCAqIEB0eXBlIHtFbGVtZW50fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5kZWZhdWx0Q2hpbGQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgdGhlIGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIHN1cmZhY2UgaWQsIGlmIG5vdCBmb3VuZCBjcmVhdGVzIGFcblx0XHQgKiBuZXcgZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQgaWQuXG5cdFx0ICogQHR5cGUge0VsZW1lbnR9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLmVsZW1lbnQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgdGhlIHN1cmZhY2UgaWQuXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuaWQgPSBpZDtcblxuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIHRoZSBkZWZhdWx0IHRyYW5zaXRpb25GbiBmb3IgdGhlIHN1cmZhY2VzLlxuXHRcdCAqIEBwYXJhbSB7P0VsZW1lbnQ9fSBmcm9tIFRoZSB2aXNpYmxlIHN1cmZhY2UgZWxlbWVudC5cblx0XHQgKiBAcGFyYW0gez9FbGVtZW50PX0gdG8gVGhlIHN1cmZhY2UgZWxlbWVudCB0byBiZSBmbGlwcGVkLlxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnRyYW5zaXRpb25GbiA9IG51bGw7XG5cblx0XHR0aGlzLmRlZmF1bHRDaGlsZCA9IHRoaXMuZ2V0Q2hpbGQoU3VyZmFjZS5ERUZBVUxUKTtcblx0XHR0aGlzLm1heWJlV3JhcENvbnRlbnRBc0RlZmF1bHRfKCk7XG5cdFx0dGhpcy5hY3RpdmVDaGlsZCA9IHRoaXMuZGVmYXVsdENoaWxkO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgc2NyZWVuIGNvbnRlbnQgdG8gYSBzdXJmYWNlLiBJZiBjb250ZW50IGhhc24ndCBiZWVuIHBhc3NlZCwgc2VlIGlmXG5cdCAqIGFuIGVsZW1lbnQgZXhpc3RzIGluIHRoZSBET00gdGhhdCBtYXRjaGVzIHRoZSBpZC4gQnkgY29udmVudGlvbiwgdGhlXG5cdCAqIGVsZW1lbnQgc2hvdWxkIGFscmVhZHkgYmUgbmVzdGVkIGluIHRoZSByaWdodCBlbGVtZW50IGFuZCBzaG91bGQgaGF2ZSBhblxuXHQgKiBpZCB0aGF0IGlzIGEgY29uY2F0ZW50YXRpb24gb2YgdGhlIHN1cmZhY2UgaWQgKyAnLScgKyB0aGUgc2NyZWVuIGlkLlxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IHNjcmVlbklkIFRoZSBzY3JlZW4gaWQgdGhlIGNvbnRlbnQgYmVsb25ncyB0b28uXG5cdCAqIEBwYXJhbSB7P3N0cmluZ3xFbGVtZW50PX0gb3B0X2NvbnRlbnQgVGhlIHN0cmluZyBjb250ZW50IG9yIGVsZW1lbnQgdG9cblx0ICogICAgIGFkZCBiZSBhZGRlZCBhcyBzdXJmYWNlIGNvbnRlbnQuXG5cdCAqIEByZXR1cm4ge0VsZW1lbnR9XG5cdCAqL1xuXHRhZGRDb250ZW50KHNjcmVlbklkLCBvcHRfY29udGVudCkge1xuXHRcdHZhciBjaGlsZCA9IHRoaXMuZGVmYXVsdENoaWxkO1xuXG5cdFx0aWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKG9wdF9jb250ZW50KSkge1xuXHRcdFx0Y2hpbGQgPSB0aGlzLmdldENoaWxkKHNjcmVlbklkKTtcblx0XHRcdGlmIChjaGlsZCkge1xuXHRcdFx0XHRkb20ucmVtb3ZlQ2hpbGRyZW4oY2hpbGQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hpbGQgPSB0aGlzLmNyZWF0ZUNoaWxkKHNjcmVlbklkKTtcblx0XHRcdFx0dGhpcy50cmFuc2l0aW9uKGNoaWxkLCBudWxsKTtcblx0XHRcdH1cblx0XHRcdGRvbS5hcHBlbmQoY2hpbGQsIG9wdF9jb250ZW50KTtcblx0XHR9XG5cblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuXG5cdFx0aWYgKGVsZW1lbnQgJiYgY2hpbGQpIHtcblx0XHRcdGRvbS5hcHBlbmQoZWxlbWVudCwgY2hpbGQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjaGlsZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGNoaWxkIG5vZGUgZm9yIHRoZSBzdXJmYWNlLlxuXHQgKiBAcGFyYW0geyFzdHJpbmd9IHNjcmVlbklkIFRoZSBzY3JlZW4gaWQuXG5cdCAqIEByZXR1cm4ge0VsZW1lbnR9XG5cdCAqL1xuXHRjcmVhdGVDaGlsZChzY3JlZW5JZCkge1xuXHRcdHZhciBjaGlsZCA9IGdsb2JhbHMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0Y2hpbGQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMubWFrZUlkXyhzY3JlZW5JZCkpO1xuXHRcdHJldHVybiBjaGlsZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGNoaWxkIG5vZGUgb2YgdGhlIHN1cmZhY2UuXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gc2NyZWVuSWQgVGhlIHNjcmVlbiBpZC5cblx0ICogQHJldHVybiB7P0VsZW1lbnR9XG5cdCAqL1xuXHRnZXRDaGlsZChzY3JlZW5JZCkge1xuXHRcdHJldHVybiBnbG9iYWxzLmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMubWFrZUlkXyhzY3JlZW5JZCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHN1cmZhY2UgZWxlbWVudCBmcm9tIGVsZW1lbnQsIGFuZCBzZXRzIGl0IHRvIHRoZSBlbCBwcm9wZXJ0eSBvZlxuXHQgKiB0aGUgY3VycmVudCBpbnN0YW5jZS5cblx0ICogPGNvZGU+dGhpcy5lbGVtZW50PC9jb2RlPiB3aWxsIGJlIHVzZWQuXG5cdCAqIEByZXR1cm4gez9FbGVtZW50fSBUaGUgY3VycmVudCBzdXJmYWNlIGVsZW1lbnQuXG5cdCAqL1xuXHRnZXRFbGVtZW50KCkge1xuXHRcdGlmICh0aGlzLmVsZW1lbnQpIHtcblx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQ7XG5cdFx0fVxuXHRcdHRoaXMuZWxlbWVudCA9IGdsb2JhbHMuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCk7XG5cdFx0cmV0dXJuIHRoaXMuZWxlbWVudDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBzdXJmYWNlIGlkLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRJZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5pZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBzdXJmYWNlIHRyYW5zaXRpb24gZnVuY3Rpb24uXG5cdCAqIFNlZSA8Y29kZT5TdXJmYWNlLmRlZmF1bHRUcmFuc2l0aW9uPC9jb2RlPi5cblx0ICogQHJldHVybiB7P0Z1bmN0aW9uPX0gVGhlIHRyYW5zaXRpb24gZnVuY3Rpb24uXG5cdCAqL1xuXHRnZXRUcmFuc2l0aW9uRm4oKSB7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNpdGlvbkZuO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1ha2VzIHRoZSBpZCBmb3IgdGhlIGVsZW1lbnQgdGhhdCBob2xkcyBjb250ZW50IGZvciBhIHNjcmVlbi5cblx0ICogQHBhcmFtIHshc3RyaW5nfSBzY3JlZW5JZCBUaGUgc2NyZWVuIGlkIHRoZSBjb250ZW50IGJlbG9uZ3MgdG9vLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRtYWtlSWRfKHNjcmVlbklkKSB7XG5cdFx0cmV0dXJuIHRoaXMuaWQgKyAnLScgKyBzY3JlZW5JZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBJZiBkZWZhdWx0IGNoaWxkIGlzIG1pc3NpbmcsIHdyYXBzIHN1cmZhY2UgY29udGVudCBhcyBkZWZhdWx0IGNoaWxkLiBJZlxuXHQgKiBzdXJmYWNlIGhhdmUgc3RhdGljIGNvbnRlbnQsIG1ha2Ugc3VyZSB0byBwbGFjZSBhXG5cdCAqIDxjb2RlPnN1cmZhY2VJZC1kZWZhdWx0PC9jb2RlPiBlbGVtZW50IGluc2lkZSBzdXJmYWNlLCBvbmx5IGNvbnRlbnRzXG5cdCAqIGluc2lkZSB0aGUgZGVmYXVsdCBjaGlsZCB3aWxsIGJlIHJlcGxhY2VkIGJ5IG5hdmlnYXRpb24uXG5cdCAqL1xuXHRtYXliZVdyYXBDb250ZW50QXNEZWZhdWx0XygpIHtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuXHRcdGlmIChlbGVtZW50ICYmICF0aGlzLmRlZmF1bHRDaGlsZCkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gZ2xvYmFscy5kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHR3aGlsZSAoZWxlbWVudC5maXJzdENoaWxkKSB7XG5cdFx0XHRcdGZyYWdtZW50LmFwcGVuZENoaWxkKGVsZW1lbnQuZmlyc3RDaGlsZCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmRlZmF1bHRDaGlsZCA9IHRoaXMuYWRkQ29udGVudChTdXJmYWNlLkRFRkFVTFQsIGZyYWdtZW50KTtcblx0XHRcdHRoaXMudHJhbnNpdGlvbihudWxsLCB0aGlzLmRlZmF1bHRDaGlsZCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHN1cmZhY2UgaWQuXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gaWRcblx0ICovXG5cdHNldElkKGlkKSB7XG5cdFx0dGhpcy5pZCA9IGlkO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHN1cmZhY2UgdHJhbnNpdGlvbiBmdW5jdGlvbi5cblx0ICogU2VlIDxjb2RlPlN1cmZhY2UuZGVmYXVsdFRyYW5zaXRpb248L2NvZGU+LlxuXHQgKiBAcGFyYW0gez9GdW5jdGlvbj19IHRyYW5zaXRpb25GbiBUaGUgdHJhbnNpdGlvbiBmdW5jdGlvbi5cblx0ICovXG5cdHNldFRyYW5zaXRpb25Gbih0cmFuc2l0aW9uRm4pIHtcblx0XHR0aGlzLnRyYW5zaXRpb25GbiA9IHRyYW5zaXRpb25Gbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBTaG93cyBzY3JlZW4gY29udGVudCBmcm9tIGEgc3VyZmFjZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHNjcmVlbklkIFRoZSBzY3JlZW4gaWQgdG8gc2hvdy5cblx0ICogQHJldHVybiB7Q2FuY2VsbGFibGVQcm9taXNlfSBQYXVzZXMgdGhlIG5hdmlnYXRpb24gdW50aWwgaXQgaXMgcmVzb2x2ZWQuXG5cdCAqL1xuXHRzaG93KHNjcmVlbklkKSB7XG5cdFx0dmFyIGZyb20gPSB0aGlzLmFjdGl2ZUNoaWxkO1xuXHRcdHZhciB0byA9IHRoaXMuZ2V0Q2hpbGQoc2NyZWVuSWQpO1xuXHRcdGlmICghdG8pIHtcblx0XHRcdHRvID0gdGhpcy5kZWZhdWx0Q2hpbGQ7XG5cdFx0fVxuXHRcdHRoaXMuYWN0aXZlQ2hpbGQgPSB0bztcblx0XHRyZXR1cm4gdGhpcy50cmFuc2l0aW9uKGZyb20sIHRvKS50aGVuQWx3YXlzKCgpID0+IHtcblx0XHRcdGlmIChmcm9tICYmIGZyb20gIT09IHRvKSB7XG5cdFx0XHRcdGRvbS5leGl0RG9jdW1lbnQoZnJvbSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBzY3JlZW4gY29udGVudCBmcm9tIGEgc3VyZmFjZS5cblx0ICogQHBhcmFtIHshc3RyaW5nfSBzY3JlZW5JZCBUaGUgc2NyZWVuIGlkIHRvIHJlbW92ZS5cblx0ICovXG5cdHJlbW92ZShzY3JlZW5JZCkge1xuXHRcdHZhciBjaGlsZCA9IHRoaXMuZ2V0Q2hpbGQoc2NyZWVuSWQpO1xuXHRcdGlmIChjaGlsZCkge1xuXHRcdFx0ZG9tLmV4aXREb2N1bWVudChjaGlsZCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLmlkO1xuXHR9XG5cblx0LyoqXG5cdCAqIEludm9rZXMgdGhlIHRyYW5zaXRpb24gZnVuY3Rpb24gc3BlY2lmaWVkIG9uIDxjb2RlPnRyYW5zaXRpb248L2NvZGU+IGF0dHJpYnV0ZS5cblx0ICogQHBhcmFtIHs/RWxlbWVudD19IGZyb21cblx0ICogQHBhcmFtIHs/RWxlbWVudD19IHRvXG5cdCAqIEByZXR1cm4gez9DYW5jZWxsYWJsZVByb21pc2U9fSBUaGlzIGNhbiByZXR1cm4gYSBwcm9taXNlLCB3aGljaCB3aWxsIHBhdXNlIHRoZVxuXHQgKiAgICAgbmF2aWdhdGlvbiB1bnRpbCBpdCBpcyByZXNvbHZlZC5cblx0ICovXG5cdHRyYW5zaXRpb24oZnJvbSwgdG8pIHtcblx0XHR2YXIgdHJhbnNpdGlvbkZuID0gdGhpcy50cmFuc2l0aW9uRm4gfHwgU3VyZmFjZS5kZWZhdWx0VHJhbnNpdGlvbjtcblx0XHRyZXR1cm4gQ2FuY2VsbGFibGVQcm9taXNlLnJlc29sdmUodHJhbnNpdGlvbkZuLmNhbGwodGhpcywgZnJvbSwgdG8pKTtcblx0fVxuXG59XG5cbi8qKlxuICAgKiBIb2xkcyB0aGUgZGVmYXVsdCBzdXJmYWNlIG5hbWUuIEVsZW1lbnRzIG9uIHRoZSBwYWdlIG11c3QgY29udGFpbiBhIGNoaWxkXG4gICAqIGVsZW1lbnQgY29udGFpbmluZyB0aGUgZGVmYXVsdCBjb250ZW50LCB0aGlzIGVsZW1lbnQgbXVzdCBiZSBhcyBmb2xsb3dpbmc6XG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqIDxjb2RlPlxuICAgKiAgIDxkaXYgaWQ9XCJteXN1cmZhY2VcIj5cbiAgICogICAgIDxkaXYgaWQ9XCJteXN1cmZhY2UtZGVmYXVsdFwiPkRlZmF1bHQgc3VyZmFjZSBjb250ZW50LjwvZGl2PlxuICAgKiAgIDwvZGl2PlxuICAgKiA8L2NvZGU+XG4gICAqXG4gICAqIFRoZSBkZWZhdWx0IGNvbnRlbnQgaXMgcmVsZXZhbnQgZm9yIHRoZSBpbml0aWFsIHBhZ2UgY29udGVudC4gV2hlbiBhXG4gICAqIHNjcmVlbiBkb2Vzbid0IHByb3ZpZGUgY29udGVudCBmb3IgdGhlIHN1cmZhY2UgdGhlIGRlZmF1bHQgY29udGVudCBpc1xuICAgKiByZXN0b3JlZCBpbnRvIHRoZSBwYWdlLlxuICAgKlxuICAgKiBAdHlwZSB7IVN0cmluZ31cbiAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgKiBAc3RhdGljXG4gICAqL1xuU3VyZmFjZS5ERUZBVUxUID0gJ2RlZmF1bHQnO1xuXG4vKipcbiAqIEhvbGRzIHRoZSBkZWZhdWx0IHRyYW5zaXRpb24gZm9yIGFsbCBzdXJmYWNlcy4gRWFjaCBzdXJmYWNlIGNvdWxkIGhhdmUgaXRzXG4gKiBvd24gdHJhbnNpdGlvbi5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIDxjb2RlPlxuICogc3VyZmFjZS5zZXRUcmFuc2l0aW9uRm4oZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAqICAgaWYgKGZyb20pIHtcbiAqICAgICBmcm9tLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gKiAgICAgZnJvbS5jbGFzc0xpc3QucmVtb3ZlKCdmbGlwcGVkJyk7XG4gKiAgIH1cbiAqICAgaWYgKHRvKSB7XG4gKiAgICAgdG8uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gKiAgICAgdG8uY2xhc3NMaXN0LmFkZCgnZmxpcHBlZCcpO1xuICogICB9XG4gKiAgIHJldHVybiBudWxsO1xuICogfSk7XG4gKiA8L2NvZGU+XG4gKlxuICogQHBhcmFtIHs/RWxlbWVudD19IGZyb20gVGhlIHZpc2libGUgc3VyZmFjZSBlbGVtZW50LlxuICogQHBhcmFtIHs/RWxlbWVudD19IHRvIFRoZSBzdXJmYWNlIGVsZW1lbnQgdG8gYmUgZmxpcHBlZC5cbiAqIEBzdGF0aWNcbiAqL1xuU3VyZmFjZS5kZWZhdWx0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG5cdGlmIChmcm9tKSB7XG5cdFx0ZnJvbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdGZyb20uY2xhc3NMaXN0LnJlbW92ZSgnZmxpcHBlZCcpO1xuXHR9XG5cdGlmICh0bykge1xuXHRcdHRvLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHRcdHRvLmNsYXNzTGlzdC5hZGQoJ2ZsaXBwZWQnKTtcblx0fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgU3VyZmFjZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGdsb2JhbHMgZnJvbSAnLi4vZ2xvYmFscy9nbG9iYWxzJztcbmltcG9ydCBVcmkgZnJvbSAnbWV0YWwtdXJpJztcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2Ygc3RhdGljIHV0aWxpdHkgZnVuY3Rpb25zLlxuICogQGNvbnN0XG4gKi9cbmNsYXNzIHV0aWxzIHtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgY3VycmVudCBicm93c2VyIHBhdGggaW5jbHVkaW5nIGhhc2hiYW5nLlxuXHQgKiBAcmV0dXJuIHshc3RyaW5nfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgZ2V0Q3VycmVudEJyb3dzZXJQYXRoKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEN1cnJlbnRCcm93c2VyUGF0aFdpdGhvdXRIYXNoKCkgKyBnbG9iYWxzLndpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGN1cnJlbnQgYnJvd3NlciBwYXRoIGV4Y2x1ZGluZyBoYXNoYmFuZy5cblx0ICogQHJldHVybiB7IXN0cmluZ31cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGdldEN1cnJlbnRCcm93c2VyUGF0aFdpdGhvdXRIYXNoKCkge1xuXHRcdHJldHVybiBnbG9iYWxzLndpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIGdsb2JhbHMud2luZG93LmxvY2F0aW9uLnNlYXJjaDtcblx0fVxuXG5cdC8qKlxuXHQgKiBFeHRyYWN0cyB0aGUgcGF0aCBwYXJ0IG9mIGFuIHVybC5cblx0ICogQHJldHVybiB7IXN0cmluZ31cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGdldFVybFBhdGgodXJsKSB7XG5cdFx0dmFyIHVyaSA9IG5ldyBVcmkodXJsKTtcblx0XHRyZXR1cm4gdXJpLmdldFBhdGhuYW1lKCkgKyB1cmkuZ2V0U2VhcmNoKCkgKyB1cmkuZ2V0SGFzaCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4dHJhY3RzIHRoZSBwYXRoIHBhcnQgb2YgYW4gdXJsIHdpdGhvdXQgaGFzaGJhbmcuXG5cdCAqIEByZXR1cm4geyFzdHJpbmd9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBnZXRVcmxQYXRoV2l0aG91dEhhc2godXJsKSB7XG5cdFx0dmFyIHVyaSA9IG5ldyBVcmkodXJsKTtcblx0XHRyZXR1cm4gdXJpLmdldFBhdGhuYW1lKCkgKyB1cmkuZ2V0U2VhcmNoKCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHVybCBpcyBpbiB0aGUgc2FtZSBicm93c2VyIGN1cnJlbnQgdXJsIGV4Y2x1ZGluZyB0aGUgaGFzaGJhbmcuXG5cdCAqIEBwYXJhbSAgeyFzdHJpbmd9IHVybFxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgaXNDdXJyZW50QnJvd3NlclBhdGgodXJsKSB7XG5cdFx0aWYgKHVybCkge1xuXHRcdFx0cmV0dXJuIHV0aWxzLmdldFVybFBhdGhXaXRob3V0SGFzaCh1cmwpID09PSB0aGlzLmdldEN1cnJlbnRCcm93c2VyUGF0aFdpdGhvdXRIYXNoKCk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgSFRNTDUgSGlzdG9yeSBhcGkgaXMgc3VwcG9ydGVkLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgaXNIdG1sNUhpc3RvcnlTdXBwb3J0ZWQoKSB7XG5cdFx0cmV0dXJuICEhKGdsb2JhbHMud2luZG93Lmhpc3RvcnkgJiYgZ2xvYmFscy53aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUpO1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgdXRpbHM7IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgc3RvcmUgZnJvbSAnLi9zdG9yZS9zdG9yZSc7XG5pbXBvcnQgQWN0aW9ucyBmcm9tICcuL2FjdGlvbnMvQWN0aW9ucyc7XG5pbXBvcnQgRGFzaGJvYXJkIGZyb20gJy4vY29tcG9uZW50cy9wYWdlcy9EYXNoYm9hcmQnO1xuaW1wb3J0IEVkaXRDYW1wYWlnbiBmcm9tICcuL2NvbXBvbmVudHMvcGFnZXMvRWRpdENhbXBhaWduJztcbmltcG9ydCBNYW5hZ2VDYW1wYWlnbnMgZnJvbSAnLi9jb21wb25lbnRzL3BhZ2VzL01hbmFnZUNhbXBhaWducyc7XG5pbXBvcnQgUm91dGVyIGZyb20gJ21ldGFsLXJvdXRlcic7XG5cbmNsYXNzIE1haW4ge1xuXHRzdGF0aWMgcnVuKG9wdF9kYXRhID0ge30pIHtcblx0XHRzdG9yZS5kaXNwYXRjaChBY3Rpb25zLnVwZGF0ZVN0YXRlKG9wdF9kYXRhKSk7XG5cblx0XHR2YXIgYmFzZVBhdGggPSBzdG9yZS5nZXRTdGF0ZSgpLmJhc2VQYXRoO1xuXHRcdFJvdXRlci5yb3V0ZXIoKS5zZXRCYXNlUGF0aChiYXNlUGF0aCk7XG5cdFx0Um91dGVyLnJvdXRlKCcvZGFzaGJvYXJkJywgRGFzaGJvYXJkLCBzdG9yZS5nZXRTdGF0ZSwgdHJ1ZSk7XG5cdFx0Um91dGVyLnJvdXRlKCcvbWFuYWdlLWNhbXBhaWducycsIE1hbmFnZUNhbXBhaWducywgc3RvcmUuZ2V0U3RhdGUsIHRydWUpO1xuXHRcdFJvdXRlci5yb3V0ZSgnL2NyZWF0ZS1jYW1wYWlnbicsIEVkaXRDYW1wYWlnbiwgc3RvcmUuZ2V0U3RhdGUsIHRydWUpO1xuXHRcdFJvdXRlci5yb3V0ZSgvXFwvZWRpdC1jYW1wYWlnbihcXC9cXGQqKT8vLCBFZGl0Q2FtcGFpZ24sIHN0b3JlLmdldFN0YXRlLCB0cnVlKTtcblx0XHRSb3V0ZXIucm91dGVyKCkubmF2aWdhdGUoYmFzZVBhdGggKyAnL2Rhc2hib2FyZCcsIHRydWUpO1xuXG5cdFx0c3RvcmUuc3Vic2NyaWJlKE1haW4ucmVmcmVzaFN0YXRlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHN0YXRpYyByZWZyZXNoU3RhdGUoKSB7XG5cdFx0Um91dGVyLmFjdGl2ZUNvbXBvbmVudC5zZXRTdGF0ZShzdG9yZS5nZXRTdGF0ZSgpKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNYWluO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cdFNBVkVfQ0FNUEFJR046ICdzYXZlLWNhbXBhaWduJyxcblx0U1RBUlRfQ0FNUEFJR05fQ1JFQVRJT046ICdzdGFydC1jYW1wYWlnbi1jcmVhdGlvbicsXG5cdFNUQVJUX0NBTVBBSUdOX0VESVRJT046ICdzdGFydC1jYW1wYWlnbi1lZGl0aW9uJyxcblx0UkVNT1ZFX0NBTVBBSUdOOiAncmVtb3ZlLWNhbXBhaWduJyxcblx0VVBEQVRFX0RBVEE6ICd1cGRhdGUtZGF0YSdcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBY3Rpb25UeXBlcyBmcm9tICcuL0FjdGlvblR5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXHRzYXZlQ2FtcGFpZ24oY2FtcGFpZ24pIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogQWN0aW9uVHlwZXMuU0FWRV9DQU1QQUlHTixcblx0XHRcdGNhbXBhaWduOiBjYW1wYWlnblxuXHRcdH07XG5cdH0sXG5cblx0c3RhcnRDYW1wYWlnbkNyZWF0aW9uKHNvdXJjZVVybCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiBBY3Rpb25UeXBlcy5TVEFSVF9DQU1QQUlHTl9DUkVBVElPTixcblx0XHRcdHNvdXJjZVVybDogc291cmNlVXJsXG5cdFx0fTtcblx0fSxcblxuXHRzdGFydENhbXBhaWduRWRpdGlvbihpZCwgc291cmNlVXJsKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IEFjdGlvblR5cGVzLlNUQVJUX0NBTVBBSUdOX0VESVRJT04sXG5cdFx0XHRpZDogaWQsXG5cdFx0XHRzb3VyY2VVcmw6IHNvdXJjZVVybFxuXHRcdH07XG5cdH0sXG5cblx0cmVtb3ZlQ2FtcGFpZ24oaWQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogQWN0aW9uVHlwZXMuUkVNT1ZFX0NBTVBBSUdOLFxuXHRcdFx0aWQ6IGlkXG5cdFx0fTtcblx0fSxcblxuXHR1cGRhdGVTdGF0ZShzdGF0ZSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiBBY3Rpb25UeXBlcy5VUERBVEVfREFUQSxcblx0XHRcdHN0YXRlOiBzdGF0ZVxuXHRcdH07XG5cdH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBKU1hDb21wb25lbnQgZnJvbSAnbWV0YWwtanN4JztcblxuY2xhc3MgQmFja0Fycm93IGV4dGVuZHMgSlNYQ29tcG9uZW50IHtcblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiA8YSBocmVmPXt0aGlzLmNvbmZpZy5iYXNlUGF0aCArIHRoaXMuY29uZmlnLnNvdXJjZVVybH0gY2xhc3M9XCJiYWNrLWFycm93XCI+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tbWVudS1sZWZ0XCI+PC9zcGFuPlxuXHRcdDwvYT47XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFja0Fycm93O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgc3RvcmUgZnJvbSAnLi4vc3RvcmUvc3RvcmUnO1xuaW1wb3J0IEFjdGlvbnMgZnJvbSAnLi4vYWN0aW9ucy9BY3Rpb25zJztcbmltcG9ydCBKU1hDb21wb25lbnQgZnJvbSAnbWV0YWwtanN4JztcbmltcG9ydCBUYWJzIGZyb20gJy4vVGFicyc7XG5cbmNsYXNzIEhlYWRlciBleHRlbmRzIEpTWENvbXBvbmVudCB7XG5cdHJlbmRlcigpIHtcblx0XHR2YXIgdGFicyA9IFtcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogJ0Rhc2hib2FyZCcsXG5cdFx0XHRcdGhyZWY6IHRoaXMuY29uZmlnLmJhc2VQYXRoICsgJy9kYXNoYm9hcmQnXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiAnTWFuYWdlIENhbXBhaWducycsXG5cdFx0XHRcdGhyZWY6IHRoaXMuY29uZmlnLmJhc2VQYXRoICsgJy9tYW5hZ2UtY2FtcGFpZ25zJ1xuXHRcdFx0fVxuXHRcdF07XG5cblx0XHRyZXR1cm4gPGRpdiBjbGFzcz1cImNhbXBhaWduLW1hbmFnZXItaGVhZGVyIHJvd1wiPlxuXHRcdFx0PGRpdiBjbGFzcz1cImNvbC1tZC0xMlwiPlxuXHRcdFx0XHQ8YVxuXHRcdFx0XHRcdGhyZWY9e3RoaXMuY29uZmlnLmJhc2VQYXRoICsgJy9jcmVhdGUtY2FtcGFpZ24nfVxuXHRcdFx0XHRcdGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5IGNhbXBhaWduLW1hbmFnZXItYnV0dG9uLW5ldyBwdWxsLXJpZ2h0XCJcblx0XHRcdFx0XHRkYXRhLW9uY2xpY2s9e3RoaXMuc3RhcnRDYW1wYWlnbkNyZWF0aW9uXy5iaW5kKHRoaXMpfT5cblx0XHRcdFx0XHROZXcgQ2FtcGFpZ25cblx0XHRcdFx0PC9hPlxuXHRcdFx0XHQ8aDQgY2xhc3M9XCJjYW1wYWlnbi1tYW5hZ2VyLXRpdGxlIGNhbXBhaWduLW1hbmFnZXItcGFnZS10aXRsZVwiPkNhbXBhaWduIE1hbmFnZXI8L2g0PlxuXHRcdFx0PC9kaXY+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwiY29sLW1kLTEyXCI+XG5cdFx0XHRcdDxUYWJzXG5cdFx0XHRcdFx0dGFicz17dGFic31cblx0XHRcdFx0XHRzZWxlY3RlZEluZGV4PXt0aGlzLmNvbmZpZy5jdXJyZW50VXJsID09ICcvbWFuYWdlLWNhbXBhaWducycgPyAxIDogMH1cblx0XHRcdFx0Lz5cblx0XHRcdDwvZGl2PlxuXHRcdDwvZGl2Pjtcblx0fVxuXG5cdHN0YXJ0Q2FtcGFpZ25DcmVhdGlvbl8oKSB7XG5cdFx0c3RvcmUuZGlzcGF0Y2goQWN0aW9ucy5zdGFydENhbXBhaWduQ3JlYXRpb24odGhpcy5jb25maWcuY3VycmVudFVybCkpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEhlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEpTWENvbXBvbmVudCBmcm9tICdtZXRhbC1qc3gnO1xuXG5jbGFzcyBUYWJzIGV4dGVuZHMgSlNYQ29tcG9uZW50IHtcblx0cmVuZGVyKCkge1xuXHRcdHZhciBpdGVtcyA9IHRoaXMuY29uZmlnLnRhYnMubWFwKCh0YWIsIGluZGV4KSA9PiB7XG5cdFx0XHRyZXR1cm4gPGxpIGNsYXNzPXt0aGlzLmNvbmZpZy5zZWxlY3RlZEluZGV4ID09IGluZGV4ID8gJ2FjdGl2ZScgOiAnJ30+XG5cdFx0XHRcdDxhIGhyZWY9e3RhYi5ocmVmfT57dGFiLm5hbWV9PC9hPlxuXHRcdFx0PC9saT5cblx0XHR9KTtcblx0XHRyZXR1cm4gPHVsIGNsYXNzPVwiY2FtcGFpZ24tbWFuYWdlci10YWJzIG5hdiBuYXYtdGFic1wiPntpdGVtc308L3VsPjtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBUYWJzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgY29yZSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgSlNYQ29tcG9uZW50IGZyb20gJ21ldGFsLWpzeCc7XG5cbmNsYXNzIENhcmQgZXh0ZW5kcyBKU1hDb21wb25lbnQge1xuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIDxkaXYgY2xhc3M9eydjYW1wYWlnbi1tYW5hZ2VyLWNhcmQgJyArICh0aGlzLmNvbmZpZy5jc3NDbGFzcyB8fCAnJyl9PlxuXHRcdFx0PGRpdiBjbGFzcz1cImNhbXBhaWduLW1hbmFnZXItY2FyZC1ib2R5IGNsZWFyZml4XCI+XG5cdFx0XHRcdHt0aGlzLmNvbmZpZy5jaGlsZHJlbn1cblx0XHRcdDwvZGl2PlxuXHRcdDwvZGl2Pjtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYXJkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQ2FyZCBmcm9tICcuL0NhcmQnO1xuaW1wb3J0IEpTWENvbXBvbmVudCBmcm9tICdtZXRhbC1qc3gnO1xuXG5jbGFzcyBJbWFnZUNhcmQgZXh0ZW5kcyBKU1hDb21wb25lbnQge1xuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIDxkaXYgY2xhc3M9XCJjYW1wYWlnbi1tYW5hZ2VyLWltYWdlLWNhcmRcIj5cblx0XHRcdDxDYXJkPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY2FtcGFpZ24tbWFuYWdlci1jYXJkLXRpdGxlXCI+XG5cdFx0XHRcdFx0e3RoaXMuY29uZmlnLnRpdGxlfVxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiaGlnaGxpZ2h0IGNvdW50XCI+e3RoaXMuY29uZmlnLmNvdW50fTwvc3Bhbj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDxkaXY+XG5cdFx0XHRcdFx0PGltZyBzcmM9e3RoaXMuY29uZmlnLmltYWdlVXJsfSAvPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvQ2FyZD5cblx0XHQ8L2Rpdj47XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VDYXJkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQ2FyZCBmcm9tICcuL0NhcmQnO1xuaW1wb3J0IEpTWENvbXBvbmVudCBmcm9tICdtZXRhbC1qc3gnO1xuXG5jbGFzcyBUYWJsZUNhcmQgZXh0ZW5kcyBKU1hDb21wb25lbnQge1xuXHRyZW5kZXIoKSB7XG5cdFx0dmFyIGhlYWRlcnMgPSB0aGlzLmNvbmZpZy5oZWFkZXJzLm1hcCgoaGVhZGVyLCBpbmRleCkgPT4ge1xuXHRcdFx0cmV0dXJuIDx0aCBjbGFzcz17J2xpZ2h0LWdyYXknICsgKGluZGV4ID09PSAwID8gJycgOiAnIHRleHQtY2VudGVyJyl9PlxuXHRcdFx0XHR7aGVhZGVyfVxuXHRcdFx0PC90aD5cblx0XHR9KTtcblx0XHR2YXIgZGF0YSA9IHRoaXMuY29uZmlnLmRhdGEubWFwKHJvdyA9PiB7XG5cdFx0XHR2YXIgY2VsbHMgPSByb3cubWFwKChjZWxsLCBpbmRleCkgPT4ge1xuXHRcdFx0XHRyZXR1cm4gPHRkIGNsYXNzPXtpbmRleCA9PT0gMCA/ICcnIDogJ3RleHQtY2VudGVyJ30+e2NlbGx9PC90ZD47XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiA8dHI+e2NlbGxzfTwvdHI+O1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIDxkaXYgY2xhc3M9XCJjYW1wYWlnbi1tYW5hZ2VyLXRhYmxlLWNhcmRcIj5cblx0XHRcdDxDYXJkPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY2FtcGFpZ24tbWFuYWdlci1jYXJkLXRpdGxlXCI+e3RoaXMuY29uZmlnLnRpdGxlfTwvZGl2PlxuXHRcdFx0XHQ8dGFibGUgY2xhc3M9XCJ0YWJsZSB0YWJsZS1jbGVhblwiPlxuXHRcdFx0XHRcdDx0aGVhZD5cblx0XHRcdFx0XHRcdDx0cj57aGVhZGVyc308L3RyPlxuXHRcdFx0XHRcdDwvdGhlYWQ+XG5cdFx0XHRcdFx0PHRib2R5PntkYXRhfTwvdGJvZHk+XG5cdFx0XHRcdDwvdGFibGU+XG5cdFx0XHQ8L0NhcmQ+XG5cdFx0PC9kaXY+O1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRhYmxlQ2FyZDtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGNvcmUgZnJvbSAnbWV0YWwnO1xuaW1wb3J0IEpTWENvbXBvbmVudCBmcm9tICdtZXRhbC1qc3gnO1xuXG5jbGFzcyBFZGl0Q2FtcGFpZ25EZXRhaWxzIGV4dGVuZHMgSlNYQ29tcG9uZW50IHtcblx0YWRkTGVhZGluZzAobnVtKSB7XG5cdFx0cmV0dXJuIG51bSA8IDEwID8gKCcwJyArIG51bSkgOiBudW07XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0dmFyIGVkaXRNb2RlID0gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5jb25maWcuZWRpdENhbXBhaWduSWQpO1xuXHRcdHZhciBjYW1wYWlnbiA9IGVkaXRNb2RlID8gdGhpcy5jb25maWcuY2FtcGFpZ25zW3RoaXMuY29uZmlnLmVkaXRDYW1wYWlnbklkXSA6IHt9O1xuXG5cdFx0cmV0dXJuIDxkaXYgY2xhc3M9XCJjYW1wYWlnbi1tYW5hZ2VyLWVkaXQtY2FtcGFpZ24tZGV0YWlscyBjb250YWluZXItZmx1aWQgd2hpdGUtYmcgY2FtcGFpZ24tbWFuYWdlciBzZXNzaW9uIHNlc3Npb24tbWVyZ2VkLW5leHRcIj5cblx0XHRcdDxoMj5EZXRhaWxzPC9oMj5cblx0XHRcdDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+XG5cdFx0XHRcdDxsYWJlbCBmb3I9XCJcIiBjbGFzcz1cImNvbC1tZC0xIGNvbnRyb2wtbGFiZWxcIj5OYW1lOjwvbGFiZWw+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJjb2wtbWQtNFwiPlxuXHRcdFx0XHRcdDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgbmFtZT1cIm5hbWVcIiB2YWx1ZT17Y2FtcGFpZ24ubmFtZSB8fCAnJ30gLz5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDxiciBjbGFzcz1cImhpZGRlbi1tZCBoaWRkZW4tbGdcIiAvPlxuXHRcdFx0XHQ8bGFiZWwgY2xhc3M9XCJjb2wtbWQtMSBjb2wtbWQtb2Zmc2V0LTIgY29udHJvbC1sYWJlbFwiPkJ1ZGdldDo8L2xhYmVsPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY29sLW1kLTJcIj5cblx0XHRcdFx0XHQ8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIG5hbWU9XCJidWRnZXRcIiB2YWx1ZT17Y2FtcGFpZ24uYnVkZ2V0IHx8ICcnfSAvPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PGRpdiBjbGFzcz1cImNvbC1tZC0yXCI+XG5cdFx0XHRcdFx0PHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbFwiPlxuXHRcdFx0XHRcdFx0PG9wdGlvbj4oJCkgRG9sbGFyczwvb3B0aW9uPlxuXHRcdFx0XHRcdDwvc2VsZWN0PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PlxuXG5cdFx0XHQ8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPlxuXHRcdFx0XHQ8bGFiZWwgZm9yPVwiXCIgY2xhc3M9XCJjb2wtbWQtMSBjb250cm9sLWxhYmVsXCI+RGVzY3JpcHRpb246PC9sYWJlbD5cblx0XHRcdFx0PGRpdiBjbGFzcz1cImNvbC1tZC0xMVwiPlxuXHRcdFx0XHRcdDx0ZXh0YXJlYSBjbGFzcz1cImZvcm0tY29udHJvbFwiIHJvd3M9XCI4XCIgY29scz1cIjQwXCIgbmFtZT1cImRlc2NyaXB0aW9uXCI+XG5cdFx0XHRcdFx0XHR7Y2FtcGFpZ24uZGVzY3JpcHRpb24gfHwgJyd9XG5cdFx0XHRcdFx0PC90ZXh0YXJlYT5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblxuXHRcdFx0PGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cblx0XHRcdFx0e3RoaXMucmVuZGVyRGF0ZUZpZWxkc18oJ1N0YXJ0cyBvbjonLCAnc3RhcnREYXRlJywgY2FtcGFpZ24uc3RhcnREYXRlKX1cblx0XHRcdFx0PGJyIGNsYXNzPVwiaGlkZGVuLW1kIGhpZGRlbi1sZ1wiIC8+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJjb2wtbWQtMlwiPjwvZGl2PlxuXHRcdFx0XHR7dGhpcy5yZW5kZXJEYXRlRmllbGRzXygnRW5kczonLCAnZW5kRGF0ZScsIGNhbXBhaWduLmVuZERhdGUpfVxuXHRcdFx0PC9kaXY+XG5cdFx0PC9kaXY+O1xuXHR9XG5cblx0cmVuZGVyRGF0ZUZpZWxkc18obGFiZWwsIGlucHV0TmFtZSwgZGF0ZSkge1xuXHRcdHZhciB0aW1lT3B0aW9ucyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuXHRcdFx0dGltZU9wdGlvbnMucHVzaChcblx0XHRcdFx0PG9wdGlvbiB2YWx1ZT17aX0gc2VsZWN0ZWQ9eyhkYXRlICYmIGRhdGUuaG91cnMgPT09IGkpIHx8IHVuZGVmaW5lZH0+XG5cdFx0XHRcdFx0e2kgPiAxMiA/IGkgLSAxMiA6IGl9OjAwIHtpID49IDEyID8gJ1BNJyA6ICdBTSd9XG5cdFx0XHRcdDwvb3B0aW9uPlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRjb25zb2xlLmxvZygndHJpZWQnLCBpbnB1dE5hbWUsIGRhdGUgPyBkYXRlLnllYXIgKyAnLScgKyBkYXRlLm1vbnRoICsgJy0nICsgZGF0ZS5kYXRlIDogJycpO1xuXHRcdHJldHVybiA8ZGl2PlxuXHRcdFx0PGxhYmVsIGZvcj1cIlwiIGNsYXNzPVwiY29sLW1kLTEgY29udHJvbC1sYWJlbFwiPntsYWJlbH08L2xhYmVsPlxuXHRcdFx0PGRpdiBjbGFzcz1cImNvbC1tZC0yXCI+XG5cdFx0XHRcdDxpbnB1dFxuXHRcdFx0XHRcdHR5cGU9XCJkYXRlXCJcblx0XHRcdFx0XHRjbGFzcz1cImZvcm0tY29udHJvbFwiXG5cdFx0XHRcdFx0bmFtZT17aW5wdXROYW1lfVxuXHRcdFx0XHRcdHZhbHVlPXtkYXRlID8gZGF0ZS55ZWFyICsgJy0nICsgdGhpcy5hZGRMZWFkaW5nMChkYXRlLm1vbnRoKSArICctJyArIHRoaXMuYWRkTGVhZGluZzAoZGF0ZS5kYXRlKSA6ICcnfVxuXHRcdFx0XHQvPlxuXHRcdFx0PC9kaXY+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwiY29sLW1kLTFcIj5cblx0XHRcdFx0PHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbFwiIG5hbWU9e2lucHV0TmFtZSArICdUaW1lJ30+e3RpbWVPcHRpb25zfTwvc2VsZWN0PlxuXHRcdFx0PC9kaXY+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwiY29sLW1kLTFcIj5cblx0XHRcdFx0PHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbFwiPlxuXHRcdFx0XHRcdDxvcHRpb24+R01UPC9vcHRpb24+XG5cdFx0XHRcdDwvc2VsZWN0PlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9kaXY+XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRWRpdENhbXBhaWduRGV0YWlscztcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGNvcmUgZnJvbSAnbWV0YWwnO1xuaW1wb3J0IEpTWENvbXBvbmVudCBmcm9tICdtZXRhbC1qc3gnO1xuXG5jbGFzcyBFZGl0Q2FtcGFpZ25Hb2FsIGV4dGVuZHMgSlNYQ29tcG9uZW50IHtcblx0cmVuZGVyKCkge1xuXHRcdHZhciBlZGl0TW9kZSA9IGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMuY29uZmlnLmVkaXRDYW1wYWlnbklkKTtcblx0XHR2YXIgY2FtcGFpZ24gPSBlZGl0TW9kZSA/IHRoaXMuY29uZmlnLmNhbXBhaWduc1t0aGlzLmNvbmZpZy5lZGl0Q2FtcGFpZ25JZF0gOiB7fTtcblxuXHRcdHJldHVybiA8ZGl2IGNsYXNzPVwiY2FtcGFpZ24tbWFuYWdlci1lZGl0LWNhbXBhaWduLWdvYWwgY29udGFpbmVyLWZsdWlkIGNhbXBhaWduLW1hbmFnZXIgc2Vzc2lvblwiPlxuXHRcdFx0PGRpdiBjbGFzcz1cImNhbXBhaWduLW1hbmFnZXItY2FyZFwiPlxuXHRcdFx0XHQ8aDI+R29hbDwvaDI+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJzZXNzaW9uLWRlc2NyaXB0aW9uXCI+XG5cdFx0XHRcdDxwPjxlbT5IZXJlIHlvdSBjYW4gZGVmaW5lIHRoZSBnb2FsIG9mIHRoaXMgc3RhZ2UuIFRoaXMgd2lsbCBiZSB1c2VkIHRvIGdlbmVyYXRlIHNtYXJ0IHJlcG9ydHMgaW4geW91ciBjYW1wYWlnbiBkYXNoYm9hcmQ8L2VtPjwvcD5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+XG5cdFx0XHQgICAgPGRpdiBjbGFzcz1cImNvbC1tZC0yXCI+XG5cdFx0XHQgICAgICA8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sXCI+XG5cdFx0XHQgICAgICAgIDxvcHRpb24+TGVhZCBHZW5lcmF0aW9uPC9vcHRpb24+XG5cdFx0XHQgICAgICA8L3NlbGVjdD5cblx0XHRcdCAgICA8L2Rpdj5cblx0XHRcdCAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTJcIj5cblx0XHRcdCAgICAgIDxpbnB1dFxuXHRcdFx0XHRcdFx0XHR0eXBlPVwidGV4dFwiXG5cdFx0XHRcdFx0XHRcdGNsYXNzPVwiZm9ybS1jb250cm9sXCJcblx0XHRcdFx0XHRcdFx0bmFtZT1cImdlbmVyYXRpb24uY291bnRcIlxuXHRcdFx0XHRcdFx0XHR2YWx1ZT17Y2FtcGFpZ24uZ29hbCA/IGNhbXBhaWduLmdvYWwuZ2VuZXJhdGlvbi5jb3VudCA6IDB9XG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0ICAgIDwvZGl2PlxuXG5cdFx0XHQgICAgPGxhYmVsIGZvcj1cIlwiIGNsYXNzPVwiY29sLW1kLTIgY29udHJvbC1sYWJlbFwiPjxkaXYgY2xhc3M9XCJ0ZXh0LXJpZ2h0XCI+bmV3IGNvbnRhY3RzIGluOiA8L2Rpdj48L2xhYmVsPlxuXHRcdFx0ICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtMlwiPlxuXHRcdFx0ICAgICAgPHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbFwiPlxuXHRcdFx0ICAgICAgICA8b3B0aW9uPjI8L29wdGlvbj5cblx0XHRcdCAgICAgIDwvc2VsZWN0PlxuXHRcdFx0ICAgIDwvZGl2PlxuXHRcdFx0ICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtMlwiPlxuXHRcdFx0ICAgICAgPHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbFwiPlxuXHRcdFx0ICAgICAgICA8b3B0aW9uPldlZWtzPC9vcHRpb24+XG5cdFx0XHQgICAgICA8L3NlbGVjdD5cblx0XHRcdCAgICA8L2Rpdj5cblx0XHRcdCAgPC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj47XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRWRpdENhbXBhaWduR29hbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGNvcmUgZnJvbSAnbWV0YWwnO1xuaW1wb3J0IEpTWENvbXBvbmVudCBmcm9tICdtZXRhbC1qc3gnO1xuaW1wb3J0IFRhY3RpY3NUYWJsZSBmcm9tICcuLi90YWJsZS9UYWN0aWNzVGFibGUnO1xuXG5jbGFzcyBFZGl0Q2FtcGFpZ25UYWN0aWNzIGV4dGVuZHMgSlNYQ29tcG9uZW50IHtcblx0cmVuZGVyKCkge1xuXHRcdHZhciBlZGl0TW9kZSA9IGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMuY29uZmlnLmVkaXRDYW1wYWlnbklkKTtcblx0XHR2YXIgY2FtcGFpZ24gPSBlZGl0TW9kZSA/IHRoaXMuY29uZmlnLmNhbXBhaWduc1t0aGlzLmNvbmZpZy5lZGl0Q2FtcGFpZ25JZF0gOiB7fTtcblxuXHRcdHJldHVybiA8ZGl2IGNsYXNzPVwiY2FtcGFpZ24tbWFuYWdlci1lZGl0LWNhbXBhaWduLXRhY3RpY3MgY29udGFpbmVyLWZsdWlkIGNhbXBhaWduLW1hbmFnZXIgd2hpdGUtYmcgc2Vzc2lvbiBzZXNzaW9uLW1lcmdlZC1uZXh0XCI+XG5cdFx0XHQ8aDI+VGFjdGljczwvaDI+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwic2Vzc2lvbi1kZXNjcmlwdGlvblwiPlxuXHRcdFx0XHQ8cD5cblx0XHRcdFx0XHQ8Yj5XaGF0IGFyZSB0YWN0aWNzPyA8L2I+XG5cdFx0XHRcdFx0PGVtPlxuXHRcdFx0XHRcdFx0VGFjdGljcyBhcmUgdGhlIGRpZmZlcmVudCB3YXlzIHRvIGFjaGl2ZSB5b3VyIG1hcmtldGluZyBnb2Fscy4gVGhleVxuXHRcdFx0XHRcdFx0dXN1YWxseSBpbmNsdWRlIHB1Ymxpc2hpbmcgZGVzdGluYXRpb25zIGxpa2UgbGFuZGluZyBwYWdlcyBvciBibG9nLFxuXHRcdFx0XHRcdFx0ZGVmaW5pbmcgYnJvYWRjYXN0IHBybW90aW9uIG9uIHNvY2lhbCBtZWRpYSBvciB2aWEgcGVyc29uYWxpemVkXG5cdFx0XHRcdFx0XHRiYW5uZXIgYWRzIGluIHlvdXIgd2VicyBhbmQgYWxzbyBvbmUgdG8gb25lIHByb21vdGlvbnMgbGlrZSBlbWFpbHMsXG5cdFx0XHRcdFx0XHRTTVMgb3IgUHVzaCBub3RpZmljYXRpb25zIHRvIHRoZSByaWdodCBhdWRpZW5jZS5cblx0XHRcdFx0XHQ8L2VtPlxuXHRcdFx0XHQ8L3A+XG5cdFx0XHQ8L2Rpdj5cblxuXHRcdFx0PFRhY3RpY3NUYWJsZVxuXHRcdFx0XHRkZXN0aW5hdGlvbnM9e3RoaXMuY29uZmlnLmRlc3RpbmF0aW9uc31cblx0XHRcdFx0c2VsZWN0ZWRUYWN0aWNJZHM9e3RoaXMuY29uZmlnLnNlbGVjdGVkVGFjdGljSWRzfVxuXHRcdFx0XHR0YWN0aWNzPXt0aGlzLmNvbmZpZy50YWN0aWNzfVxuXHRcdFx0Lz5cblx0XHRcdDxpbnB1dFxuXHRcdFx0XHR0eXBlPVwiaGlkZGVuXCJcblx0XHRcdFx0dmFsdWU9e3RoaXMuY29uZmlnLnNlbGVjdGVkVGFjdGljSWRzLmpvaW4oJywnKX1cblx0XHRcdFx0bmFtZT1cInRhY3RpY0lkc1wiXG5cdFx0XHQvPlxuXHRcdDwvZGl2Pjtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBFZGl0Q2FtcGFpZ25UYWN0aWNzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQ2FyZCBmcm9tICcuLi9jYXJkcy9DYXJkJztcbmltcG9ydCBIZWFkZXIgZnJvbSAnLi4vSGVhZGVyJztcbmltcG9ydCBJbWFnZUNhcmQgZnJvbSAnLi4vY2FyZHMvSW1hZ2VDYXJkJztcbmltcG9ydCBKU1hDb21wb25lbnQgZnJvbSAnbWV0YWwtanN4JztcbmltcG9ydCBUYWJsZUNhcmQgZnJvbSAnLi4vY2FyZHMvVGFibGVDYXJkJztcblxuY2xhc3MgRGFzaGJvYXJkIGV4dGVuZHMgSlNYQ29tcG9uZW50IHtcblx0YWRkRG90c18obnVtYmVyKSB7XG5cdFx0dmFyIHN0ciA9IG51bWJlci50b1N0cmluZygpO1xuXHRcdHZhciBmaW5hbFN0ciA9ICcnO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChpID4gMCAmJiBpIDwgc3RyLmxlbmd0aCAtIDEgJiYgKGkgJSAzID09PSBzdHIubGVuZ3RoICUgMykpIHtcblx0XHRcdFx0ZmluYWxTdHIgKz0gJy4nO1xuXHRcdFx0fVxuXHRcdFx0ZmluYWxTdHIgKz0gc3RyW2ldO1xuXHRcdH1cblx0XHRyZXR1cm4gZmluYWxTdHI7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIDxkaXYgY2xhc3M9XCJjYW1wYWlnbi1tYW5hZ2VyIGNvbnRhaW5lci1mbHVpZFwiPlxuXHRcdFx0PGRpdiBjbGFzcz1cImNhbXBhaWduLW1hbmFnZXItZGFzaGJvYXJkXCI+XG5cdFx0XHRcdDxIZWFkZXIgY3VycmVudFVybD17dGhpcy5jb25maWcuY3VycmVudFVybH0gYmFzZVBhdGg9e3RoaXMuY29uZmlnLmJhc2VQYXRofSAvPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwicm93XCI+XG5cdFx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdFx0aWQ9XCJjYW1wYWlnbi1tYW5hZ2VyLWFjdGl2ZS1jYXJkXCJcblx0XHRcdFx0XHRcdGNsYXNzPVwiY29sLW1kLTQgY2FtcGFpZ24tbWFuYWdlci1jYXJkLXdyYXBwZXJcIj5cblx0XHRcdFx0XHRcdDxDYXJkIGNzc0NsYXNzPVwiY2xlYXJmaXhcIj5cblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImNvbC1tZC00XCI+XG5cdFx0XHRcdFx0XHRcdFx0PGltZyBzcmM9e3RoaXMuY29uZmlnLmJhc2VSZXNvdXJjZVVybCArICdpbWFnZXMvdGFyZ2V0LnBuZyd9IGhlaWdodD1cIjEwMFwiIC8+XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY29sLW1kLThcIj5cblx0XHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaGlnaGxpZ2h0IGJpZ1wiPnt0aGlzLmNvbmZpZy5jYW1wYWlnbnMubGVuZ3RofTwvZGl2PlxuXHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJjYW1wYWlnbi1tYW5hZ2VyLWNhcmQtbGFiZWxcIj5BY3RpdmUgQ2FtcGFpZ25zPC9kaXY+XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0PC9DYXJkPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRcdGlkPVwiY2FtcGFpZ24tbWFuYWdlci1hbW91bnQtY2FyZFwiXG5cdFx0XHRcdFx0XHRjbGFzcz1cImNvbC1tZC00IGNhbXBhaWduLW1hbmFnZXItZ3JvdXAgY2FtcGFpZ24tbWFuYWdlci1jYXJkLXdyYXBwZXJcIj5cblx0XHRcdFx0XHRcdDxDYXJkIGNzc0NsYXNzPVwiY2xlYXJmaXhcIj5cblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImNvbC1tZC02XCI+XG5cdFx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImNhbXBhaWduLW1hbmFnZXItYW1vdW50LXZhbHVlXCI+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImhpZ2hsaWdodFwiPnt0aGlzLmFkZERvdHNfKHRoaXMuc3VtXygnaW5mbHVlbmNlZFdpbnMnKSl9PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJsaWdodC1ncmF5XCI+JDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY2FtcGFpZ24tbWFuYWdlci1jYXJkLWxhYmVsXCI+SW5mbHVlbmNlZCB3aW5zPC9kaXY+XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIj5cblx0XHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY2FtcGFpZ24tbWFuYWdlci1hbW91bnQtdmFsdWVcIj5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiaGlnaGxpZ2h0XCI+e3RoaXMuYWRkRG90c18odGhpcy5zdW1fKCdidWRnZXQnKSl9PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJsaWdodC1ncmF5XCI+JDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY2FtcGFpZ24tbWFuYWdlci1jYXJkLWxhYmVsXCI+VG90YWwgYXNzaWduZWQgYnVkZ2V0PC9kaXY+XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0PC9DYXJkPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRcdGlkPVwiY2FtcGFpZ24tbWFuYWdlci1sZWFkcy1jYXJkXCJcblx0XHRcdFx0XHRcdGNsYXNzPVwiY29sLW1kLTQgY2FtcGFpZ24tbWFuYWdlci1jYXJkLXdyYXBwZXJcIj5cblx0XHRcdFx0XHRcdDxDYXJkIGNzc0NsYXNzPVwiY2xlYXJmaXhcIj5cblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImNvbC1tZC01XCI+XG5cdFx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImhpZ2hsaWdodCBiaWdcIj57dGhpcy5zdW1fKCdsZWFkc0NvdW50Jyl9PC9kaXY+XG5cdFx0XHRcdFx0XHRcdFx0PHAgY2xhc3M9XCJjYW1wYWlnbi1tYW5hZ2VyLWNhcmQtbGFiZWxcIj5cblx0XHRcdFx0XHRcdFx0XHRcdFRvdGFsIGxlYWRzXG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3Bhbj4oTGVhZCBDb3N0IDEuMjYlKTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8L3A+XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY29sLW1kLTIgaGlkZGVuLXNtIGNhbXBhaWduLW1hbmFnZXItY2FyZC1wZW9wbGVcIj5cblx0XHRcdFx0XHRcdFx0XHQ8aW1nIHNyYz17dGhpcy5jb25maWcuYmFzZVJlc291cmNlVXJsICsgJ2ltYWdlcy9wZW9wbGUucG5nJ30gLz5cblx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJjb2wtbWQtNVwiPlxuXHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJoaWdobGlnaHQgYmlnXCI+e3RoaXMuc3VtXygnaW5mbHVlbmNlZEN1c3RvbWVycycpfTwvZGl2PlxuXHRcdFx0XHRcdFx0XHRcdDxwIGNsYXNzPVwiY2FtcGFpZ24tbWFuYWdlci1jYXJkLWxhYmVsXCI+SW5mbHVlbmNlZCBjdXN0b21lcnM8L3A+XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0PC9DYXJkPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwicm93IHJvdy1kZXN0aW5hdGlvbnNcIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY29sLW1kLTQgY2FtcGFpZ24tbWFuYWdlci1jYXJkLXdyYXBwZXJcIj5cblx0XHRcdFx0XHRcdDxJbWFnZUNhcmRcblx0XHRcdFx0XHRcdFx0Y291bnQ9ezI4OTR9XG5cdFx0XHRcdFx0XHRcdGltYWdlVXJsPXt0aGlzLmNvbmZpZy5iYXNlUmVzb3VyY2VVcmwgKyAnaW1hZ2VzL2NoYXJ0LnBuZyd9XG5cdFx0XHRcdFx0XHRcdHRpdGxlPVwiRGVzdGluYXRpb25zIHZpZXdzXCJcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImNvbC1tZC00IGNhbXBhaWduLW1hbmFnZXItY2FyZC13cmFwcGVyXCI+XG5cdFx0XHRcdFx0XHQ8VGFibGVDYXJkXG5cdFx0XHRcdFx0XHRcdGhlYWRlcnM9e1snTmFtZScsICdWaWV3cycsICdDVFInXX1cblx0XHRcdFx0XHRcdFx0ZGF0YT17W1xuXHRcdFx0XHRcdFx0XHRcdFsnRGVzdGluYXRpb24gbmFtZSAwMDEnLCAnMTJrJywgJzclJ10sXG5cdFx0XHRcdFx0XHRcdFx0WydEZXN0aW5hdGlvbiBuYW1lIDAwMScsICcxMmsnLCAnNyUnXSxcblx0XHRcdFx0XHRcdFx0XHRbJ0Rlc3RpbmF0aW9uIG5hbWUgMDAxJywgJzEyaycsICc3JSddLFxuXHRcdFx0XHRcdFx0XHRcdFsnRGVzdGluYXRpb24gbmFtZSAwMDEnLCAnMTJrJywgJzclJ10sXG5cdFx0XHRcdFx0XHRcdFx0WydEZXN0aW5hdGlvbiBuYW1lIDAwMScsICcxMmsnLCAnNyUnXVxuXHRcdFx0XHRcdFx0XHRdfVxuXHRcdFx0XHRcdFx0XHR0aXRsZT1cIlRvcCA1IERlc3RpbmF0aW9uc1wiXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJjb2wtbWQtNCBjYW1wYWlnbi1tYW5hZ2VyLWNhcmQtd3JhcHBlclwiPlxuXHRcdFx0XHRcdFx0PEltYWdlQ2FyZFxuXHRcdFx0XHRcdFx0XHRjb3VudD17Mjg5NH1cblx0XHRcdFx0XHRcdFx0aW1hZ2VVcmw9e3RoaXMuY29uZmlnLmJhc2VSZXNvdXJjZVVybCArICdpbWFnZXMvY2hhcnRXaXRoTGFiZWxzLnBuZyd9XG5cdFx0XHRcdFx0XHRcdHRpdGxlPVwiRGVzdGluYXRpb25zIGNvbnZlcnNpb25zXCJcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJyb3cgcm93LXByb21vdGlvbnNcIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY29sLW1kLTQgY2FtcGFpZ24tbWFuYWdlci1jYXJkLXdyYXBwZXJcIj5cblx0XHRcdFx0XHRcdDxJbWFnZUNhcmRcblx0XHRcdFx0XHRcdFx0Y291bnQ9ezI4OTR9XG5cdFx0XHRcdFx0XHRcdGltYWdlVXJsPXt0aGlzLmNvbmZpZy5iYXNlUmVzb3VyY2VVcmwgKyAnaW1hZ2VzL2NoYXJ0LnBuZyd9XG5cdFx0XHRcdFx0XHRcdHRpdGxlPVwiQmFubmVyIEFkcyB2aWV3c1wiXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJjb2wtbWQtNCBjYW1wYWlnbi1tYW5hZ2VyLWNhcmQtd3JhcHBlclwiPlxuXHRcdFx0XHRcdFx0PFRhYmxlQ2FyZFxuXHRcdFx0XHRcdFx0XHRoZWFkZXJzPXtbJ05hbWUnLCAnIyBQcm9tb3Rpb25zJywgJyMgUmVhY2gnLCAnQ1RSJ119XG5cdFx0XHRcdFx0XHRcdGRhdGE9e1tcblx0XHRcdFx0XHRcdFx0XHRbJ1NNUycsICcxNTAnLCAnMTUwJywgJzclJ10sXG5cdFx0XHRcdFx0XHRcdFx0WydFbWFpbCcsICc4NjAnLCAnODYwJywgJzUlJ10sXG5cdFx0XHRcdFx0XHRcdFx0WydQdXNoJywgJzc1JywgJzI2MCcsICczJSddXG5cdFx0XHRcdFx0XHRcdF19XG5cdFx0XHRcdFx0XHRcdHRpdGxlPVwiT25lIHRvIE9uZSBwcm9tb3Rpb25zXCJcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImNvbC1tZC00IGNhbXBhaWduLW1hbmFnZXItY2FyZC13cmFwcGVyXCI+XG5cdFx0XHRcdFx0XHQ8VGFibGVDYXJkXG5cdFx0XHRcdFx0XHRcdGhlYWRlcnM9e1snQ2hhbm5lbCcsICcjIFBvc3QnLCAnUmVhY2gnLCAnQ1RSJ119XG5cdFx0XHRcdFx0XHRcdGRhdGE9e1tcblx0XHRcdFx0XHRcdFx0XHRbJ0ZhY2Vib29rJywgJzE1MCcsICcxNTAnLCAnNyUnXSxcblx0XHRcdFx0XHRcdFx0XHRbJ1R3aXR0ZXInLCAnMTUwJywgJzE1MCcsICc3JSddLFxuXHRcdFx0XHRcdFx0XHRcdFsnTGlua2VkSW4nLCAnMTUwJywgJzE1MCcsICc3JSddXG5cdFx0XHRcdFx0XHRcdF19XG5cdFx0XHRcdFx0XHRcdHRpdGxlPVwiU29jaWFsIFByb21vdGlvbnNcIlxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj47XG5cdH1cblxuXHRzdW1fKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5jb25maWcuY2FtcGFpZ25zLnJlZHVjZSgocHJldiwgY3VycikgPT4gcHJldiArIGN1cnJbbmFtZV0sIDApO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERhc2hib2FyZDtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSwgb2JqZWN0IH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IHN0b3JlIGZyb20gJy4uLy4uL3N0b3JlL3N0b3JlJztcbmltcG9ydCBBY3Rpb25zIGZyb20gJy4uLy4uL2FjdGlvbnMvQWN0aW9ucyc7XG5pbXBvcnQgQmFja0Fycm93IGZyb20gJy4uL0JhY2tBcnJvdyc7XG5pbXBvcnQgRWRpdENhbXBhaWduRGV0YWlscyBmcm9tICcuLi9lZGl0L0VkaXRDYW1wYWlnbkRldGFpbHMnO1xuaW1wb3J0IEVkaXRDYW1wYWlnbkdvYWwgZnJvbSAnLi4vZWRpdC9FZGl0Q2FtcGFpZ25Hb2FsJztcbmltcG9ydCBFZGl0Q2FtcGFpZ25UYWN0aWNzIGZyb20gJy4uL2VkaXQvRWRpdENhbXBhaWduVGFjdGljcyc7XG5pbXBvcnQgSlNYQ29tcG9uZW50IGZyb20gJ21ldGFsLWpzeCc7XG5cbmNsYXNzIEVkaXRDYW1wYWlnbiBleHRlbmRzIEpTWENvbXBvbmVudCB7XG5cdGJ1aWxkRGF0ZV8oZGF0ZVN0ciwgdGltZSkge1xuXHRcdHZhciBkYXRlID0gbmV3IERhdGUoZGF0ZVN0ciA/IGRhdGVTdHIgOiBEYXRlLm5vdygpKTtcblx0XHRkYXRlLnNldEhvdXJzKHRpbWUpO1xuXHRcdHJldHVybiB7XG5cdFx0XHRkYXRlOiBkYXRlLmdldERhdGUoKSxcblx0XHRcdG1vbnRoOiBkYXRlLmdldE1vbnRoKCkgKyAxLFxuXHRcdFx0eWVhcjogZGF0ZS5nZXRGdWxsWWVhcigpLFxuXHRcdFx0aG91cnM6IGRhdGUuZ2V0SG91cnMoKSxcblx0XHRcdG1pbnV0ZXM6IGRhdGUuZ2V0TWludXRlcygpXG5cdFx0fTtcblx0fVxuXG5cdGdldERhdGFfKCkge1xuXHRcdHZhciBkYXRhID0ge307XG5cdFx0dmFyIG5hbWVkRmllbGRzID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2Zvcm0gW25hbWVdJyk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lZEZpZWxkcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIG5hbWUgPSBuYW1lZEZpZWxkc1tpXS5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcblx0XHRcdGRhdGFbbmFtZV0gPSBuYW1lZEZpZWxkc1tpXS50ZXh0ID8gbmFtZWRGaWVsZHNbaV0udGV4dCA6IG5hbWVkRmllbGRzW2ldLnZhbHVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZGF0YTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHR2YXIgZWRpdE1vZGUgPSBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLmNvbmZpZy5lZGl0Q2FtcGFpZ25JZCk7XG5cdFx0dmFyIGVkaXRDYW1wYWlnbiA9XG5cdFx0XHRlZGl0TW9kZSA/IHRoaXMuY29uZmlnLmNhbXBhaWduc1t0aGlzLmNvbmZpZy5lZGl0Q2FtcGFpZ25JZF0gOiBudWxsO1xuXG5cdFx0cmV0dXJuIDxkaXYgY2xhc3M9XCJjYW1wYWlnbi1tYW5hZ2VyLWVkaXQtY2FtcGFpZ25cIj5cblx0XHRcdDxkaXYgY2xhc3M9XCJjb250YWluZXItZmx1aWQgd2hpdGUtYmcgY2FtcGFpZ24tbWFuYWdlclwiPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY2FtcGFpZ24tbWFuYWdlci1wYWdlLXRpdGxlXCI+XG5cdFx0XHRcdFx0PEJhY2tBcnJvd1xuXHRcdFx0XHRcdFx0YmFzZVBhdGg9e3RoaXMuY29uZmlnLmJhc2VQYXRofVxuXHRcdFx0XHRcdFx0c291cmNlVXJsPXt0aGlzLmNvbmZpZy5zb3VyY2VVcmx9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8aDE+XG5cdFx0XHRcdFx0XHR7ZWRpdE1vZGUgPyAnRWRpdCcgOiAnTmV3J30gQ2FtcGFpZ25cblx0XHRcdFx0XHQ8L2gxPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PlxuXG5cdFx0XHQ8Zm9ybSBjbGFzcz1cImZvcm0taG9yaXpvbnRhbFwiPlxuXHRcdFx0XHQ8RWRpdENhbXBhaWduRGV0YWlsc1xuXHRcdFx0XHRcdGNhbXBhaWducz17dGhpcy5jb25maWcuY2FtcGFpZ25zfVxuXHRcdFx0XHRcdGVkaXRDYW1wYWlnbklkPXt0aGlzLmNvbmZpZy5lZGl0Q2FtcGFpZ25JZH1cblx0XHRcdFx0Lz5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY2FtcGFpZ24tbWFuYWdlci1lZGl0LWNhbXBhaWduLWpvdXJuZXkgY29udGFpbmVyLWZsdWlkIHdoaXRlLWJnIGNhbXBhaWduLW1hbmFnZXIgc2Vzc2lvblwiPlxuXHRcdFx0XHRcdDxoMj5Kb3VybmV5PC9oMj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwic2Vzc2lvbi1kZXNjcmlwdGlvblwiPlxuXHRcdFx0XHRcdFx0PHA+XG5cdFx0XHRcdFx0XHRcdDxiPldoYXQncyB0aGUgam91cm5leT8gPC9iPlxuXHRcdFx0XHRcdFx0XHQ8ZW0+VGhlIGpvdXJuZXkgZGVmaW5lcyB0aGUgc3RlcHMgb3Igc3RhZ2VzIG9mIHlvdXIgY2FtcGFpZ24uIElmXG5cdFx0XHRcdFx0XHRcdFx0eW91IGRvbid0IGhhdmUgc3RhZ2VzLCBqdXN0IHVzZSB0aGUgc2luZ2xlIHN0ZXAgam91cm5leS4gSWYgeW91XG5cdFx0XHRcdFx0XHRcdFx0YXJlICB1c2luZyBtdWx0aS1zdGVwIGpvdXJuZXlzIHlvdSdsbCBiZSBhYmxlIHRvIGRlZmluZSBnb2Fsc1xuXHRcdFx0XHRcdFx0XHRcdGZvciBlYWNoIHN0YWdlIGFuZCBwcm9ncmFtIHRhY3RpYyB0aGF0IGRlcGVuZCBvbiBpbmZvcm1hdGlvblxuXHRcdFx0XHRcdFx0XHRcdGZyb20gdGhlIHByZXZpb3VzIHN0YWdlLlxuXHRcdFx0XHRcdFx0XHQ8L2VtPlxuXHRcdFx0XHRcdFx0PC9wPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+XG5cdFx0XHRcdFx0XHQ8bGFiZWwgZm9yPVwiXCIgY2xhc3M9XCJjb2wtbWQtMSBjb250cm9sLWxhYmVsXCI+Sm91cm5leTwvbGFiZWw+XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY29sLW1kLTJcIj5cblx0XHRcdFx0XHRcdFx0PHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbFwiIG5hbWU9XCJqb3VybmV5XCI+XG5cdFx0XHRcdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cIjFcIj5TYWxlcyBGdW5uZWw8L29wdGlvbj5cblx0XHRcdFx0XHRcdFx0PC9zZWxlY3Q+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJjb2wtbWQtNFwiPlxuXHRcdFx0XHRcdFx0XHQ8YSBjbGFzcz1cImJ0bi1tYW5hZ2Utam91cm5leVwiPk1hbmFnZSBqb3VybmV5czwvYT5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8RWRpdENhbXBhaWduR29hbFxuXHRcdFx0XHRcdGNhbXBhaWducz17dGhpcy5jb25maWcuY2FtcGFpZ25zfVxuXHRcdFx0XHRcdGVkaXRDYW1wYWlnbklkPXt0aGlzLmNvbmZpZy5lZGl0Q2FtcGFpZ25JZH1cblx0XHRcdFx0Lz5cblxuXHRcdFx0XHQ8RWRpdENhbXBhaWduVGFjdGljc1xuXHRcdFx0XHRcdGRlc3RpbmF0aW9ucz17dGhpcy5jb25maWcuZGVzdGluYXRpb25zfVxuXHRcdFx0XHRcdHNlbGVjdGVkVGFjdGljSWRzPXtlZGl0Q2FtcGFpZ24gPyBlZGl0Q2FtcGFpZ24udGFjdGljSWRzIDogW119XG5cdFx0XHRcdFx0dGFjdGljcz17dGhpcy5jb25maWcudGFjdGljc31cblx0XHRcdFx0Lz5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY29udGFpbmVyLWZsdWlkIGNhbXBhaWduLW1hbmFnZXIgd2hpdGUtYmcgc2Vzc2lvblwiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG5cdFx0XHRcdFx0XHRcdDxhXG5cdFx0XHRcdFx0XHRcdFx0aHJlZj17dGhpcy5jb25maWcuYmFzZVBhdGggKyB0aGlzLmNvbmZpZy5zb3VyY2VVcmx9XG5cdFx0XHRcdFx0XHRcdFx0Y2xhc3M9XCJidG4gYnRuLWxnIGJ0bi1zdWNjZXNzXCJcblx0XHRcdFx0XHRcdFx0XHRkYXRhLW9uY2xpY2s9e3RoaXMuc2F2ZV8uYmluZCh0aGlzKX0+XG5cdFx0XHRcdFx0XHRcdFx0e2VkaXRNb2RlID8gJ1NhdmUnIDogJ0NyZWF0ZSd9IENhbXBhaWduXG5cdFx0XHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0XHRcdFx0PGFcblx0XHRcdFx0XHRcdFx0XHRocmVmPXt0aGlzLmNvbmZpZy5iYXNlUGF0aCArIHRoaXMuY29uZmlnLnNvdXJjZVVybH1cblx0XHRcdFx0XHRcdFx0XHRjbGFzcz1cImJ0biBidG4tbGcgYnRuLWxpZ2h0ZXJcIj5cblx0XHRcdFx0XHRcdFx0XHRDYW5jZWxcblx0XHRcdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9mb3JtPlxuXHRcdDwvZGl2Pjtcblx0fVxuXG5cdHNhdmVfKCkge1xuXHRcdHZhciBkYXRhID0gdGhpcy5nZXREYXRhXygpO1xuXHRcdHN0b3JlLmRpc3BhdGNoKEFjdGlvbnMuc2F2ZUNhbXBhaWduKG9iamVjdC5taXhpbihkYXRhLCB7XG5cdFx0XHRpZDogY29yZS5pc051bWJlcih0aGlzLmNvbmZpZy5lZGl0Q2FtcGFpZ25JZCkgPyB0aGlzLmNvbmZpZy5lZGl0Q2FtcGFpZ25JZCA6IHVuZGVmaW5lZCxcblx0XHRcdGJ1ZGdldDogcGFyc2VJbnQoZGF0YS5idWRnZXQsIDEwKSB8fCAwLFxuXHRcdFx0c3RhcnREYXRlOiB0aGlzLmJ1aWxkRGF0ZV8oZGF0YS5zdGFydERhdGUsIGRhdGEuc3RhcnREYXRlVGltZSksXG5cdFx0XHRlbmREYXRlOiB0aGlzLmJ1aWxkRGF0ZV8oZGF0YS5lbmREYXRlLCBkYXRhLmVuZERhdGVUaW1lKSxcblx0XHRcdGdvYWw6IHtcblx0XHRcdFx0Z2VuZXJhdGlvbjoge1xuXHRcdFx0XHRcdGNvdW50OiBkYXRhWydnZW5lcmF0aW9uLmNvdW50J11cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGpvdXJuZXk6IHBhcnNlSW50KGRhdGEuam91cm5leSwgMTApLFxuXHRcdFx0dGFjdGljSWRzOiBkYXRhLnRhY3RpY0lkcy5zcGxpdCgnLCcpLm1hcChpZCA9PiBwYXJzZUludChpZCwgMTApKS5maWx0ZXIoaWQgPT4gISFpZClcblx0XHR9KSkpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVkaXRDYW1wYWlnbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGNvcmUgZnJvbSAnbWV0YWwnO1xuaW1wb3J0IENhbXBhaWduVGFibGUgZnJvbSAnLi4vdGFibGUvQ2FtcGFpZ25UYWJsZSc7XG5pbXBvcnQgQ2FyZCBmcm9tICcuLi9jYXJkcy9DYXJkJztcbmltcG9ydCBIZWFkZXIgZnJvbSAnLi4vSGVhZGVyJztcbmltcG9ydCBKU1hDb21wb25lbnQgZnJvbSAnbWV0YWwtanN4JztcbmltcG9ydCBTZWFyY2ggZnJvbSAnLi4vc2VhcmNoL1NlYXJjaCc7XG5cbmNsYXNzIE1hbmFnZUNhbXBhaWducyBleHRlbmRzIEpTWENvbXBvbmVudCB7XG5cdGZpbHRlckNhbXBhaWduc18oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2FtcGFpZ25zXG5cdFx0XHQuZmlsdGVyKGNhbXBhaWduID0+IHtcblx0XHRcdFx0cmV0dXJuICF0aGlzLnNlYXJjaEJ5IHx8XG5cdFx0XHRcdFx0Y2FtcGFpZ24ubmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgodGhpcy5zZWFyY2hCeS50b0xvd2VyQ2FzZSgpKTtcblx0XHRcdH0pXG5cdFx0XHQuc29ydCgoYzEsIGMyKSA9PiB7XG5cdFx0XHRcdGlmICh0aGlzLnNvcnRCeSA9PT0gJ2RhdGUnKSB7XG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gdGhpcy50b0RhdGVfKGMxLnN0YXJ0RGF0ZSkgLSB0aGlzLnRvRGF0ZV8oYzIuc3RhcnREYXRlKTtcblx0XHRcdFx0XHRyZXR1cm4gc3RhcnQgIT09IDAgPyBzdGFydCA6IHRoaXMudG9EYXRlXyhjMS5lbmREYXRlKSAtIHRoaXMudG9EYXRlXyhjMi5lbmREYXRlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gYzEubmFtZS5sb2NhbGVDb21wYXJlKGMyLm5hbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gPGRpdiBjbGFzcz1cImNhbXBhaWduLW1hbmFnZXIgY29udGFpbmVyLWZsdWlkXCI+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwiY2FtcGFpZ24tbWFuYWdlci1tYW5hZ2UtY2FtcGFpZ25zXCI+XG5cdFx0XHRcdDxIZWFkZXIgY3VycmVudFVybD17dGhpcy5jb25maWcuY3VycmVudFVybH0gYmFzZVBhdGg9e3RoaXMuY29uZmlnLmJhc2VQYXRofSAvPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwicm93XCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImNvbC1tZC00XCI+PC9kaXY+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImNvbC1tZC00XCI+XG5cdFx0XHRcdFx0XHQ8U2VhcmNoIG9uSW5wdXQ9e3RoaXMuc2VhcmNoXy5iaW5kKHRoaXMpfSAvPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PENhcmQ+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImZvcm0taW5saW5lIHNlbGVjdCBwdWxsLXJpZ2h0XCI+XG5cdFx0XHRcdFx0XHQ8bGFiZWw+VmlldyBNb2RlOjwvbGFiZWw+XG5cdFx0XHRcdFx0XHQ8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sXCI+XG5cdFx0XHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJuYW1lXCI+TGlzdDwvb3B0aW9uPlxuXHRcdFx0XHRcdFx0PC9zZWxlY3Q+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImZvcm0taW5saW5lIHNlbGVjdFwiPlxuXHRcdFx0XHRcdFx0PGxhYmVsPk9yZGVyIGJ5OjwvbGFiZWw+XG5cdFx0XHRcdFx0XHQ8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sXCIgZGF0YS1vbmNoYW5nZT17dGhpcy5zb3J0Xy5iaW5kKHRoaXMpfT5cblx0XHRcdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cIm5hbWVcIj5OYW1lPC9vcHRpb24+XG5cdFx0XHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJkYXRlXCI+U2NoZWR1bGVkIERhdGU8L29wdGlvbj5cblx0XHRcdFx0XHRcdDwvc2VsZWN0PlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxDYW1wYWlnblRhYmxlXG5cdFx0XHRcdFx0XHRiYXNlUGF0aD17dGhpcy5jb25maWcuYmFzZVBhdGh9XG5cdFx0XHRcdFx0XHRjYW1wYWlnbnM9e3RoaXMuZmlsdGVyQ2FtcGFpZ25zXygpfVxuXHRcdFx0XHRcdFx0Y3VycmVudFVybD17dGhpcy5jb25maWcuY3VycmVudFVybH1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L0NhcmQ+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj47XG5cdH1cblxuXHRzZWFyY2hfKGV2ZW50KSB7XG5cdFx0dGhpcy5zZWFyY2hCeSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcblx0fVxuXG5cdHNvcnRfKGV2ZW50KSB7XG5cdFx0dGhpcy5zb3J0QnkgPSBldmVudC50YXJnZXQudmFsdWU7XG5cdH1cblxuXHR0b0RhdGVfKG9iaikge1xuXHRcdHJldHVybiBuZXcgRGF0ZShvYmoueWVhciwgb2JqLm1vbnRoLCBvYmouZGF0ZSwgb2JqLmhvdXJzLCBvYmoubWludXRlcyk7XG5cdH1cbn1cblxuTWFuYWdlQ2FtcGFpZ25zLlNUQVRFID0ge1xuXHRjYW1wYWlnbnM6IHtcblx0XHR2YWxpZGF0b3I6IEFycmF5LmlzQXJyYXlcblx0fSxcblx0c2VhcmNoQnk6IHtcblx0XHR2YWxpZGF0b3I6IGNvcmUuaXNTdHJpbmdcblx0fSxcblx0c29ydEJ5OiB7XG5cdFx0dmFsaWRhdG9yOiBjb3JlLmlzU3RyaW5nXG5cdH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1hbmFnZUNhbXBhaWducztcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEpTWENvbXBvbmVudCBmcm9tICdtZXRhbC1qc3gnO1xuXG5jbGFzcyBTZWFyY2ggZXh0ZW5kcyBKU1hDb21wb25lbnQge1xuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBjYW1wYWlnbi1tYW5hZ2VyLXNlYXJjaFwiPlxuXHRcdFx0PGlucHV0XG5cdFx0XHRcdHR5cGU9XCJ0ZXh0XCJcblx0XHRcdFx0Y2xhc3M9XCJmb3JtLWNvbnRyb2wgaW5wdXQtbGdcIlxuXHRcdFx0XHRwbGFjZWhvbGRlcj1cIlNlYXJjaFwiXG5cdFx0XHRcdHZhbHVlPXt0aGlzLmNvbmZpZy52YWx1ZSB8fCAnJ31cblx0XHRcdFx0ZGF0YS1vbmlucHV0PXt0aGlzLmNvbmZpZy5vbklucHV0fVxuXHRcdFx0Lz5cblx0XHRcdDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvbiBpbnB1dC1ncm91cC1hZGRvbi1jbGVhblwiPlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tc2VhcmNoXCI+PC9zcGFuPlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9kaXY+O1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlYXJjaDtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGRvbSBmcm9tICdtZXRhbC1kb20nO1xuaW1wb3J0IHN0b3JlIGZyb20gJy4uLy4uL3N0b3JlL3N0b3JlJztcbmltcG9ydCBBY3Rpb25zIGZyb20gJy4uLy4uL2FjdGlvbnMvQWN0aW9ucyc7XG5pbXBvcnQgSlNYQ29tcG9uZW50IGZyb20gJ21ldGFsLWpzeCc7XG5cbmNsYXNzIENhbXBhaWduVGFibGUgZXh0ZW5kcyBKU1hDb21wb25lbnQge1xuXHRlZGl0XyhldmVudCkge1xuXHRcdHZhciBpZCA9IHRoaXMuZ2V0Um93SWRfKGV2ZW50KTtcblx0XHRzdG9yZS5kaXNwYXRjaChBY3Rpb25zLnN0YXJ0Q2FtcGFpZ25FZGl0aW9uKGlkLCB0aGlzLmNvbmZpZy5jdXJyZW50VXJsKSk7XG5cdH1cblxuXHRnZXRSb3dJZF8oZXZlbnQpIHtcblx0XHRyZXR1cm4gcGFyc2VJbnQoZG9tLnBhcmVudChldmVudC50YXJnZXQsICd0cicpLmdldEF0dHJpYnV0ZSgnZGF0YS1pZCcpLCAxMCk7XG5cdH1cblxuXHRyZW1vdmVfKGV2ZW50KSB7XG5cdFx0dmFyIGlkID0gdGhpcy5nZXRSb3dJZF8oZXZlbnQpO1xuXHRcdHN0b3JlLmRpc3BhdGNoKEFjdGlvbnMucmVtb3ZlQ2FtcGFpZ24oaWQpKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gPGRpdiBjbGFzcz1cImNhbXBhaWduLW1hbmFnZXItY2FtcGFpZ24tdGFibGUgY2FtcGFpZ24tbWFuYWdlci10YWJsZVwiPlxuXHRcdFx0PHRhYmxlIGNsYXNzPVwidGFibGUgdGFibGUtYm94XCI+XG5cdFx0XHRcdDx0aGVhZD5cblx0XHRcdFx0XHQ8dHI+XG5cdFx0XHRcdFx0XHQ8dGggY2xhc3M9XCJsaWdodC1ncmF5XCI+TmFtZTwvdGg+XG5cdFx0XHRcdFx0XHQ8dGggY2xhc3M9XCJsaWdodC1ncmF5XCI+U2NoZWR1bGVkIERhdGU8L3RoPlxuXHRcdFx0XHRcdFx0PHRoIGNsYXNzPVwibGlnaHQtZ3JheVwiPkdvYWw8L3RoPlxuXHRcdFx0XHRcdFx0PHRoIGNsYXNzPVwibGlnaHQtZ3JheVwiPkVkaXQ8L3RoPlxuXHRcdFx0XHRcdFx0PHRoIGNsYXNzPVwibGlnaHQtZ3JheVwiPlJlbW92ZTwvdGg+XG5cdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0PC90aGVhZD5cblx0XHRcdFx0PHRib2R5Pnt0aGlzLnJlbmRlclJvd3NfKCl9PC90Ym9keT5cblx0XHRcdDwvdGFibGU+XG5cdFx0PC9kaXY+O1xuXHR9XG5cblx0cmVuZGVyRGF0ZV8oZGF0ZSkge1xuXHRcdHJldHVybiA8c3Bhbj57TU9OVEhTW2RhdGUubW9udGggLSAxXSArICcgJyArIGRhdGUuZGF0ZSArICcsICcgKyBkYXRlLnllYXJ9PC9zcGFuPjtcblx0fVxuXG5cdHJlbmRlclJvd3NfKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbmZpZy5jYW1wYWlnbnMubWFwKGNhbXBhaWduID0+IHtcblx0XHRcdHJldHVybiA8dHIgZGF0YS1pZD17Y2FtcGFpZ24uaWR9PlxuXHRcdFx0XHQ8dGQ+PHNwYW4+e2NhbXBhaWduLm5hbWV9PC9zcGFuPjwvdGQ+XG5cdFx0XHRcdDx0ZD5cblx0XHRcdFx0XHQ8c3Bhbj5cblx0XHRcdFx0XHRcdHt0aGlzLnJlbmRlckRhdGVfKGNhbXBhaWduLnN0YXJ0RGF0ZSl9IHRvIHt0aGlzLnJlbmRlckRhdGVfKGNhbXBhaWduLmVuZERhdGUpfVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PC90ZD5cblx0XHRcdFx0PHRkPlxuXHRcdFx0XHRcdDxzcGFuPkxlYWQgR2VuZXJhdGlvbiAtIHtjYW1wYWlnbi5nb2FsLmdlbmVyYXRpb24uY291bnR9IG5ldyBjb250YWN0cyBpbiAyIHdlZWtzPC9zcGFuPlxuXHRcdFx0XHQ8L3RkPlxuXHRcdFx0XHQ8dGQ+XG5cdFx0XHRcdFx0PGFcblx0XHRcdFx0XHRcdGhyZWY9e3RoaXMuY29uZmlnLmJhc2VQYXRoICsgJy9lZGl0LWNhbXBhaWduLycgKyBjYW1wYWlnbi5pZH1cblx0XHRcdFx0XHRcdGRhdGEtb25jbGljaz17dGhpcy5lZGl0Xy5iaW5kKHRoaXMpfT5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1jb2cgdGFibGUtYWN0aW9uLWljb24gdGFibGUtYWN0aW9uLWVkaXRcIj48L3NwYW4+XG5cdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHQ8L3RkPlxuXHRcdFx0XHQ8dGQ+XG5cdFx0XHRcdFx0PHNwYW5cblx0XHRcdFx0XHRcdGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi10cmFzaCB0YWJsZS1hY3Rpb24taWNvbiB0YWJsZS1hY3Rpb24tcmVtb3ZlXCJcblx0XHRcdFx0XHRcdGRhdGEtb25jbGljaz17dGhpcy5yZW1vdmVfLmJpbmQodGhpcyl9PlxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PC90ZD5cblx0XHRcdDwvdHI+XG5cdFx0fSk7XG5cdH1cbn1cblxudmFyIE1PTlRIUyA9IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5Jyxcblx0J0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddO1xuXG5leHBvcnQgZGVmYXVsdCBDYW1wYWlnblRhYmxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgZG9tIGZyb20gJ21ldGFsLWRvbSc7XG5pbXBvcnQgSlNYQ29tcG9uZW50IGZyb20gJ21ldGFsLWpzeCc7XG5cbmNsYXNzIFRhY3RpY3NUYWJsZSBleHRlbmRzIEpTWENvbXBvbmVudCB7XG5cdHJlbW92ZV8oKSB7XG5cdFx0dmFyIHJvdyA9IHBhcnNlSW50KGRvbS5wYXJlbnQoZXZlbnQudGFyZ2V0LCAndHInKS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcm93JyksIDEwKTtcblx0XHR2YXIgdGFjdGljSWRzID0gdGhpcy5zZWxlY3RlZFRhY3RpY0lkcy5jb25jYXQoKTtcblx0XHR0YWN0aWNJZHMuc3BsaWNlKHJvdywgMSk7XG5cdFx0dGhpcy5zZWxlY3RlZFRhY3RpY0lkcyA9IHRhY3RpY0lkcztcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gPGRpdiBjbGFzcz1cImNhbXBhaWduLW1hbmFnZXItdGFjdGljcy10YWJsZSBjYW1wYWlnbi1tYW5hZ2VyLXRhYmxlXCI+XG5cdFx0XHQ8dGFibGUgY2xhc3M9XCJ0YWJsZSB0YWJsZS1ib3hcIj5cblx0XHRcdFx0PHRoZWFkPlxuXHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdDx0aCBjbGFzcz1cImxpZ2h0LWdyYXlcIj5OYW1lPC90aD5cblx0XHRcdFx0XHRcdDx0aCBjbGFzcz1cImxpZ2h0LWdyYXlcIj5EZXN0aW5hdGlvbjwvdGg+XG5cdFx0XHRcdFx0XHQ8dGggY2xhc3M9XCJsaWdodC1ncmF5XCI+UHJvbW9zPC90aD5cblx0XHRcdFx0XHRcdDx0aCBjbGFzcz1cImxpZ2h0LWdyYXlcIj5BdWRpZW5jZTwvdGg+XG5cdFx0XHRcdFx0XHQ8dGggY2xhc3M9XCJsaWdodC1ncmF5XCI+QmFubmVyczwvdGg+XG5cdFx0XHRcdFx0XHQ8dGggY2xhc3M9XCJsaWdodC1ncmF5XCI+UmVtb3ZlPC90aD5cblx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHQ8L3RoZWFkPlxuXHRcdFx0XHQ8dGJvZHk+e3RoaXMucmVuZGVyUm93c18oKX08L3Rib2R5PlxuXHRcdFx0PC90YWJsZT5cblx0XHQ8L2Rpdj47XG5cdH1cblxuXHRyZW5kZXJSb3dzXygpIHtcblx0XHRyZXR1cm4gdGhpcy5zZWxlY3RlZFRhY3RpY0lkcy5tYXAoKGlkLCBpbmRleCkgPT4ge1xuXHRcdFx0cmV0dXJuIDx0ciBkYXRhLXJvdz17aW5kZXh9PlxuXHRcdFx0XHQ8dGQ+XG5cdFx0XHRcdFx0PHNwYW4+XG5cdFx0XHRcdFx0XHR7dGhpcy5jb25maWcuZGVzdGluYXRpb25zW3RoaXMuY29uZmlnLnRhY3RpY3NbaWRdLmRlc3RpbmF0aW9uSWRdLm5hbWV9XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8L3RkPlxuXHRcdFx0XHQ8dGQ+PHNwYW4+e3RoaXMuY29uZmlnLnRhY3RpY3NbaWRdLm5hbWV9PC9zcGFuPjwvdGQ+XG5cdFx0XHRcdDx0ZD5cblx0XHRcdFx0XHQ8c3BhblxuXHRcdFx0XHRcdFx0Y2xhc3M9eyh0aGlzLmNvbmZpZy50YWN0aWNzW2lkXS5vbmVUb09uZVByb21vcy5sZW5ndGggPiAwKSA/ICdnbHlwaGljb24gZ2x5cGhpY29uLW9rJyA6ICcnfT5cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDwvdGQ+XG5cdFx0XHRcdDx0ZD5cblx0XHRcdFx0XHQ8c3BhblxuXHRcdFx0XHRcdFx0Y2xhc3M9eyh0aGlzLmNvbmZpZy50YWN0aWNzW2lkXS5vbmVUb09uZVByb21vcy5sZW5ndGggPiAwKSA/ICdnbHlwaGljb24gZ2x5cGhpY29uLW9rJyA6ICcnfT5cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDwvdGQ+XG5cdFx0XHRcdDx0ZD5cblx0XHRcdFx0XHQ8c3BhblxuXHRcdFx0XHRcdFx0Y2xhc3M9eyh0aGlzLmNvbmZpZy50YWN0aWNzW2lkXS5wcm9tb3Rpb25hbEFkcy5sZW5ndGggPiAwKSA/ICdnbHlwaGljb24gZ2x5cGhpY29uLW9rJyA6ICcnfT5cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDwvdGQ+XG5cdFx0XHRcdDx0ZD5cblx0XHRcdFx0XHQ8c3BhblxuXHRcdFx0XHRcdFx0Y2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXRyYXNoIHRhYmxlLWFjdGlvbi1pY29uIHRhYmxlLWFjdGlvbi1yZW1vdmVcIlxuXHRcdFx0XHRcdFx0ZGF0YS1vbmNsaWNrPXt0aGlzLnJlbW92ZV8uYmluZCh0aGlzKX0+XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8L3RkPlxuXHRcdFx0PC90cj5cblx0XHR9KTtcblx0fVxufVxuXG5UYWN0aWNzVGFibGUuU1RBVEUgPSB7XG5cdHNlbGVjdGVkVGFjdGljSWRzOiB7XG5cdFx0dmFsaWRhdG9yOiBBcnJheS5pc0FycmF5XG5cdH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRhY3RpY3NUYWJsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgY29yZSwgb2JqZWN0IH0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IEFjdGlvblR5cGVzIGZyb20gJy4uL2FjdGlvbnMvQWN0aW9uVHlwZXMnO1xuXG5mdW5jdGlvbiBjYW1wYWlnbnMoc3RhdGUsIGFjdGlvbikge1xuXHRzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cdFx0Y2FzZSBBY3Rpb25UeXBlcy5SRU1PVkVfQ0FNUEFJR046XG5cdFx0XHRzdGF0ZSA9IHN0YXRlLmNvbmNhdCgpO1xuXHRcdFx0c3RhdGUuc3BsaWNlKGFjdGlvbi5pZCwgMSk7XG5cdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0Y2FzZSBBY3Rpb25UeXBlcy5TQVZFX0NBTVBBSUdOOlxuXHRcdFx0c3RhdGUgPSBzdGF0ZS5jb25jYXQoKTtcblx0XHRcdGlmIChjb3JlLmlzRGVmQW5kTm90TnVsbChhY3Rpb24uY2FtcGFpZ24uaWQpKSB7XG5cdFx0XHRcdHN0YXRlW2FjdGlvbi5jYW1wYWlnbi5pZF0gPSBvYmplY3QubWl4aW4oXG5cdFx0XHRcdFx0c3RhdGVbYWN0aW9uLmNhbXBhaWduLmlkXSxcblx0XHRcdFx0XHRhY3Rpb24uY2FtcGFpZ25cblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN0YXRlLnB1c2gob2JqZWN0Lm1peGluKGFjdGlvbi5jYW1wYWlnbiwge1xuXHRcdFx0XHRcdGlkOiBzdGF0ZS5sZW5ndGgsXG5cdFx0XHRcdFx0aW5mbHVlbmNlZEN1c3RvbWVyczogMCxcblx0XHRcdFx0XHRpbmZsdWVuY2VkV2luczogMCxcblx0XHRcdFx0XHRsZWFkc0NvdW50OiAwXG5cdFx0XHRcdH0pKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdGF0ZTtcblx0fVxuXHRyZXR1cm4gc3RhdGUgfHwgW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNhbXBhaWducztcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEFjdGlvblR5cGVzIGZyb20gJy4uL2FjdGlvbnMvQWN0aW9uVHlwZXMnO1xuXG5mdW5jdGlvbiBlZGl0Q2FtcGFpZ25JZChzdGF0ZSwgYWN0aW9uKSB7XG5cdHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcblx0XHRjYXNlIEFjdGlvblR5cGVzLlNUQVJUX0NBTVBBSUdOX0VESVRJT046XG5cdFx0XHRyZXR1cm4gYWN0aW9uLmlkO1xuXHRcdGNhc2UgQWN0aW9uVHlwZXMuU1RBUlRfQ0FNUEFJR05fQ1JFQVRJT046XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRyZXR1cm4gc3RhdGUgfHwgbnVsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZWRpdENhbXBhaWduSWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBY3Rpb25UeXBlcyBmcm9tICcuLi9hY3Rpb25zL0FjdGlvblR5cGVzJztcbmltcG9ydCBjYW1wYWlnbnMgZnJvbSAnLi9jYW1wYWlnbnMnO1xuaW1wb3J0IGVkaXRDYW1wYWlnbklkIGZyb20gJy4vZWRpdENhbXBhaWduSWQnO1xuaW1wb3J0IHNvdXJjZVVybCBmcm9tICcuL3NvdXJjZVVybCc7XG5cbmZ1bmN0aW9uIGJhc2VQYXRoKHN0YXRlKSB7XG5cdHJldHVybiBzdGF0ZSB8fCAnJztcbn1cblxuZnVuY3Rpb24gYmFzZVJlc291cmNlVXJsKHN0YXRlKSB7XG5cdHJldHVybiBzdGF0ZSB8fCAnLyc7XG59XG5cbmZ1bmN0aW9uIGRlc3RpbmF0aW9ucyhzdGF0ZSkge1xuXHRyZXR1cm4gc3RhdGUgfHwgW107XG59XG5cbmZ1bmN0aW9uIGF1ZGllbmNlcyhzdGF0ZSkge1xuXHRyZXR1cm4gc3RhdGUgfHwgW107XG59XG5cbmZ1bmN0aW9uIGJhbm5lcnMoc3RhdGUpIHtcblx0cmV0dXJuIHN0YXRlIHx8IFtdO1xufVxuXG5mdW5jdGlvbiBkaXNwbGF5cyhzdGF0ZSkge1xuXHRyZXR1cm4gc3RhdGUgfHwgW107XG59XG5cbmZ1bmN0aW9uIHRhY3RpY3Moc3RhdGUpIHtcblx0cmV0dXJuIHN0YXRlIHx8IFtdO1xufVxuXG52YXIgY29tYmluZWQgPSBSZWR1eC5jb21iaW5lUmVkdWNlcnMoe1xuXHRiYXNlUGF0aCxcblx0YmFzZVJlc291cmNlVXJsLFxuXHRjYW1wYWlnbnMsXG5cdGVkaXRDYW1wYWlnbklkLFxuXHRkZXN0aW5hdGlvbnMsXG5cdGF1ZGllbmNlcyxcblx0YmFubmVycyxcblx0ZGlzcGxheXMsXG5cdHRhY3RpY3MsXG5cdHNvdXJjZVVybFxufSk7XG5cbmZ1bmN0aW9uIHJvb3RSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcblx0c3dpdGNoIChhY3Rpb24udHlwZSkge1xuXHRcdGNhc2UgQWN0aW9uVHlwZXMuVVBEQVRFX0RBVEE6XG5cdFx0XHRyZXR1cm4gYWN0aW9uLnN0YXRlO1xuXHR9XG5cdHJldHVybiBjb21iaW5lZChzdGF0ZSwgYWN0aW9uKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcm9vdFJlZHVjZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBY3Rpb25UeXBlcyBmcm9tICcuLi9hY3Rpb25zL0FjdGlvblR5cGVzJztcblxuZnVuY3Rpb24gc291cmNlVXJsKHN0YXRlLCBhY3Rpb24pIHtcblx0c3dpdGNoIChhY3Rpb24udHlwZSkge1xuXHRcdGNhc2UgQWN0aW9uVHlwZXMuU1RBUlRfQ0FNUEFJR05fQ1JFQVRJT046XG5cdFx0Y2FzZSBBY3Rpb25UeXBlcy5TVEFSVF9DQU1QQUlHTl9FRElUSU9OOlxuXHRcdFx0cmV0dXJuIGFjdGlvbi5zb3VyY2VVcmwgfHwgJy8nO1xuXHR9XG5cdHJldHVybiBzdGF0ZSB8fCAnLyc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNvdXJjZVVybDtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHJvb3RSZWR1Y2VyIGZyb20gJy4uL3JlZHVjZXJzL3Jvb3RSZWR1Y2VyJztcblxuZXhwb3J0IGRlZmF1bHQgUmVkdXguY3JlYXRlU3RvcmUocm9vdFJlZHVjZXIpO1xuIl19
