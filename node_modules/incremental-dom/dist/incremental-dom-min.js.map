{"version":3,"sources":["incremental-dom-min.js","src/context.js","src/node_data.js","src/notifications.js","src/util.js","src/symbols.js","src/attributes.js","src/nodes.js","src/core.js","src/virtual_elements.js"],"names":["global","factory","exports","module","define","amd","IncrementalDOM","this","Context","created","notifications","nodesCreated","deleted","nodesDeleted","NodeData","nodeName","key","attrs","createMap","attrsArr","newAttrs","keyMap","keyMapValid","text","prototype","markCreated","node","push","markDeleted","notifyChanges","length","hasOwnProperty","Object","create","has","map","property","call","initData","data","getData","toLowerCase","Element","getAttribute","symbols","default","placeholder","applyAttr","el","name","value","removeAttribute","setAttribute","applyProp","applyStyle","style","cssText","elStyle","obj","prop","applyAttributeTyped","type","updateAttribute","mutator","attributes","currentNode","currentParent","previousNode","root","doc","getNamespaceForTag","tag","parent","namespaceURI","createElement","statics","namespace","createElementNS","i","createText","createTextNode","createKeyMap","children","count","child","getKeyMap","getChild","registerChild","context","patch","fn","prevContext","prevRoot","prevDoc","prevCurrentNode","prevCurrentParent","prevPreviousNode","ownerDocument","enterNode","exitNode","matches","alignWithDOM","replaceChild","insertBefore","clearUnvisitedDOM","lastChild","removeChild","parentNode","firstChild","nextNode","nextSibling","_elementOpen","_elementClose","_text","currentElement","skip","ATTRIBUTES_OFFSET","argsBuilder","elementOpen","var_args","attrsChanged","j","arguments","attr","undefined","elementOpenStart","elementOpenEnd","apply","elementClose","elementVoid","elementPlaceholder","formatted"],"mappings":"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","file":"incremental-dom-min.js","sourcesContent":["\n/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.IncrementalDOM = {}));\n}(this, function (exports) { 'use strict';\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n\n  /**\n    * Keeps track whether or not we are in an attributes declaration (after\n    * elementOpenStart, but before elementOpenEnd).\n    * @type {boolean}\n    */\n  var inAttributes = false;\n\n\n  /**\n    * Keeps track whether or not we are in an element that should not have its\n    * children cleared.\n    * @type {boolean}\n    */\n  var inSkip = false;\n\n\n  /**\n   * Makes sure that there is a current patch context.\n   * @param {*} context\n   */\n  var assertInPatch = function(context) {\n    if (!context) {\n      throw new Error('Cannot call currentElement() unless in patch');\n    }\n  };\n\n\n  /**\n  * Makes sure that keyed Element matches the tag name provided.\n  * @param {!string} nodeName The nodeName of the node that is being matched.\n  * @param {string=} tag The tag name of the Element.\n  * @param {?string=} key The key of the Element.\n  */\n  var assertKeyedTagMatches = function(nodeName, tag, key) {\n    if (nodeName !== tag) {\n      throw new Error('Was expecting node with key \"' + key + '\" to be a ' +\n          tag + ', not a ' + nodeName + '.');\n    }\n  };\n\n\n  /**\n   * Makes sure that a patch closes every node that it opened.\n   * @param {?Node} openElement\n   * @param {!Node|!DocumentFragment} root\n   */\n  var assertNoUnclosedTags = function(openElement, root) {\n    if (openElement === root) {\n      return;\n    }\n\n    var currentElement = openElement;\n    var openTags = [];\n    while (currentElement && currentElement !== root) {\n      openTags.push(currentElement.nodeName.toLowerCase());\n      currentElement = currentElement.parentNode;\n    }\n\n    throw new Error('One or more tags were not closed:\\n' +\n        openTags.join('\\n'));\n  };\n\n\n  /**\n   * Makes sure that the caller is not where attributes are expected.\n   * @param {string} functionName\n   */\n  var assertNotInAttributes = function(functionName) {\n    if (inAttributes) {\n      throw new Error(functionName + '() may not be called between ' +\n          'elementOpenStart() and elementOpenEnd().');\n    }\n  };\n\n\n  /**\n   * Makes sure that the caller is not inside an element that has declared skip.\n   * @param {string} functionName\n   */\n  var assertNotInSkip = function(functionName) {\n    if (inSkip) {\n      throw new Error(functionName + '() may not be called inside an element ' +\n          'that has called skip().');\n    }\n  };\n\n\n  /**\n   * Makes sure that the caller is where attributes are expected.\n   * @param {string} functionName\n   */\n  var assertInAttributes = function(functionName) {\n    if (!inAttributes) {\n      throw new Error(functionName + '() must be called after ' +\n          'elementOpenStart().');\n    }\n  };\n\n\n  /**\n   * Makes sure the patch closes virtual attributes call\n   */\n  var assertVirtualAttributesClosed = function() {\n    if (inAttributes) {\n      throw new Error('elementOpenEnd() must be called after calling ' +\n          'elementOpenStart().');\n    }\n  };\n\n\n  /**\n    * Makes sure that placeholders have a key specified. Otherwise, conditional\n    * placeholders and conditional elements next to placeholders will cause\n    * placeholder elements to be re-used as non-placeholders and vice versa.\n    * @param {string} key\n    */\n  var assertPlaceholderKeySpecified = function(key) {\n    if (!key) {\n      throw new Error('Placeholder elements must have a key specified.');\n    }\n  };\n\n\n  /**\n    * Makes sure that tags are correctly nested.\n    * @param {string} nodeName\n    * @param {string} tag\n    */\n  var assertCloseMatchesOpenTag = function(nodeName, tag) {\n    if (nodeName !== tag) {\n      throw new Error('Received a call to close ' + tag + ' but ' +\n          nodeName + ' was open.');\n    }\n  };\n\n\n  /**\n   * Makes sure that no children elements have been declared yet in the current\n   * element.\n   * @param {string} functionName\n   * @param {?Node} previousNode\n   */\n  var assertNoChildrenDeclaredYet = function(functionName, previousNode) {\n    if (previousNode !== null) {\n      throw new Error(functionName + '() must come before any child ' +\n          'declarations inside the current element.');\n    }\n  };\n\n\n  /**\n   * Updates the state of being in an attribute declaration.\n   * @param {boolean} value\n   * @return {boolean} the previous value.\n   */\n  var setInAttributes = function(value) {\n    var previous = inAttributes;\n    inAttributes = value;\n    return previous;\n  };\n\n\n  /**\n   * Updates the state of being in a skip element.\n   * @param {boolean} value\n   * @return {boolean} the previous value.\n   */\n  var setInSkip = function(value) {\n    var previous = inSkip;\n    inSkip = value;\n    return previous;\n  };\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  /** */\n  exports.notifications = {\n    /**\n     * Called after patch has compleated with any Nodes that have been created\n     * and added to the DOM.\n     * @type {?function(Array<!Node>)}\n     */\n    nodesCreated: null,\n\n    /**\n     * Called after patch has compleated with any Nodes that have been removed\n     * from the DOM.\n     * Note it's an applications responsibility to handle any childNodes.\n     * @type {?function(Array<!Node>)}\n     */\n    nodesDeleted: null\n  };\n\n  /**\n   * Keeps track of the state of a patch.\n   * @constructor\n   */\n  function Context() {\n    /**\n     * @type {(Array<!Node>|undefined)}\n     */\n    this.created = exports.notifications.nodesCreated && [];\n\n    /**\n     * @type {(Array<!Node>|undefined)}\n     */\n    this.deleted = exports.notifications.nodesDeleted && [];\n  }\n\n\n  /**\n   * @param {!Node} node\n   */\n  Context.prototype.markCreated = function(node) {\n    if (this.created) {\n      this.created.push(node);\n    }\n  };\n\n\n  /**\n   * @param {!Node} node\n   */\n  Context.prototype.markDeleted = function(node) {\n    if (this.deleted) {\n      this.deleted.push(node);\n    }\n  };\n\n\n  /**\n   * Notifies about nodes that were created during the patch opearation.\n   */\n  Context.prototype.notifyChanges = function() {\n    if (this.created && this.created.length > 0) {\n      exports.notifications.nodesCreated(this.created);\n    }\n\n    if (this.deleted && this.deleted.length > 0) {\n      exports.notifications.nodesDeleted(this.deleted);\n    }\n  };\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n\n  /**\n   * A cached reference to the hasOwnProperty function.\n   */\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\n  /**\n   * A cached reference to the create function.\n   */\n  var create = Object.create;\n\n\n  /**\n   * Used to prevent property collisions between our \"map\" and its prototype.\n   * @param {!Object<string, *>} map The map to check.\n   * @param {string} property The property to check.\n   * @return {boolean} Whether map has property.\n   */\n  var has = function(map, property) {\n    return hasOwnProperty.call(map, property);\n  };\n\n\n  /**\n   * Creates an map object without a prototype.\n   * @return {!Object}\n   */\n  var createMap = function() {\n    return create(null);\n  };\n\n  /**\n   * Keeps track of information needed to perform diffs for a given DOM node.\n   * @param {!string} nodeName\n   * @param {?string=} key\n   * @constructor\n   */\n  function NodeData(nodeName, key) {\n    /**\n     * The attributes and their values.\n     * @const {!Object<string, *>}\n     */\n    this.attrs = createMap();\n\n    /**\n     * An array of attribute name/value pairs, used for quickly diffing the\n     * incomming attributes to see if the DOM node's attributes need to be\n     * updated.\n     * @const {Array<*>}\n     */\n    this.attrsArr = [];\n\n    /**\n     * The incoming attributes for this Node, before they are updated.\n     * @const {!Object<string, *>}\n     */\n    this.newAttrs = createMap();\n\n    /**\n     * The key used to identify this node, used to preserve DOM nodes when they\n     * move within their parent.\n     * @const\n     */\n    this.key = key;\n\n    /**\n     * Keeps track of children within this node by their key.\n     * {?Object<string, !Element>}\n     */\n    this.keyMap = null;\n\n    /**\n     * Whether or not the keyMap is currently valid.\n     * {boolean}\n     */\n    this.keyMapValid = true;\n\n    /**\n     * The node name for this node.\n     * @const {string}\n     */\n    this.nodeName = nodeName;\n\n    /**\n     * @type {?string}\n     */\n    this.text = null;\n  }\n\n\n  /**\n   * Initializes a NodeData object for a Node.\n   *\n   * @param {Node} node The node to initialize data for.\n   * @param {string} nodeName The node name of node.\n   * @param {?string=} key The key that identifies the node.\n   * @return {!NodeData} The newly initialized data object\n   */\n  var initData = function(node, nodeName, key) {\n    var data = new NodeData(nodeName, key);\n    node['__incrementalDOMData'] = data;\n    return data;\n  };\n\n\n  /**\n   * Retrieves the NodeData object for a Node, creating it if necessary.\n   *\n   * @param {Node} node The node to retrieve the data for.\n   * @return {!NodeData} The NodeData for this Node.\n   */\n  var getData = function(node) {\n    var data = node['__incrementalDOMData'];\n\n    if (!data) {\n      var nodeName = node.nodeName.toLowerCase();\n      var key = null;\n\n      if (node instanceof Element) {\n        key = node.getAttribute('key');\n      }\n\n      data = initData(node, nodeName, key);\n    }\n\n    return data;\n  };\n\n  /**\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *      http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  exports.symbols = {\n    default: '__default',\n\n    placeholder: '__placeholder'\n  };\n\n  /**\n   * Applies an attribute or property to a given Element. If the value is null\n   * or undefined, it is removed from the Element. Otherwise, the value is set\n   * as an attribute.\n   * @param {!Element} el\n   * @param {string} name The attribute's name.\n   * @param {?(boolean|number|string)=} value The attribute's value.\n   */\n  exports.applyAttr = function(el, name, value) {\n    if (value == null) {\n      el.removeAttribute(name);\n    } else {\n      el.setAttribute(name, value);\n    }\n  };\n\n  /**\n   * Applies a property to a given Element.\n   * @param {!Element} el\n   * @param {string} name The property's name.\n   * @param {*} value The property's value.\n   */\n  exports.applyProp = function(el, name, value) {\n    el[name] = value;\n  };\n\n\n  /**\n   * Applies a style to an Element. No vendor prefix expansion is done for\n   * property names/values.\n   * @param {!Element} el\n   * @param {string} name The attribute's name.\n   * @param {*} style The style to set. Either a string of css or an object\n   *     containing property-value pairs.\n   */\n  var applyStyle = function(el, name, style) {\n    if (typeof style === 'string') {\n      el.style.cssText = style;\n    } else {\n      el.style.cssText = '';\n      var elStyle = el.style;\n      var obj = /** @type {!Object<string,string>} */(style);\n\n      for (var prop in obj) {\n        if (has(obj, prop)) {\n          elStyle[prop] = obj[prop];\n        }\n      }\n    }\n  };\n\n\n  /**\n   * Updates a single attribute on an Element.\n   * @param {!Element} el\n   * @param {string} name The attribute's name.\n   * @param {*} value The attribute's value. If the value is an object or\n   *     function it is set on the Element, otherwise, it is set as an HTML\n   *     attribute.\n   */\n  var applyAttributeTyped = function(el, name, value) {\n    var type = typeof value;\n\n    if (type === 'object' || type === 'function') {\n      exports.applyProp(el, name, value);\n    } else {\n      exports.applyAttr(el, name, /** @type {?(boolean|number|string)} */(value));\n    }\n  };\n\n\n  /**\n   * Calls the appropriate attribute mutator for this attribute.\n   * @param {!Element} el\n   * @param {string} name The attribute's name.\n   * @param {*} value The attribute's value.\n   */\n  var updateAttribute = function(el, name, value) {\n    var data = getData(el);\n    var attrs = data.attrs;\n\n    if (attrs[name] === value) {\n      return;\n    }\n\n    var mutator = exports.attributes[name] || exports.attributes[exports.symbols.default];\n    mutator(el, name, value);\n\n    attrs[name] = value;\n  };\n\n\n  /**\n   * A publicly mutable object to provide custom mutators for attributes.\n   * @const {!Object<string, function(!Element, string, *)>}\n   */\n  exports.attributes = createMap();\n\n  // Special generic mutator that's called for any attribute that does not\n  // have a specific mutator.\n  exports.attributes[exports.symbols.default] = applyAttributeTyped;\n\n  exports.attributes[exports.symbols.placeholder] = function() {};\n\n  exports.attributes['style'] = applyStyle;\n\n  /**\n   * Gets the namespace to create an element (of a given tag) in.\n   * @param {string} tag The tag to get the namespace for.\n   * @param {?Node} parent\n   * @return {?string} The namespace to create the tag in.\n   */\n  var getNamespaceForTag = function(tag, parent) {\n    if (tag === 'svg') {\n      return 'http://www.w3.org/2000/svg';\n    }\n\n    if (getData(parent).nodeName === 'foreignObject') {\n      return null;\n    }\n\n    return parent.namespaceURI;\n  };\n\n\n  /**\n   * Creates an Element.\n   * @param {Document} doc The document with which to create the Element.\n   * @param {?Node} parent\n   * @param {string} tag The tag for the Element.\n   * @param {?string=} key A key to identify the Element.\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n   *     static attributes for the Element.\n   * @return {!Element}\n   */\n  var createElement = function(doc, parent, tag, key, statics) {\n    var namespace = getNamespaceForTag(tag, parent);\n    var el;\n\n    if (namespace) {\n      el = doc.createElementNS(namespace, tag);\n    } else {\n      el = doc.createElement(tag);\n    }\n\n    initData(el, tag, key);\n\n    if (statics) {\n      for (var i = 0; i < statics.length; i += 2) {\n        updateAttribute(el, /** @type {!string}*/(statics[i]), statics[i + 1]);\n      }\n    }\n\n    return el;\n  };\n\n\n  /**\n   * Creates a Text Node.\n   * @param {Document} doc The document with which to create the Element.\n   * @return {!Text}\n   */\n  var createText = function(doc) {\n    var node = doc.createTextNode('');\n    initData(node, '#text', null);\n    return node;\n  };\n\n\n  /**\n   * Creates a mapping that can be used to look up children using a key.\n   * @param {?Node} el\n   * @return {!Object<string, !Element>} A mapping of keys to the children of the\n   *     Element.\n   */\n  var createKeyMap = function(el) {\n    var map = createMap();\n    var children = el.children;\n    var count = children.length;\n\n    for (var i = 0; i < count; i += 1) {\n      var child = children[i];\n      var key = getData(child).key;\n\n      if (key) {\n        map[key] = child;\n      }\n    }\n\n    return map;\n  };\n\n\n  /**\n   * Retrieves the mapping of key to child node for a given Element, creating it\n   * if necessary.\n   * @param {?Node} el\n   * @return {!Object<string, !Node>} A mapping of keys to child Elements\n   */\n  var getKeyMap = function(el) {\n    var data = getData(el);\n\n    if (!data.keyMap) {\n      data.keyMap = createKeyMap(el);\n    }\n\n    return data.keyMap;\n  };\n\n\n  /**\n   * Retrieves a child from the parent with the given key.\n   * @param {?Node} parent\n   * @param {?string=} key\n   * @return {?Node} The child corresponding to the key.\n   */\n  var getChild = function(parent, key) {\n    return key ? getKeyMap(parent)[key] : null;\n  };\n\n\n  /**\n   * Registers an element as being a child. The parent will keep track of the\n   * child using the key. The child can be retrieved using the same key using\n   * getKeyMap. The provided key should be unique within the parent Element.\n   * @param {?Node} parent The parent of child.\n   * @param {string} key A key to identify the child with.\n   * @param {!Node} child The child to register.\n   */\n  var registerChild = function(parent, key, child) {\n    getKeyMap(parent)[key] = child;\n  };\n\n  /** @type {?Context} */\n  var context = null;\n\n  /** @type {?Node} */\n  var currentNode;\n\n  /** @type {?Node} */\n  var currentParent;\n\n  /** @type {?Node} */\n  var previousNode;\n\n  /** @type {?Element|?DocumentFragment} */\n  var root;\n\n  /** @type {?Document} */\n  var doc;\n\n\n  /**\n   * Patches the document starting at el with the provided function. This function\n   * may be called during an existing patch operation.\n   * @param {!Element|!DocumentFragment} node The Element or Document\n   *     to patch.\n   * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n   *     calls that describe the DOM.\n   * @param {T=} data An argument passed to fn to represent DOM state.\n   * @template T\n   */\n  exports.patch = function(node, fn, data) {\n    var prevContext = context;\n    var prevRoot = root;\n    var prevDoc = doc;\n    var prevCurrentNode = currentNode;\n    var prevCurrentParent = currentParent;\n    var prevPreviousNode = previousNode;\n    var previousInAttributes = false;\n    var previousInSkip = false;\n\n    context = new Context();\n    root = node;\n    doc = node.ownerDocument;\n    currentNode = node;\n    currentParent = null;\n    previousNode = null;\n\n    if (process.env.NODE_ENV !== 'production') {\n      previousInAttributes = setInAttributes(false);\n      previousInSkip = setInSkip(false);\n    }\n\n    enterNode();\n    fn(data);\n    exitNode();\n\n    if (process.env.NODE_ENV !== 'production') {\n      assertVirtualAttributesClosed();\n      assertNoUnclosedTags(previousNode, node);\n      setInAttributes(previousInAttributes);\n      setInSkip(previousInSkip);\n    }\n\n    context.notifyChanges();\n\n    context = prevContext;\n    root = prevRoot;\n    doc = prevDoc;\n    currentNode = prevCurrentNode;\n    currentParent = prevCurrentParent;\n    previousNode = prevPreviousNode;\n  };\n\n\n  /**\n   * Checks whether or not the current node matches the specified nodeName and\n   * key.\n   *\n   * @param {?string} nodeName The nodeName for this node.\n   * @param {?string=} key An optional key that identifies a node.\n   * @return {boolean} True if the node matches, false otherwise.\n   */\n  var matches = function(nodeName, key) {\n    var data = getData(currentNode);\n\n    // Key check is done using double equals as we want to treat a null key the\n    // same as undefined. This should be okay as the only values allowed are\n    // strings, null and undefined so the == semantics are not too weird.\n    return nodeName === data.nodeName && key == data.key;\n  };\n\n\n  /**\n   * Aligns the virtual Element definition with the actual DOM, moving the\n   * corresponding DOM node to the correct location or creating it if necessary.\n   * @param {string} nodeName For an Element, this should be a valid tag string.\n   *     For a Text, this should be #text.\n   * @param {?string=} key The key used to identify this element.\n   * @param {?Array<*>=} statics For an Element, this should be an array of\n   *     name-value pairs.\n   */\n  var alignWithDOM = function(nodeName, key, statics) {\n    if (currentNode && matches(nodeName, key)) {\n      return;\n    }\n\n    var node;\n\n    // Check to see if the node has moved within the parent.\n    if (key) {\n      node = getChild(currentParent, key);\n      if (node && process.env.NODE_ENV !== 'production') {\n        assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n      }\n    }\n\n    // Create the node if it doesn't exist.\n    if (!node) {\n      if (nodeName === '#text') {\n        node = createText(doc);\n      } else {\n        node = createElement(doc, currentParent, nodeName, key, statics);\n      }\n\n      if (key) {\n        registerChild(currentParent, key, node);\n      }\n\n      context.markCreated(node);\n    }\n\n    // If the node has a key, remove it from the DOM to prevent a large number\n    // of re-orders in the case that it moved far or was completely removed.\n    // Since we hold on to a reference through the keyMap, we can always add it\n    // back.\n    if (currentNode && getData(currentNode).key) {\n      currentParent.replaceChild(node, currentNode);\n      getData(currentParent).keyMapValid = false;\n    } else {\n      currentParent.insertBefore(node, currentNode);\n    }\n\n    currentNode = node;\n  };\n\n\n  /**\n   * Clears out any unvisited Nodes, as the corresponding virtual element\n   * functions were never called for them.\n   */\n  var clearUnvisitedDOM = function() {\n    var node = currentParent;\n    var data = getData(node);\n    var keyMap = data.keyMap;\n    var keyMapValid = data.keyMapValid;\n    var child = node.lastChild;\n    var key;\n\n    if (child === previousNode && keyMapValid) {\n      return;\n    }\n\n    if (data.attrs[exports.symbols.placeholder] && node !== root) {\n      return;\n    }\n\n    while (child !== previousNode) {\n      node.removeChild(child);\n      context.markDeleted(/** @type {!Node}*/(child));\n\n      key = getData(child).key;\n      if (key) {\n        delete keyMap[key];\n      }\n      child = node.lastChild;\n    }\n\n    // Clean the keyMap, removing any unusued keys.\n    if (!keyMapValid) {\n      for (key in keyMap) {\n        child = keyMap[key];\n        if (child.parentNode !== node) {\n          context.markDeleted(child);\n          delete keyMap[key];\n        }\n      }\n\n      data.keyMapValid = true;\n    }\n  };\n\n\n  /**\n   * Changes to the first child of the current node.\n   */\n  var enterNode = function() {\n    currentParent = currentNode;\n    currentNode = currentNode.firstChild;\n    previousNode = null;\n  };\n\n\n  /**\n   * Changes to the next sibling of the current node.\n   */\n  var nextNode = function() {\n    previousNode = currentNode;\n    currentNode = currentNode.nextSibling;\n  };\n\n\n  /**\n   * Changes to the parent of the current node, removing any unvisited children.\n   */\n  var exitNode = function() {\n    clearUnvisitedDOM();\n\n    previousNode = currentParent;\n    currentNode = currentParent.nextSibling;\n    currentParent = currentParent.parentNode;\n  };\n\n\n  /**\n   * Makes sure that the current node is an Element with a matching tagName and\n   * key.\n   *\n   * @param {string} tag The element's tag.\n   * @param {?string=} key The key used to identify this element. This can be an\n   *     empty string, but performance may be better if a unique value is used\n   *     when iterating over an array of items.\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n   *     static attributes for the Element. These will only be set once when the\n   *     Element is created.\n   * @return {!Element} The corresponding Element.\n   */\n  var _elementOpen = function(tag, key, statics) {\n    alignWithDOM(tag, key, statics);\n    enterNode();\n    return /** @type {!Element} */(currentParent);\n  };\n\n\n  /**\n   * Closes the currently open Element, removing any unvisited children if\n   * necessary.\n   *\n   * @return {!Element} The corresponding Element.\n   */\n  var _elementClose = function() {\n    if (process.env.NODE_ENV !== 'production') {\n      setInSkip(false);\n    }\n\n    exitNode();\n    return /** @type {!Element} */(previousNode);\n  };\n\n\n  /**\n   * Makes sure the current node is a Text node and creates a Text node if it is\n   * not.\n   *\n   * @return {!Text} The corresponding Text Node.\n   */\n  var _text = function() {\n    alignWithDOM('#text', null, null);\n    nextNode();\n    return /** @type {!Text} */(previousNode);\n  };\n\n\n  /**\n   * Gets the current Element being patched.\n   * @return {!Element}\n   */\n  exports.currentElement = function() {\n    if (process.env.NODE_ENV !== 'production') {\n      assertInPatch(context);\n      assertNotInAttributes('currentElement');\n    }\n    return /** @type {!Element} */(currentParent);\n  };\n\n\n  /**\n   * Skips the children in a subtree, allowing an Element to be closed without\n   * clearing out the children.\n   */\n  exports.skip = function() {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNoChildrenDeclaredYet('skip', previousNode);\n      setInSkip(true);\n    }\n    previousNode = currentParent.lastChild;\n  };\n\n  /**\n   * The offset in the virtual element declaration where the attributes are\n   * specified.\n   * @const\n   */\n  var ATTRIBUTES_OFFSET = 3;\n\n\n  /**\n   * Builds an array of arguments for use with elementOpenStart, attr and\n   * elementOpenEnd.\n   * @const {Array<*>}\n   */\n  var argsBuilder = [];\n\n\n  /**\n   * @param {string} tag The element's tag.\n   * @param {?string=} key The key used to identify this element. This can be an\n   *     empty string, but performance may be better if a unique value is used\n   *     when iterating over an array of items.\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n   *     static attributes for the Element. These will only be set once when the\n   *     Element is created.\n   * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n   *     for the Element.\n   * @return {!Element} The corresponding Element.\n   */\n  exports.elementOpen = function(tag, key, statics, var_args) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotInAttributes('elementOpen');\n      assertNotInSkip('elementOpen');\n    }\n\n    var node = _elementOpen(tag, key, statics);\n    var data = getData(node);\n\n    /*\n     * Checks to see if one or more attributes have changed for a given Element.\n     * When no attributes have changed, this is much faster than checking each\n     * individual argument. When attributes have changed, the overhead of this is\n     * minimal.\n     */\n    var attrsArr = data.attrsArr;\n    var newAttrs = data.newAttrs;\n    var attrsChanged = false;\n    var i = ATTRIBUTES_OFFSET;\n    var j = 0;\n\n    for (; i < arguments.length; i += 1, j += 1) {\n      if (attrsArr[j] !== arguments[i]) {\n        attrsChanged = true;\n        break;\n      }\n    }\n\n    for (; i < arguments.length; i += 1, j += 1) {\n      attrsArr[j] = arguments[i];\n    }\n\n    if (j < attrsArr.length) {\n      attrsChanged = true;\n      attrsArr.length = j;\n    }\n\n    /*\n     * Actually perform the attribute update.\n     */\n    if (attrsChanged) {\n      for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n        newAttrs[arguments[i]] = arguments[i + 1];\n      }\n\n      for (var attr in newAttrs) {\n        updateAttribute(node, attr, newAttrs[attr]);\n        newAttrs[attr] = undefined;\n      }\n    }\n\n    return node;\n  };\n\n\n  /**\n   * Declares a virtual Element at the current location in the document. This\n   * corresponds to an opening tag and a elementClose tag is required. This is\n   * like elementOpen, but the attributes are defined using the attr function\n   * rather than being passed as arguments. Must be folllowed by 0 or more calls\n   * to attr, then a call to elementOpenEnd.\n   * @param {string} tag The element's tag.\n   * @param {?string=} key The key used to identify this element. This can be an\n   *     empty string, but performance may be better if a unique value is used\n   *     when iterating over an array of items.\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n   *     static attributes for the Element. These will only be set once when the\n   *     Element is created.\n   */\n  exports.elementOpenStart = function(tag, key, statics) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotInAttributes('elementOpenStart');\n      setInAttributes(true);\n    }\n\n    argsBuilder[0] = tag;\n    argsBuilder[1] = key;\n    argsBuilder[2] = statics;\n  };\n\n\n  /***\n   * Defines a virtual attribute at this point of the DOM. This is only valid\n   * when called between elementOpenStart and elementOpenEnd.\n   *\n   * @param {string} name\n   * @param {*} value\n   */\n  exports.attr = function(name, value) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertInAttributes('attr');\n    }\n\n    argsBuilder.push(name, value);\n  };\n\n\n  /**\n   * Closes an open tag started with elementOpenStart.\n   * @return {!Element} The corresponding Element.\n   */\n  exports.elementOpenEnd = function() {\n    if (process.env.NODE_ENV !== 'production') {\n      assertInAttributes('elementOpenEnd');\n      setInAttributes(false);\n    }\n\n    var node = exports.elementOpen.apply(null, argsBuilder);\n    argsBuilder.length = 0;\n    return node;\n  };\n\n\n  /**\n   * Closes an open virtual Element.\n   *\n   * @param {string} tag The element's tag.\n   * @return {!Element} The corresponding Element.\n   */\n  exports.elementClose = function(tag) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotInAttributes('elementClose');\n    }\n\n    var node = _elementClose();\n\n    if (process.env.NODE_ENV !== 'production') {\n      assertCloseMatchesOpenTag(getData(node).nodeName, tag);\n    }\n\n    return node;\n  };\n\n\n  /**\n   * Declares a virtual Element at the current location in the document that has\n   * no children.\n   * @param {string} tag The element's tag.\n   * @param {?string=} key The key used to identify this element. This can be an\n   *     empty string, but performance may be better if a unique value is used\n   *     when iterating over an array of items.\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n   *     static attributes for the Element. These will only be set once when the\n   *     Element is created.\n   * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n   *     for the Element.\n   * @return {!Element} The corresponding Element.\n   */\n  exports.elementVoid = function(tag, key, statics, var_args) {\n    var node = exports.elementOpen.apply(null, arguments);\n    exports.elementClose.apply(null, arguments);\n    return node;\n  };\n\n\n  /**\n   * Declares a virtual Element at the current location in the document that is a\n   * placeholder element. Children of this Element can be manually managed and\n   * will not be cleared by the library.\n   *\n   * A key must be specified to make sure that this node is correctly preserved\n   * across all conditionals.\n   *\n   * @param {string} tag The element's tag.\n   * @param {string} key The key used to identify this element.\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n   *     static attributes for the Element. These will only be set once when the\n   *     Element is created.\n   * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n   *     for the Element.\n   * @return {!Element} The corresponding Element.\n   */\n  exports.elementPlaceholder = function(tag, key, statics, var_args) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertPlaceholderKeySpecified(key);\n    }\n\n    exports.elementOpen.apply(null, arguments);\n    exports.skip();\n    return exports.elementClose.apply(null, arguments);\n  };\n\n\n  /**\n   * Declares a virtual Text at this point in the document.\n   *\n   * @param {string|number|boolean} value The value of the Text.\n   * @param {...(function((string|number|boolean)):string)} var_args\n   *     Functions to format the value which are called only when the value has\n   *     changed.\n   * @return {!Text} The corresponding text node.\n   */\n  exports.text = function(value, var_args) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotInAttributes('text');\n      assertNotInSkip('text');\n    }\n\n    var node = _text();\n    var data = getData(node);\n\n    if (data.text !== value) {\n      data.text = /** @type {string} */(value);\n\n      var formatted = value;\n      for (var i = 1; i < arguments.length; i += 1) {\n        formatted = arguments[i](formatted);\n      }\n\n      node.data = formatted;\n    }\n\n    return node;\n  };\n\n}));\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { notifications } from './notifications';\n\n\n/**\n * Keeps track of the state of a patch.\n * @constructor\n */\nfunction Context() {\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = notifications.nodesDeleted && [];\n}\n\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function(node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function(node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function() {\n  if (this.created && this.created.length > 0) {\n    notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    notifications.nodesDeleted(this.deleted);\n  }\n};\n\n\n/** */\nexport {\n  Context\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createMap } from './util';\n\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const {!Object<string, *>}\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, !Element>}\n   */\n  this.keyMap = null;\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function(node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {Node} node The node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nvar getData = function(node) {\n  var data = node['__incrementalDOMData'];\n\n  if (!data) {\n    var nodeName = node.nodeName.toLowerCase();\n    var key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n\n/** */\nexport {\n  getData,\n  initData\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** */\nvar notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\nexport {\n  notifications\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\n/**\n * A cached reference to the create function.\n */\nvar create = Object.create;\n\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nvar has = function(map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nvar createMap = function() {\n  return create(null);\n};\n\n\n/** */\nexport {\n  createMap,\n  has\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar symbols = {\n  default: '__default',\n\n  placeholder: '__placeholder'\n};\n\n/** */\nexport {\n  symbols\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getData } from './node_data';\nimport { symbols } from './symbols';\nimport {\n  createMap,\n  has\n} from './util';\n\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nvar applyAttr = function(el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    el.setAttribute(name, value);\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nvar applyProp = function(el, name, value) {\n  el[name] = value;\n};\n\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nvar applyStyle = function(el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    var elStyle = el.style;\n    var obj = /** @type {!Object<string,string>} */(style);\n\n    for (var prop in obj) {\n      if (has(obj, prop)) {\n        elStyle[prop] = obj[prop];\n      }\n    }\n  }\n};\n\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nvar applyAttributeTyped = function(el, name, value) {\n  var type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, /** @type {?(boolean|number|string)} */(value));\n  }\n};\n\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function(el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nvar attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes[symbols.placeholder] = function() {};\n\nattributes['style'] = applyStyle;\n\n\n/** */\nexport {\n  updateAttribute,\n  applyProp,\n  applyAttr,\n  attributes\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { updateAttribute } from './attributes';\nimport {\n    getData,\n    initData\n} from './node_data';\nimport { createMap } from './util';\n\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @param {?Node} parent\n * @return {?string} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function(tag, parent) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (getData(parent).nodeName === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n};\n\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {?Node} parent\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element.\n * @return {!Element}\n */\nvar createElement = function(doc, parent, tag, key, statics) {\n  var namespace = getNamespaceForTag(tag, parent);\n  var el;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (var i = 0; i < statics.length; i += 2) {\n      updateAttribute(el, /** @type {!string}*/(statics[i]), statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n\n/**\n * Creates a Text Node.\n * @param {Document} doc The document with which to create the Element.\n * @return {!Text}\n */\nvar createText = function(doc) {\n  var node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n};\n\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {?Node} el\n * @return {!Object<string, !Element>} A mapping of keys to the children of the\n *     Element.\n */\nvar createKeyMap = function(el) {\n  var map = createMap();\n  var children = el.children;\n  var count = children.length;\n\n  for (var i = 0; i < count; i += 1) {\n    var child = children[i];\n    var key = getData(child).key;\n\n    if (key) {\n      map[key] = child;\n    }\n  }\n\n  return map;\n};\n\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {?Node} el\n * @return {!Object<string, !Node>} A mapping of keys to child Elements\n */\nvar getKeyMap = function(el) {\n  var data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {?Node} parent\n * @param {?string=} key\n * @return {?Node} The child corresponding to the key.\n */\nvar getChild = function(parent, key) {\n  return key ? getKeyMap(parent)[key] : null;\n};\n\n\n/**\n * Registers an element as being a child. The parent will keep track of the\n * child using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {?Node} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nvar registerChild = function(parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\n\n/** */\nexport {\n  createElement,\n  createText,\n  getChild,\n  registerChild\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  createElement,\n  createText,\n  getChild,\n  registerChild\n} from './nodes';\nimport { getData } from './node_data';\nimport { Context } from './context';\nimport { symbols } from './symbols';\nimport {\n  assertInPatch,\n  assertKeyedTagMatches,\n  assertNoUnclosedTags,\n  assertNotInAttributes,\n  assertVirtualAttributesClosed,\n  assertNoChildrenDeclaredYet,\n  setInAttributes,\n  setInSkip\n} from './assertions';\nimport { notifications } from './notifications';\n\n\n/** @type {?Context} */\nvar context = null;\n\n/** @type {?Node} */\nvar currentNode;\n\n/** @type {?Node} */\nvar currentParent;\n\n/** @type {?Node} */\nvar previousNode;\n\n/** @type {?Element|?DocumentFragment} */\nvar root;\n\n/** @type {?Document} */\nvar doc;\n\n\n/**\n * Patches the document starting at el with the provided function. This function\n * may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nvar patch = function(node, fn, data) {\n  var prevContext = context;\n  var prevRoot = root;\n  var prevDoc = doc;\n  var prevCurrentNode = currentNode;\n  var prevCurrentParent = currentParent;\n  var prevPreviousNode = previousNode;\n  var previousInAttributes = false;\n  var previousInSkip = false;\n\n  context = new Context();\n  root = node;\n  doc = node.ownerDocument;\n  currentNode = node;\n  currentParent = null;\n  previousNode = null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    previousInAttributes = setInAttributes(false);\n    previousInSkip = setInSkip(false);\n  }\n\n  enterNode();\n  fn(data);\n  exitNode();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertVirtualAttributesClosed();\n    assertNoUnclosedTags(previousNode, node);\n    setInAttributes(previousInAttributes);\n    setInSkip(previousInSkip);\n  }\n\n  context.notifyChanges();\n\n  context = prevContext;\n  root = prevRoot;\n  doc = prevDoc;\n  currentNode = prevCurrentNode;\n  currentParent = prevCurrentParent;\n  previousNode = prevPreviousNode;\n};\n\n\n/**\n * Checks whether or not the current node matches the specified nodeName and\n * key.\n *\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function(nodeName, key) {\n  var data = getData(currentNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return nodeName === data.nodeName && key == data.key;\n};\n\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n * @param {?Array<*>=} statics For an Element, this should be an array of\n *     name-value pairs.\n */\nvar alignWithDOM = function(nodeName, key, statics) {\n  if (currentNode && matches(nodeName, key)) {\n    return;\n  }\n\n  var node;\n\n  // Check to see if the node has moved within the parent.\n  if (key) {\n    node = getChild(currentParent, key);\n    if (node && process.env.NODE_ENV !== 'production') {\n      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n    }\n  }\n\n  // Create the node if it doesn't exist.\n  if (!node) {\n    if (nodeName === '#text') {\n      node = createText(doc);\n    } else {\n      node = createElement(doc, currentParent, nodeName, key, statics);\n    }\n\n    if (key) {\n      registerChild(currentParent, key, node);\n    }\n\n    context.markCreated(node);\n  }\n\n  // If the node has a key, remove it from the DOM to prevent a large number\n  // of re-orders in the case that it moved far or was completely removed.\n  // Since we hold on to a reference through the keyMap, we can always add it\n  // back.\n  if (currentNode && getData(currentNode).key) {\n    currentParent.replaceChild(node, currentNode);\n    getData(currentParent).keyMapValid = false;\n  } else {\n    currentParent.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n};\n\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n */\nvar clearUnvisitedDOM = function() {\n  var node = currentParent;\n  var data = getData(node);\n  var keyMap = data.keyMap;\n  var keyMapValid = data.keyMapValid;\n  var child = node.lastChild;\n  var key;\n\n  if (child === previousNode && keyMapValid) {\n    return;\n  }\n\n  if (data.attrs[symbols.placeholder] && node !== root) {\n    return;\n  }\n\n  while (child !== previousNode) {\n    node.removeChild(child);\n    context.markDeleted(/** @type {!Node}*/(child));\n\n    key = getData(child).key;\n    if (key) {\n      delete keyMap[key];\n    }\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  if (!keyMapValid) {\n    for (key in keyMap) {\n      child = keyMap[key];\n      if (child.parentNode !== node) {\n        context.markDeleted(child);\n        delete keyMap[key];\n      }\n    }\n\n    data.keyMapValid = true;\n  }\n};\n\n\n/**\n * Changes to the first child of the current node.\n */\nvar enterNode = function() {\n  currentParent = currentNode;\n  currentNode = currentNode.firstChild;\n  previousNode = null;\n};\n\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextNode = function() {\n  previousNode = currentNode;\n  currentNode = currentNode.nextSibling;\n};\n\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar exitNode = function() {\n  clearUnvisitedDOM();\n\n  previousNode = currentParent;\n  currentNode = currentParent.nextSibling;\n  currentParent = currentParent.parentNode;\n};\n\n\n/**\n * Makes sure that the current node is an Element with a matching tagName and\n * key.\n *\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpen = function(tag, key, statics) {\n  alignWithDOM(tag, key, statics);\n  enterNode();\n  return /** @type {!Element} */(currentParent);\n};\n\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n *\n * @return {!Element} The corresponding Element.\n */\nvar elementClose = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    setInSkip(false);\n  }\n\n  exitNode();\n  return /** @type {!Element} */(previousNode);\n};\n\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n *\n * @return {!Text} The corresponding Text Node.\n */\nvar text = function() {\n  alignWithDOM('#text', null, null);\n  nextNode();\n  return /** @type {!Text} */(previousNode);\n};\n\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nvar currentElement = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInPatch(context);\n    assertNotInAttributes('currentElement');\n  }\n  return /** @type {!Element} */(currentParent);\n};\n\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nvar skip = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoChildrenDeclaredYet('skip', previousNode);\n    setInSkip(true);\n  }\n  previousNode = currentParent.lastChild;\n};\n\n\n/** */\nexport {\n  elementOpen,\n  elementClose,\n  text,\n  patch,\n  currentElement,\n  skip\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  elementOpen as coreElementOpen,\n  elementClose as coreElementClose,\n  text as coreText,\n  currentElement,\n  skip\n} from './core';\nimport { updateAttribute } from './attributes';\nimport { getData } from './node_data';\nimport { symbols } from './symbols';\nimport {\n  assertNotInAttributes,\n  assertNotInSkip,\n  assertInAttributes,\n  assertPlaceholderKeySpecified,\n  assertCloseMatchesOpenTag,\n  setInAttributes\n} from './assertions';\n\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpen = function(tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpen');\n    assertNotInSkip('elementOpen');\n  }\n\n  var node = coreElementOpen(tag, key, statics);\n  var data = getData(node);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var newAttrs = data.newAttrs;\n  var attrsChanged = false;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  /*\n   * Actually perform the attribute update.\n   */\n  if (attrsChanged) {\n    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n      newAttrs[arguments[i]] = arguments[i + 1];\n    }\n\n    for (var attr in newAttrs) {\n      updateAttribute(node, attr, newAttrs[attr]);\n      newAttrs[attr] = undefined;\n    }\n  }\n\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nvar elementOpenStart = function(tag, key, statics) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpenStart');\n    setInAttributes(true);\n  }\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nvar attr = function(name, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('attr');\n  }\n\n  argsBuilder.push(name, value);\n};\n\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpenEnd = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('elementOpenEnd');\n    setInAttributes(false);\n  }\n\n  var node = elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nvar elementClose = function(tag) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementClose');\n  }\n\n  var node = coreElementClose();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertCloseMatchesOpenTag(getData(node).nodeName, tag);\n  }\n\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementVoid = function(tag, key, statics, var_args) {\n  var node = elementOpen.apply(null, arguments);\n  elementClose.apply(null, arguments);\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document that is a\n * placeholder element. Children of this Element can be manually managed and\n * will not be cleared by the library.\n *\n * A key must be specified to make sure that this node is correctly preserved\n * across all conditionals.\n *\n * @param {string} tag The element's tag.\n * @param {string} key The key used to identify this element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementPlaceholder = function(tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertPlaceholderKeySpecified(key);\n  }\n\n  elementOpen.apply(null, arguments);\n  skip();\n  return elementClose.apply(null, arguments);\n};\n\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} var_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nvar text = function(value, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('text');\n    assertNotInSkip('text');\n  }\n\n  var node = coreText();\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */(value);\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      formatted = arguments[i](formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  return node;\n};\n\n\n/** */\nexport {\n  elementOpenStart,\n  elementOpenEnd,\n  elementOpen,\n  elementVoid,\n  elementClose,\n  elementPlaceholder,\n  text,\n  attr\n};\n"],"sourceRoot":"/source/"}